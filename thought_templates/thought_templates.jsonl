{"thought_name": "Merge Strings Alternately", "thought_question": "```\ndef mergeAlternately(self, word1: str, word2: str) -> str: \"\"\" You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.Return the merged string. Note: * word1 and word2 consist of lowercase English letters. Examples: * mergeAlternately(\"abc\",\"pqr\") => \"apbqcr\" * mergeAlternately(\"ab\",\"pqrs\") => \"apbqrs\" * mergeAlternately(\"abcd\",\"pq\") => \"apbqcd\" \"\"\"\n```", "thought_answer": "```\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        m, n = len(word1), len(word2)\n        i = j = 0\n\n        ans = list()\n        while i < m or j < n:\n            if i < m:\n                ans.append(word1[i])\n                i += 1\n            if j < n:\n                ans.append(word2[j])\n                j += 1\n        \n        return \"\".join(ans)\n```"}
{"thought_name": "Greatest Common Divisor of Strings", "thought_question": "```\ndef gcdOfStrings(self, str1: str, str2: str) -> str: \"\"\" For two strings s and t, we say \"t divides s\" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2. Note: * str1 and str2 consist of English uppercase letters. Examples: * gcdOfStrings(\"ABCABC\",\"ABC\") => \"ABC\" * gcdOfStrings(\"ABABAB\",\"ABAB\") => \"AB\" * gcdOfStrings(\"LEET\",\"CODE\") => \"\" \"\"\"\n```", "thought_answer": "```\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        for i in range(min(len(str1), len(str2)), 0, -1):\n            if (len(str1) % i) == 0 and (len(str2) % i) == 0:\n                if str1[: i] * (len(str1) // i) == str1 and str1[: i] * (len(str2) // i) == str2:\n                    return str1[: i]\n        return ''\n```"}
{"thought_name": "Kids With the Greatest Number of Candies", "thought_question": "```\ndef kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]: \"\"\" There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.Note: * that multiple kids can have the greatest number of candies. Examples: * kidsWithCandies([2,3,5,1,3],3) => [true,true,true,false,true] * kidsWithCandies([4,2,1,1,2],1) => [true,false,false,false,false] * kidsWithCandies([12,1,12],10) => [true,false,true] \"\"\"\n```", "thought_answer": "```\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        maxCandies = max(candies)\n        ret = [candy + extraCandies >= maxCandies for candy in candies]\n        return ret\n```"}
{"thought_name": "Can Place Flowers", "thought_question": "```\ndef canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool: \"\"\" You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise. Note: * There are no two adjacent flowers in flowerbed. Examples: * canPlaceFlowers([1,0,0,0,1],1) => true * canPlaceFlowers([1,0,0,0,1],2) => false \"\"\"\n```", "thought_answer": "```\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        count, m, prev = 0, len(flowerbed), -1\n        for i in range(m):\n            if flowerbed[i] == 1:\n                if prev < 0:\n                    count += i // 2\n                else:\n                    count += (i - prev - 2) // 2\n                prev = i\n        \n        if prev < 0:\n            count += (m + 1) // 2\n        else:\n            count += (m - prev - 1) // 2\n        \n        return count >= n\n```"}
{"thought_name": "Reverse Vowels of a String", "thought_question": "```\ndef reverseVowels(self, s: str) -> str: \"\"\" Given a string s, reverse only all the vowels in the string and return it.The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once. Note: * s consist of printable ASCII characters. Examples: * reverseVowels(\"hello\") => \"holle\" * reverseVowels(\"leetcode\") => \"leotcede\" \"\"\"\n```", "thought_answer": "```\n    def reverseVowels(self, s: str) -> str:\n        def isVowel(ch: str) -> bool:\n            return ch in \"aeiouAEIOU\"\n        \n        n = len(s)\n        s = list(s)\n        i, j = 0, n - 1\n        while i < j:\n            while i < n and not isVowel(s[i]):\n                i += 1\n            while j > 0 and not isVowel(s[j]):\n                j -= 1\n            if i < j:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        \n        return \"\".join(s)\n```"}
{"thought_name": "Reverse Words in a String", "thought_question": "```\ndef reverseWords(self, s: str) -> str: \"\"\" Given an input string s, reverse the order of the words.A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.Return a string of the words in reverse order concatenated by a single space. Note: * s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Examples: * reverseWords(\"the sky is blue\") => \"blue is sky the\" * reverseWords(\"  hello world  \") => \"world hello\" * reverseWords(\"a good   example\") => \"example good a\" \"\"\"\n```", "thought_answer": "```\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n```"}
{"thought_name": "Product of Array Except Self", "thought_question": "```\ndef productExceptSelf(self, nums: List[int]) -> List[int]: \"\"\" Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation. Note: * The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Examples: * productExceptSelf([1,2,3,4]) => [24,12,8,6] * productExceptSelf([-1,1,0,-3,3]) => [0,0,9,0,0] \"\"\"\n```", "thought_answer": "```\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        length = len(nums)\n        \n        # L \u548c R \u5206\u522b\u8868\u793a\u5de6\u53f3\u4e24\u4fa7\u7684\u4e58\u79ef\u5217\u8868\n        L, R, answer = [0]*length, [0]*length, [0]*length\n        \n        # L[i] \u4e3a\u7d22\u5f15 i \u5de6\u4fa7\u6240\u6709\u5143\u7d20\u7684\u4e58\u79ef\n        # \u5bf9\u4e8e\u7d22\u5f15\u4e3a '0' \u7684\u5143\u7d20\uff0c\u56e0\u4e3a\u5de6\u4fa7\u6ca1\u6709\u5143\u7d20\uff0c\u6240\u4ee5 L[0] = 1\n        L[0] = 1\n        for i in range(1, length):\n            L[i] = nums[i - 1] * L[i - 1]\n        \n        # R[i] \u4e3a\u7d22\u5f15 i \u53f3\u4fa7\u6240\u6709\u5143\u7d20\u7684\u4e58\u79ef\n        # \u5bf9\u4e8e\u7d22\u5f15\u4e3a 'length-1' \u7684\u5143\u7d20\uff0c\u56e0\u4e3a\u53f3\u4fa7\u6ca1\u6709\u5143\u7d20\uff0c\u6240\u4ee5 R[length-1] = 1\n        R[length - 1] = 1\n        for i in reversed(range(length - 1)):\n            R[i] = nums[i + 1] * R[i + 1]\n\n        # \u5bf9\u4e8e\u7d22\u5f15 i\uff0c\u9664 nums[i] \u4e4b\u5916\u5176\u4f59\u5404\u5143\u7d20\u7684\u4e58\u79ef\u5c31\u662f\u5de6\u4fa7\u6240\u6709\u5143\u7d20\u7684\u4e58\u79ef\u4e58\u4ee5\u53f3\u4fa7\u6240\u6709\u5143\u7d20\u7684\u4e58\u79ef\n        for i in range(length):\n            answer[i] = L[i] * R[i]\n        \n        return answer\n```"}
{"thought_name": "Increasing Triplet Subsequence", "thought_question": "```\ndef increasingTriplet(self, nums: List[int]) -> bool: \"\"\" Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. Examples: * increasingTriplet([1,2,3,4,5]) => true * increasingTriplet([5,4,3,2,1]) => false * increasingTriplet([2,1,5,0,4,6]) => true \"\"\"\n```", "thought_answer": "```\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 3:\n            return False\n        leftMin = [0] * n\n        leftMin[0] = nums[0]\n        for i in range(1, n):\n            leftMin[i] = min(leftMin[i - 1], nums[i])\n        rightMax = [0] * n\n        rightMax[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            rightMax[i] = max(rightMax[i + 1], nums[i])\n        for i in range(1, n - 1):\n            if leftMin[i - 1] < nums[i] < rightMax[i + 1]:\n                return True\n        return False\n```"}
{"thought_name": "String Compression ", "thought_question": "```\ndef compress(self, chars: List[str]) -> int: \"\"\" Given an array of characters chars, compress it using the following algorithm:Begin with an empty string s. For each group of consecutive repeating characters in chars: * If the group's length is 1, append the character to s. * Otherwise, append the character followed by the group's length.\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.After you are done modifying the input array, return the new length of the array.You must write an algorithm that uses only constant extra space. Examples: * compress([\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]) => 6 * compress([\"a\"]) => 1 * compress([\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]) => 4 \"\"\"\n```", "thought_answer": "```\n    def compress(self, chars: List[str]) -> int:\n        def reverse(left: int, right: int) -> None:\n            while left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n\n        n = len(chars)\n        write = left = 0\n        for read in range(n):\n            if read == n - 1 or chars[read] != chars[read + 1]:\n                chars[write] = chars[read]\n                write += 1\n                num = read - left + 1\n                if num > 1:\n                    anchor = write\n                    while num > 0:\n                        chars[write] = str(num % 10)\n                        write += 1\n                        num //= 10\n                    reverse(anchor, write - 1)\n                left = read + 1\n        return write\n```"}
{"thought_name": "Move Zeroes ", "thought_question": "```\ndef moveZeroes(self, nums: List[int]) -> None: \"\"\" Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.Note: * that you must do this in-place without making a copy of the array. Examples: * moveZeroes([0,1,0,3,12]) => [1,3,12,0,0] * moveZeroes([0]) => [0] \"\"\"\n```", "thought_answer": "```\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        left = right = 0\n        while right < n:\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n            right += 1\n```"}
{"thought_name": "Is Subsequence", "thought_question": "```\ndef isSubsequence(self, s: str, t: str) -> bool: \"\"\" Given two strings s and t, return true if s is a subsequence of t, or false otherwise.A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). Examples: * isSubsequence(\"abc\",\"ahbgdc\") => true * isSubsequence(\"axc\",\"ahbgdc\") => false \"\"\"\n```", "thought_answer": "```\n    def isSubsequence(self, s: str, t: str) -> bool:\n        n, m = len(s), len(t)\n        i = j = 0\n        while i < n and j < m:\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == n\n```"}
{"thought_name": "Container With Most Water ", "thought_question": "```\ndef maxArea(self, height: List[int]) -> int: \"\"\" You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store. Notice * that you may not slant the container. Examples: * maxArea([1,8,6,2,5,4,8,3,7]) => 49 * maxArea([1,1]) => 1 \"\"\"\n```", "thought_answer": "```\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        ans = 0\n        while l < r:\n            area = min(height[l], height[r]) * (r - l)\n            ans = max(ans, area)\n            if height[l] <= height[r]:\n                l += 1\n            else:\n                r -= 1\n        return ans\n```"}
{"thought_name": "Max Number of K-Sum Pairs ", "thought_question": "```\ndef maxOperations(self, nums: List[int], k: int) -> int: \"\"\" You are given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.Return the maximum number of operations you can perform on the array. Examples: * maxOperations([1,2,3,4],5) => 2 * maxOperations([3,1,3,4,3],6) => 1 \"\"\"\n```", "thought_answer": "```\n    def maxOperations(nums: List[int], k: int) -> int:\n        res = 0\n        counts = {} # \u7edf\u8ba1\u51fa\u73b0\u4e14\u672a\u4f7f\u7528\u7684\u6570\u5b57\u4e2a\u6570\n        for num in nums:\n            # \u5982\u679cnum\u4e4b\u524d\u5b58\u5728\u53ef\u4ee5\u548c\u5b83\u914d\u5bf9\u7684\u6570\uff0c\u90a3\u4e48\u5c31\u5f97\u5230\u4e00\u4e2a\u6570\u5bf9\n            if counts.get(k - num, 0) > 0:\n                res += 1\n                counts[k - num] -= 1   # \u914d\u5bf9\u7684\u90a3\u4e2a\u6570\u76f8\u5f53\u4e8e\u88ab\u79fb\u9664\u4e86\uff0c\u4e2a\u6570-1\n            else:\n                counts[num] = counts.get(num, 0) + 1  # \u4e0d\u5b58\u5728\u914d\u5bf9\u7684\u6570\uff0c\u8fd9\u4e2a\u6570\u5f85\u5339\u914d\u4e2a\u6570\u52a01\n        return res\n```"}
{"thought_name": "Maximum Average Subarray I ", "thought_question": "```\ndef findMaxAverage(self, nums: List[int], k: int) -> float: \"\"\" You are given an integer array nums consisting of n elements, and an integer k.Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. Examples: * findMaxAverage([1,12,-5,-6,50,3],4) => 12.75000 * findMaxAverage([5],1) => 5.00000 \"\"\"\n```", "thought_answer": "```\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\n        maxTotal = total = sum(nums[:k])\n        n = len(nums)\n\n        for i in range(k, n):\n            total = total - nums[i - k] + nums[i]\n            maxTotal = max(maxTotal, total)\n        \n        return maxTotal / k\n```"}
{"thought_name": "Maximum Number of Vowels in a Substring of Given Length", "thought_question": "```\ndef maxVowels(self, s: str, k: int) -> int: \"\"\" Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'. Examples: * maxVowels(\"abciiidef\",3) => 3 * maxVowels(\"aeiou\",2) => 2 * maxVowels(\"leetcode\",3) => 2 \"\"\"\n```", "thought_answer": "```\n    def maxVowels(self, s: str, k: int) -> int:\n        def isVowel(ch):\n            return int(ch in \"aeiou\")\n        \n        n = len(s)\n        vowel_count = sum(1 for i in range(k) if isVowel(s[i]))\n        ans = vowel_count\n        for i in range(k, n):\n            vowel_count += isVowel(s[i]) - isVowel(s[i - k])\n            ans = max(ans, vowel_count)\n        return ans\n```"}
{"thought_name": "Max Consecutive Ones III", "thought_question": "```\ndef longestOnes(self, nums: List[int], k: int) -> int: \"\"\" Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's. Examples: * longestOnes([1,1,1,0,0,0,1,1,1,1,0],2) => 6 * longestOnes([0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1],3) => 10 \"\"\"\n```", "thought_answer": "```\n    def longestOnes(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        P = [0]\n        for num in nums:\n            P.append(P[-1] + (1 - num))\n        \n        ans = 0\n        for right in range(n):\n            left = bisect.bisect_left(P, P[right + 1] - k)\n            ans = max(ans, right - left + 1)\n        \n        return ans\n```"}
{"thought_name": "Longest Subarray of 1's After Deleting One Element ", "thought_question": "```\ndef longestSubarray(self, nums: List[int]) -> int: \"\"\" Given a binary array nums, you should delete one element from it.Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray. Examples: * longestSubarray([1,1,0,1]) => 3 * longestSubarray([0,1,1,1,0,1,1,0,1]) => 5 * longestSubarray([1,1,1]) => 2 \"\"\"\n```", "thought_answer": "```\n    def longestSubarray(self, nums: List[int]) -> int:\n        ans = 0\n        p0 = p1 = 0\n        for num in nums:\n            if num == 0:\n                p1, p0 = p0, 0\n            else:\n                p0 += 1\n                p1 += 1\n            ans = max(ans, p1)\n        if ans == len(nums):\n            ans -= 1\n        return ans\n```"}
{"thought_name": "Find the Highest Altitude ", "thought_question": "```\ndef largestAltitude(self, gain: List[int]) -> int: \"\"\" There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 <= i < n). Return the highest altitude of a point. Examples: * largestAltitude([-5,1,5,0,-7]) => 1 * largestAltitude([-4,-3,-2,-1,4,3,2]) => 0 \"\"\"\n```", "thought_answer": "```\n    def largestAltitude(self, gain: List[int]) -> int:\n        ans = total = 0\n        for x in gain:\n            total += x\n            ans = max(ans, total)\n        return ans\n```"}
{"thought_name": "Find Pivot Index ", "thought_question": "```\ndef pivotIndex(self, nums: List[int]) -> int: \"\"\" Given an array of integers nums, calculate the pivot index of this array.The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.Return the leftmost pivot index. If no such index exists, return -1. Examples: * pivotIndex([1,7,3,6,5,6]) => 3 * pivotIndex([1,2,3]) => -1 * pivotIndex([2,1,-1]) => 0 \"\"\"\n```", "thought_answer": "```\n    def pivotIndex(self, nums: List[int]) -> int:\n        sum_left, sum_right = 0, sum(nums)\n        for i in range(len(nums)):\n            sum_right -= nums[i]\n            # \u82e5\u5de6\u4fa7\u5143\u7d20\u548c\u7b49\u4e8e\u53f3\u4fa7\u5143\u7d20\u548c\uff0c\u8fd4\u56de\u4e2d\u5fc3\u4e0b\u6807 i\n            if sum_left == sum_right:\n                return i\n            sum_left += nums[i]\n        return -1\n```"}
{"thought_name": "Find the Difference of Two Arrays ", "thought_question": "```\ndef findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]: \"\"\" Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: * answer[0] is a list of all distinct integers in nums1 which are not present in nums2. * answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note: * the integers in the lists may be returned in any order. Examples: * findDifference([1,2,3],[2,4,6]) => [[1,3],[4,6]] * findDifference([1,2,3,3],[1,1,2,2]) => [[3],[]] \"\"\"\n```", "thought_answer": "```\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        def search(s1: set, s2: set, idx: int):\n            for num in s1:\n                if num not in s2:\n                    answer[idx].append(num)\n\n        answer = [[], []]  \n        set1, set2 = set(nums1), set(nums2)   # \u8f6c\u4e3a\u96c6\u5408\uff0c\u7528\u4e8e\u5feb\u901f\u5224\u65ad\u662f\u5426\u5305\u542b\u67d0\u4e2a\u5143\u7d20\n        \n        # \u679a\u4e3e\u96c6\u54081\u7684\u5143\u7d20\uff0c\u627e\u5230\u4e0d\u5728\u96c6\u54082\u7684\u5143\u7d20\n        search(set1, set2, 0)\n        # \u679a\u4e3e\u96c6\u54082\u7684\u5143\u7d20\uff0c\u627e\u5230\u4e0d\u5728\u96c6\u54081\u7684\u5143\u7d20\n        search(set2, set1, 1)\n        \n        return answer\n```"}
{"thought_name": "Unique Number of Occurrences ", "thought_question": "```\ndef uniqueOccurrences(self, arr: List[int]) -> bool: \"\"\" Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise. Examples: * uniqueOccurrences([1,2,2,1,1,3]) => true * uniqueOccurrences([1,2]) => false * uniqueOccurrences([-3,0,1,-3,1,1,1,-3,10,0]) => true \"\"\"\n```", "thought_answer": "```\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        counts = Counter(arr)     # \u7edf\u8ba1\u6bcf\u4e2a\u5143\u7d20\u51fa\u73b0\u6b21\u6570\n        counts_set = set()        # \u6240\u6709\u7684\u6b21\u6570\u96c6\u5408\n        \n        for cnt in counts.values():\n            if cnt in counts_set: return False # \u5f53\u524d\u6b21\u6570\u5df2\u51fa\u73b0\uff0c\u4e0d\u662f\u552f\u4e00\u7684\n            counts_set.add(cnt)\n        \n        return True\n```"}
{"thought_name": "Determine if Two Strings Are Close ", "thought_question": "```\ndef closeStrings(self, word1: str, word2: str) -> bool: \"\"\" wo strings are considered close if you can attain one from the other using the following operations: * Operation 1: Swap any two existing characters. * For example, abcde -> aecdb * Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. * For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)You can use the operations on either string as many times as necessary.Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise. Examples: * closeStrings(\"abc\",\"bca\") => true * closeStrings(\"a\",\"aa\") => false * closeStrings(\"cabbba\",\"abbccc\") => true \"\"\"\n```", "thought_answer": "```\n    def closeStrings(self, s: str, t: str) -> bool:\n        return len(s) == len(t) and \\\n               set(s) == set(t) and \\\n               Counter(Counter(s).values()) == Counter(Counter(t).values())\n```"}
{"thought_name": "Equal Row and Column Pairs ", "thought_question": "```\ndef equalPairs(self, grid: List[List[int]]) -> int: \"\"\" Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array). Examples: * equalPairs([[3,2,1],[1,7,6],[2,7,7]]) => 1 * equalPairs([[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]) => 3 \"\"\"\n```", "thought_answer": "```\n    def equalPairs(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        ans = 0\n        for i in range(n):\n            for j in range(n):\n                ans += all(grid[i][k] == grid[k][j] for k in range(n))\n        return ans\n```"}
{"thought_name": "Removing Stars From a String ", "thought_question": "```\ndef removeStars(self, s: str) -> str: \"\"\" You are given a string s, which contains stars *.In one operation, you can: * Choose a star in s. * Remove the closest non-star character to its left, as well as remove the star itself.\nReturn the string after all stars have been removed.Note: * The input will be generated such that the operation is always possible. * It can be shown that the resulting string will always be unique. Examples: * removeStars(\"leet**cod*e\") => \"lecoe\" * removeStars(\"erase*****\") => \"\" \"\"\"\n```", "thought_answer": "```\n    def removeStars(self, s: str) -> str:\n        st = []\n        for c in s:\n            if c == '*': st.pop()\n            else: st.append(c)\n        return ''.join(st)\n```"}
{"thought_name": "Asteroid Collision ", "thought_question": "```\ndef asteroidCollision(self, asteroids: List[int]) -> List[int]: \"\"\" We are given an array asteroids of integers representing asteroids in a row.For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. Examples: * asteroidCollision([5,10,-5]) => [5,10] * asteroidCollision([8,-8]) => [] * asteroidCollision([10,2,-5]) => [10] \"\"\"\n```", "thought_answer": "```\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stack = [-1001]     # \u6808\u5e95\u662f\u4e2a\u4e0d\u53ef\u80fd\u78b0\u649e\u7684\u5411\u5de6\u6700\u5927\u8d28\u91cf\u884c\u661f\n        for a in asteroids:\n            if stack[-1] < 0 or a > 0 :\n                stack.append(a)\n            elif stack[-1] <= -a:\n                # \u6bd4\u6808\u9876\u5411\u53f3\u98de\u884c\u7684\u8d28\u91cf\u5927\u5c31\u51fa\u6808\n                while stack[-1] > 0 and stack[-1] < -a:\n                    stack.pop()\n                if stack[-1] < 0:\n                    stack.append(a)\n                elif stack[-1] == -a:   # \u62b5\u6d88\u60c5\u51b5\n                    stack.pop()\n        return stack[1:]\n```"}
{"thought_name": "Decode String ", "thought_question": "```\ndef decodeString(self, s: str) -> str: \"\"\" Given an encoded string, return its decoded string.The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].The test cases are generated so that the length of the output will never exceed 105. Examples: * decodeString(\"3[a]2[bc]\") => \"aaabcbc\" * decodeString(\"3[a2[c]]\") => \"accaccacc\" * decodeString(\"2[abc]3[cd]ef\") => \"abcabccdcdcdef\" \"\"\"\n```", "thought_answer": "```\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n```"}
{"thought_name": "Dota2 Senate ", "thought_question": "```\ndef predictPartyVictory(self, senate: str) -> str: \"\"\" In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\n* Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\n* Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\nGiven a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\nExamples: * predictPartyVictory(\"RD\") => \"Radiant\" * predictPartyVictory(\"RDD\") => \"Dire\" \"\"\"\n```", "thought_answer": "```\n    def predictPartyVictory(self, senate: str) -> str:\n        def aciton(q1: \"deque\", q2: \"deque\"):\n            q2.popleft()    # q2\u9635\u8425\u9996\u4e2a\u53c2\u8bae\u9662\u4e27\u5931\u6743\u529b\uff0c\u76f4\u63a5\u51fa\u961f\n            q1.append(q1.popleft() + n)     #  q1\u6267\u884c\u6743\u529b\u7684\u53c2\u8bae\u9662\u51fa\u961f; q1\u6267\u884c\u6743\u529b\u7684\u53c2\u8bae\u5458\u91cd\u65b0\u5165\u961f\uff0c\u52a0n\u662f\u4e3a\u4e86\u8868\u793a\u5176\u8fdb\u5165\u4e86\u4e0b\u4e00\u8f6e\n\n        radiants = deque()    # \u961f\u5217\u4e2d\u8bb0\u5f55\u7740Radiannt\u9635\u8425\u4e2d\u53ef\u4ee5\u6267\u884c\u6743\u529b\u7684\u4eba\n        dires = deque()       # \u961f\u5217\u4e2d\u8bb0\u5f55\u7740Dire\u9635\u8425\u4e2d\u53ef\u4ee5\u6267\u884c\u6743\u529b\u7684\u4eba\n        n = len(senate)\n        for i, se in enumerate(senate):\n            # \u521d\u59cb\u6240\u6709\u53c2\u8bae\u5458\u90fd\u53ef\u4ee5\u6267\u884c\u6743\u529b\uff0c\u5c06\u6bcf\u4e2a\u53c2\u8bae\u5458\u4e0b\u6807\u6dfb\u52a0\u5230\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\n            if se == 'R':\n                radiants.append(i)\n            else:\n                dires.append(i)\n\n        # \u53ea\u6709\u4e00\u4e2a\u9635\u8425\u7684\u961f\u5217\u4e3a\u7a7a\u4e86\uff0c\u8bf4\u660e\u8fd9\u4e2a\u9635\u8425\u6240\u6709\u53c2\u8bae\u9662\u90fd\u5931\u53bb\u6743\u529b\u4e86\uff0c\u53e6\u4e00\u4e2a\u9635\u8425\u83b7\u80dc\n        while radiants and  dires:\n            if radiants[0] < dires[0]:\n                # Radiant\u9635\u8425\u7684\u4eba\u66f4\u9760\u524d\uff0c\u4ed6\u5c06\u7981\u6b62Dire\u9635\u8425\u4e2d\u9996\u4e2a\u62e5\u6709\u6743\u529b\u7684\u4eba\uff0c\u7136\u540e\u5b83\u91cd\u65b0\u6392\u5230\u961f\u4f0d\u6700\u540e\uff0c\u7b49\u5f85\u4e0b\u4e00\u6b21\u8f6e\u5230\u5b83\u6267\u884c\u6743\u529b\n                aciton(radiants, dires)\n            else:\n                # Dire\u9635\u8425\u7684\u4eba\u66f4\u9760\u524d\uff0c\u4ed6\u5c06\u7981\u6b62Radiant\u9635\u8425\u4e2d\u9996\u4e2a\u62e5\u6709\u6743\u529b\u7684\u4eba\uff0c\u7136\u540e\u5b83\u91cd\u65b0\u6392\u5230\u961f\u4f0d\u6700\u540e\uff0c\u7b49\u5f85\u4e0b\u4e00\u6b21\u8f6e\u5230\u5b83\u6267\u884c\u6743\u529b\n                aciton(dires, radiants)\n\n        return  \"Radiant\" if radiants else \"Dire\"\n```"}
{"thought_name": "Delete the Middle Node of a Linked List", "thought_question": "```\ndef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]: \"\"\" You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\n\nThe middle node of a linked list of size n is the \u230an / 2\u230bth node from the start using 0-based indexing, where \u230ax\u230b denotes the largest integer less than or equal to x.\n\n* For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\nExamples: * deleteMiddle([1,3,4,7,1,2,6]) => [1,3,4,1,2,6] * deleteMiddle([1,2,3,4]) => [1,2,4] * deleteMiddle([2,1]) => [2] \"\"\"\n```", "thought_answer": "```\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return None     # \u94fe\u8868\u957f\u5ea6\u4e3a0\u62161\uff0c\u5220\u9664\u540e\u4e3a\u7a7a\u94fe\u8868\n        slow = fast = head    # \u5feb\u6162\u6307\u9488\uff0c\u5feb\u6162\u6307\u9488\u5747\u6307\u5411\u5934\u8282\u70b9\n        while fast and fast.next:    \n            fast = fast.next.next    # \u5feb\u6307\u9488\u6bcf\u6b21\u79fb\u52a8\u4e24\u4e2a\u8282\u70b9\n            pre = slow               # \u5148\u8bb0\u5f55\u5f53\u524d\u6162\u6307\u9488\u6307\u5411\u7684\u8282\u70b9\uff0c\u518d\u79fb\u52a8\u6162\u6307\u9488\uff0c\u4ece\u800c\u4fdd\u8bc1pre\u59cb\u7ec8\u6307\u5411slow\u7684\u4e0a\u4e00\u4e2a\u8282\u70b9\n            slow = slow.next         # \u6162\u6307\u9488\u6bcf\u6b21\u79fb\u52a8\u4e00\u4e2a\u8282\u70b9\n        # \u5feb\u6307\u9488\u5230\u8fbe\u94fe\u8868\u5c3e\u90e8\u65f6\uff0c\u6162\u6307\u9488\u5373\u6307\u5411\u4e2d\u95f4\u8282\u70b9\uff0cpre\u6307\u5411\u524d\u4e00\u4e2a\u8282\u70b9\n        pre.next = pre.next.next\n        return head     # \u8fd4\u56de\u539f\u6765\u7684\u5934\u8282\u70b9\n```"}
{"thought_name": "Odd Even Linked List ", "thought_question": "```\ndef oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]: \"\"\" Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\n\nThe first node is considered odd, and the second node is even, and so on.\n\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\n\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExamples: * oddEvenList([1,2,3,4,5]) => [1,3,5,2,4] * oddEvenList([2,1,3,5,6,4,7]) => [2,3,6,7,1,5,4] \"\"\"\n```", "thought_answer": "```\n    def oddEvenList(self, head: ListNode) -> ListNode:\n        if not head:return head\n        odd = head\n        even_head = even = head.next\n        while odd.next and even.next:\n            odd.next = odd.next.next\n            even.next = even.next.next\n            odd,even = odd.next,even.next\n        odd.next = even_head\n        return head\n```"}
{"thought_name": "Reverse Linked List ", "thought_question": "```\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]: \"\"\" Given the head of a singly linked list, reverse the list, and return the reversed list.\nExamples: * oddEvenList([1,2,3,4,5]) => [1,3,5,2,4] * reverseList([1,2]) => [2,1] * reverseList([]) => [] \"\"\"\n```", "thought_answer": "```\n    def reverseList(self, head: ListNode) -> ListNode:\n        cur, pre = head, None\n        while cur:\n            tmp = cur.next # \u6682\u5b58\u540e\u7ee7\u8282\u70b9 cur.next\n            cur.next = pre # \u4fee\u6539 next \u5f15\u7528\u6307\u5411\n            pre = cur      # pre \u6682\u5b58 cur\n            cur = tmp      # cur \u8bbf\u95ee\u4e0b\u4e00\u8282\u70b9\n        return pre\n```"}
{"thought_name": "Maximum Twin Sum of a Linked List ", "thought_question": "```\ndef pairSum(self, head: Optional[ListNode]) -> int: \"\"\" In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.\n\n* For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.\nThe twin sum is defined as the sum of a node and its twin.\n\nGiven the head of a linked list with even length, return the maximum twin sum of the linked list.\nExamples: * pairSum([5,4,2,1]) => 6 * pairSum([4,2,2,3]) => 7 * pairSum([1,100000]) => 100001 \"\"\"\n```", "thought_answer": "```\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        arr=[]\n        while head:\n            arr.append(head.val)\n            head=head.next\n        maxsum=0\n        i,j=0,len(arr)-1\n        while i<j:\n            maxsum=max(maxsum,arr[i]+arr[j])\n            i+=1\n            j-=1\n        return maxsum\n```"}
{"thought_name": "Maximum Depth of Binary Tree ", "thought_question": "```\ndef maxDepth(self, root: Optional[TreeNode]) -> int: \"\"\" Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExamples: * maxDepth([3,9,20,null,null,15,7]) => 3 * maxDepth([1,null,2]) => 2 \"\"\"\n```", "thought_answer": "```\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        queue, res = [root], 0\n        while queue:\n            tmp = []\n            for node in queue:\n                if node.left: tmp.append(node.left)\n                if node.right: tmp.append(node.right)\n            queue = tmp\n            res += 1\n        return res\n```"}
{"thought_name": "Leaf-Similar Trees ", "thought_question": "```\ndef leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool: \"\"\" Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\nExamples: * leafSimilar([3,5,1,6,2,9,8,null,null,7,4],[3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]) => true * leafSimilar([1,2,3],[1,3,2]) => false \"\"\"\n```", "thought_answer": "```\n    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:\n        res1 = []\n        res2 = []\n        self.dfs(root1, res1)\n        self.dfs(root2, res2)\n        return res1 == res2\n        \n\n    def dfs(self, root, result):\n        stack = []\n        current = root\n        while current is not None or len(stack) > 0:\n            # \u76f8\u5f53\u4e8e\u9012\u5f52\u6cd5\u4e2d\u7684 dfs(root.left), \u4f18\u5148\u628aleft\u8282\u70b9\u90fd\u538b\u5165\u6808            \n            while current:\n                stack.append(current)\n                current = current.left\n\n            # left \u8282\u70b9\u90fd\u5df2\u7ecf\u538b\u5b8c\u4e86, \u4ece\u6808\u4e2d\u53d6\u6700\u8fd1\u538b\u5165\u7684 TreeNode\n            current = stack.pop()\n\n            if current.left is None and current.right is None:\n                result.append(current.val)\n\n            # \u76f8\u5f53\u4e8e\u9012\u5f52\u6cd5\u4e2d\u7684 dfs(root.right) \u90a3\u4e00\u6b65\n            current = current.right\n```"}
{"thought_name": "Count Good Nodes in Binary Tree ", "thought_question": "```\ndef goodNodes(self, root: TreeNode) -> int: \"\"\" Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\n\nReturn the number of good nodes in the binary tree.\nExamples: * goodNodes([3,1,4,3,null,1,5]) => 4 * goodNodes([3,3,null,4,2]) => 3 * goodNodes([1]) => 1 \"\"\"\n```", "thought_answer": "```\n    def goodNodes(self, root: TreeNode, mx=-inf) -> int:\n        if root is None:\n            return 0\n        left = self.goodNodes(root.left, max(mx, root.val))\n        right = self.goodNodes(root.right, max(mx, root.val))\n        return left + right + (mx <= root.val)\n```"}
{"thought_name": "Path Sum III ", "thought_question": "```\ndef pathSum(self, root: Optional[TreeNode], targetSum: int) -> int: \"\"\" Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\nExamples: * pathSum([10,5,-3,3,2,null,11,3,-2,null,1],8) => 3 * pathSum([5,4,8,11,null,13,4,7,2,null,null,5,1],22) => 3 \"\"\"\n```", "thought_answer": "```\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        ans = 0\n        cnt = defaultdict(int)\n        cnt[0] = 1\n\n        def dfs(node: Optional[TreeNode], s: int) -> None:\n            if node is None:\n                return\n            nonlocal ans\n            s += node.val\n            ans += cnt[s - targetSum]\n            cnt[s] += 1\n            dfs(node.left, s)\n            dfs(node.right, s)\n            cnt[s] -= 1  # \u6062\u590d\u73b0\u573a\n\n        dfs(root, 0)\n        return ans\n```"}
{"thought_name": "Longest ZigZag Path in a Binary Tree ", "thought_question": "```\ndef longestZigZag(self, root: Optional[TreeNode]) -> int: \"\"\" You are given the root of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n* Choose any node in the binary tree and a direction (right or left).\n* If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n* Change the direction from right to left or from left to right.\n* Repeat the second and third steps until you can't move in the tree.\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\nExamples: * longestZigZag([1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]) => 3 * longestZigZag([1,1,1,null,1,null,null,1,1,null,1]) => 4 * longestZigZag([1]) => 0 \"\"\"\n```", "thought_answer": "```\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\n        ans=0\n        def dfs(nd):\n            if not nd:\n                return -1,-1\n            nonlocal ans\n            l1,r1=dfs(nd.left)\n            l2,r2=dfs(nd.right)\n            ans=max(ans, 1+r1, 1+l2)\n            return 1+r1, 1+l2\n        dfs(root)\n        return ans\n```"}
{"thought_name": "Lowest Common Ancestor of a Binary Tree ", "thought_question": "```\ndef lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': \"\"\" Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: \u201cThe lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).\u201d\nExamples: * lowestCommonAncestor([3,5,1,6,2,0,8,null,null,7,4],5,1) => 3 * lowestCommonAncestor([3,5,1,6,2,0,8,null,null,7,4],5,4) => 5 * lowestCommonAncestor([1,2],1,2) => 1 \"\"\"\n```", "thought_answer": "```\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        if not root or root == p or root == q: return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if not left: return right\n        if not right: return left\n        return root\n```"}
{"thought_name": "Binary Tree Right Side View ", "thought_question": "```\ndef rightSideView(self, root: Optional[TreeNode]) -> List[int]: \"\"\" Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExamples: * rightSideView([1,2,3,null,5,null,4]) => [1,3,4] * rightSideView([1,null,3]) => [1,3] * rightSideView([]) => [] \"\"\"\n```", "thought_answer": "```\n    def rightSideView(self, root: TreeNode) -> List[int]:\n        rightmost_value_at_depth = dict() # \u6df1\u5ea6\u4e3a\u7d22\u5f15\uff0c\u5b58\u653e\u8282\u70b9\u7684\u503c\n        max_depth = -1\n\n        stack = [(root, 0)]\n        while stack:\n            node, depth = stack.pop()\n\n            if node is not None:\n                # \u7ef4\u62a4\u4e8c\u53c9\u6811\u7684\u6700\u5927\u6df1\u5ea6\n                max_depth = max(max_depth, depth)\n\n                # \u5982\u679c\u4e0d\u5b58\u5728\u5bf9\u5e94\u6df1\u5ea6\u7684\u8282\u70b9\u6211\u4eec\u624d\u63d2\u5165\n                rightmost_value_at_depth.setdefault(depth, node.val)\n\n                stack.append((node.left, depth + 1))\n                stack.append((node.right, depth + 1))\n\n        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]\n```"}
{"thought_name": "Maximum Level Sum of a Binary Tree ", "thought_question": "```\ndef maxLevelSum(self, root: Optional[TreeNode]) -> int: \"\"\" Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.\nReturn the smallest level x such that the sum of all the values of nodes at level x is maximal.\nExamples: * maxLevelSum([1,7,0,7,-8,null,null]) => 2 * maxLevelSum([989,null,10250,98693,-89388,null,null,null,-32127]) => 2 \"\"\"\n```", "thought_answer": "```\n    def maxLevelSum(self, root: Optional[TreeNode]) -> int:\n        ans, num, queue, level = 1, -inf, deque([root]), 1\n        while queue:\n            s = 0\n            for i in range(len(queue)):\n                node = queue.popleft()\n                s += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if s > num:\n                ans, num = level, s\n            level += 1\n        return ans\n```"}
{"thought_name": "Search in a Binary Search Tree ", "thought_question": "```\ndef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]: \"\"\" You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nExamples: * searchBST([4,2,7,1,3],2) => [2,1,3] * searchBST([4,2,7,1,3],5) => [] \"\"\"\n```", "thought_answer": "```\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if root == None or root.val == val:\n            return root\n        #\u4e8c\u53c9\u641c\u7d22\u6811\u6709\u5e8f\uff0c\u6839\u8282\u70b9\u5927\u4e8e\u5de6\u8282\u70b9\uff0c\u5c0f\u4e8e\u53f3\u8282\u70b9\n        #\u82e5\u8282\u70b9\u503c\u5927\u4e8e\u76ee\u6807\u503c\uff0c\u5219\u641c\u7d22\u5de6\u5b50\u6811\n        if root.val > val:\n            result=self.searchBST(root.left,val)\n        #\u82e5\u8282\u70b9\u503c\u5c0f\u4e8e\u76ee\u6807\u503c\uff0c\u5219\u641c\u7d22\u53f3\u5b50\u6811\n        if root.val < val:\n            result=self.searchBST(root.right,val)\n        return result\n```"}
{"thought_name": "Delete Node in a BST ", "thought_question": "```\ndef deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]: \"\"\" Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\n* Search for a node to remove.\n* If the node is found, delete the node.\nExamples: * deleteNode([5,3,6,2,4,null,7],3) => [5,4,6,2,null,null,7] * deleteNode([5,3,6,2,4,null,7],0) => [5,3,6,2,4,null,7] * deleteNode([],0) => [] \"\"\"\n```", "thought_answer": "```\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if root:\n            if root.val < key:\n                root.right = self.deleteNode(root.right, key)\n            elif root.val > key:\n                root.left = self.deleteNode(root.left, key)\n            else:\n                if not root.left or not root.right:\n                    root = root.left if root.left else root.right\n                else:\n                    node = root.left\n                    while node.right:\n                        node = node.right\n                    node.left = self.deleteNode(root.left, node.val)\n                    node.right = root.right\n                    root = node\n        return root\n```"}
{"thought_name": "Keys and Rooms ", "thought_question": "```\ndef canVisitAllRooms(self, rooms: List[List[int]]) -> bool: \"\"\" There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\nExamples: * canVisitAllRooms([[1],[2],[3],[]]) => true * canVisitAllRooms([[1,3],[3,0,1],[2],[0]]) => false \"\"\"\n```", "thought_answer": "```\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited, queue = {0}, [0]\n        while queue:\n            room_index = queue.pop()\n            for key in rooms[room_index]:\n                if key not in visited:\n                    visited.add(key)\n                    queue.insert(0,key)\n        return len(visited) == len(rooms)\n```"}
{"thought_name": "Number of Provinces ", "thought_question": "```\ndef findCircleNum(self, isConnected: List[List[int]]) -> int: \"\"\" There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n\nReturn the total number of provinces.\nExamples: * findCircleNum([[1,1,0],[1,1,0],[0,0,1]]) => 2 * findCircleNum([[1,0,0],[0,1,0],[0,0,1]]) => 3 \"\"\"\n```", "thought_answer": "```\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:   \n        #dfs\n        def dfs(i):\n            for j in range(n):\n                if isConnected[i][j] == 1 and j not in cnt:\n                    cnt.add(j)\n                    dfs(j)\n        n = len(isConnected)\n        ans = 0\n        cnt = set()\n        for i in range(n):\n            if i not in cnt:\n                ans += 1\n                dfs(i)\n        return ans\n        #bfs\n        n = len(isConnected)\n        ans = 0\n        cnt = set()\n        for i in range(n):\n            if i not in cnt:\n                queue = [i]\n                while queue:\n                    j = queue.pop(0)\n                    cnt.add(j)\n                    for k in range(n):\n                        if isConnected[j][k] == 1 and k not in cnt:\n                            queue.append(k)\n                ans += 1\n        return ans\n```"}
{"thought_name": "Reorder Routes to Make All Paths Lead to the City Zero ", "thought_question": "```\ndef minReorder(self, n: int, connections: List[List[int]]) -> int: \"\"\" There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\n\nThis year, there will be a big event in the capital (city 0), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.\n\nIt's guaranteed that each city can reach city 0 after reorder.\nExamples: * minReorder(6,[[0,1],[1,3],[2,3],[4,0],[4,5]]) => 3 * minReorder(5,[[1,0],[1,2],[3,2],[3,4]]) => 2 * minReorder(3,[[1,0],[2,0]]) => 0 \"\"\"\n```", "thought_answer": "```\n    def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        def dfs(a: int, fa: int) -> int:\n            return sum(c + dfs(b, a) for b, c in g[a] if b != fa)\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append((b, 1))\n            g[b].append((a, 0))\n        return dfs(0, -1)\n```"}
{"thought_name": "Evaluate Division ", "thought_question": "```\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]: \"\"\" You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\n\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\n\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\n\nNote: \n* The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n* The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\nExamples: * calcEquation([[\"a\",\"b\"],[\"b\",\"c\"]],[2.0,3.0],[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]) => [6.00000,0.50000,-1.00000,1.00000,-1.00000] * calcEquation([[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]],[1.5,2.5,5.0],[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]) => [3.75000,0.40000,5.00000,0.20000] * calcEquation([[\"a\",\"b\"]],[0.5],[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]) => [0.50000,2.00000,-1.00000,-1.00000] \"\"\"\n```", "thought_answer": "```\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = defaultdict(list)\n        for (a, b), val in zip(equations, values):\n            graph[a].append((b, val))\n            graph[b].append((a, 1.0 / val))\n\n        def bfs(init, goal):\n            if init not in graph or goal not in graph:\n                return -1.0\n            explored = {init}\n            q = deque([(init, 1.0)])\n            while q:\n                node, v = q.popleft()\n                if node == goal:\n                    return v\n                for nxt, cost in graph[node]:\n                    if nxt not in explored:\n                        explored.add(nxt)\n                        q.append((nxt, v * cost))\n            return -1.0\n\n        return [bfs(i, g) for i, g in queries]\n```"}
{"thought_name": "Nearest Exit from Entrance in Maze ", "thought_question": "```\ndef nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int: \"\"\" You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\nIn one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\nReturn the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\nExamples: * nearestExit([[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]],[1,2]) => 1 * nearestExit([[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]],[1,0]) => 2 * nearestExit([[\".\",\"+\"]],[0,0]) => -1 \"\"\"\n```", "thought_answer": "```\n    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n        # \u591a\u6e90BFS\uff0c\u6211\u4ece\u51fa\u53e3\u51fa\u53d1\uff0c\u770b\u770b\u6700\u5feb\u5230\u8fbeentrance\u7684\u8def\u5f84\n        q = deque()\n        visted = set()\n        ei = entrance[0]\n        ej = entrance[1]\n        for i in range(len(maze)):\n            for j in range(len(maze[0])):\n                if i == 0 or i == len(maze)-1 or j == 0 or j == len(maze[0])-1:\n                    if maze[i][j] == '.':\n                        if (i,j) != (ei,ej):\n                            q.append((i,j,0))\n                            visted.add((i,j,0))\n        dirc = [(-1,0),(1,0),(0,-1),(0,1)]\n        while q:\n            i,j,step = q.popleft()\n            if i == ei and j == ej:\n                return step\n            \n            for m,n in dirc:\n                if 0 <= i+m < len(maze) and 0 <= j+n <len(maze[0]) and (i+m,j+n) not in visted:\n                    if maze[i+m][j+n] == '.':\n                        visted.add((i+m,j+n))\n                        q.append((i+m,j+n,step+1))\n        return -1\n```"}
{"thought_name": "Rotting Oranges ", "thought_question": "```\ndef orangesRotting(self, grid: List[List[int]]) -> int: \"\"\" You are given an m x n grid where each cell can have one of three values:\n\n* 0 representing an empty cell,\n* 1 representing a fresh orange, or\n* 2 representing a rotten orange.\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\nExamples: * orangesRotting([[2,1,1],[1,1,0],[0,1,1]]) => 4 * orangesRotting([[2,1,1],[0,1,1],[1,0,1]]) => -1 * orangesRotting([[0,2]]) => 0 \"\"\"\n```", "thought_answer": "```\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        row = len(grid)\n        col = len(grid[0])\n        rotten = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 2} # \u8150\u70c2\u96c6\u5408\n        fresh = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 1}  # \u65b0\u9c9c\u96c6\u5408\n        time = 0\n        while fresh:\n            if not rotten: return -1\n            rotten = {(i + di, j + dj) for i, j in rotten for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)] if (i + di, j + dj) in fresh} # \u5373\u5c06\u8150\u70c2\u7684\u5982\u679c\u5728\u65b0\u9c9c\u7684\u96c6\u5408\u4e2d\uff0c\u5c31\u5c06\u5b83\u8150\u70c2\n            fresh -= rotten # \u5254\u9664\u8150\u70c2\u7684\n            time += 1\n        return time\n```"}
{"thought_name": "Kth Largest Element in an Array ", "thought_question": "```\ndef findKthLargest(self, nums: List[int], k: int) -> int: \"\"\" Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\n\nCan you solve it without sorting?\nExamples: * findKthLargest([3,2,1,5,6,4],2) => 5 * findKthLargest([3,2,3,1,2,4,5,5,6],4) => 4   \"\"\"\n```", "thought_answer": "```\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        \n        def partition(arr: List[int], low: int, high: int) -> int:\n            pivot = arr[low]                                        # \u9009\u53d6\u6700\u5de6\u8fb9\u4e3apivot\n\n            left, right = low, high     # \u53cc\u6307\u9488\n            while left < right:\n                \n                while left<right and arr[right] >= pivot:          # \u627e\u5230\u53f3\u8fb9\u7b2c\u4e00\u4e2a<pivot\u7684\u5143\u7d20\n                    right -= 1\n                arr[left] = arr[right]                             # \u5e76\u5c06\u5176\u79fb\u52a8\u5230left\u5904\n                \n                while left<right and arr[left] <= pivot:           # \u627e\u5230\u5de6\u8fb9\u7b2c\u4e00\u4e2a>pivot\u7684\u5143\u7d20\n                    left += 1\n                arr[right] = arr[left]                             # \u5e76\u5c06\u5176\u79fb\u52a8\u5230right\u5904\n            \n            arr[left] = pivot           # pivot\u653e\u7f6e\u5230\u4e2d\u95f4left=right\u5904\n            return left\n        \n        def randomPartition(arr: List[int], low: int, high: int) -> int:\n            pivot_idx = random.randint(low, high)                   # \u968f\u673a\u9009\u62e9pivot\n            arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low]     # pivot\u653e\u7f6e\u5230\u6700\u5de6\u8fb9\n            return partition(arr, low, high)                        # \u8c03\u7528partition\u51fd\u6570\n\n        def topKSplit(arr: List[int], low: int, high: int, k: int) -> int:\n            # mid = partition(arr, low, high)                   # \u4ee5mid\u4e3a\u5206\u5272\u70b9\u3010\u975e\u968f\u673a\u9009\u62e9pivot\u3011\n            mid = randomPartition(arr, low, high)               # \u4ee5mid\u4e3a\u5206\u5272\u70b9\u3010\u968f\u673a\u9009\u62e9pivot\u3011\n            if mid == k-1:                                      # \u7b2ck\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u4e3ak-1\n                return arr[mid]                                 #\u3010\u627e\u5230\u5373\u8fd4\u56de\u3011\n            elif mid < k-1:\n                return topKSplit(arr, mid+1, high, k)           # \u9012\u5f52\u5bf9mid\u53f3\u4fa7\u5143\u7d20\u8fdb\u884c\u6392\u5e8f\n            else:\n                return topKSplit(arr, low, mid-1, k)            # \u9012\u5f52\u5bf9mid\u5de6\u4fa7\u5143\u7d20\u8fdb\u884c\u6392\u5e8f\n        \n        n = len(nums)\n        return topKSplit(nums, 0, n-1, n-k+1)                   # \u7b2ck\u5927\u5143\u7d20\u5373\u4e3a\u7b2cn-k+1\u5c0f\u5143\u7d20\n```"}
{"thought_name": "Maximum Subsequence Score ", "thought_question": "```\ndef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int: \"\"\" You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\n\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\n* The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\n* It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\nExamples: * maxScore([1,3,3,2],[2,1,3,4],3) => 12 * maxScore([4,2,3,1,1],[7,5,10,9,6],1) => 30 \"\"\"\n```", "thought_answer": "```\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        for i in range(len(nums2)):\n            nums2[i] = [nums2[i], nums1[i]]\n        nums2.sort()#\u7ed1\u5b9a\u3001\u6392\u5e8f\n        pq = nums2[len(nums2) - k:len(nums2)]\n        num = sum(x[1] for x in pq)#\u6c42\u521d\u59cb\u5143\u7d20\u548c\n        pq = [x[1] for x in pq]\n        heapq.heapify(pq)#\u751f\u6210\u5c0f\u9876\u5806\n        ans = num * nums2[-k][0]\n        for i in range(len(nums2) - k - 1, -1, -1):#\u4ece\u540e\u5411\u524d\u904d\u5386\n            if pq[0]<nums2[i][1]:#\u7ef4\u62a4\n                num += nums2[i][1] - pq[0]\n                heapq.heappop(pq)\n                heapq.heappush(pq, nums2[i][1])\n            ans = max(ans, num*nums2[i][0])\n        return ans\n```"}
{"thought_name": "Total Cost to Hire K Workers ", "thought_question": "```\ndef totalCost(self, costs: List[int], k: int, candidates: int) -> int: \"\"\" You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\n\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\n\n* You will run k sessions and hire exactly one worker in each session.\n* In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\n* For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].\n* In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\n* If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n* A worker can only be chosen once.\nReturn the total cost to hire exactly k workers.\nExamples: * totalCost([17,12,10,2,7,2,11,20,8],3,4) => 11 * totalCost([1,2,4,1],3,3) => 4 \"\"\"\n```", "thought_answer": "```\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        if candidates * 2 + k > n:\n            # \u4e5f\u53ef\u4ee5 sum(nsmallest(k, costs))\uff0c\u4f46\u6548\u7387\u4e0d\u5982\u76f4\u63a5\u6392\u5e8f\n            costs.sort()\n            return sum(costs[:k])\n\n        pre = costs[:candidates]\n        suf = costs[-candidates:]\n        heapify(pre)\n        heapify(suf)\n\n        ans = 0\n        i = candidates\n        j = n - 1 - candidates\n        for _ in range(k):\n            if pre[0] <= suf[0]:\n                ans += heapreplace(pre, costs[i])\n                i += 1\n            else:\n                ans += heapreplace(suf, costs[j])\n                j -= 1\n        return ans\n```"}
{"thought_name": "Guess Number Higher or Lower ", "thought_question": "```\ndef guessNumber(self, n: int) -> int: \"\"\" We are playing the Guess Game. The game is as follows:\n\nI pick a number from 1 to n. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n* -1: Your guess is higher than the number I picked (i.e. num > pick).\n* 1: Your guess is lower than the number I picked (i.e. num < pick).\n* 0: your guess is equal to the number I picked (i.e. num == pick).\nReturn the number that I picked.\nExamples: * guessNumber(10,6) => 6 * guessNumber(1,1) => 1 * guessNumber(2,1) => 1 \"\"\"\n```", "thought_answer": "```\n    def guessNumber(self, n: int) -> int:\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n```"}
{"thought_name": "Successful Pairs of Spells and Potions", "thought_question": "```\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]: \"\"\" You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.\n\nYou are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\n\nReturn an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.\nExamples: * successfulPairs([5,1,3],[1,2,3,4,5],7) => [4,0,3] * successfulPairs([3,1,2],[8,5,8],16) => [2,0,2] \"\"\"\n```", "thought_answer": "```\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        success -= 1\n        return [m - bisect_right(potions, success // x) for x in spells]\n```"}
{"thought_name": "Find Peak Element ", "thought_question": "```\ndef findPeakElement(self, nums: List[int]) -> int: \"\"\" A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in O(log n) time.\nExamples: * findPeakElement([1,2,3,1]) => 2 * findPeakElement([1,2,1,3,5,6,4]) => 5 \"\"\"\n```", "thought_answer": "```\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = -1, len(nums) - 1  # \u5f00\u533a\u95f4 (-1, n-1)\n        while left + 1 < right:  # \u5f00\u533a\u95f4\u4e0d\u4e3a\u7a7a\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid\n        return right\n```"}
{"thought_name": "Koko Eating Bananas ", "thought_question": "```\ndef minEatingSpeed(self, piles: List[int], h: int) -> int: \"\"\" Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExamples: * minEatingSpeed([3,6,7,11],8) => 4 * minEatingSpeed([30,11,23,4,20],5) => 30 * minEatingSpeed([30,11,23,4,20],6) => 23 \"\"\"\n```", "thought_answer": "```\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        n = len(piles)\n        left = 0  # \u6052\u4e3a False\n        right = max(piles)  # \u6052\u4e3a True\n        while left + 1 < right:  # \u5f00\u533a\u95f4\u4e0d\u4e3a\u7a7a\n            mid = (left + right) // 2\n            if sum((p - 1) // mid for p in piles) <= h - n:\n                right = mid  # \u5faa\u73af\u4e0d\u53d8\u91cf\uff1a\u6052\u4e3a True\n            else:\n                left = mid  # \u5faa\u73af\u4e0d\u53d8\u91cf\uff1a\u6052\u4e3a False\n        return right  # \u6700\u5c0f\u7684 True\n```"}
{"thought_name": "Letter Combinations of a Phone Number ", "thought_question": "```\ndef letterCombinations(self, digits: str) -> List[str]: \"\"\" Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExamples: * letterCombinations(\"23\") => [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] * letterCombinations(\"2\") => [\"a\",\"b\",\"c\"] \"\"\"\n```", "thought_answer": "```\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits: return []\n\n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n                \n        def backtrack(conbination,nextdigit):\n            if len(nextdigit) == 0:\n                res.append(conbination)\n            else:\n                for letter in phone[nextdigit[0]]:\n                    backtrack(conbination + letter,nextdigit[1:])\n\n        res = []\n        backtrack('',digits)\n        return res\n```"}
{"thought_name": "Combination Sum III ", "thought_question": "```\ndef combinationSum3(self, k: int, n: int) -> List[List[int]]: \"\"\" Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n\n* Only numbers 1 through 9 are used.\n* Each number is used at most once.\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExamples: * combinationSum3(3,7) => [[1,2,4]] * combinationSum3(3,9) => [[1,2,6],[1,3,5],[2,3,4]] * combinationSum3(4,1) => [] \"\"\"\n```", "thought_answer": "```\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        ans = []\n        path = []\n        def dfs(i: int, t: int) -> None:\n            d = k - len(path)  # \u8fd8\u8981\u9009 d \u4e2a\u6570\n            if t < 0 or t > (i * 2 - d + 1) * d // 2:  # \u526a\u679d\n                return\n            if d == 0:  # \u627e\u5230\u4e00\u4e2a\u5408\u6cd5\u7ec4\u5408\n                ans.append(path.copy())\n                return\n            for j in range(i, d - 1, -1):\n                path.append(j)\n                dfs(j - 1, t - j)\n                path.pop()\n        dfs(9, n)\n        return ans\n```"}
{"thought_name": "N-th Tribonacci Number ", "thought_question": "```\ndef tribonacci(self, n: int) -> int: \"\"\" The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.\nExamples: * tribonacci(4) => 4 * tribonacci(25) => 1389537 \"\"\"\n```", "thought_answer": "```\n    def tribonacci(self, n: int) -> int:\n\n        def gen_trib():\n            a, b, c = 0, 1, 1 \n            while True:\n                d = a + b + c\n                # python generator \u7684\u5173\u952e\u5b57 yield\n                yield d \n                a, b, c = b, c, d\n\n        if n == 0:\n            return 0\n        if n < 3:\n            return 1\n    \n        # g \u662f\u4e00\u4e2a\u751f\u6210\u5668\uff0c\u901a\u8fc7 next() \u6216\u8005 enumerate \u7b49\u65b9\u5f0f\u53ef\u4ee5\u83b7\u53d6\u4e0b\u4e00\u4e2a\u7ed3\u679c\n        g = gen_trib()\n        for i, res in enumerate(g):\n\n            if i == n-3:\n                return res\n```"}
{"thought_name": "Min Cost Climbing Stairs ", "thought_question": "```\ndef minCostClimbingStairs(self, cost: List[int]) -> int: \"\"\" You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index 0, or the step with index 1.\n\nReturn the minimum cost to reach the top of the floor.\nExamples: * minCostClimbingStairs([10,15,20]) => 15 * minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) => 6 \"\"\"\n```", "thought_answer": "```\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        minCost = [0] * n\n        minCost[1] = min(cost[0], cost[1])\n        for i in range(2, n):\n            minCost[i] = min(minCost[i - 1] + cost[i], minCost[i - 2] + cost[i - 1])\n        return minCost[-1]\n```"}
{"thought_name": "House Robber ", "thought_question": "```\ndef rob(self, nums: List[int]) -> int: \"\"\" You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExamples: * rob([1,2,3,1]) => 4 * rob([2,7,9,3,1]) => 12 \"\"\"\n```", "thought_answer": "```\ndef rob(self, nums: List[int]) -> int:\n    if len(nums) == 0:\n        return 0\n\n    # \u5b50\u95ee\u9898\uff1a\n    # f(k) = \u5077 [0..k) \u623f\u95f4\u4e2d\u7684\u6700\u5927\u91d1\u989d\n\n    # f(0) = 0\n    # f(1) = nums[0]\n    # f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\n\n    N = len(nums)\n    dp = [0] * (N+1)\n    dp[0] = 0\n    dp[1] = nums[0]\n    for k in range(2, N+1):\n        dp[k] = max(dp[k-1], nums[k-1] + dp[k-2])\n    return dp[N]\n```"}
{"thought_name": "Unique Paths ", "thought_question": "```\ndef uniquePaths(self, m: int, n: int) -> int: \"\"\" There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nExamples: * uniquePaths(3,7) => 28 * uniquePaths(3,2) => 3 \"\"\"\n```", "thought_answer": "```\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = 1\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = 1\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = 1\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = dp[i][j+1] + dp[i+1][j]\n        \n        return dp[0][0]\n```"}
{"thought_name": "Longest Common Subsequence ", "thought_question": "```\ndef longestCommonSubsequence(self, text1: str, text2: str) -> int: \"\"\" Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n* For example, \"ace\" is a subsequence of \"abcde\".\nA common subsequence of two strings is a subsequence that is common to both strings.\nExamples: * longestCommonSubsequence(\"abcde\",\"ace\") => 3 * longestCommonSubsequence(\"abc\",\"abc\") => 3 * longestCommonSubsequence(\"abc\",\"def\") => 0 \"\"\"\n```", "thought_answer": "```\n    def longestCommonSubsequence(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        @cache\n        def dfs(i, j):\n            if i < 0 or j < 0:\n                return 0\n            if s[i] == t[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n        return dfs(n - 1, m - 1)\n```"}
{"thought_name": "Best Time to Buy and Sell Stock with Transaction Fee ", "thought_question": "```\ndef maxProfit(self, prices: List[int], fee: int) -> int: \"\"\" You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\nNote:\n* You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n* The transaction fee is only charged once for each stock purchase and sale.\nExamples: * maxProfit([1,3,2,8,4,9],2) => 8 * maxProfit([1,3,7,5,10,3],3) => 6 \"\"\"\n```", "thought_answer": "```\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        n = len(prices)\n        @cache  # \u7f13\u5b58\u88c5\u9970\u5668\uff0c\u907f\u514d\u91cd\u590d\u8ba1\u7b97 dfs \u7684\u7ed3\u679c\n        def dfs(i: int, hold: bool) -> int:\n            if i < 0:\n                return -inf if hold else 0\n            if hold:\n                return max(dfs(i - 1, True), dfs(i - 1, False) - prices[i])\n            return max(dfs(i - 1, False), dfs(i - 1, True) + prices[i] - fee)\n        return dfs(n - 1, False)\n```"}
{"thought_name": "Edit Distance ", "thought_question": "```\ndef minDistance(self, word1: str, word2: str) -> int: \"\"\" Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n* Insert a character\n* Delete a character\n* Replace a character\nExamples: * minDistance(\"horse\",\"ros\") => 3 * minDistance(\"intention\",\"execution\") => 5 \"\"\"\n```", "thought_answer": "```\n    def minDistance(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        @cache\n        def dfs(i, j):\n            if i < 0: return j + 1\n            if j < 0: return i + 1\n            if s[i] == t[j]: return dfs(i - 1, j - 1)\n            return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1\n        return dfs(n - 1, m - 1)\n```"}
{"thought_name": "Counting Bits", "thought_question": "```\ndef countBits(self, n: int) -> List[int]: \"\"\" Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\nExamples: * countBits(2) => [0,1,1] * countBits(5) => [0,1,1,2,1,2] \"\"\"\n```", "thought_answer": "```\n    def countBits(self, n: int) -> List[int]:\n        result=[0]*(n+1)\n        for i in range(1,n+1):\n            if i&1:\n                result[i]=result[i-1]+1\n            else:\n                result[i]=result[i//2]\n        return result\n```"}
{"thought_name": "Single Number ", "thought_question": "```\ndef singleNumber(self, nums: List[int]) -> int: \"\"\" Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExamples: * singleNumber([2,2,1]) => 1 * singleNumber([4,1,2,1,2]) => 4 * singleNumber([1]) => 1 \"\"\"\n```", "thought_answer": "```\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        x = 0\n        for num in nums:  # 1. \u904d\u5386 nums \u6267\u884c\u5f02\u6216\u8fd0\u7b97\n            x ^= num      \n        return x;         # 2. \u8fd4\u56de\u51fa\u73b0\u4e00\u6b21\u7684\u6570\u5b57 x\n```"}
{"thought_name": "Minimum Flips to Make a OR b Equal to c ", "thought_question": "```\ndef minFlips(self, a: int, b: int, c: int) -> int: \"\"\" Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).\nFlip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\nExamples: * minFlips(2,6,5) => 3 * minFlips(4,2,7) => 1 * minFlips(1,2,3) => 0 \"\"\"\n```", "thought_answer": "```\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        ans = 0\n        for i in range(32):\n            bit_a, bit_b, bit_c = (a >> i) & 1, (b >> i) & 1, (c >> i) & 1\n            if bit_c == 0:\n                ans += bit_a + bit_b\n            else:\n                ans += int(bit_a + bit_b == 0)\n        return ans\n```"}
{"thought_name": "Search Suggestions System ", "thought_question": "```\ndef suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]: \"\"\" You are given an array of strings products and a string searchWord.\n\nDesign a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\nExamples: * suggestedProducts([\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"],\"mouse\") => [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]] * suggestedProducts([\"havana\"],\"havana\") => [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]] \"\"\"\n```", "thought_answer": "```\n    def suggestedProducts(self, ps: List[str], w: str) -> List[List[str]]:\n        ps.sort()\n        n = len(ps)\n        ans = []\n        for i in range(len(w)):\n            cur = w[:i + 1]\n            l, r = 0, n - 1\n            while l < r:\n                mid = (l + r) // 2\n                if ps[mid] >= cur:\n                    r = mid\n                else:\n                    l = mid + 1\n            lst = []\n            if ps[r] >= cur:\n                for j in range(r, min(n - 1, r + 2) + 1):\n                    if len(ps[j]) < len(cur) or ps[j][:i + 1] != cur:\n                        break\n                    lst.append(ps[j])\n            ans.append(lst)\n        return ans\n```"}
{"thought_name": "Non-overlapping Intervals ", "thought_question": "```\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -> int: \"\"\" Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nExamples: * eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]) => 1 * eraseOverlapIntervals([[1,2],[1,2],[1,2]]) => 2 * eraseOverlapIntervals([[1,2],[2,3]]) => 0 \"\"\"\n```", "thought_answer": "```\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        right = intervals[0][1]\n        remove = 0\n\n        for i in range(1, n):\n            if intervals[i][0] < right:\n                remove += 1\n            else:\n                right = intervals[i][1]\n        \n        return remove\n```"}
{"thought_name": "Minimum Number of Arrows to Burst Balloons ", "thought_question": "```\ndef findMinArrowShots(self, points: List[List[int]]) -> int: \"\"\" There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExamples: * findMinArrowShots([[10,16],[2,8],[1,6],[7,12]]) => 2 * findMinArrowShots([[1,2],[3,4],[5,6],[7,8]]) => 4 * findMinArrowShots([[1,2],[2,3],[3,4],[4,5]]) => 2 \"\"\" \n```", "thought_answer": "```\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        points.sort()   # \u6839\u636e\u533a\u95f4\u8d77\u70b9\u5bf9\u533a\u95f4\u8fdb\u884c\u5347\u5e8f\u6392\u5e8f\uff0c\u8d77\u70b9\u76f8\u540c\u6839\u636e\u533a\u95f4\u7ec8\u70b9\u5347\u5e8f\u6392\u5e8f\n        arrow = 0       # \u4f7f\u7528\u7bad\u6570\n        start, end = points[0]  # \u5f53\u524d\u533a\u95f4\u4ea4\u96c6\u8d77\u70b9\u548c\u7ec8\u70b9\uff0c\u521d\u59cb\u4e3a\u9996\u4e2a\u533a\u95f4\u8d77\u70b9\u548c\u7ec8\u70b9\n        # \u904d\u5386\u6bcf\u4e2a\u533a\u95f4\uff0c\u76f8\u540c\u533a\u95f4\u7684\u4ea4\u96c6\u4e3a\u5176\u672c\u8eab\uff0c\u56e0\u6b64\u7b2c\u4e00\u4e2a\u533a\u95f4\u7684\u904d\u5386\u4e0d\u5f71\u54cd\u7ed3\u679c\n        for (p_x, p_y) in points:\n            if p_x > end:\n                # \u5f53\u524d\u533a\u95f4\u4e0e\u5f53\u524d\u533a\u95f4\u4ea4\u96c6\u6ca1\u6709\u4ea4\u96c6\uff0c\u5f53\u524d\u4ea4\u96c6\u4f7f\u7528\u4e00\u4e2a\u6839\u7bad\uff1b\u66f4\u65b0\u533a\u95f4\u4ea4\u96c6\u4e3a\u5f53\u524d\u533a\u95f4\n                arrow += 1\n                start, end = p_x, p_y\n            else:\n                # \u5f53\u524d\u533a\u95f4\u4e0e\u5f53\u524d\u533a\u95f4\u4ea4\u96c6\u6709\u4ea4\u96c6\uff0c\u66f4\u65b0\u533a\u95f4\u4ea4\u96c6\n                start = max(start, p_x)\n                end = min(end, p_y)\n        arrow += 1  # \u6700\u540e\u4e00\u4e2a\u533a\u95f4\u4ea4\u96c6\u8fd8\u9700\u8981\u4f7f\u7528\u4e00\u6839\u7bad\n        return arrow\n```"}
{"thought_name": "Daily Temperatures ", "thought_question": "```\ndef dailyTemperatures(self, temperatures: List[int]) -> List[int]: \"\"\" Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\nExamples: * dailyTemperatures([73,74,75,71,69,72,76,73]) => [1,1,4,2,1,1,0,0] * dailyTemperatures([30,40,50,60]) => [1,1,1,0] * dailyTemperatures([30,60,90]) => [1,1,0] \"\"\" \n```", "thought_answer": "```\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        n = len(temperatures)\n        ans = [0] * n\n        st = []\n        for i in range(n - 1, -1, -1):\n            t = temperatures[i]\n            while st and t >= temperatures[st[-1]]:\n                st.pop()\n            if st:\n                ans[i] = st[-1] - i\n            st.append(i)\n        return ans\n```"}
