[
    {
        "thought_name": "Merge Strings Alternately",
        "thought_question": "```\ndef mergeAlternately(self, word1: str, word2: str) -> str: \"\"\" You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.Return the merged string. Note: * word1 and word2 consist of lowercase English letters. Examples: * mergeAlternately(\"abc\",\"pqr\") => \"apbqcr\" * mergeAlternately(\"ab\",\"pqrs\") => \"apbqrs\" * mergeAlternately(\"abcd\",\"pq\") => \"apbqcd\" \"\"\"\n```",
        "thought_answer": "```\n    def mergeAlternately(self, word1: str, word2: str) -> str:\n        m, n = len(word1), len(word2)\n        i = j = 0\n\n        ans = list()\n        while i < m or j < n:\n            if i < m:\n                ans.append(word1[i])\n                i += 1\n            if j < n:\n                ans.append(word2[j])\n                j += 1\n        \n        return \"\".join(ans)\n```"
    },
    {
        "thought_name": "Greatest Common Divisor of Strings",
        "thought_question": "```\ndef gcdOfStrings(self, str1: str, str2: str) -> str: \"\"\" For two strings s and t, we say \"t divides s\" if and only if s = t + t + t + ... + t + t (i.e., t is concatenated with itself one or more times).Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2. Note: * str1 and str2 consist of English uppercase letters. Examples: * gcdOfStrings(\"ABCABC\",\"ABC\") => \"ABC\" * gcdOfStrings(\"ABABAB\",\"ABAB\") => \"AB\" * gcdOfStrings(\"LEET\",\"CODE\") => \"\" \"\"\"\n```",
        "thought_answer": "```\n    def gcdOfStrings(self, str1: str, str2: str) -> str:\n        for i in range(min(len(str1), len(str2)), 0, -1):\n            if (len(str1) % i) == 0 and (len(str2) % i) == 0:\n                if str1[: i] * (len(str1) // i) == str1 and str1[: i] * (len(str2) // i) == str2:\n                    return str1[: i]\n        return ''\n```"
    },
    {
        "thought_name": "Kids With the Greatest Number of Candies",
        "thought_question": "```\ndef kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]: \"\"\" There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.Note: * that multiple kids can have the greatest number of candies. Examples: * kidsWithCandies([2,3,5,1,3],3) => [true,true,true,false,true] * kidsWithCandies([4,2,1,1,2],1) => [true,false,false,false,false] * kidsWithCandies([12,1,12],10) => [true,false,true] \"\"\"\n```",
        "thought_answer": "```\n    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:\n        maxCandies = max(candies)\n        ret = [candy + extraCandies >= maxCandies for candy in candies]\n        return ret\n```"
    },
    {
        "thought_name": "Can Place Flowers",
        "thought_question": "```\ndef canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool: \"\"\" You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise. Note: * There are no two adjacent flowers in flowerbed. Examples: * canPlaceFlowers([1,0,0,0,1],1) => true * canPlaceFlowers([1,0,0,0,1],2) => false \"\"\"\n```",
        "thought_answer": "```\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        count, m, prev = 0, len(flowerbed), -1\n        for i in range(m):\n            if flowerbed[i] == 1:\n                if prev < 0:\n                    count += i // 2\n                else:\n                    count += (i - prev - 2) // 2\n                prev = i\n        \n        if prev < 0:\n            count += (m + 1) // 2\n        else:\n            count += (m - prev - 1) // 2\n        \n        return count >= n\n```"
    },
    {
        "thought_name": "Reverse Vowels of a String",
        "thought_question": "```\ndef reverseVowels(self, s: str) -> str: \"\"\" Given a string s, reverse only all the vowels in the string and return it.The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once. Note: * s consist of printable ASCII characters. Examples: * reverseVowels(\"hello\") => \"holle\" * reverseVowels(\"leetcode\") => \"leotcede\" \"\"\"\n```",
        "thought_answer": "```\n    def reverseVowels(self, s: str) -> str:\n        def isVowel(ch: str) -> bool:\n            return ch in \"aeiouAEIOU\"\n        \n        n = len(s)\n        s = list(s)\n        i, j = 0, n - 1\n        while i < j:\n            while i < n and not isVowel(s[i]):\n                i += 1\n            while j > 0 and not isVowel(s[j]):\n                j -= 1\n            if i < j:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n        \n        return \"\".join(s)\n```"
    },
    {
        "thought_name": "Reverse Words in a String",
        "thought_question": "```\ndef reverseWords(self, s: str) -> str: \"\"\" Given an input string s, reverse the order of the words.A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.Return a string of the words in reverse order concatenated by a single space. Note: * s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Examples: * reverseWords(\"the sky is blue\") => \"blue is sky the\" * reverseWords(\"  hello world  \") => \"world hello\" * reverseWords(\"a good   example\") => \"example good a\" \"\"\"\n```",
        "thought_answer": "```\n    def reverseWords(self, s: str) -> str:\n        return \" \".join(reversed(s.split()))\n```"
    },
    {
        "thought_name": "Product of Array Except Self",
        "thought_question": "```\ndef productExceptSelf(self, nums: List[int]) -> List[int]: \"\"\" Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.You must write an algorithm that runs in O(n) time and without using the division operation. Note: * The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. Examples: * productExceptSelf([1,2,3,4]) => [24,12,8,6] * productExceptSelf([-1,1,0,-3,3]) => [0,0,9,0,0] \"\"\"\n```",
        "thought_answer": "```\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        length = len(nums)\n        \n        # L 和 R 分别表示左右两侧的乘积列表\n        L, R, answer = [0]*length, [0]*length, [0]*length\n        \n        # L[i] 为索引 i 左侧所有元素的乘积\n        # 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1\n        L[0] = 1\n        for i in range(1, length):\n            L[i] = nums[i - 1] * L[i - 1]\n        \n        # R[i] 为索引 i 右侧所有元素的乘积\n        # 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1\n        R[length - 1] = 1\n        for i in reversed(range(length - 1)):\n            R[i] = nums[i + 1] * R[i + 1]\n\n        # 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积\n        for i in range(length):\n            answer[i] = L[i] * R[i]\n        \n        return answer\n```"
    },
    {
        "thought_name": "Increasing Triplet Subsequence",
        "thought_question": "```\ndef increasingTriplet(self, nums: List[int]) -> bool: \"\"\" Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false. Examples: * increasingTriplet([1,2,3,4,5]) => true * increasingTriplet([5,4,3,2,1]) => false * increasingTriplet([2,1,5,0,4,6]) => true \"\"\"\n```",
        "thought_answer": "```\n    def increasingTriplet(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n < 3:\n            return False\n        leftMin = [0] * n\n        leftMin[0] = nums[0]\n        for i in range(1, n):\n            leftMin[i] = min(leftMin[i - 1], nums[i])\n        rightMax = [0] * n\n        rightMax[n - 1] = nums[n - 1]\n        for i in range(n - 2, -1, -1):\n            rightMax[i] = max(rightMax[i + 1], nums[i])\n        for i in range(1, n - 1):\n            if leftMin[i - 1] < nums[i] < rightMax[i + 1]:\n                return True\n        return False\n```"
    },
    {
        "thought_name": "String Compression ",
        "thought_question": "```\ndef compress(self, chars: List[str]) -> int: \"\"\" Given an array of characters chars, compress it using the following algorithm:Begin with an empty string s. For each group of consecutive repeating characters in chars: * If the group's length is 1, append the character to s. * Otherwise, append the character followed by the group's length.\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.After you are done modifying the input array, return the new length of the array.You must write an algorithm that uses only constant extra space. Examples: * compress([\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]) => 6 * compress([\"a\"]) => 1 * compress([\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]) => 4 \"\"\"\n```",
        "thought_answer": "```\n    def compress(self, chars: List[str]) -> int:\n        def reverse(left: int, right: int) -> None:\n            while left < right:\n                chars[left], chars[right] = chars[right], chars[left]\n                left += 1\n                right -= 1\n\n        n = len(chars)\n        write = left = 0\n        for read in range(n):\n            if read == n - 1 or chars[read] != chars[read + 1]:\n                chars[write] = chars[read]\n                write += 1\n                num = read - left + 1\n                if num > 1:\n                    anchor = write\n                    while num > 0:\n                        chars[write] = str(num % 10)\n                        write += 1\n                        num //= 10\n                    reverse(anchor, write - 1)\n                left = read + 1\n        return write\n```"
    },
    {
        "thought_name": "Move Zeroes ",
        "thought_question": "```\ndef moveZeroes(self, nums: List[int]) -> None: \"\"\" Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.Note: * that you must do this in-place without making a copy of the array. Examples: * moveZeroes([0,1,0,3,12]) => [1,3,12,0,0] * moveZeroes([0]) => [0] \"\"\"\n```",
        "thought_answer": "```\n    def moveZeroes(self, nums: List[int]) -> None:\n        n = len(nums)\n        left = right = 0\n        while right < n:\n            if nums[right] != 0:\n                nums[left], nums[right] = nums[right], nums[left]\n                left += 1\n            right += 1\n```"
    },
    {
        "thought_name": "Is Subsequence",
        "thought_question": "```\ndef isSubsequence(self, s: str, t: str) -> bool: \"\"\" Given two strings s and t, return true if s is a subsequence of t, or false otherwise.A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not). Examples: * isSubsequence(\"abc\",\"ahbgdc\") => true * isSubsequence(\"axc\",\"ahbgdc\") => false \"\"\"\n```",
        "thought_answer": "```\n    def isSubsequence(self, s: str, t: str) -> bool:\n        n, m = len(s), len(t)\n        i = j = 0\n        while i < n and j < m:\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        return i == n\n```"
    },
    {
        "thought_name": "Container With Most Water ",
        "thought_question": "```\ndef maxArea(self, height: List[int]) -> int: \"\"\" You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store. Notice * that you may not slant the container. Examples: * maxArea([1,8,6,2,5,4,8,3,7]) => 49 * maxArea([1,1]) => 1 \"\"\"\n```",
        "thought_answer": "```\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        ans = 0\n        while l < r:\n            area = min(height[l], height[r]) * (r - l)\n            ans = max(ans, area)\n            if height[l] <= height[r]:\n                l += 1\n            else:\n                r -= 1\n        return ans\n```"
    },
    {
        "thought_name": "Max Number of K-Sum Pairs ",
        "thought_question": "```\ndef maxOperations(self, nums: List[int], k: int) -> int: \"\"\" You are given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.Return the maximum number of operations you can perform on the array. Examples: * maxOperations([1,2,3,4],5) => 2 * maxOperations([3,1,3,4,3],6) => 1 \"\"\"\n```",
        "thought_answer": "```\n    def maxOperations(nums: List[int], k: int) -> int:\n        res = 0\n        counts = {} # 统计出现且未使用的数字个数\n        for num in nums:\n            # 如果num之前存在可以和它配对的数，那么就得到一个数对\n            if counts.get(k - num, 0) > 0:\n                res += 1\n                counts[k - num] -= 1   # 配对的那个数相当于被移除了，个数-1\n            else:\n                counts[num] = counts.get(num, 0) + 1  # 不存在配对的数，这个数待匹配个数加1\n        return res\n```"
    },
    {
        "thought_name": "Maximum Average Subarray I ",
        "thought_question": "```\ndef findMaxAverage(self, nums: List[int], k: int) -> float: \"\"\" You are given an integer array nums consisting of n elements, and an integer k.Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. Examples: * findMaxAverage([1,12,-5,-6,50,3],4) => 12.75000 * findMaxAverage([5],1) => 5.00000 \"\"\"\n```",
        "thought_answer": "```\n    def findMaxAverage(self, nums: List[int], k: int) -> float:\n        maxTotal = total = sum(nums[:k])\n        n = len(nums)\n\n        for i in range(k, n):\n            total = total - nums[i - k] + nums[i]\n            maxTotal = max(maxTotal, total)\n        \n        return maxTotal / k\n```"
    },
    {
        "thought_name": "Maximum Number of Vowels in a Substring of Given Length",
        "thought_question": "```\ndef maxVowels(self, s: str, k: int) -> int: \"\"\" Given a string s and an integer k, return the maximum number of vowel letters in any substring of s with length k.Vowel letters in English are 'a', 'e', 'i', 'o', and 'u'. Examples: * maxVowels(\"abciiidef\",3) => 3 * maxVowels(\"aeiou\",2) => 2 * maxVowels(\"leetcode\",3) => 2 \"\"\"\n```",
        "thought_answer": "```\n    def maxVowels(self, s: str, k: int) -> int:\n        def isVowel(ch):\n            return int(ch in \"aeiou\")\n        \n        n = len(s)\n        vowel_count = sum(1 for i in range(k) if isVowel(s[i]))\n        ans = vowel_count\n        for i in range(k, n):\n            vowel_count += isVowel(s[i]) - isVowel(s[i - k])\n            ans = max(ans, vowel_count)\n        return ans\n```"
    },
    {
        "thought_name": "Max Consecutive Ones III",
        "thought_question": "```\ndef longestOnes(self, nums: List[int], k: int) -> int: \"\"\" Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's. Examples: * longestOnes([1,1,1,0,0,0,1,1,1,1,0],2) => 6 * longestOnes([0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1],3) => 10 \"\"\"\n```",
        "thought_answer": "```\n    def longestOnes(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        P = [0]\n        for num in nums:\n            P.append(P[-1] + (1 - num))\n        \n        ans = 0\n        for right in range(n):\n            left = bisect.bisect_left(P, P[right + 1] - k)\n            ans = max(ans, right - left + 1)\n        \n        return ans\n```"
    },
    {
        "thought_name": "Longest Subarray of 1's After Deleting One Element ",
        "thought_question": "```\ndef longestSubarray(self, nums: List[int]) -> int: \"\"\" Given a binary array nums, you should delete one element from it.Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray. Examples: * longestSubarray([1,1,0,1]) => 3 * longestSubarray([0,1,1,1,0,1,1,0,1]) => 5 * longestSubarray([1,1,1]) => 2 \"\"\"\n```",
        "thought_answer": "```\n    def longestSubarray(self, nums: List[int]) -> int:\n        ans = 0\n        p0 = p1 = 0\n        for num in nums:\n            if num == 0:\n                p1, p0 = p0, 0\n            else:\n                p0 += 1\n                p1 += 1\n            ans = max(ans, p1)\n        if ans == len(nums):\n            ans -= 1\n        return ans\n```"
    },
    {
        "thought_name": "Find the Highest Altitude ",
        "thought_question": "```\ndef largestAltitude(self, gain: List[int]) -> int: \"\"\" There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 <= i < n). Return the highest altitude of a point. Examples: * largestAltitude([-5,1,5,0,-7]) => 1 * largestAltitude([-4,-3,-2,-1,4,3,2]) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def largestAltitude(self, gain: List[int]) -> int:\n        ans = total = 0\n        for x in gain:\n            total += x\n            ans = max(ans, total)\n        return ans\n```"
    },
    {
        "thought_name": "Find Pivot Index ",
        "thought_question": "```\ndef pivotIndex(self, nums: List[int]) -> int: \"\"\" Given an array of integers nums, calculate the pivot index of this array.The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.Return the leftmost pivot index. If no such index exists, return -1. Examples: * pivotIndex([1,7,3,6,5,6]) => 3 * pivotIndex([1,2,3]) => -1 * pivotIndex([2,1,-1]) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def pivotIndex(self, nums: List[int]) -> int:\n        sum_left, sum_right = 0, sum(nums)\n        for i in range(len(nums)):\n            sum_right -= nums[i]\n            # 若左侧元素和等于右侧元素和，返回中心下标 i\n            if sum_left == sum_right:\n                return i\n            sum_left += nums[i]\n        return -1\n```"
    },
    {
        "thought_name": "Find the Difference of Two Arrays ",
        "thought_question": "```\ndef findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]: \"\"\" Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: * answer[0] is a list of all distinct integers in nums1 which are not present in nums2. * answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note: * the integers in the lists may be returned in any order. Examples: * findDifference([1,2,3],[2,4,6]) => [[1,3],[4,6]] * findDifference([1,2,3,3],[1,1,2,2]) => [[3],[]] \"\"\"\n```",
        "thought_answer": "```\n    def findDifference(self, nums1: List[int], nums2: List[int]) -> List[List[int]]:\n        def search(s1: set, s2: set, idx: int):\n            for num in s1:\n                if num not in s2:\n                    answer[idx].append(num)\n\n        answer = [[], []]  \n        set1, set2 = set(nums1), set(nums2)   # 转为集合，用于快速判断是否包含某个元素\n        \n        # 枚举集合1的元素，找到不在集合2的元素\n        search(set1, set2, 0)\n        # 枚举集合2的元素，找到不在集合1的元素\n        search(set2, set1, 1)\n        \n        return answer\n```"
    },
    {
        "thought_name": "Unique Number of Occurrences ",
        "thought_question": "```\ndef uniqueOccurrences(self, arr: List[int]) -> bool: \"\"\" Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise. Examples: * uniqueOccurrences([1,2,2,1,1,3]) => true * uniqueOccurrences([1,2]) => false * uniqueOccurrences([-3,0,1,-3,1,1,1,-3,10,0]) => true \"\"\"\n```",
        "thought_answer": "```\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        counts = Counter(arr)     # 统计每个元素出现次数\n        counts_set = set()        # 所有的次数集合\n        \n        for cnt in counts.values():\n            if cnt in counts_set: return False # 当前次数已出现，不是唯一的\n            counts_set.add(cnt)\n        \n        return True\n```"
    },
    {
        "thought_name": "Determine if Two Strings Are Close ",
        "thought_question": "```\ndef closeStrings(self, word1: str, word2: str) -> bool: \"\"\" wo strings are considered close if you can attain one from the other using the following operations: * Operation 1: Swap any two existing characters. * For example, abcde -> aecdb * Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. * For example, aacabb -> bbcbaa (all a's turn into b's, and all b's turn into a's)You can use the operations on either string as many times as necessary.Given two strings, word1 and word2, return true if word1 and word2 are close, and false otherwise. Examples: * closeStrings(\"abc\",\"bca\") => true * closeStrings(\"a\",\"aa\") => false * closeStrings(\"cabbba\",\"abbccc\") => true \"\"\"\n```",
        "thought_answer": "```\n    def closeStrings(self, s: str, t: str) -> bool:\n        return len(s) == len(t) and \\\n               set(s) == set(t) and \\\n               Counter(Counter(s).values()) == Counter(Counter(t).values())\n```"
    },
    {
        "thought_name": "Equal Row and Column Pairs ",
        "thought_question": "```\ndef equalPairs(self, grid: List[List[int]]) -> int: \"\"\" Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array). Examples: * equalPairs([[3,2,1],[1,7,6],[2,7,7]]) => 1 * equalPairs([[3,1,2,2],[1,4,4,5],[2,4,2,2],[2,4,2,2]]) => 3 \"\"\"\n```",
        "thought_answer": "```\n    def equalPairs(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        ans = 0\n        for i in range(n):\n            for j in range(n):\n                ans += all(grid[i][k] == grid[k][j] for k in range(n))\n        return ans\n```"
    },
    {
        "thought_name": "Removing Stars From a String ",
        "thought_question": "```\ndef removeStars(self, s: str) -> str: \"\"\" You are given a string s, which contains stars *.In one operation, you can: * Choose a star in s. * Remove the closest non-star character to its left, as well as remove the star itself.\nReturn the string after all stars have been removed.Note: * The input will be generated such that the operation is always possible. * It can be shown that the resulting string will always be unique. Examples: * removeStars(\"leet**cod*e\") => \"lecoe\" * removeStars(\"erase*****\") => \"\" \"\"\"\n```",
        "thought_answer": "```\n    def removeStars(self, s: str) -> str:\n        st = []\n        for c in s:\n            if c == '*': st.pop()\n            else: st.append(c)\n        return ''.join(st)\n```"
    },
    {
        "thought_name": "Asteroid Collision ",
        "thought_question": "```\ndef asteroidCollision(self, asteroids: List[int]) -> List[int]: \"\"\" We are given an array asteroids of integers representing asteroids in a row.For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet. Examples: * asteroidCollision([5,10,-5]) => [5,10] * asteroidCollision([8,-8]) => [] * asteroidCollision([10,2,-5]) => [10] \"\"\"\n```",
        "thought_answer": "```\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stack = [-1001]     # 栈底是个不可能碰撞的向左最大质量行星\n        for a in asteroids:\n            if stack[-1] < 0 or a > 0 :\n                stack.append(a)\n            elif stack[-1] <= -a:\n                # 比栈顶向右飞行的质量大就出栈\n                while stack[-1] > 0 and stack[-1] < -a:\n                    stack.pop()\n                if stack[-1] < 0:\n                    stack.append(a)\n                elif stack[-1] == -a:   # 抵消情况\n                    stack.pop()\n        return stack[1:]\n```"
    },
    {
        "thought_name": "Decode String ",
        "thought_question": "```\ndef decodeString(self, s: str) -> str: \"\"\" Given an encoded string, return its decoded string.The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.You may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].The test cases are generated so that the length of the output will never exceed 105. Examples: * decodeString(\"3[a]2[bc]\") => \"aaabcbc\" * decodeString(\"3[a2[c]]\") => \"accaccacc\" * decodeString(\"2[abc]3[cd]ef\") => \"abcabccdcdcdef\" \"\"\"\n```",
        "thought_answer": "```\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n```"
    },
    {
        "thought_name": "Dota2 Senate ",
        "thought_question": "```\ndef predictPartyVictory(self, senate: str) -> str: \"\"\" In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise one of the two rights:\n\n* Ban one senator's right: A senator can make another senator lose all his rights in this and all the following rounds.\n* Announce the victory: If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\nGiven a string senate representing each senator's party belonging. The character 'R' and 'D' represent the Radiant party and the Dire party. Then if there are n senators, the size of the given string will be n.\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be \"Radiant\" or \"Dire\".\nExamples: * predictPartyVictory(\"RD\") => \"Radiant\" * predictPartyVictory(\"RDD\") => \"Dire\" \"\"\"\n```",
        "thought_answer": "```\n    def predictPartyVictory(self, senate: str) -> str:\n        def aciton(q1: \"deque\", q2: \"deque\"):\n            q2.popleft()    # q2阵营首个参议院丧失权力，直接出队\n            q1.append(q1.popleft() + n)     #  q1执行权力的参议院出队; q1执行权力的参议员重新入队，加n是为了表示其进入了下一轮\n\n        radiants = deque()    # 队列中记录着Radiannt阵营中可以执行权力的人\n        dires = deque()       # 队列中记录着Dire阵营中可以执行权力的人\n        n = len(senate)\n        for i, se in enumerate(senate):\n            # 初始所有参议员都可以执行权力，将每个参议员下标添加到对应的队列中\n            if se == 'R':\n                radiants.append(i)\n            else:\n                dires.append(i)\n\n        # 只有一个阵营的队列为空了，说明这个阵营所有参议院都失去权力了，另一个阵营获胜\n        while radiants and  dires:\n            if radiants[0] < dires[0]:\n                # Radiant阵营的人更靠前，他将禁止Dire阵营中首个拥有权力的人，然后它重新排到队伍最后，等待下一次轮到它执行权力\n                aciton(radiants, dires)\n            else:\n                # Dire阵营的人更靠前，他将禁止Radiant阵营中首个拥有权力的人，然后它重新排到队伍最后，等待下一次轮到它执行权力\n                aciton(dires, radiants)\n\n        return  \"Radiant\" if radiants else \"Dire\"\n```"
    },
    {
        "thought_name": "Delete the Middle Node of a Linked List",
        "thought_question": "```\ndef deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]: \"\"\" You are given the head of a linked list. Delete the middle node, and return the head of the modified linked list.\n\nThe middle node of a linked list of size n is the ⌊n / 2⌋th node from the start using 0-based indexing, where ⌊x⌋ denotes the largest integer less than or equal to x.\n\n* For n = 1, 2, 3, 4, and 5, the middle nodes are 0, 1, 1, 2, and 2, respectively.\nExamples: * deleteMiddle([1,3,4,7,1,2,6]) => [1,3,4,1,2,6] * deleteMiddle([1,2,3,4]) => [1,2,4] * deleteMiddle([2,1]) => [2] \"\"\"\n```",
        "thought_answer": "```\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: return None     # 链表长度为0或1，删除后为空链表\n        slow = fast = head    # 快慢指针，快慢指针均指向头节点\n        while fast and fast.next:    \n            fast = fast.next.next    # 快指针每次移动两个节点\n            pre = slow               # 先记录当前慢指针指向的节点，再移动慢指针，从而保证pre始终指向slow的上一个节点\n            slow = slow.next         # 慢指针每次移动一个节点\n        # 快指针到达链表尾部时，慢指针即指向中间节点，pre指向前一个节点\n        pre.next = pre.next.next\n        return head     # 返回原来的头节点\n```"
    },
    {
        "thought_name": "Odd Even Linked List ",
        "thought_question": "```\ndef oddEvenList(self, head: Optional[ListNode]) -> Optional[ListNode]: \"\"\" Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\n\nThe first node is considered odd, and the second node is even, and so on.\n\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\n\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExamples: * oddEvenList([1,2,3,4,5]) => [1,3,5,2,4] * oddEvenList([2,1,3,5,6,4,7]) => [2,3,6,7,1,5,4] \"\"\"\n```",
        "thought_answer": "```\n    def oddEvenList(self, head: ListNode) -> ListNode:\n        if not head:return head\n        odd = head\n        even_head = even = head.next\n        while odd.next and even.next:\n            odd.next = odd.next.next\n            even.next = even.next.next\n            odd,even = odd.next,even.next\n        odd.next = even_head\n        return head\n```"
    },
    {
        "thought_name": "Reverse Linked List ",
        "thought_question": "```\ndef reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]: \"\"\" Given the head of a singly linked list, reverse the list, and return the reversed list.\nExamples: * oddEvenList([1,2,3,4,5]) => [1,3,5,2,4] * reverseList([1,2]) => [2,1] * reverseList([]) => [] \"\"\"\n```",
        "thought_answer": "```\n    def reverseList(self, head: ListNode) -> ListNode:\n        cur, pre = head, None\n        while cur:\n            tmp = cur.next # 暂存后继节点 cur.next\n            cur.next = pre # 修改 next 引用指向\n            pre = cur      # pre 暂存 cur\n            cur = tmp      # cur 访问下一节点\n        return pre\n```"
    },
    {
        "thought_name": "Maximum Twin Sum of a Linked List ",
        "thought_question": "```\ndef pairSum(self, head: Optional[ListNode]) -> int: \"\"\" In a linked list of size n, where n is even, the ith node (0-indexed) of the linked list is known as the twin of the (n-1-i)th node, if 0 <= i <= (n / 2) - 1.\n\n* For example, if n = 4, then node 0 is the twin of node 3, and node 1 is the twin of node 2. These are the only nodes with twins for n = 4.\nThe twin sum is defined as the sum of a node and its twin.\n\nGiven the head of a linked list with even length, return the maximum twin sum of the linked list.\nExamples: * pairSum([5,4,2,1]) => 6 * pairSum([4,2,2,3]) => 7 * pairSum([1,100000]) => 100001 \"\"\"\n```",
        "thought_answer": "```\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        arr=[]\n        while head:\n            arr.append(head.val)\n            head=head.next\n        maxsum=0\n        i,j=0,len(arr)-1\n        while i<j:\n            maxsum=max(maxsum,arr[i]+arr[j])\n            i+=1\n            j-=1\n        return maxsum\n```"
    },
    {
        "thought_name": "Maximum Depth of Binary Tree ",
        "thought_question": "```\ndef maxDepth(self, root: Optional[TreeNode]) -> int: \"\"\" Given the root of a binary tree, return its maximum depth.\n\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nExamples: * maxDepth([3,9,20,null,null,15,7]) => 3 * maxDepth([1,null,2]) => 2 \"\"\"\n```",
        "thought_answer": "```\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        queue, res = [root], 0\n        while queue:\n            tmp = []\n            for node in queue:\n                if node.left: tmp.append(node.left)\n                if node.right: tmp.append(node.right)\n            queue = tmp\n            res += 1\n        return res\n```"
    },
    {
        "thought_name": "Leaf-Similar Trees ",
        "thought_question": "```\ndef leafSimilar(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> bool: \"\"\" Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\nExamples: * leafSimilar([3,5,1,6,2,9,8,null,null,7,4],[3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]) => true * leafSimilar([1,2,3],[1,3,2]) => false \"\"\"\n```",
        "thought_answer": "```\n    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:\n        res1 = []\n        res2 = []\n        self.dfs(root1, res1)\n        self.dfs(root2, res2)\n        return res1 == res2\n        \n\n    def dfs(self, root, result):\n        stack = []\n        current = root\n        while current is not None or len(stack) > 0:\n            # 相当于递归法中的 dfs(root.left), 优先把left节点都压入栈            \n            while current:\n                stack.append(current)\n                current = current.left\n\n            # left 节点都已经压完了, 从栈中取最近压入的 TreeNode\n            current = stack.pop()\n\n            if current.left is None and current.right is None:\n                result.append(current.val)\n\n            # 相当于递归法中的 dfs(root.right) 那一步\n            current = current.right\n```"
    },
    {
        "thought_name": "Count Good Nodes in Binary Tree ",
        "thought_question": "```\ndef goodNodes(self, root: TreeNode) -> int: \"\"\" Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.\n\nReturn the number of good nodes in the binary tree.\nExamples: * goodNodes([3,1,4,3,null,1,5]) => 4 * goodNodes([3,3,null,4,2]) => 3 * goodNodes([1]) => 1 \"\"\"\n```",
        "thought_answer": "```\n    def goodNodes(self, root: TreeNode, mx=-inf) -> int:\n        if root is None:\n            return 0\n        left = self.goodNodes(root.left, max(mx, root.val))\n        right = self.goodNodes(root.right, max(mx, root.val))\n        return left + right + (mx <= root.val)\n```"
    },
    {
        "thought_name": "Path Sum III ",
        "thought_question": "```\ndef pathSum(self, root: Optional[TreeNode], targetSum: int) -> int: \"\"\" Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).\nExamples: * pathSum([10,5,-3,3,2,null,11,3,-2,null,1],8) => 3 * pathSum([5,4,8,11,null,13,4,7,2,null,null,5,1],22) => 3 \"\"\"\n```",
        "thought_answer": "```\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        ans = 0\n        cnt = defaultdict(int)\n        cnt[0] = 1\n\n        def dfs(node: Optional[TreeNode], s: int) -> None:\n            if node is None:\n                return\n            nonlocal ans\n            s += node.val\n            ans += cnt[s - targetSum]\n            cnt[s] += 1\n            dfs(node.left, s)\n            dfs(node.right, s)\n            cnt[s] -= 1  # 恢复现场\n\n        dfs(root, 0)\n        return ans\n```"
    },
    {
        "thought_name": "Longest ZigZag Path in a Binary Tree ",
        "thought_question": "```\ndef longestZigZag(self, root: Optional[TreeNode]) -> int: \"\"\" You are given the root of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n* Choose any node in the binary tree and a direction (right or left).\n* If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n* Change the direction from right to left or from left to right.\n* Repeat the second and third steps until you can't move in the tree.\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\nExamples: * longestZigZag([1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]) => 3 * longestZigZag([1,1,1,null,1,null,null,1,1,null,1]) => 4 * longestZigZag([1]) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\n        ans=0\n        def dfs(nd):\n            if not nd:\n                return -1,-1\n            nonlocal ans\n            l1,r1=dfs(nd.left)\n            l2,r2=dfs(nd.right)\n            ans=max(ans, 1+r1, 1+l2)\n            return 1+r1, 1+l2\n        dfs(root)\n        return ans\n```"
    },
    {
        "thought_name": "Lowest Common Ancestor of a Binary Tree ",
        "thought_question": "```\ndef lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode': \"\"\" Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\n\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExamples: * lowestCommonAncestor([3,5,1,6,2,0,8,null,null,7,4],5,1) => 3 * lowestCommonAncestor([3,5,1,6,2,0,8,null,null,7,4],5,4) => 5 * lowestCommonAncestor([1,2],1,2) => 1 \"\"\"\n```",
        "thought_answer": "```\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        if not root or root == p or root == q: return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if not left: return right\n        if not right: return left\n        return root\n```"
    },
    {
        "thought_name": "Binary Tree Right Side View ",
        "thought_question": "```\ndef rightSideView(self, root: Optional[TreeNode]) -> List[int]: \"\"\" Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExamples: * rightSideView([1,2,3,null,5,null,4]) => [1,3,4] * rightSideView([1,null,3]) => [1,3] * rightSideView([]) => [] \"\"\"\n```",
        "thought_answer": "```\n    def rightSideView(self, root: TreeNode) -> List[int]:\n        rightmost_value_at_depth = dict() # 深度为索引，存放节点的值\n        max_depth = -1\n\n        stack = [(root, 0)]\n        while stack:\n            node, depth = stack.pop()\n\n            if node is not None:\n                # 维护二叉树的最大深度\n                max_depth = max(max_depth, depth)\n\n                # 如果不存在对应深度的节点我们才插入\n                rightmost_value_at_depth.setdefault(depth, node.val)\n\n                stack.append((node.left, depth + 1))\n                stack.append((node.right, depth + 1))\n\n        return [rightmost_value_at_depth[depth] for depth in range(max_depth + 1)]\n```"
    },
    {
        "thought_name": "Maximum Level Sum of a Binary Tree ",
        "thought_question": "```\ndef maxLevelSum(self, root: Optional[TreeNode]) -> int: \"\"\" Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.\nReturn the smallest level x such that the sum of all the values of nodes at level x is maximal.\nExamples: * maxLevelSum([1,7,0,7,-8,null,null]) => 2 * maxLevelSum([989,null,10250,98693,-89388,null,null,null,-32127]) => 2 \"\"\"\n```",
        "thought_answer": "```\n    def maxLevelSum(self, root: Optional[TreeNode]) -> int:\n        ans, num, queue, level = 1, -inf, deque([root]), 1\n        while queue:\n            s = 0\n            for i in range(len(queue)):\n                node = queue.popleft()\n                s += node.val\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if s > num:\n                ans, num = level, s\n            level += 1\n        return ans\n```"
    },
    {
        "thought_name": "Search in a Binary Search Tree ",
        "thought_question": "```\ndef searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]: \"\"\" You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nExamples: * searchBST([4,2,7,1,3],2) => [2,1,3] * searchBST([4,2,7,1,3],5) => [] \"\"\"\n```",
        "thought_answer": "```\n    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        if root == None or root.val == val:\n            return root\n        #二叉搜索树有序，根节点大于左节点，小于右节点\n        #若节点值大于目标值，则搜索左子树\n        if root.val > val:\n            result=self.searchBST(root.left,val)\n        #若节点值小于目标值，则搜索右子树\n        if root.val < val:\n            result=self.searchBST(root.right,val)\n        return result\n```"
    },
    {
        "thought_name": "Delete Node in a BST ",
        "thought_question": "```\ndef deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]: \"\"\" Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.\nBasically, the deletion can be divided into two stages:\n* Search for a node to remove.\n* If the node is found, delete the node.\nExamples: * deleteNode([5,3,6,2,4,null,7],3) => [5,4,6,2,null,null,7] * deleteNode([5,3,6,2,4,null,7],0) => [5,3,6,2,4,null,7] * deleteNode([],0) => [] \"\"\"\n```",
        "thought_answer": "```\n    def deleteNode(self, root: Optional[TreeNode], key: int) -> Optional[TreeNode]:\n        if root:\n            if root.val < key:\n                root.right = self.deleteNode(root.right, key)\n            elif root.val > key:\n                root.left = self.deleteNode(root.left, key)\n            else:\n                if not root.left or not root.right:\n                    root = root.left if root.left else root.right\n                else:\n                    node = root.left\n                    while node.right:\n                        node = node.right\n                    node.left = self.deleteNode(root.left, node.val)\n                    node.right = root.right\n                    root = node\n        return root\n```"
    },
    {
        "thought_name": "Keys and Rooms ",
        "thought_question": "```\ndef canVisitAllRooms(self, rooms: List[List[int]]) -> bool: \"\"\" There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\nExamples: * canVisitAllRooms([[1],[2],[3],[]]) => true * canVisitAllRooms([[1,3],[3,0,1],[2],[0]]) => false \"\"\"\n```",
        "thought_answer": "```\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        visited, queue = {0}, [0]\n        while queue:\n            room_index = queue.pop()\n            for key in rooms[room_index]:\n                if key not in visited:\n                    visited.add(key)\n                    queue.insert(0,key)\n        return len(visited) == len(rooms)\n```"
    },
    {
        "thought_name": "Number of Provinces ",
        "thought_question": "```\ndef findCircleNum(self, isConnected: List[List[int]]) -> int: \"\"\" There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n\nReturn the total number of provinces.\nExamples: * findCircleNum([[1,1,0],[1,1,0],[0,0,1]]) => 2 * findCircleNum([[1,0,0],[0,1,0],[0,0,1]]) => 3 \"\"\"\n```",
        "thought_answer": "```\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:   \n        #dfs\n        def dfs(i):\n            for j in range(n):\n                if isConnected[i][j] == 1 and j not in cnt:\n                    cnt.add(j)\n                    dfs(j)\n        n = len(isConnected)\n        ans = 0\n        cnt = set()\n        for i in range(n):\n            if i not in cnt:\n                ans += 1\n                dfs(i)\n        return ans\n        #bfs\n        n = len(isConnected)\n        ans = 0\n        cnt = set()\n        for i in range(n):\n            if i not in cnt:\n                queue = [i]\n                while queue:\n                    j = queue.pop(0)\n                    cnt.add(j)\n                    for k in range(n):\n                        if isConnected[j][k] == 1 and k not in cnt:\n                            queue.append(k)\n                ans += 1\n        return ans\n```"
    },
    {
        "thought_name": "Reorder Routes to Make All Paths Lead to the City Zero ",
        "thought_question": "```\ndef minReorder(self, n: int, connections: List[List[int]]) -> int: \"\"\" There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\n\nThis year, there will be a big event in the capital (city 0), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.\n\nIt's guaranteed that each city can reach city 0 after reorder.\nExamples: * minReorder(6,[[0,1],[1,3],[2,3],[4,0],[4,5]]) => 3 * minReorder(5,[[1,0],[1,2],[3,2],[3,4]]) => 2 * minReorder(3,[[1,0],[2,0]]) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        def dfs(a: int, fa: int) -> int:\n            return sum(c + dfs(b, a) for b, c in g[a] if b != fa)\n\n        g = [[] for _ in range(n)]\n        for a, b in connections:\n            g[a].append((b, 1))\n            g[b].append((a, 0))\n        return dfs(0, -1)\n```"
    },
    {
        "thought_name": "Evaluate Division ",
        "thought_question": "```\ndef calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]: \"\"\" You are given an array of variable pairs equations and an array of real numbers values, where equations[i] = [Ai, Bi] and values[i] represent the equation Ai / Bi = values[i]. Each Ai or Bi is a string that represents a single variable.\n\nYou are also given some queries, where queries[j] = [Cj, Dj] represents the jth query where you must find the answer for Cj / Dj = ?.\n\nReturn the answers to all queries. If a single answer cannot be determined, return -1.0.\n\nNote: \n* The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.\n* The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.\nExamples: * calcEquation([[\"a\",\"b\"],[\"b\",\"c\"]],[2.0,3.0],[[\"a\",\"c\"],[\"b\",\"a\"],[\"a\",\"e\"],[\"a\",\"a\"],[\"x\",\"x\"]]) => [6.00000,0.50000,-1.00000,1.00000,-1.00000] * calcEquation([[\"a\",\"b\"],[\"b\",\"c\"],[\"bc\",\"cd\"]],[1.5,2.5,5.0],[[\"a\",\"c\"],[\"c\",\"b\"],[\"bc\",\"cd\"],[\"cd\",\"bc\"]]) => [3.75000,0.40000,5.00000,0.20000] * calcEquation([[\"a\",\"b\"]],[0.5],[[\"a\",\"b\"],[\"b\",\"a\"],[\"a\",\"c\"],[\"x\",\"y\"]]) => [0.50000,2.00000,-1.00000,-1.00000] \"\"\"\n```",
        "thought_answer": "```\n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        graph = defaultdict(list)\n        for (a, b), val in zip(equations, values):\n            graph[a].append((b, val))\n            graph[b].append((a, 1.0 / val))\n\n        def bfs(init, goal):\n            if init not in graph or goal not in graph:\n                return -1.0\n            explored = {init}\n            q = deque([(init, 1.0)])\n            while q:\n                node, v = q.popleft()\n                if node == goal:\n                    return v\n                for nxt, cost in graph[node]:\n                    if nxt not in explored:\n                        explored.add(nxt)\n                        q.append((nxt, v * cost))\n            return -1.0\n\n        return [bfs(i, g) for i, g in queries]\n```"
    },
    {
        "thought_name": "Nearest Exit from Entrance in Maze ",
        "thought_question": "```\ndef nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int: \"\"\" You are given an m x n matrix maze (0-indexed) with empty cells (represented as '.') and walls (represented as '+'). You are also given the entrance of the maze, where entrance = [entrancerow, entrancecol] denotes the row and column of the cell you are initially standing at.\nIn one step, you can move one cell up, down, left, or right. You cannot step into a cell with a wall, and you cannot step outside the maze. Your goal is to find the nearest exit from the entrance. An exit is defined as an empty cell that is at the border of the maze. The entrance does not count as an exit.\nReturn the number of steps in the shortest path from the entrance to the nearest exit, or -1 if no such path exists.\nExamples: * nearestExit([[\"+\",\"+\",\".\",\"+\"],[\".\",\".\",\".\",\"+\"],[\"+\",\"+\",\"+\",\".\"]],[1,2]) => 1 * nearestExit([[\"+\",\"+\",\"+\"],[\".\",\".\",\".\"],[\"+\",\"+\",\"+\"]],[1,0]) => 2 * nearestExit([[\".\",\"+\"]],[0,0]) => -1 \"\"\"\n```",
        "thought_answer": "```\n    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n        # 多源BFS，我从出口出发，看看最快到达entrance的路径\n        q = deque()\n        visted = set()\n        ei = entrance[0]\n        ej = entrance[1]\n        for i in range(len(maze)):\n            for j in range(len(maze[0])):\n                if i == 0 or i == len(maze)-1 or j == 0 or j == len(maze[0])-1:\n                    if maze[i][j] == '.':\n                        if (i,j) != (ei,ej):\n                            q.append((i,j,0))\n                            visted.add((i,j,0))\n        dirc = [(-1,0),(1,0),(0,-1),(0,1)]\n        while q:\n            i,j,step = q.popleft()\n            if i == ei and j == ej:\n                return step\n            \n            for m,n in dirc:\n                if 0 <= i+m < len(maze) and 0 <= j+n <len(maze[0]) and (i+m,j+n) not in visted:\n                    if maze[i+m][j+n] == '.':\n                        visted.add((i+m,j+n))\n                        q.append((i+m,j+n,step+1))\n        return -1\n```"
    },
    {
        "thought_name": "Rotting Oranges ",
        "thought_question": "```\ndef orangesRotting(self, grid: List[List[int]]) -> int: \"\"\" You are given an m x n grid where each cell can have one of three values:\n\n* 0 representing an empty cell,\n* 1 representing a fresh orange, or\n* 2 representing a rotten orange.\nEvery minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.\n\nReturn the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1.\nExamples: * orangesRotting([[2,1,1],[1,1,0],[0,1,1]]) => 4 * orangesRotting([[2,1,1],[0,1,1],[1,0,1]]) => -1 * orangesRotting([[0,2]]) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        row = len(grid)\n        col = len(grid[0])\n        rotten = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 2} # 腐烂集合\n        fresh = {(i, j) for i in range(row) for j in range(col) if grid[i][j] == 1}  # 新鲜集合\n        time = 0\n        while fresh:\n            if not rotten: return -1\n            rotten = {(i + di, j + dj) for i, j in rotten for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)] if (i + di, j + dj) in fresh} # 即将腐烂的如果在新鲜的集合中，就将它腐烂\n            fresh -= rotten # 剔除腐烂的\n            time += 1\n        return time\n```"
    },
    {
        "thought_name": "Kth Largest Element in an Array ",
        "thought_question": "```\ndef findKthLargest(self, nums: List[int], k: int) -> int: \"\"\" Given an integer array nums and an integer k, return the kth largest element in the array.\n\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\n\nCan you solve it without sorting?\nExamples: * findKthLargest([3,2,1,5,6,4],2) => 5 * findKthLargest([3,2,3,1,2,4,5,5,6],4) => 4   \"\"\"\n```",
        "thought_answer": "```\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        \n        def partition(arr: List[int], low: int, high: int) -> int:\n            pivot = arr[low]                                        # 选取最左边为pivot\n\n            left, right = low, high     # 双指针\n            while left < right:\n                \n                while left<right and arr[right] >= pivot:          # 找到右边第一个<pivot的元素\n                    right -= 1\n                arr[left] = arr[right]                             # 并将其移动到left处\n                \n                while left<right and arr[left] <= pivot:           # 找到左边第一个>pivot的元素\n                    left += 1\n                arr[right] = arr[left]                             # 并将其移动到right处\n            \n            arr[left] = pivot           # pivot放置到中间left=right处\n            return left\n        \n        def randomPartition(arr: List[int], low: int, high: int) -> int:\n            pivot_idx = random.randint(low, high)                   # 随机选择pivot\n            arr[low], arr[pivot_idx] = arr[pivot_idx], arr[low]     # pivot放置到最左边\n            return partition(arr, low, high)                        # 调用partition函数\n\n        def topKSplit(arr: List[int], low: int, high: int, k: int) -> int:\n            # mid = partition(arr, low, high)                   # 以mid为分割点【非随机选择pivot】\n            mid = randomPartition(arr, low, high)               # 以mid为分割点【随机选择pivot】\n            if mid == k-1:                                      # 第k小元素的下标为k-1\n                return arr[mid]                                 #【找到即返回】\n            elif mid < k-1:\n                return topKSplit(arr, mid+1, high, k)           # 递归对mid右侧元素进行排序\n            else:\n                return topKSplit(arr, low, mid-1, k)            # 递归对mid左侧元素进行排序\n        \n        n = len(nums)\n        return topKSplit(nums, 0, n-1, n-k+1)                   # 第k大元素即为第n-k+1小元素\n```"
    },
    {
        "thought_name": "Maximum Subsequence Score ",
        "thought_question": "```\ndef maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int: \"\"\" You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\n\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\n* The sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\n* It can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\nExamples: * maxScore([1,3,3,2],[2,1,3,4],3) => 12 * maxScore([4,2,3,1,1],[7,5,10,9,6],1) => 30 \"\"\"\n```",
        "thought_answer": "```\n    def maxScore(self, nums1: List[int], nums2: List[int], k: int) -> int:\n        for i in range(len(nums2)):\n            nums2[i] = [nums2[i], nums1[i]]\n        nums2.sort()#绑定、排序\n        pq = nums2[len(nums2) - k:len(nums2)]\n        num = sum(x[1] for x in pq)#求初始元素和\n        pq = [x[1] for x in pq]\n        heapq.heapify(pq)#生成小顶堆\n        ans = num * nums2[-k][0]\n        for i in range(len(nums2) - k - 1, -1, -1):#从后向前遍历\n            if pq[0]<nums2[i][1]:#维护\n                num += nums2[i][1] - pq[0]\n                heapq.heappop(pq)\n                heapq.heappush(pq, nums2[i][1])\n            ans = max(ans, num*nums2[i][0])\n        return ans\n```"
    },
    {
        "thought_name": "Total Cost to Hire K Workers ",
        "thought_question": "```\ndef totalCost(self, costs: List[int], k: int, candidates: int) -> int: \"\"\" You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\n\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\n\n* You will run k sessions and hire exactly one worker in each session.\n* In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\n* For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].\n* In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\n* If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n* A worker can only be chosen once.\nReturn the total cost to hire exactly k workers.\nExamples: * totalCost([17,12,10,2,7,2,11,20,8],3,4) => 11 * totalCost([1,2,4,1],3,3) => 4 \"\"\"\n```",
        "thought_answer": "```\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        if candidates * 2 + k > n:\n            # 也可以 sum(nsmallest(k, costs))，但效率不如直接排序\n            costs.sort()\n            return sum(costs[:k])\n\n        pre = costs[:candidates]\n        suf = costs[-candidates:]\n        heapify(pre)\n        heapify(suf)\n\n        ans = 0\n        i = candidates\n        j = n - 1 - candidates\n        for _ in range(k):\n            if pre[0] <= suf[0]:\n                ans += heapreplace(pre, costs[i])\n                i += 1\n            else:\n                ans += heapreplace(suf, costs[j])\n                j -= 1\n        return ans\n```"
    },
    {
        "thought_name": "Guess Number Higher or Lower ",
        "thought_question": "```\ndef guessNumber(self, n: int) -> int: \"\"\" We are playing the Guess Game. The game is as follows:\n\nI pick a number from 1 to n. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n* -1: Your guess is higher than the number I picked (i.e. num > pick).\n* 1: Your guess is lower than the number I picked (i.e. num < pick).\n* 0: your guess is equal to the number I picked (i.e. num == pick).\nReturn the number that I picked.\nExamples: * guessNumber(10,6) => 6 * guessNumber(1,1) => 1 * guessNumber(2,1) => 1 \"\"\"\n```",
        "thought_answer": "```\n    def guessNumber(self, n: int) -> int:\n        left, right = 1, n\n        while left <= right:\n            mid = left + (right - left) // 2\n            res = guess(mid)\n            if res == 0:\n                return mid\n            elif res < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return -1\n```"
    },
    {
        "thought_name": "Successful Pairs of Spells and Potions",
        "thought_question": "```\ndef successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]: \"\"\" You are given two positive integer arrays spells and potions, of length n and m respectively, where spells[i] represents the strength of the ith spell and potions[j] represents the strength of the jth potion.\n\nYou are also given an integer success. A spell and potion pair is considered successful if the product of their strengths is at least success.\n\nReturn an integer array pairs of length n where pairs[i] is the number of potions that will form a successful pair with the ith spell.\nExamples: * successfulPairs([5,1,3],[1,2,3,4,5],7) => [4,0,3] * successfulPairs([3,1,2],[8,5,8],16) => [2,0,2] \"\"\"\n```",
        "thought_answer": "```\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        m = len(potions)\n        success -= 1\n        return [m - bisect_right(potions, success // x) for x in spells]\n```"
    },
    {
        "thought_name": "Find Peak Element ",
        "thought_question": "```\ndef findPeakElement(self, nums: List[int]) -> int: \"\"\" A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in O(log n) time.\nExamples: * findPeakElement([1,2,3,1]) => 2 * findPeakElement([1,2,1,3,5,6,4]) => 5 \"\"\"\n```",
        "thought_answer": "```\n    def findPeakElement(self, nums: List[int]) -> int:\n        left, right = -1, len(nums) - 1  # 开区间 (-1, n-1)\n        while left + 1 < right:  # 开区间不为空\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid\n        return right\n```"
    },
    {
        "thought_name": "Koko Eating Bananas ",
        "thought_question": "```\ndef minEatingSpeed(self, piles: List[int], h: int) -> int: \"\"\" Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\n\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\n\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\n\nReturn the minimum integer k such that she can eat all the bananas within h hours.\nExamples: * minEatingSpeed([3,6,7,11],8) => 4 * minEatingSpeed([30,11,23,4,20],5) => 30 * minEatingSpeed([30,11,23,4,20],6) => 23 \"\"\"\n```",
        "thought_answer": "```\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        n = len(piles)\n        left = 0  # 恒为 False\n        right = max(piles)  # 恒为 True\n        while left + 1 < right:  # 开区间不为空\n            mid = (left + right) // 2\n            if sum((p - 1) // mid for p in piles) <= h - n:\n                right = mid  # 循环不变量：恒为 True\n            else:\n                left = mid  # 循环不变量：恒为 False\n        return right  # 最小的 True\n```"
    },
    {
        "thought_name": "Letter Combinations of a Phone Number ",
        "thought_question": "```\ndef letterCombinations(self, digits: str) -> List[str]: \"\"\" Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.\nExamples: * letterCombinations(\"23\") => [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] * letterCombinations(\"2\") => [\"a\",\"b\",\"c\"] \"\"\"\n```",
        "thought_answer": "```\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits: return []\n\n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n                \n        def backtrack(conbination,nextdigit):\n            if len(nextdigit) == 0:\n                res.append(conbination)\n            else:\n                for letter in phone[nextdigit[0]]:\n                    backtrack(conbination + letter,nextdigit[1:])\n\n        res = []\n        backtrack('',digits)\n        return res\n```"
    },
    {
        "thought_name": "Combination Sum III ",
        "thought_question": "```\ndef combinationSum3(self, k: int, n: int) -> List[List[int]]: \"\"\" Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n\n* Only numbers 1 through 9 are used.\n* Each number is used at most once.\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExamples: * combinationSum3(3,7) => [[1,2,4]] * combinationSum3(3,9) => [[1,2,6],[1,3,5],[2,3,4]] * combinationSum3(4,1) => [] \"\"\"\n```",
        "thought_answer": "```\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        ans = []\n        path = []\n        def dfs(i: int, t: int) -> None:\n            d = k - len(path)  # 还要选 d 个数\n            if t < 0 or t > (i * 2 - d + 1) * d // 2:  # 剪枝\n                return\n            if d == 0:  # 找到一个合法组合\n                ans.append(path.copy())\n                return\n            for j in range(i, d - 1, -1):\n                path.append(j)\n                dfs(j - 1, t - j)\n                path.pop()\n        dfs(9, n)\n        return ans\n```"
    },
    {
        "thought_name": "N-th Tribonacci Number ",
        "thought_question": "```\ndef tribonacci(self, n: int) -> int: \"\"\" The Tribonacci sequence Tn is defined as follows: \n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven n, return the value of Tn.\nExamples: * tribonacci(4) => 4 * tribonacci(25) => 1389537 \"\"\"\n```",
        "thought_answer": "```\n    def tribonacci(self, n: int) -> int:\n\n        def gen_trib():\n            a, b, c = 0, 1, 1 \n            while True:\n                d = a + b + c\n                # python generator 的关键字 yield\n                yield d \n                a, b, c = b, c, d\n\n        if n == 0:\n            return 0\n        if n < 3:\n            return 1\n    \n        # g 是一个生成器，通过 next() 或者 enumerate 等方式可以获取下一个结果\n        g = gen_trib()\n        for i, res in enumerate(g):\n\n            if i == n-3:\n                return res\n```"
    },
    {
        "thought_name": "Min Cost Climbing Stairs ",
        "thought_question": "```\ndef minCostClimbingStairs(self, cost: List[int]) -> int: \"\"\" You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index 0, or the step with index 1.\n\nReturn the minimum cost to reach the top of the floor.\nExamples: * minCostClimbingStairs([10,15,20]) => 15 * minCostClimbingStairs([1,100,1,1,1,100,1,1,100,1]) => 6 \"\"\"\n```",
        "thought_answer": "```\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        minCost = [0] * n\n        minCost[1] = min(cost[0], cost[1])\n        for i in range(2, n):\n            minCost[i] = min(minCost[i - 1] + cost[i], minCost[i - 2] + cost[i - 1])\n        return minCost[-1]\n```"
    },
    {
        "thought_name": "House Robber ",
        "thought_question": "```\ndef rob(self, nums: List[int]) -> int: \"\"\" You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\nExamples: * rob([1,2,3,1]) => 4 * rob([2,7,9,3,1]) => 12 \"\"\"\n```",
        "thought_answer": "```\ndef rob(self, nums: List[int]) -> int:\n    if len(nums) == 0:\n        return 0\n\n    # 子问题：\n    # f(k) = 偷 [0..k) 房间中的最大金额\n\n    # f(0) = 0\n    # f(1) = nums[0]\n    # f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\n\n    N = len(nums)\n    dp = [0] * (N+1)\n    dp[0] = 0\n    dp[1] = nums[0]\n    for k in range(2, N+1):\n        dp[k] = max(dp[k-1], nums[k-1] + dp[k-2])\n    return dp[N]\n```"
    },
    {
        "thought_name": "Unique Paths ",
        "thought_question": "```\ndef uniquePaths(self, m: int, n: int) -> int: \"\"\" There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\n\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.\nExamples: * uniquePaths(3,7) => 28 * uniquePaths(3,2) => 3 \"\"\"\n```",
        "thought_answer": "```\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[m-1][n-1] = 1\n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = 1\n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = 1\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = dp[i][j+1] + dp[i+1][j]\n        \n        return dp[0][0]\n```"
    },
    {
        "thought_name": "Longest Common Subsequence ",
        "thought_question": "```\ndef longestCommonSubsequence(self, text1: str, text2: str) -> int: \"\"\" Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n* For example, \"ace\" is a subsequence of \"abcde\".\nA common subsequence of two strings is a subsequence that is common to both strings.\nExamples: * longestCommonSubsequence(\"abcde\",\"ace\") => 3 * longestCommonSubsequence(\"abc\",\"abc\") => 3 * longestCommonSubsequence(\"abc\",\"def\") => 0 \"\"\"\n```",
        "thought_answer": "```\n    def longestCommonSubsequence(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        @cache\n        def dfs(i, j):\n            if i < 0 or j < 0:\n                return 0\n            if s[i] == t[j]:\n                return dfs(i - 1, j - 1) + 1\n            return max(dfs(i - 1, j), dfs(i, j - 1))\n        return dfs(n - 1, m - 1)\n```"
    },
    {
        "thought_name": "Best Time to Buy and Sell Stock with Transaction Fee ",
        "thought_question": "```\ndef maxProfit(self, prices: List[int], fee: int) -> int: \"\"\" You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\n\nNote:\n* You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n* The transaction fee is only charged once for each stock purchase and sale.\nExamples: * maxProfit([1,3,2,8,4,9],2) => 8 * maxProfit([1,3,7,5,10,3],3) => 6 \"\"\"\n```",
        "thought_answer": "```\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        n = len(prices)\n        @cache  # 缓存装饰器，避免重复计算 dfs 的结果\n        def dfs(i: int, hold: bool) -> int:\n            if i < 0:\n                return -inf if hold else 0\n            if hold:\n                return max(dfs(i - 1, True), dfs(i - 1, False) - prices[i])\n            return max(dfs(i - 1, False), dfs(i - 1, True) + prices[i] - fee)\n        return dfs(n - 1, False)\n```"
    },
    {
        "thought_name": "Edit Distance ",
        "thought_question": "```\ndef minDistance(self, word1: str, word2: str) -> int: \"\"\" Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n* Insert a character\n* Delete a character\n* Replace a character\nExamples: * minDistance(\"horse\",\"ros\") => 3 * minDistance(\"intention\",\"execution\") => 5 \"\"\"\n```",
        "thought_answer": "```\n    def minDistance(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        @cache\n        def dfs(i, j):\n            if i < 0: return j + 1\n            if j < 0: return i + 1\n            if s[i] == t[j]: return dfs(i - 1, j - 1)\n            return min(dfs(i - 1, j), dfs(i, j - 1), dfs(i - 1, j - 1)) + 1\n        return dfs(n - 1, m - 1)\n```"
    },
    {
        "thought_name": "Counting Bits",
        "thought_question": "```\ndef countBits(self, n: int) -> List[int]: \"\"\" Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\nExamples: * countBits(2) => [0,1,1] * countBits(5) => [0,1,1,2,1,2] \"\"\"\n```",
        "thought_answer": "```\n    def countBits(self, n: int) -> List[int]:\n        result=[0]*(n+1)\n        for i in range(1,n+1):\n            if i&1:\n                result[i]=result[i-1]+1\n            else:\n                result[i]=result[i//2]\n        return result\n```"
    },
    {
        "thought_name": "Single Number ",
        "thought_question": "```\ndef singleNumber(self, nums: List[int]) -> int: \"\"\" Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExamples: * singleNumber([2,2,1]) => 1 * singleNumber([4,1,2,1,2]) => 4 * singleNumber([1]) => 1 \"\"\"\n```",
        "thought_answer": "```\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        x = 0\n        for num in nums:  # 1. 遍历 nums 执行异或运算\n            x ^= num      \n        return x;         # 2. 返回出现一次的数字 x\n```"
    },
    {
        "thought_name": "Minimum Flips to Make a OR b Equal to c ",
        "thought_question": "```\ndef minFlips(self, a: int, b: int, c: int) -> int: \"\"\" Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make ( a OR b == c ). (bitwise OR operation).\nFlip operation consists of change any single bit 1 to 0 or change the bit 0 to 1 in their binary representation.\nExamples: * minFlips(2,6,5) => 3 * minFlips(4,2,7) => 1 * minFlips(1,2,3) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        ans = 0\n        for i in range(32):\n            bit_a, bit_b, bit_c = (a >> i) & 1, (b >> i) & 1, (c >> i) & 1\n            if bit_c == 0:\n                ans += bit_a + bit_b\n            else:\n                ans += int(bit_a + bit_b == 0)\n        return ans\n```"
    },
    {
        "thought_name": "Search Suggestions System ",
        "thought_question": "```\ndef suggestedProducts(self, products: List[str], searchWord: str) -> List[List[str]]: \"\"\" You are given an array of strings products and a string searchWord.\n\nDesign a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.\n\nReturn a list of lists of the suggested products after each character of searchWord is typed.\nExamples: * suggestedProducts([\"mobile\",\"mouse\",\"moneypot\",\"monitor\",\"mousepad\"],\"mouse\") => [[\"mobile\",\"moneypot\",\"monitor\"],[\"mobile\",\"moneypot\",\"monitor\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"],[\"mouse\",\"mousepad\"]] * suggestedProducts([\"havana\"],\"havana\") => [[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"],[\"havana\"]] \"\"\"\n```",
        "thought_answer": "```\n    def suggestedProducts(self, ps: List[str], w: str) -> List[List[str]]:\n        ps.sort()\n        n = len(ps)\n        ans = []\n        for i in range(len(w)):\n            cur = w[:i + 1]\n            l, r = 0, n - 1\n            while l < r:\n                mid = (l + r) // 2\n                if ps[mid] >= cur:\n                    r = mid\n                else:\n                    l = mid + 1\n            lst = []\n            if ps[r] >= cur:\n                for j in range(r, min(n - 1, r + 2) + 1):\n                    if len(ps[j]) < len(cur) or ps[j][:i + 1] != cur:\n                        break\n                    lst.append(ps[j])\n            ans.append(lst)\n        return ans\n```"
    },
    {
        "thought_name": "Non-overlapping Intervals ",
        "thought_question": "```\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -> int: \"\"\" Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nExamples: * eraseOverlapIntervals([[1,2],[2,3],[3,4],[1,3]]) => 1 * eraseOverlapIntervals([[1,2],[1,2],[1,2]]) => 2 * eraseOverlapIntervals([[1,2],[2,3]]) => 0 \"\"\"\n```",
        "thought_answer": "```\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        \n        intervals.sort(key=lambda x: x[1])\n        n = len(intervals)\n        right = intervals[0][1]\n        remove = 0\n\n        for i in range(1, n):\n            if intervals[i][0] < right:\n                remove += 1\n            else:\n                right = intervals[i][1]\n        \n        return remove\n```"
    },
    {
        "thought_name": "Minimum Number of Arrows to Burst Balloons ",
        "thought_question": "```\ndef findMinArrowShots(self, points: List[List[int]]) -> int: \"\"\" There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons.\n\nArrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart <= x <= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path.\n\nGiven the array points, return the minimum number of arrows that must be shot to burst all balloons.\nExamples: * findMinArrowShots([[10,16],[2,8],[1,6],[7,12]]) => 2 * findMinArrowShots([[1,2],[3,4],[5,6],[7,8]]) => 4 * findMinArrowShots([[1,2],[2,3],[3,4],[4,5]]) => 2 \"\"\" \n```",
        "thought_answer": "```\n    def findMinArrowShots(self, points: List[List[int]]) -> int:\n        points.sort()   # 根据区间起点对区间进行升序排序，起点相同根据区间终点升序排序\n        arrow = 0       # 使用箭数\n        start, end = points[0]  # 当前区间交集起点和终点，初始为首个区间起点和终点\n        # 遍历每个区间，相同区间的交集为其本身，因此第一个区间的遍历不影响结果\n        for (p_x, p_y) in points:\n            if p_x > end:\n                # 当前区间与当前区间交集没有交集，当前交集使用一个根箭；更新区间交集为当前区间\n                arrow += 1\n                start, end = p_x, p_y\n            else:\n                # 当前区间与当前区间交集有交集，更新区间交集\n                start = max(start, p_x)\n                end = min(end, p_y)\n        arrow += 1  # 最后一个区间交集还需要使用一根箭\n        return arrow\n```"
    },
    {
        "thought_name": "Daily Temperatures ",
        "thought_question": "```\ndef dailyTemperatures(self, temperatures: List[int]) -> List[int]: \"\"\" Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.\nExamples: * dailyTemperatures([73,74,75,71,69,72,76,73]) => [1,1,4,2,1,1,0,0] * dailyTemperatures([30,40,50,60]) => [1,1,1,0] * dailyTemperatures([30,60,90]) => [1,1,0] \"\"\" \n```",
        "thought_answer": "```\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        n = len(temperatures)\n        ans = [0] * n\n        st = []\n        for i in range(n - 1, -1, -1):\n            t = temperatures[i]\n            while st and t >= temperatures[st[-1]]:\n                st.pop()\n            if st:\n                ans[i] = st[-1] - i\n            st.append(i)\n        return ans\n```"
    }
]