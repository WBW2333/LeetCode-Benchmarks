{
    "leetcode-benchmark-0": {
        "id": "leetcode-benchmark-0",
        "title": "Two Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,7,11,15\\], target = 9\n**Output:** \\[0,1\\]\n**Explanation:** Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,4\\], target = 6\n**Output:** \\[1,2\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[3,3\\], target = 6\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`\n*   **Only one valid answer exists.**\n\n**",
            "follow_up": "Follow-up:** Can you come up with an algorithm that is less than `O(n2)` time complexity?"
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int[] twoSum(int[] nums, int target) {\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        int complement = target - nums[i];\n        if (map.containsKey(complement)) {\n            return new int[]{map.get(complement), i};\n        }\n        map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = target - nums[i];\n        if (map.find(complement) != map.end()) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {};\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "python": "\n    ```python\ndef twoSum(nums, target):\n    map = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in map:\n            return [map[complement], i]\n        map[num] = i\n    return []\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "javascript": "\n    ```javascript\nfunction twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n    }\n    return [];\n}\n```\n    \n    The algorithm leverages a hash map (unordered_map in C++, HashMap in Java, dictionary in Python, and Map in JavaScript). It iterates through the given 'nums' array and calculates the complementary value (target - current value). If the complementary value is already in the hash map, it means that we found a solution, and we return those indices. If the complement is not in the hash map, we store the current element in the hash map with its index. If the algorithm doesn't find the solution, it returns an empty array or throws an exception (in Java).\n\nThis approach has a time complexity of O(n) and a space complexity of O(n) as well.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,7,11,15], target = 9",
                    "output": " [0,1]",
                    "explanation": " Because nums\\[0\\] + nums\\[1\\] == 9, we return \\[0, 1\\]."
                },
                {
                    "input": " nums = [3,2,4], target = 6",
                    "output": " [1,2]",
                    "explanation": null
                },
                {
                    "input": " nums = [3,3], target = 6",
                    "output": " [0,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,7,11,15],9",
                    "output": "[0,1]"
                },
                {
                    "input": "[3,2,4],6",
                    "output": "[1,2]"
                },
                {
                    "input": "[3,3],6",
                    "output": "[0,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-0",
        "prompt": "Given an array of integers `nums` and an integer `target`, return _indices of the two numbers such that they add up to `target`_.\n\nYou may assume that each input would have **_exactly_ one solution**, and you may not use the _same_ element twice.\n\nYou can return the answer in any order."
    },
    "leetcode-benchmark-1": {
        "id": "leetcode-benchmark-1",
        "title": "Palindrome Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 121\n**Output:** true\n**Explanation:** 121 reads as 121 from left to right and from right to left.\n\n",
                "**Example 2:**\n\n**Input:** x = -121\n**Output:** false\n**Explanation:** From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** x = 10\n**Output:** false\n**Explanation:** Reads 01 from right to left. Therefore it is not a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= x <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without converting the integer to a string?"
        },
        "java": "\n    ```java\npublic boolean isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "c++": "\n    ```cpp\nbool isPalindrome(int x) {\n    if (x < 0) return false;\n    int original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return original == reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "python": "\n    ```python\ndef is_palindrome(x: int) -> bool:\n    if x < 0:\n        return False\n    original, reversed = x, 0\n    while x > 0:\n        reversed = reversed * 10 + x % 10\n        x //= 10\n    return original == reversed\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "javascript": "\n    ```javascript\nfunction isPalindrome(x) {\n    if (x < 0) return false;\n    let original = x, reversed = 0;\n    while (x > 0) {\n        reversed = reversed * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    return original === reversed;\n}\n```\n\n    \n    Here is the algorithm:\n\n1. If the integer is negative, immediately return false, as negative numbers cannot be palindromes.\n2. Create a variable named `original` to store the original integer value and `reversed` initialized with 0 to store the reversed integer value.\n3. Iterate through the integer while it's greater than zero and, in each iteration, perform the following operations:\n   a. Multiply the `reversed` value by 10 and add the modulus of the integer (x) by 10.\n   b. Divide the integer (x) by 10, discarding the remainder.\n4. Compare `original` and `reversed` integers; if they are equal, return true; otherwise, return false.\n\nThis approach requires O(log10(n)) time complexity as we are dividing the input by 10 in each iteration.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " x = 121",
                    "output": " True",
                    "explanation": " 121 reads as 121 from left to right and from right to left."
                },
                {
                    "input": " x = -121",
                    "output": " False",
                    "explanation": " From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome."
                },
                {
                    "input": " x = 10",
                    "output": " False",
                    "explanation": " Reads 01 from right to left. Therefore it is not a palindrome."
                }
            ],
            "function_input": [
                {
                    "input": "121",
                    "output": "True"
                },
                {
                    "input": "-121",
                    "output": "False"
                },
                {
                    "input": "10",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-1",
        "prompt": "Given an integer `x`, return `true` _if_ `x` _is a_ _**palindrome**__, and_ `false` _otherwise_."
    },
    "leetcode-benchmark-2": {
        "id": "leetcode-benchmark-2",
        "title": "Roman to Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"III \"\n**Output:** 3\n**Explanation:** III = 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"LVIII \"\n**Output:** 58\n**Explanation:** L = 50, V= 5, III = 3.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"MCMXCIV \"\n**Output:** 1994\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 15`\n*   `s` contains only the characters `('I', 'V', 'X', 'L', 'C', 'D', 'M')`.\n*   It is **guaranteed** that `s` is a valid roman numeral in the range `[1, 3999]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int romanToInt(String s) {\n    Map<Character, Integer> romanValues = new HashMap<>();\n    romanValues.put('I', 1);\n    romanValues.put('V', 5);\n    romanValues.put('X', 10);\n    romanValues.put('L', 50);\n    romanValues.put('C', 100);\n    romanValues.put('D', 500);\n    romanValues.put('M', 1000);\n\n    int total = 0;\n    int prevValue = 0;\n\n    for (char c : s.toCharArray()) {\n        int currValue = romanValues.get(c);\n        total += currValue > prevValue ? currValue - 2 * prevValue : currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "c++": "\n    ```cpp\nint romanToInt(string s) {\n    unordered_map<char, int> roman_values = { {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000} };\n    int total = 0;\n    int prev_value = 0;\n\n    for (char c : s) {\n        int current_value = roman_values[c];\n        if (current_value > prev_value)\n            total += current_value - (2 * prev_value);\n        else\n            total += current_value;\n        prev_value = current_value;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "python": "\n    ```python\ndef roman_to_int(s):\n    roman_values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    total = 0\n    prev_value = 0\n    \n    for c in s:\n        current_value = roman_values[c]\n        if current_value > prev_value:\n            total += current_value - 2 * prev_value\n        else:\n            total += current_value\n        prev_value = current_value\n\n    return total\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "javascript": "\n    ```javascript\nfunction romanToInt(s) {\n    const romanValues = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000};\n    let total = 0;\n    let prevValue = 0;\n\n    for (let i = 0; i < s.length; i++) {\n        let currValue = romanValues[s[i]];\n        if (currValue > prevValue)\n            total += currValue - (2 * prevValue);\n        else\n            total += currValue;\n        prevValue = currValue;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm iterates through the input string, which represents the Roman numeral. At each iteration, the character is converted to its corresponding integer value using a hash map. Then, the value is added to the total. However, if the current value is greater than the previous value, it means that we need to subtract the previous value from the current value (while considering that the previous value has already been added once). To do this, we add to the total the current value minus 2 times the previous value. Finally, the previous value is updated, and the loop continues. After the loop finishes, the total gives us the integer value equivalent to the Roman numeral.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"III \"",
                    "output": " 3",
                    "explanation": " III = 3."
                },
                {
                    "input": " s =  \"LVIII \"",
                    "output": " 58",
                    "explanation": " L = 50, V= 5, III = 3."
                },
                {
                    "input": " s =  \"MCMXCIV \"",
                    "output": " 1994",
                    "explanation": " M = 1000, CM = 900, XC = 90 and IV = 4."
                }
            ],
            "function_input": [
                {
                    "input": "\"III\"",
                    "output": "3"
                },
                {
                    "input": "\"LVIII\"",
                    "output": "58"
                },
                {
                    "input": "\"MCMXCIV\"",
                    "output": "1994"
                }
            ]
        },
        "task_id": "leetcode-benchmark-2",
        "prompt": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two ones added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven a roman numeral, convert it to an integer."
    },
    "leetcode-benchmark-3": {
        "id": "leetcode-benchmark-3",
        "title": "Longest Common Prefix",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\" \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"flower \", \"flow \", \"flight \"\\]\n**Output:**  \"fl \"\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"dog \", \"racecar \", \"car \"\\]\n**Output:**  \" \"\n**Explanation:** There is no common prefix among the input strings."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n\n    for (int i = 0; i < strs[0].length(); ++i) {\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; ++j) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c) {\n                return strs[0].substring(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nstring longestCommonPrefix(vector<string>& strs) {\n    if (strs.empty()) return \"\";\n\n    for (int i = 0; i < strs[0].size(); ++i) {\n        char c = strs[0][i];\n        for (int j = 1; j < strs.size(); ++j) {\n            if (i == strs[j].size() || strs[j][i] != c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "python": "\n    ```python\ndef longest_common_prefix(strs):\n    if not strs:\n        return \"\"\n\n    for i, c in enumerate(strs[0]):\n        for j in range(1, len(strs)):\n            if i == len(strs[j]) or strs[j][i] != c:\n                return strs[0][:i]\n    return strs[0]\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "javascript": "\n    ```javascript\nfunction longestCommonPrefix(strs) {\n    if (strs.length === 0) return \"\";\n\n    for (let i = 0; i < strs[0].length; ++i) {\n        const c = strs[0][i];\n        for (let j = 1; j < strs.length; ++j) {\n            if (i === strs[j].length || strs[j][i] !== c) {\n                return strs[0].substr(0, i);\n            }\n        }\n    }\n    return strs[0];\n}\n```\n    \n    The algorithm iterates through the characters in the first string and compares the equivalent characters in the subsequent strings. If there is a mismatch detected, return the common prefix up to the mismatch point. If the algorithm finishes iterating over the first string, return the entire first string as the common prefix.\n\n1. Check if the input array is empty, if it is, return an empty string as there is no common prefix.\n2. Iterate through the characters of the first string.\n3. For each character, iterate through the rest of the strings in the array.\n4. Compare the current character with the corresponding character in the other strings.\n5. If there is a mismatch or if we reach the end of a string, return the common prefix substring up to the current index.\n6. If the loop reaches the end of the first string, then the whole first string is the common prefix. Return the entire first string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " strs = [ \"flower \", \"flow \", \"flight \"]",
                    "output": "  \"fl \"",
                    "explanation": null
                },
                {
                    "input": " strs = [ \"dog \", \"racecar \", \"car \"]",
                    "output": "  \" \"",
                    "explanation": " There is no common prefix among the input strings."
                }
            ],
            "function_input": [
                {
                    "input": "[\"flower\",\"flow\",\"flight\"]",
                    "output": "\"fl\""
                },
                {
                    "input": "[\"dog\",\"racecar\",\"car\"]",
                    "output": "\"\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-3",
        "prompt": "Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string `\" \"`."
    },
    "leetcode-benchmark-4": {
        "id": "leetcode-benchmark-4",
        "title": "Valid Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"() \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"()\\[\\]{} \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"(\\] \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of parentheses only `'()[]{}'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isValid(String s) {\n    Stack<Character> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.peek() != '(') return false;\n            if (c == '}' && stack.peek() != '{') return false;\n            if (c == ']' && stack.peek() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "c++": "\n    ```cpp\nbool isValid(std::string s) {\n    std::stack<char> stack;\n\n    for (char c : s) {\n        if (c == '(' || c == '{' || c == '[') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) return false;\n            if (c == ')' && stack.top() != '(') return false;\n            if (c == '}' && stack.top() != '{') return false;\n            if (c == ']' && stack.top() != '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.empty();\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "python": "\n    ```python\ndef is_valid(s: str) -> bool:\n    stack = []\n\n    for c in s:\n        if c in '([{':\n            stack.append(c)\n        else:\n            if not stack:\n                return False\n            if c == ')' and stack[-1] != '(':\n                return False\n            if c == '}' and stack[-1] != '{':\n                return False\n            if c == ']' and stack[-1] != '[':\n                return False\n            stack.pop()\n\n    return not stack\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "javascript": "\n    ```javascript\nfunction isValid(s) {\n    const stack = [];\n\n    for (const c of s) {\n        if (c === '(' || c === '{' || c === '[') {\n            stack.push(c);\n        } else {\n            if (!stack.length) return false;\n            if (c === ')' && stack[stack.length - 1] !== '(') return false;\n            if (c === '}' && stack[stack.length - 1] !== '{') return false;\n            if (c === ']' && stack[stack.length - 1] !== '[') return false;\n            stack.pop();\n        }\n    }\n\n    return stack.length === 0;\n}\n```\n    \n    The algorithm uses a stack data structure to check the validity of the input string. It iterates through the string one character at a time. When an open bracket is encountered, it is pushed onto the stack. When a close bracket is encountered, the algorithm checks if the stack is empty or the corresponding open bracket is not at the top of the stack. If either of these conditions is true, the function returns false. If not, the open bracket is popped from the stack. After iterating through the entire string, the function checks if the stack is empty. If the stack is not empty, the function returns false, indicating there were unmatched open braces. Otherwise, the function returns true, indicating that the string is valid.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"() \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s =  \"()[]{} \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s =  \"(] \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"()\"",
                    "output": "True"
                },
                {
                    "input": "\"()[]{}\"",
                    "output": "True"
                },
                {
                    "input": "\"(] \"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-4",
        "prompt": "Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.\n\nAn input string is valid if:\n\n1.  Open brackets must be closed by the same type of brackets.\n2.  Open brackets must be closed in the correct order.\n3.  Every close bracket has a corresponding open bracket of the same type."
    },
    "leetcode-benchmark-5": {
        "id": "leetcode-benchmark-5",
        "title": "Remove Duplicates from Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.\n\nConsider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** 2, nums = \\[1,2,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,2,2,3,3,4\\]\n**Output:** 5, nums = \\[0,1,2,3,4,\\_,\\_,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-100 <= nums[i] <= 100`\n*   `nums` is sorted in **non-decreasing** order.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int removeDuplicates(int[] nums) {\n    if (nums.length == 0) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.length; j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "c++": "\n    ```cpp\nint removeDuplicates(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int i = 0;\n    for (int j = 1; j < nums.size(); j++) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "python": "\n    ```python\ndef removeDuplicates(nums):\n    if not nums: return 0\n    i = 0\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            i += 1\n            nums[i] = nums[j]\n    return i + 1\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "javascript": "\n    ```javascript\nfunction removeDuplicates(nums) {\n    if (nums.length === 0) return 0;\n    let i = 0;\n    for (let j = 1; j < nums.length; j++) {\n        if (nums[j] !== nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n    }\n    return i + 1;\n}\n```\n\n    \n    We use two pointers `i` and `j`. `i` starts at the first element and `j` at the second. We go through the array with `j` and compare the elements at the two pointers. If they are different, it means we found a unique element, so we move `i` to the next position and copy the value from `j` to `i`. When we finish going through the array, the length of the unique part is `i+1`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,1,2]",
                    "output": " 2, nums = [1,2,_]",
                    "explanation": " Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
                },
                {
                    "input": " nums = [0,0,1,1,1,2,2,3,3,4]",
                    "output": " 5, nums = [0,1,2,3,4,_,_,_,_,_]",
                    "explanation": " Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,2]",
                    "output": "2"
                },
                {
                    "input": "[0,0,1,1,1,2,2,3,3,4]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-5",
        "prompt": "Given an integer array `nums` sorted in **non-decreasing order**, remove the duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears only **once**. The **relative order** of the elements should be kept the **same**. Then return _the number of unique elements in_ `nums`.\n\nConsider the number of unique elements of `nums` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the unique elements in the order they were present in `nums` initially. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**."
    },
    "leetcode-benchmark-6": {
        "id": "leetcode-benchmark-6",
        "title": "Remove Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint val = ...; // Value to remove\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,2,3\\], val = 3\n**Output:** 2, nums = \\[2,2,\\_,\\_\\]\n**Explanation:** Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,2,2,3,0,4,2\\], val = 2\n**Output:** 5, nums = \\[0,1,4,0,3,\\_,\\_,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 100`\n*   `0 <= nums[i] <= 50`\n*   `0 <= val <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int removeElement(int[] nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.length; j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "c++": "\n    ```cpp\nint removeElement(vector<int>& nums, int val) {\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "python": "\n    ```python\ndef removeElement(nums, val):\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "javascript": "\n    ```javascript\nfunction removeElement(nums, val) {\n    let i = 0;\n    for (let j = 0; j < nums.length; j++) {\n        if (nums[j] !== val) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses two pointers approach. The pointer `i` maintains the position where the next non-val element should be placed, and pointer `j` iterates through the array. If the element at `j` is not equal to `val`, we place it at the position `i` and increment the `i` pointer. The loop continues until we have checked all the elements in the array. The `i` pointer will give us the count of elements that are not equal to `val`, which is the result. Thus, we return the value of `i` as the final result.\n\nThe time complexity of this algorithm is O(n), where n is the number of elements in the array, as we only iterate through the array once. The space complexity is O(1) since we do not use any extra memory. We modify the input array in-place.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,2,2,3], val = 3",
                    "output": " 2, nums = [2,2,_,_]",
                    "explanation": " Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
                },
                {
                    "input": " nums = [0,1,2,2,3,0,4,2], val = 2",
                    "output": " 5, nums = [0,1,4,0,3,_,_,_]",
                    "explanation": " Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,2,3],3",
                    "output": "2"
                },
                {
                    "input": "[0,1,2,2,3,0,4,2],2",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-6",
        "prompt": "Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm). The order of the elements may be changed. Then return _the number of elements in_ `nums` _which are not equal to_ `val`.\n\nConsider the number of elements in `nums` which are not equal to `val` be `k`, to get accepted, you need to do the following things:\n\n*   Change the array `nums` such that the first `k` elements of `nums` contain the elements which are not equal to `val`. The remaining elements of `nums` are not important as well as the size of `nums`.\n*   Return `k`.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint val = ...; // Value to remove\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**."
    },
    "leetcode-benchmark-7": {
        "id": "leetcode-benchmark-7",
        "title": "Find the Index of the First Occurrence in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.",
            "examples": [
                "**Example 1:**\n\n**Input:** haystack =  \"sadbutsad \", needle =  \"sad \"\n**Output:** 0\n**Explanation:**  \"sad \" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n\n",
                "**Example 2:**\n\n**Input:** haystack =  \"leetcode \", needle =  \"leeto \"\n**Output:** -1\n**Explanation:**  \"leeto \" did not occur in  \"leetcode \", so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= haystack.length, needle.length <= 104`\n*   `haystack` and `needle` consist of only lowercase English characters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int strStr(String haystack, String needle) {\n    if (needle.isEmpty()) return 0;\n    \n    int index = haystack.indexOf(needle);\n    return index;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "c++": "\n    ```cpp\nint strStr(string haystack, string needle) {\n    if(needle.empty()) return 0;\n\n    size_t pos = haystack.find(needle);\n    if(pos != string::npos)\n        return pos;\n    return -1;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "python": "\n    ```python\ndef strStr(haystack: str, needle: str) -> int:\n    if not needle:\n        return 0\n    try:\n        index = haystack.index(needle)\n        return index\n    except ValueError:\n        return -1\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "javascript": "\n    ```javascript\nfunction strStr(haystack, needle) {\n    if (needle === '') return 0;\n\n    let index = haystack.indexOf(needle);\n    return index;\n}\n```\n    \n    The algorithm searches for the first occurrence of the `needle` string in the `haystack` string. First, it checks if the `needle` is empty, and if it is, it returns 0. Otherwise, it uses the built-in `find`, `indexOf` or `index` functions provided by the corresponding language's string data type. These functions return the index of the first occurrence of the specified substring. If the substring is not found, they return specific values like string::npos for C++, -1 for Java, and raise a ValueError exception for Python. Depending on the returned value, the algorithm either returns the index of the first occurrence or -1, indicating that `needle` is not part of `haystack`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " haystack =  \"sadbutsad \", needle =  \"sad \"",
                    "output": " 0",
                    "explanation": "  \"sad \" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0."
                },
                {
                    "input": " haystack =  \"leetcode \", needle =  \"leeto \"",
                    "output": " -1",
                    "explanation": "  \"leeto \" did not occur in  \"leetcode \", so we return -1."
                }
            ],
            "function_input": [
                {
                    "input": "\"sadbutsad\",\"sad\"",
                    "output": "0"
                },
                {
                    "input": "\"leetcode\",\"leeto\"",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-7",
        "prompt": "Given two strings `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`."
    },
    "leetcode-benchmark-8": {
        "id": "leetcode-benchmark-8",
        "title": "Search Insert Position",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 5\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 2\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,3,5,6\\], target = 7\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` contains **distinct** values sorted in **ascending** order.\n*   `-104 <= target <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int searchInsert(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "c++": "\n    ```cpp\nint searchInsert(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "python": "\n    ```python\ndef searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "javascript": "\n    ```javascript\nfunction searchInsert(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n```\n    \n    The given problem requires a binary search algorithm. We define two pointers, `left` and `right`, initially set to the first and last index of the array. We then enter a loop that continues as long as left is less than or equal to right. Inside the loop, we calculate the middle index, `mid`, as the average of left and right. If the value at this middle index is equal to the target value, we return the middle index. If the middle value is less than the target value, we set left to `mid + 1`, meaning we search the right half of the remaining array. If the middle value is greater than the target value, we set the right to `mid - 1`, meaning we search the left half of the remaining array. After the loop, if the target value is not found, we return the value of the left pointer, which represents the index where the target value should be inserted.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,5,6], target = 5",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " nums = [1,3,5,6], target = 2",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " nums = [1,3,5,6], target = 7",
                    "output": " 4",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,5,6],5",
                    "output": "2"
                },
                {
                    "input": "[1,3,5,6],2",
                    "output": "1"
                },
                {
                    "input": "[1,3,5,6],7",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-8",
        "prompt": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with `O(log n)` runtime complexity."
    },
    "leetcode-benchmark-9": {
        "id": "leetcode-benchmark-9",
        "title": "Length of Last Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello World \"\n**Output:** 5\n**Explanation:** The last word is  \"World \" with length 5.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"   fly me   to   the moon   \"\n**Output:** 4\n**Explanation:** The last word is  \"moon \" with length 4.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"luffy is still joyboy \"\n**Output:** 6\n**Explanation:** The last word is  \"joyboy \" with length 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only English letters and spaces `' '`.\n*   There will be at least one word in `s`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int lengthOfLastWord(String s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s.charAt(tail) == ' ') tail--;\n    while (tail >= 0 && s.charAt(tail) != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLastWord(string s) {\n    int length = 0;\n    int tail = s.length() - 1;\n    while (tail >= 0 && s[tail] == ' ') tail--;\n    while (tail >= 0 && s[tail] != ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "python": "\n    ```python\ndef length_of_last_word(s: str) -> int:\n    length = 0\n    tail = len(s) - 1\n    while tail >= 0 and s[tail] == ' ':\n        tail -= 1\n    while tail >= 0 and s[tail] != ' ':\n        length += 1\n        tail -= 1\n    return length\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "javascript": "\n    ```javascript\nfunction lengthOfLastWord(s) {\n    let length = 0;\n    let tail = s.length - 1;\n    while (tail >= 0 && s[tail] === ' ') tail--;\n    while (tail >= 0 && s[tail] !== ' ') {\n        length++;\n        tail--;\n    }\n    return length;\n}\n```\n    \n    The algorithm for finding the length of the last word in a string containing multiple words separated by spaces is as follows:\n\n1. Initialize variables for the length of the last word and the tail (i.e., the end) of the input string.\n2. Traverse the string in reverse order to find the start of the last word by checking if a character is a space. Skip all spaces found.\n3. Continue traversing the string in reverse order and record the length of the last word until a space is encountered or the start of the string is reached.\n4. Return the length of the last word.\n\nThis algorithm is implemented in each of the given programming languages (C++, Java, Python, and JavaScript) with the appropriate syntax and variable initialization. The functions are named `lengthOfLastWord` for C++, Java, and JavaScript, and `length_of_last_word` for Python.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"Hello World \"",
                    "output": " 5",
                    "explanation": " The last word is  \"World \" with length 5."
                },
                {
                    "input": " s =  \"   fly me   to   the moon   \"",
                    "output": " 4",
                    "explanation": " The last word is  \"moon \" with length 4."
                },
                {
                    "input": " s =  \"luffy is still joyboy \"",
                    "output": " 6",
                    "explanation": " The last word is  \"joyboy \" with length 6."
                }
            ],
            "function_input": [
                {
                    "input": "\"HelloWorld\"",
                    "output": "5"
                },
                {
                    "input": "\"flymetothemoon\"",
                    "output": "4"
                },
                {
                    "input": "\"luffyisstilljoyboy\"",
                    "output": "6"
                }
            ]
        },
        "task_id": "leetcode-benchmark-9",
        "prompt": "Given a string `s` consisting of words and spaces, return _the length of the **last** word in the string._\n\nA **word** is a maximal substring consisting of non-space characters only."
    },
    "leetcode-benchmark-10": {
        "id": "leetcode-benchmark-10",
        "title": "Plus One",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits = \\[1,2,3\\]\n**Output:** \\[1,2,4\\]\n**Explanation:** The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be \\[1,2,4\\].\n\n",
                "**Example 2:**\n\n**Input:** digits = \\[4,3,2,1\\]\n**Output:** \\[4,3,2,2\\]\n**Explanation:** The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be \\[4,3,2,2\\].\n\n",
                "**Example 3:**\n\n**Input:** digits = \\[9\\]\n**Output:** \\[1,0\\]\n**Explanation:** The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be \\[1,0\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= digits.length <= 100`\n*   `0 <= digits[i] <= 9`\n*   `digits` does not contain any leading `0`'s.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] plusOne(int[] digits) {\n    int n = digits.length;\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    int[] newDigits = new int[n + 1];\n    newDigits[0] = 1;\n    return newDigits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> plusOne(std::vector<int>& digits) {\n    int n = digits.size();\n\n    for(int i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.insert(digits.begin(), 1);\n    return digits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "python": "\n    ```python\ndef plusOne(digits: List[int]) -> List[int]:\n    n = len(digits)\n\n    for i in range(n - 1, -1, -1):\n        if digits[i] < 9:\n            digits[i] += 1\n            return digits\n        digits[i] = 0\n\n    digits.insert(0, 1)\n    return digits\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "javascript": "\n    ```javascript\nfunction plusOne(digits) {\n    let n = digits.length;\n\n    for(let i = n - 1; i >= 0; i--) {\n        if(digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n\n    digits.unshift(1);\n    return digits;\n}\n```\n\n    \n    We start by iterating through the array from the least significant digit (rightmost) to the most significant digit (leftmost). In each iteration, we check whether the digit is less than 9. If the digit is less than 9, increment it and return the incremented array. If the digit is 9, we set it to 0 and continue the loop to the next most significant digit.\n\nAfter the loop, if we haven't found any digit less than 9, that means we have a number like 9999...9 which needs to be incremented to 10000...0. So we add a 1 at the beginning of the array (the most significant digit). Finally, we return the incremented array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " digits = [1,2,3]",
                    "output": " [1,2,4]",
                    "explanation": " The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be \\[1,2,4\\]."
                },
                {
                    "input": " digits = [4,3,2,1]",
                    "output": " [4,3,2,2]",
                    "explanation": " The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be \\[4,3,2,2\\]."
                },
                {
                    "input": " digits = [9]",
                    "output": " [1,0]",
                    "explanation": " The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be \\[1,0\\]."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "[1,2,4]"
                },
                {
                    "input": "[4,3,2,1]",
                    "output": "[4,3,2,2]"
                },
                {
                    "input": "[9]",
                    "output": "[1,0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-10",
        "prompt": "You are given a **large integer** represented as an integer array `digits`, where each `digits[i]` is the `ith` digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading `0`'s.\n\nIncrement the large integer by one and return _the resulting array of digits_."
    },
    "leetcode-benchmark-11": {
        "id": "leetcode-benchmark-11",
        "title": "Add Binary",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two binary strings `a` and `b`, return _their sum as a binary string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = \"11\", b = \"1\"\n**Output:** \"100\"\n\n",
                "**Example 2:**\n\n**Input:** a = \"1010\", b = \"1011\"\n**Output:** \"10101\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a.length, b.length <= 104`\n*   `a` and `b` consist only of `'0'` or `'1'` characters.\n*   Each string does not contain leading zeros except for the zero itself.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String addBinary(String a, String b) {\n    StringBuilder result = new StringBuilder();\n    int i = a.length() - 1, j = b.length() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry != 0) {\n        if (i >= 0) carry += a.charAt(i--) - '0';\n        if (j >= 0) carry += b.charAt(j--) - '0';\n        result.insert(0, carry % 2);\n        carry /= 2;\n    }\n    return result.toString();\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "c++": "\n    ```cpp\nstd::string addBinary(std::string a, std::string b) {\n    std::string result = \"\";\n    int i = a.size() - 1, j = b.size() - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += a[i--] - '0';\n        if (j >= 0) carry += b[j--] - '0';\n        result = char(carry % 2 + '0') + result;\n        carry /= 2;\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "python": "\n    ```python\ndef addBinary(a: str, b: str) -> str:\n    result, carry, i, j = \"\", 0, len(a) - 1, len(b) - 1\n    while i >= 0 or j >= 0 or carry:\n        if i >= 0:\n            carry += int(a[i])\n            i -= 1\n        if j >= 0:\n            carry += int(b[j])\n            j -= 1\n        result = str(carry % 2) + result\n        carry //= 2\n    return result\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "javascript": "\n    ```javascript\nfunction addBinary(a, b) {\n    let result = \"\";\n    let i = a.length - 1, j = b.length - 1, carry = 0;\n    while (i >= 0 || j >= 0 || carry) {\n        if (i >= 0) carry += parseInt(a[i--], 10);\n        if (j >= 0) carry += parseInt(b[j--], 10);\n        result = (carry % 2) + result;\n        carry = Math.floor(carry / 2);\n    }\n    return result;\n}\n```\n    \n    The algorithm initializes an empty result binary string, carry, and two pointers i and j pointing to the last element of strings a and b respectively.\nIn each iteration:\n- If i is not out of bounds, add the corresponding binary number to the carry.\n- If j is not out of bounds, add the corresponding binary number to the carry.\n- Append the remainder of dividing carry by 2 to the result binary string (left side).\n- Update carry by dividing it by 2 (integer division).\n\nThis process continues until i and j pointers become out of bounds and there is no carry left.\n\nFinally, return the result binary string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " a = \"11\", b = \"1\"",
                    "output": " \"100\"",
                    "explanation": null
                },
                {
                    "input": " a = \"1010\", b = \"1011\"",
                    "output": " \"10101\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"11\",\"1\"",
                    "output": "\"100\""
                },
                {
                    "input": "\"1010\",\"1011\"",
                    "output": "\"10101\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-11",
        "prompt": "Given two binary strings `a` and `b`, return _their sum as a binary string_."
    },
    "leetcode-benchmark-12": {
        "id": "leetcode-benchmark-12",
        "title": "Sqrt(x)",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.\n\nYou **must not use** any built-in exponent function or operator.\n\n*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 4\n**Output:** 2\n**Explanation:** The square root of 4 is 2, so we return 2.\n\n",
                "**Example 2:**\n\n**Input:** x = 8\n**Output:** 2\n**Explanation:** The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= x <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans = 0;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid <= x / mid) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "c++": "\n    ```cpp\nint mySqrt(int x) {\n    if (x == 0 || x == 1) return x;\n    int start = 1, end = x, ans;\n    while (start <= end) {\n        int mid = (start + end) / 2;\n        if (mid * mid == x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "python": "\n    ```python\ndef mySqrt(x):\n    if x == 0 or x == 1:\n        return x\n    start, end, ans = 1, x, 0\n    while start <= end:\n        mid = (start + end) // 2\n        if mid * mid == x:\n            return mid\n        if mid * mid < x:\n            start = mid + 1\n            ans = mid\n        else:\n            end = mid - 1\n    return ans\n```\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "javascript": "\n    ```javascript\nfunction mySqrt(x) {\n    if (x === 0 || x === 1) return x;\n    let start = 1, end = x, ans;\n    while (start <= end) {\n        let mid = Math.floor((start + end) / 2);\n        if (mid * mid === x) return mid;\n        if (mid * mid < x) {\n            start = mid + 1;\n            ans = mid;\n        } else {\n            end = mid - 1;\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm uses a binary search approach to find the integer square root of the given number `x`. It starts with the smallest possible answer (1) and the largest possible answer (x), updating the \"start\" and \"end\" positions based on whether the current midpoint squared is smaller or larger than x. The integer square root of the number is found when `mid * mid == x`, or when the closest integer (under or equal to x) value has been located. The binary search approach keeps the time complexity at O(log(x)), making it an efficient solution.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " x = 4",
                    "output": " 2",
                    "explanation": " The square root of 4 is 2, so we return 2."
                },
                {
                    "input": " x = 8",
                    "output": " 2",
                    "explanation": " The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned."
                }
            ],
            "function_input": [
                {
                    "input": "4",
                    "output": "2"
                },
                {
                    "input": "8",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-12",
        "prompt": "Given a non-negative integer `x`, return _the square root of_ `x` _rounded down to the nearest integer_. The returned integer should be **non-negative** as well.\n\nYou **must not use** any built-in exponent function or operator.\n\n*   For example, do not use `pow(x, 0.5)` in c++ or `x ** 0.5` in python."
    },
    "leetcode-benchmark-13": {
        "id": "leetcode-benchmark-13",
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "content": {
            "problem": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 2\n**Explanation:** There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:** There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 45`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "c++": "\n    ```cpp\nint climbStairs(int n) {\n    if(n <= 2) return n;\n    int a = 1, b = 2, c;\n    for(int i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "python": "\n    ```python\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    a, b = 1, 2\n    for _ in range(3, n+1):\n        a, b = b, a + b\n    return b\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "javascript": "\n    ```javascript\nfunction climbStairs(n) {\n    if(n <= 2) return n;\n    let a = 1, b = 2, c;\n    for(let i = 3; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return c;\n}\n```\n\n    \n    This problem can be solved using dynamic programming. The number of ways to reach the top can be calculated by finding the sum of the ways to reach the previous two steps. We start with the base cases where `n` is 1 or 2, and then iteratively build up the solution. In each iteration, we update `a` and `b` with the new number of ways to reach steps `n-2` and `n-1` respectively, and keep calculating the number of ways to reach step `n` using `a + b`. This continues until we reach the top and return the final result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " 2",
                    "explanation": " There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps"
                },
                {
                    "input": " n = 3",
                    "output": " 3",
                    "explanation": " There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "2"
                },
                {
                    "input": "3",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-13",
        "prompt": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?"
    },
    "leetcode-benchmark-14": {
        "id": "leetcode-benchmark-14",
        "title": "Merge Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\n\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,3,0,0,0\\], m = 3, nums2 = \\[2,5,6\\], n = 3\n**Output:** \\[1,2,2,3,5,6\\]\n**Explanation:** The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1\\], m = 1, nums2 = \\[\\], n = 0\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\].\n\n",
                "**Example 3:**\n\n**Input:** nums1 = \\[0\\], m = 0, nums2 = \\[1\\], n = 1\n**Output:** \\[1\\]\n**Explanation:** The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
            ],
            "constraints": "**Constraints:**\n\n*   `nums1.length == m + n`\n*   `nums2.length == n`\n*   `0 <= m, n <= 200`\n*   `1 <= m + n <= 200`\n*   `-109 <= nums1[i], nums2[j] <= 109`\n\n**",
            "follow_up": "Follow up:** Can you come up with an algorithm that runs in `O(m + n)` time?"
        },
        "java": "\n    ```java\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "c++": "\n    ```cpp\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n    int i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "python": "\n    ```python\ndef merge(nums1, m, nums2, n):\n    i, j, k = m - 1, n - 1, m + n - 1\n    while i >= 0 and j >= 0:\n        if nums1[i] > nums2[j]:\n            nums1[k] = nums1[i]\n            i -= 1\n        else:\n            nums1[k] = nums2[j]\n            j -= 1\n        k -= 1\n    while j >= 0:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "javascript": "\n    ```javascript\nfunction merge(nums1, m, nums2, n) {\n    let i = m - 1, j = n - 1, k = m + n - 1;\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j])\n            nums1[k--] = nums1[i--];\n        else\n            nums1[k--] = nums2[j--];\n    }\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n```\n    \n    We use a two-pointer approach to merge nums1 and nums2 in reverse order. Initialize three pointers i, j, and k pointing to the last elements of nums1, nums2, and the merged nums1 array respectively.\n\nIterate in a while loop until i and j are both less than 0. Compare the values of nums1[i] and nums2[j]. If nums1[i] is greater, assign nums1[i] at position k in nums1, decrement i and k. Otherwise, assign nums2[j] at position k in nums1, and decrement j and k. This process continues for all elements in nums2.\n\nAfter the loop, if there are still elements remaining in nums2 (j >= 0), copy the remaining elements of nums2 to nums1. In this way, we merge nums1 and nums2 in non-decreasing order.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
                    "output": " [1,2,2,3,5,6]",
                    "explanation": " The arrays we are merging are \\[1,2,3\\] and \\[2,5,6\\].\nThe result of the merge is \\[1,2,2,3,5,6\\] with the underlined elements coming from nums1."
                },
                {
                    "input": " nums1 = [1], m = 1, nums2 = [], n = 0",
                    "output": " [1]",
                    "explanation": " The arrays we are merging are \\[1\\] and \\[\\].\nThe result of the merge is \\[1\\]."
                },
                {
                    "input": " nums1 = [0], m = 0, nums2 = [1], n = 1",
                    "output": " [1]",
                    "explanation": " The arrays we are merging are \\[\\] and \\[1\\].\nThe result of the merge is \\[1\\].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,0,0,0],3,[2,5,6],3",
                    "output": "[1,2,2,3,5,6]"
                },
                {
                    "input": "[1],1,[],0",
                    "output": "[1]"
                },
                {
                    "input": "[0],0,[1],1",
                    "output": "[1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-14",
        "prompt": "You are given two integer arrays `nums1` and `nums2`, sorted in **non-decreasing order**, and two integers `m` and `n`, representing the number of elements in `nums1` and `nums2` respectively.\n\n**Merge** `nums1` and `nums2` into a single array sorted in **non-decreasing order**.\n\nThe final sorted array should not be returned by the function, but instead be _stored inside the array_ `nums1`. To accommodate this, `nums1` has a length of `m + n`, where the first `m` elements denote the elements that should be merged, and the last `n` elements are set to `0` and should be ignored. `nums2` has a length of `n`."
    },
    "leetcode-benchmark-15": {
        "id": "leetcode-benchmark-15",
        "title": "Symmetric Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center).",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,2,3,4,4,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,2,null,3,null,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Could you solve it both recursively and iteratively?"
        },
        "java": "\n    ```java\npublic boolean isSymmetric(TreeNode root) {\n    return checkSymmetry(root, root);\n}\n\npublic boolean checkSymmetry(TreeNode node1, TreeNode node2) {\n    if (node1 == null && node2 == null) return true;\n    if (node1 == null || node2 == null) return false;\n    return (node1.val == node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "c++": "\n    ```cpp\nbool isSymmetric(TreeNode* root) {\n    return checkSymmetry(root, root);\n}\n\nbool checkSymmetry(TreeNode* node1, TreeNode* node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1->val == node2->val) && checkSymmetry(node1->right, node2->left) && checkSymmetry(node1->left, node2->right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "python": "\n    ```python\ndef isSymmetric(root):\n    return checkSymmetry(root, root)\n\ndef checkSymmetry(node1, node2):\n    if not node1 and not node2:\n        return True\n    if not node1 or not node2:\n        return False\n    return (node1.val == node2.val) and checkSymmetry(node1.right, node2.left) and checkSymmetry(node1.left, node2.right)\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "javascript": "\n    ```javascript\nfunction isSymmetric(root) {\n    return checkSymmetry(root, root);\n}\n\nfunction checkSymmetry(node1, node2) {\n    if (!node1 && !node2) return true;\n    if (!node1 || !node2) return false;\n    return (node1.val === node2.val) && checkSymmetry(node1.right, node2.left) && checkSymmetry(node1.left, node2.right);\n}\n```\n    \n    The algorithm works by comparing the left subtree and right subtree of the root node. It uses a helper function, 'checkSymmetry()', which takes two nodes as its arguments. The base cases for this helper function are when both nodes are null, in which case the function should return true, or when one of the nodes is null, in which case the function should return false.\n\nThe function then checks whether the values of both nodes are equal and continues to call itself recursively, but with the arguments changed to evaluate the left subtree and right subtree symmetrically. If the left and right subtrees have symmetric nodes, the function will return true; otherwise, it will return false.\n\nThe recursive calls in the helper function flip the direction of traversal for both subtrees to ensure that the subtrees are compared symmetrically. In each recursive call, the appropriate child nodes are visited in opposite directions to make sure they can be properly compared.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,2,2,3,4,4,3]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " root = [1,2,2,null,3,null,3]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,2,3,4,4,3]",
                    "output": "True"
                },
                {
                    "input": "[1,2,2,null,3,null,3]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-15",
        "prompt": "Given the `root` of a binary tree, _check whether it is a mirror of itself_ (i.e., symmetric around its center)."
    },
    "leetcode-benchmark-16": {
        "id": "leetcode-benchmark-16",
        "title": "Maximum Depth of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,null,2\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-100 <= Node.val <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxDepth(TreeNode root) {\n    if (root == null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "c++": "\n    ```cpp\nint maxDepth(TreeNode* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    return 1 + max(maxDepth(root->left), maxDepth(root->right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "python": "\n    ```python\ndef maxDepth(root):\n    if root is None:\n        return 0\n    return 1 + max(maxDepth(root.left), maxDepth(root.right))\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "javascript": "\n    ```javascript\nfunction maxDepth(root) {\n    if (root === null) {\n        return 0;\n    }\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n}\n```\n    \n    The algorithm is a simple recursive traversal of the binary tree. We start from the root, and for each node, we calculate the maximum depth of its left and right subtrees. We return the maximum of these two depths plus 1 (for the current node). If the node is null, we return a depth of 0 since this path doesn't exist. This way, we traverse all potential paths in the tree and return the longest one.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [3,9,20,null,null,15,7]",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " root = [1,null,2]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,9,20,null,null,15,7]",
                    "output": "3"
                },
                {
                    "input": "[1,null,2]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-16",
        "prompt": "Given the `root` of a binary tree, return _its maximum depth_.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node."
    },
    "leetcode-benchmark-17": {
        "id": "leetcode-benchmark-17",
        "title": "Minimum Depth of Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n**Note:** A leaf is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,9,20,null,null,15,7\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,null,3,null,4,null,5,null,6\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 105]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minDepth(TreeNode root) {\n    if (root == null) return 0;\n    int left = minDepth(root.left);\n    int right = minDepth(root.right);\n    return (left == 0 || right == 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "c++": "\n    ```cpp\nint minDepth(TreeNode* root) {\n    if (!root) return 0;\n    int left = minDepth(root->left);\n    int right = minDepth(root->right);\n    return (left == 0 || right == 0) ? left + right + 1 : min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "python": "\n    ```python\ndef minDepth(root):\n    if not root:\n        return 0\n    left = minDepth(root.left)\n    right = minDepth(root.right)\n    return (left == 0 or right == 0) and left + right + 1 or min(left, right) + 1\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "javascript": "\n    ```javascript\nfunction minDepth(root) {\n    if (!root) return 0;\n    let left = minDepth(root.left);\n    let right = minDepth(root.right);\n    return (left === 0 || right === 0) ? left + right + 1 : Math.min(left, right) + 1;\n}\n```\n    \n    We perform a depth-first search on the tree. The base case would be an empty tree with a depth of 0.\n\nFor each non-null subtree, we recursively find the minimum depth of the left and right children. Then, we have three cases:\n1. If both left and right children are null, then the current node is a leaf node, and the minimum depth is 1.\n2. If either left or right child is null, we return the depth of the other child + 1.\n3. If both children are non-null, we take the minimum depth of both children and add 1.\n\nTo handle all the cases in a single line, we use a ternary conditional expression in C++, Java, and JavaScript, and use the `and`-`or` short-circuit syntax in Python. We check if either left or right is 0, and in that case return left + right + 1 which handles cases 1 and 2; otherwise, we return the minimum depth of both children + 1, which handles case 3.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [3,9,20,null,null,15,7]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " root = [2,null,3,null,4,null,5,null,6]",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,9,20,null,null,15,7]",
                    "output": "2"
                },
                {
                    "input": "[2,null,3,null,4,null,5,null,6]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-17",
        "prompt": "Given a binary tree, find its minimum depth.\n\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\n\n**Note:** A leaf is a node with no children."
    },
    "leetcode-benchmark-18": {
        "id": "leetcode-benchmark-18",
        "title": "Pascal's Triangle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:",
            "examples": [
                "**Example 1:**\n\n**Input:** numRows = 5\n**Output:** \\[\\[1\\],\\[1,1\\],\\[1,2,1\\],\\[1,3,3,1\\],\\[1,4,6,4,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** numRows = 1\n**Output:** \\[\\[1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= numRows <= 30`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic List<List<Integer>> generate(int numRows) {\n    List<List<Integer>> pascalsTriangle = new ArrayList<>();\n    for (int i = 0; i < numRows; i++) {\n        List<Integer> row = new ArrayList<>();\n        row.add(1);\n        for (int j = 1; j < i; j++) {\n            row.add(pascalsTriangle.get(i - 1).get(j - 1) + pascalsTriangle.get(i - 1).get(j));\n        }\n        if (i > 0) row.add(1);\n        pascalsTriangle.add(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "c++": "\n    ```cpp\nvector<vector<int>> generate(int numRows) {\n    vector<vector<int>> pascalsTriangle(numRows);\n    for (int i = 0; i < numRows; i++) {\n        pascalsTriangle[i].resize(i + 1);\n        pascalsTriangle[i][0] = pascalsTriangle[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            pascalsTriangle[i][j] = pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j];\n        }\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "python": "\n    ```python\ndef generate(numRows):\n    pascalsTriangle = []\n    for i in range(numRows):\n        row = [1]\n        if i > 0:\n            for j in range(1, i):\n                row.append(pascalsTriangle[i-1][j-1] + pascalsTriangle[i-1][j])\n            row.append(1)\n        pascalsTriangle.append(row)\n    return pascalsTriangle\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "javascript": "\n    ```javascript\nfunction generate(numRows) {\n    const pascalsTriangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        for (let j = 1; j < i; j++) {\n            row.push(pascalsTriangle[i - 1][j - 1] + pascalsTriangle[i - 1][j]);\n        }\n        if (i > 0) row.push(1);\n        pascalsTriangle.push(row);\n    }\n    return pascalsTriangle;\n}\n```\n    \n    The algorithm iterates through each row of Pascal's Triangle, from 0 to numRows-1, and generates the corresponding row with the required values based on the row index. For each row, it initializes an array or list, and then sets the first element to 1 (since all rows start with 1).\n\nNext, we iterate from the second element to the (i-1)-th element of the row (i being the row index). Each element (at index j) of the row is set to the sum of the two values positioned just above it in the previous row - these values are available at (i-1, j-1) and (i-1, j) in Pascal's Triangle.\n\nIf the current row is not the first row, we add another 1 at the end of the row, since all rows end with 1 (except the very first row).\n\nFinally, we append the row to the resulting Pascal's Triangle structure (list of lists or vector of vectors). After completing the loop, the algorithm returns the Pascal's Triangle structure containing numRows.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " numRows = 5",
                    "output": " [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
                    "explanation": null
                },
                {
                    "input": " numRows = 1",
                    "output": " [[1]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
                },
                {
                    "input": "1",
                    "output": "[[1]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-18",
        "prompt": "Given an integer `numRows`, return the first numRows of **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:"
    },
    "leetcode-benchmark-19": {
        "id": "leetcode-benchmark-19",
        "title": "Pascal's Triangle II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:",
            "examples": [
                "**Example 1:**\n\n**Input:** rowIndex = 3\n**Output:** \\[1,3,3,1\\]\n\n",
                "**Example 2:**\n\n**Input:** rowIndex = 0\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** rowIndex = 1\n**Output:** \\[1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= rowIndex <= 33`\n\n**",
            "follow_up": "Follow up:** Could you optimize your algorithm to use only `O(rowIndex)` extra space?"
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> getRow(int rowIndex) {\n    List<Integer> row = new ArrayList<>();\n    for (int i = 0; i <= rowIndex; i++) {\n        row.add(1);\n        for (int j = i - 1; j > 0; j--) {\n            row.set(j, row.get(j) + row.get(j - 1));\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getRow(int rowIndex) {\n    vector<int> row(rowIndex + 1, 1);\n    for (int i = 1; i <= rowIndex; i++) {\n        for (int j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "python": "\n    ```python\ndef get_row(rowIndex):\n    row = [1] * (rowIndex + 1)\n    for i in range(1, rowIndex + 1):\n        for j in range(i - 1, 0, -1):\n            row[j] += row[j - 1]\n    return row\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "javascript": "\n    ```javascript\nfunction getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(1);\n    for (let i = 1; i <= rowIndex; i++) {\n        for (let j = i - 1; j > 0; j--) {\n            row[j] += row[j - 1];\n        }\n    }\n    return row;\n}\n```\n    \n    The algorithm initializes the row with the given rowIndex size and fills it with 1s. Then, we iterate through the rowIndex and update each entry of the row using the sum of the two numbers directly above it (based on Pascal's triangle property), i.e., row[j] = row[j] + row[j-1]. We get the rowIndexth row of Pascal's triangle once the iterations are completed.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " rowIndex = 3",
                    "output": " [1,3,3,1]",
                    "explanation": null
                },
                {
                    "input": " rowIndex = 0",
                    "output": " [1]",
                    "explanation": null
                },
                {
                    "input": " rowIndex = 1",
                    "output": " [1,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "[1,3,3,1]"
                },
                {
                    "input": "0",
                    "output": "[1]"
                },
                {
                    "input": "1",
                    "output": "[1,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-19",
        "prompt": "Given an integer `rowIndex`, return the `rowIndexth` (**0-indexed**) row of the **Pascal's triangle**.\n\nIn **Pascal's triangle**, each number is the sum of the two numbers directly above it as shown:"
    },
    "leetcode-benchmark-20": {
        "id": "leetcode-benchmark-20",
        "title": "Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 5\n**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transactions are done and the max profit = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int minPrice = Integer.MAX_VALUE;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int minPrice = INT_MAX;\n    int maxProfit = 0;\n    for (int price : prices) {\n        minPrice = min(minPrice, price);\n        maxProfit = max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    minPrice = float('inf')\n    maxProfit = 0\n    for price in prices:\n        minPrice = min(minPrice, price)\n        maxProfit = max(maxProfit, price - minPrice)\n    return maxProfit\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let minPrice = Number.MAX_VALUE;\n    let maxProfit = 0;\n    for (const price of prices) {\n        minPrice = Math.min(minPrice, price);\n        maxProfit = Math.max(maxProfit, price - minPrice);\n    }\n    return maxProfit;\n}\n```\n    \n    The algorithm iterates through the input array of prices. We maintain two variables: `minPrice` to track the minimum price encountered up to the current day, and `maxProfit` to track maximum achievable profit. \n\nFor each day, we update:\n1. `minPrice` by comparing its value with the current day's stock price.\n2. `maxProfit` by comparing its value with the difference between the current day's stock price and the minimum stock price encountered so far.\n\nAt the end of the iteration, the algorithm returns the value stored in `maxProfit`, which is the maximum possible profit that can be achieved.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " prices = [7,1,5,3,6,4]",
                    "output": " 5",
                    "explanation": " Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell."
                },
                {
                    "input": " prices = [7,6,4,3,1]",
                    "output": " 0",
                    "explanation": " In this case, no transactions are done and the max profit = 0."
                }
            ],
            "function_input": [
                {
                    "input": "[7,1,5,3,6,4]",
                    "output": "5"
                },
                {
                    "input": "[7,6,4,3,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-20",
        "prompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nYou want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.\n\nReturn _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`."
    },
    "leetcode-benchmark-21": {
        "id": "leetcode-benchmark-21",
        "title": "Valid Palindrome",
        "difficulty": "Easy",
        "content": {
            "problem": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"A man, a plan, a canal: Panama \"\n**Output:** true\n**Explanation:**  \"amanaplanacanalpanama \" is a palindrome.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"race a car \"\n**Output:** false\n**Explanation:**  \"raceacar \" is not a palindrome.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"  \"\n**Output:** true\n**Explanation:** s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2 * 105`\n*   `s` consists only of printable ASCII characters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isPalindrome(String s) {\n    StringBuilder cleaned = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (Character.isLetterOrDigit(c)) {\n            cleaned.append(Character.toLowerCase(c));\n        }\n    }\n    int left = 0, right = cleaned.length() - 1;\n    while (left < right) {\n        if (cleaned.charAt(left++) != cleaned.charAt(right--)) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\n\nbool isPalindrome(std::string s) {\n    s.erase(std::remove_if(s.begin(), s.end(), [](char c) { return !std::isalnum(c); }), s.end());\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left++] != s[right--]) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "python": "\n    ```python\ndef isPalindrome(s: str) -> bool:\n    cleaned = \"\".join(c.lower() for c in s if c.isalnum())\n    left, right = 0, len(cleaned) - 1\n    while left < right:\n        if cleaned[left] != cleaned[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "javascript": "\n    ```javascript\nfunction isPalindrome(s) {\n    const cleaned = s.toLowerCase().replace(/[^a-z0-9]/g, '');\n    let left = 0, right = cleaned.length - 1;\n    while (left < right) {\n        if (cleaned[left++] !== cleaned[right--]) return false;\n    }\n    return true;\n}\n```\n    \n    1. Clean the given string by removing non-alphanumeric characters and converting uppercase letters to lowercase.\n2. Initialize two pointers: `left` pointing to the beginning of the cleaned string and `right` pointing to the end.\n3. Iterate through the cleaning string, comparing the characters at the `left` and `right` pointers. If they are not equal, return `false` as it's not a palindrome.\n4. If the loop completes, it means the input string is a palindrome, so return `true`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"A man, a plan, a canal: Panama \"",
                    "output": " True",
                    "explanation": "  \"amanaplanacanalpanama \" is a palindrome."
                },
                {
                    "input": " s =  \"race a car \"",
                    "output": " False",
                    "explanation": "  \"raceacar \" is not a palindrome."
                },
                {
                    "input": " s =  \"  \"",
                    "output": " True",
                    "explanation": " s is an empty string  \" \" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome."
                }
            ],
            "function_input": [
                {
                    "input": "\"Aman,",
                    "output": "True"
                },
                {
                    "input": "\"raceacar\"",
                    "output": "False"
                },
                {
                    "input": "\"\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-21",
        "prompt": "A phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` _if it is a **palindrome**, or_ `false` _otherwise_."
    },
    "leetcode-benchmark-22": {
        "id": "leetcode-benchmark-22",
        "title": "Single Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,2,1\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,1,2,1,2\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-3 * 104 <= nums[i] <= 3 * 104`\n*   Each element in the array appears twice except for one element which appears only once.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int singleNumber(int[] nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "c++": "\n    ```cpp\nint singleNumber(vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "python": "\n    ```python\ndef singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "javascript": "\n    ```javascript\nfunction singleNumber(nums) {\n    let result = 0;\n    for (let num of nums) {\n        result ^= num;\n    }\n    return result;\n}\n```\n    \n    The algorithm utilizes the XOR bitwise operation. XOR is a binary operation that outputs 1 when the inputs differ and 0 when the inputs are the same. \n\nTo find the single element that appears once in the array, we XOR all elements in the array. Since every pair of identical numbers will cancel each other out as `a ^ a = 0`, the remaining XOR result would be the single unique number, as `0 ^ a = a`.\n\nThe algorithm processes the array once, giving it a linear time complexity of O(n), and only requires a constant amount of extra space to store the `result` variable, satisfying the requirements.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,2,1]",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " nums = [4,1,2,1,2]",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " nums = [1]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,2,1]",
                    "output": "1"
                },
                {
                    "input": "[4,1,2,1,2]",
                    "output": "4"
                },
                {
                    "input": "[1]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-22",
        "prompt": "Given a **non-empty** array of integers `nums`, every element appears _twice_ except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space."
    },
    "leetcode-benchmark-23": {
        "id": "leetcode-benchmark-23",
        "title": "Linked List Cycle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[3,2,0,-4\\], pos = 1\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n",
                "**Example 2:**\n\n**Input:** head = \\[1,2\\], pos = 0\n**Output:** true\n**Explanation:** There is a cycle in the linked list, where the tail connects to the 0th node.\n\n",
                "**Example 3:**\n\n**Input:** head = \\[1\\], pos = -1\n**Output:** false\n**Explanation:** There is no cycle in the linked list."
            ],
            "constraints": "**Constraints:**\n\n*   The number of the nodes in the list is in the range `[0, 104]`.\n*   `-105 <= Node.val <= 105`\n*   `pos` is `-1` or a **valid index** in the linked-list.\n\n**",
            "follow_up": "Follow up:** Can you solve it using `O(1)` (i.e. constant) memory?"
        },
        "java": "\n    ```java\npublic boolean hasCycle(ListNode head) {\n    ListNode slow = head, fast = head;\n    while (fast != null && fast.next != null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool hasCycle(ListNode *head) {\n    ListNode *slow = head, *fast = head;\n    while (fast != nullptr && fast->next != nullptr) {\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "python": "\n    ```python\ndef hasCycle(head):\n    slow = fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "javascript": "\n    ```javascript\nfunction hasCycle(head) {\n    let slow = head, fast = head;\n    while (fast !== null && fast.next !== null) {\n        slow = slow.next;\n        fast = fast.next.next;\n        if (slow === fast) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm used is Floyd's cycle-finding algorithm, also known as the \"tortoise and the hare\" algorithm. There are two pointers, one slow (tortoise) and another fast (hare). The slow pointer moves one step at a time, and the fast pointer moves two steps. \n\nInitially, both pointers are set to the head of the linked list. The pointers are moved forward with their respective speeds until either the fast pointer reaches the end of the linked list or both pointers meet at the same node. \n\nIf the fast pointer reaches the end, it means that there is no cycle and the function returns false. If the pointers meet at some point in the linked list, there is a cycle and the function returns true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " head = [3,2,0,-4], pos = 1",
                    "output": " True",
                    "explanation": " There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed)."
                },
                {
                    "input": " head = [1,2], pos = 0",
                    "output": " True",
                    "explanation": " There is a cycle in the linked list, where the tail connects to the 0th node."
                },
                {
                    "input": " head = [1], pos = -1",
                    "output": " False",
                    "explanation": " There is no cycle in the linked list."
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,0,-4],1",
                    "output": "True"
                },
                {
                    "input": "[1,2],0",
                    "output": "True"
                },
                {
                    "input": "[1],-1",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-23",
        "prompt": "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.\n\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. **Note that `pos` is not passed as a parameter**.\n\nReturn `true` _if there is a cycle in the linked list_. Otherwise, return `false`."
    },
    "leetcode-benchmark-24": {
        "id": "leetcode-benchmark-24",
        "title": "Read N Characters Given Read4",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method to read `n` characters.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The `read` function will only be called once for each test case.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** file =  \"abc \", n = 4\n**Output:** 3\n**Explanation:** After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nNote that  \"abc \" is the file's content, not buf. buf is the destination buffer that you will have to write the results to.\n\n",
                "**Example 2:**\n\n**Input:** file =  \"abcde \", n = 5\n**Output:** 5\n**Explanation:** After calling your read method, buf should contain  \"abcde \". We read a total of 5 characters from the file, so return 5.\n\n",
                "**Example 3:**\n\n**Input:** file =  \"abcdABCD1234 \", n = 12\n**Output:** 12\n**Explanation:** After calling your read method, buf should contain  \"abcdABCD1234 \". We read a total of 12 characters from the file, so return 12."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= file.length <= 500`\n*   `file` consist of English letters and digits.\n*   `1 <= n <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int read4(char[] buf4);\n\npublic int read(char[] buf, int n) {\n    int totalRead = 0;\n    char[] buf4 = new char[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; i++) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "c++": "\n    ```cpp\nint read4(char *buf4);\n\nint read(char *buf, int n) {\n    int totalRead = 0;\n    char buf4[4];\n\n    while (totalRead < n) {\n        int read4Count = read4(buf4);\n        for (int i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "python": "\n    ```python\ndef read4(buf4: List[str]) -> int:\n    pass\n\ndef read(buf: List[str], n: int) -> int:\n    total_read = 0\n    buf4 = [''] * 4\n\n    while total_read < n:\n        read4_count = read4(buf4)\n        for i in range(read4_count):\n            if total_read < n:\n                buf[total_read] = buf4[i]\n                total_read += 1\n            else:\n                break\n        if read4_count < 4:\n            break\n\n    return total_read\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "javascript": "\n    ```javascript\nfunction read4(buf4) {\n    // Implemented elsewhere\n}\n\nfunction read(buf, n) {\n    let totalRead = 0;\n    const buf4 = new Array(4);\n\n    while (totalRead < n) {\n        const read4Count = read4(buf4);\n        for(let i = 0; i < read4Count && totalRead < n; ++i) {\n            buf[totalRead++] = buf4[i];\n        }\n        if (read4Count < 4) break;\n    }\n\n    return totalRead;\n}\n```\n    \n    The algorithm relies on the read4 function provided, which reads 4 characters at a time. We read and store these characters in a buffer (`buf4`) and then transfer them one by one into the destination buffer (`buf`) until we reach the desired number of characters (`n`). We repeat this process until we have read `n` characters or reached the end of the `file`. If we reach the end of the file, the read4 function will return less than 4 characters, which is detected and used to break the loop.\n\nIn each language, we declare a buffer `buf4` of length 4 to store the characters read using the read4 function. We keep track of the total characters read (`totalRead`) and iterate through the characters in `buf4`, transferring them one by one to the destination buffer `buf`. We make sure not to exceed the requested number of characters `n`.\n\nOnce we reach the end of the file, the read4 function will return less than 4 characters. If this happens, we break the loop and return the total number of characters read, which is stored in `totalRead`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " file =  \"abc \", n = 4",
                    "output": " 3",
                    "explanation": " After calling your read method, buf should contain  \"abc \". We read a total of 3 characters from the file, so return 3.\nNote that  \"abc \" is the file's content, not buf. buf is the destination buffer that you will have to write the results to."
                },
                {
                    "input": " file =  \"abcde \", n = 5",
                    "output": " 5",
                    "explanation": " After calling your read method, buf should contain  \"abcde \". We read a total of 5 characters from the file, so return 5."
                },
                {
                    "input": " file =  \"abcdABCD1234 \", n = 12",
                    "output": " 12",
                    "explanation": " After calling your read method, buf should contain  \"abcdABCD1234 \". We read a total of 12 characters from the file, so return 12."
                }
            ],
            "function_input": [
                {
                    "input": "\"abc\",4",
                    "output": "3"
                },
                {
                    "input": "\"abcde\",5",
                    "output": "5"
                },
                {
                    "input": "\"abcdABCD1234\",12",
                    "output": "12"
                }
            ]
        },
        "task_id": "leetcode-benchmark-24",
        "prompt": "Given a `file` and assume that you can only read the file using a given method `read4`, implement a method to read `n` characters.\n\n**Method read4:**\n\nThe API `read4` reads **four consecutive characters** from `file`, then writes those characters into the buffer array `buf4`.\n\nThe return value is the number of actual characters read.\n\nNote that `read4()` has its own file pointer, much like `FILE *fp` in C.\n\n**Definition of read4:**\n\n    Parameter:  char\\[\\] buf4\n    Returns:    int\n\nbuf4\\[\\] is a destination, not a source. The results from read4 will be copied to buf4\\[\\].\n\nBelow is a high-level example of how `read4` works:\n\nFile file( \"abcde `\"); // File is  \"`abcde `\", initially file pointer (fp) points to 'a' char[] buf4 = new char[4]; // Create buffer with enough space to store characters read4(buf4); // read4 returns 4. Now buf4 =  \"abcd \", fp points to 'e' read4(buf4); // read4 returns 1. Now buf4 =  \"e \", fp points to end of file read4(buf4); // read4 returns 0. Now buf4 =  \" \", fp points to end of file`\n\n**Method read:**\n\nBy using the `read4` method, implement the method read that reads `n` characters from `file` and store it in the buffer array `buf`. Consider that you cannot manipulate `file` directly.\n\nThe return value is the number of actual characters read.\n\n**Definition of read:**\n\n    Parameters:\tchar\\[\\] buf, int n\n    Returns:\tint\n\nbuf\\[\\] is a destination, not a source. You will need to write the results to buf\\[\\].\n\n**Note:**\n\n*   Consider that you cannot manipulate the file directly. The file is only accessible for `read4` but not for `read`.\n*   The `read` function will only be called once for each test case.\n*   You may assume the destination buffer array, `buf`, is guaranteed to have enough space for storing `n` characters."
    },
    "leetcode-benchmark-25": {
        "id": "leetcode-benchmark-25",
        "title": "Excel Sheet Column Title",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `columnNumber`, return _its corresponding column title as it appears in an Excel sheet_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
            "examples": [
                "**Example 1:**\n\n**Input:** columnNumber = 1\n**Output:**  \"A \"\n\n",
                "**Example 2:**\n\n**Input:** columnNumber = 28\n**Output:**  \"AB \"\n\n",
                "**Example 3:**\n\n**Input:** columnNumber = 701\n**Output:**  \"ZY \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= columnNumber <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String convertToTitle(int columnNumber) {\n    StringBuilder result = new StringBuilder();\n    while (columnNumber > 0) {\n        columnNumber--;\n        result.insert(0, (char) ('A' + columnNumber % 26));\n        columnNumber /= 26;\n    }\n    return result.toString();\n}\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string convertToTitle(int columnNumber) {\n    std::string result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = (char)(columnNumber % 26 + 'A') + result;\n        columnNumber /= 26;\n    }\n    return result;\n}\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "python": "\n    ```python\ndef convert_to_title(columnNumber: int) -> str:\n    result = \"\"\n    while columnNumber:\n        columnNumber -= 1\n        result = chr(columnNumber % 26 + ord('A')) + result\n        columnNumber //= 26\n    return result\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "javascript": "\n    ```javascript\nfunction convertToTitle(columnNumber) {\n    let result = \"\";\n    while (columnNumber) {\n        columnNumber--;\n        result = String.fromCharCode(columnNumber % 26 + 'A'.charCodeAt(0)) + result;\n        columnNumber = Math.floor(columnNumber / 26);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm converts an integer `columnNumber` to its corresponding column title as it appears in an Excel sheet. It does so by treating the Excel sheet column headers as a Base-26 number system where the numbers are represented by the characters from A-Z.\n\n1. We start by initializing an empty string called `result` that will store the final column title.\n2. In a while loop, we continue until the `columnNumber` is greater than 0.\n3. We subtract 1 from `columnNumber`, as the base representation starts from A (1).\n4. The remainder of `columnNumber` divided by 26 is the index of the character in the A-Z range, which is added to the `result` string.\n5. `columnNumber` is then divided by 26 and the loop continues until `columnNumber` is 0.\n6. Once the loop is finished, the `result` string is returned as the corresponding column title.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " columnNumber = 1",
                    "output": "  \"A \"",
                    "explanation": null
                },
                {
                    "input": " columnNumber = 28",
                    "output": "  \"AB \"",
                    "explanation": null
                },
                {
                    "input": " columnNumber = 701",
                    "output": "  \"ZY \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1",
                    "output": "\"A\""
                },
                {
                    "input": "28",
                    "output": "\"AB\""
                },
                {
                    "input": "701",
                    "output": "\"ZY\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-25",
        "prompt": "Given an integer `columnNumber`, return _its corresponding column title as it appears in an Excel sheet_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n..."
    },
    "leetcode-benchmark-26": {
        "id": "leetcode-benchmark-26",
        "title": "Majority Element",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `n / 2` times. You may assume that the majority element always exists in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,1,1,1,2,2\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**",
            "follow_up": "Follow-up:** Could you solve the problem in linear time and in `O(1)` space?"
        },
        "java": "\n    ```java\npublic int majorityElement(int[] nums) {\n    int count = 0;\n    Integer candidate = null;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "c++": "\n    ```cpp\nint majorityElement(vector<int>& nums) {\n    int count = 0;\n    int candidate;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "python": "\n    ```python\ndef majority_element(nums):\n    count = 0\n    candidate = None\n\n    for num in nums:\n        if count == 0:\n            candidate = num\n        count += (num == candidate) - (num != candidate)\n\n    return candidate\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "javascript": "\n    ```javascript\nfunction majorityElement(nums) {\n    let count = 0;\n    let candidate = null;\n\n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        count += (num === candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n```\n    \n    The algorithm used here is called the Boyer-Moore Majority Vote algorithm. It works by initializing a candidate element and a count. Then, we iterate through the given array. If the count is 0, we set the candidate to the current element in the array. Then we update the count by adding 1 if the current element is equal to the candidate, or subtracting 1 otherwise. At the end of the iteration, the candidate will have the majority element.\n\nThe algorithm works because if there is a majority element, it will always appear more than the sum of all other elements, so the count will not be 0 at the end.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,2,3]",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " nums = [2,2,1,1,1,2,2]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,3]",
                    "output": "3"
                },
                {
                    "input": "[2,2,1,1,1,2,2]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-26",
        "prompt": "Given an array `nums` of size `n`, return _the majority element_.\n\nThe majority element is the element that appears more than `n / 2` times. You may assume that the majority element always exists in the array."
    },
    "leetcode-benchmark-27": {
        "id": "leetcode-benchmark-27",
        "title": "Excel Sheet Column Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return _its corresponding column number_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
            "examples": [
                "**Example 1:**\n\n**Input:** columnTitle =  \"A \"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** columnTitle =  \"AB \"\n**Output:** 28\n\n",
                "**Example 3:**\n\n**Input:** columnTitle =  \"ZY \"\n**Output:** 701"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= columnTitle.length <= 7`\n*   `columnTitle` consists only of uppercase English letters.\n*   `columnTitle` is in the range `[ \"A \", \"FXSHRXW \"]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int titleToNumber(String columnTitle) {\n    int result = 0;\n    for (char c : columnTitle.toCharArray()) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "c++": "\n    ```cpp\nint titleToNumber(string columnTitle) {\n    int result = 0;\n    for (char c : columnTitle) {\n        result = result * 26 + (c - 'A' + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "python": "\n    ```python\ndef title_to_number(column_title: str) -> int:\n    result = 0\n    for c in column_title:\n        result = result * 26 + (ord(c) - ord('A') + 1)\n    return result\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "javascript": "\n    ```javascript\nfunction titleToNumber(columnTitle) {\n    let result = 0;\n    for (let c of columnTitle) {\n        result = result * 26 + (c.charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the given `columnTitle` string and computes the corresponding column number by treating the string like a base-26 number representation, where 'A' represents the digit 1 and 'Z' represents the digit 26. To convert each character to its corresponding numeric value, we subtract the ASCII value of 'A' and add 1. In each iteration, the current result is multiplied by 26 and the numeric value of the current character is added to the result. Finally, the accumulated result is returned as the column number.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " columnTitle =  \"A \"",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " columnTitle =  \"AB \"",
                    "output": " 28",
                    "explanation": null
                },
                {
                    "input": " columnTitle =  \"ZY \"",
                    "output": " 701",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"A\"",
                    "output": "1"
                },
                {
                    "input": "\"AB\"",
                    "output": "28"
                },
                {
                    "input": "\"ZY\"",
                    "output": "701"
                }
            ]
        },
        "task_id": "leetcode-benchmark-27",
        "prompt": "Given a string `columnTitle` that represents the column title as appears in an Excel sheet, return _its corresponding column number_.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n..."
    },
    "leetcode-benchmark-28": {
        "id": "leetcode-benchmark-28",
        "title": "Reverse Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Reverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 00000010100101000001111010011100\n**Output:**    964176192 (00111001011110000010100101000000)\n**Explanation:** The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**.\n\n",
                "**Example 2:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:**   3221225471 (10111111111111111111111111111111)\n**Explanation:** The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**."
            ],
            "constraints": "**Constraints:**\n\n*   The input must be a **binary string** of length `32`\n\n**",
            "follow_up": "Follow up:** If this function is called many times, how would you optimize it?"
        },
        "java": "\n    ```java\npublic int reverseBits(int n) {\n    int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "c++": "\n    ```cpp\nunsigned int reverseBits(unsigned int n) {\n    unsigned int res = 0;\n    for (int i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "python": "\n    ```python\ndef reverse_bits(n: int) -> int:\n    res = 0\n    for _ in range(32):\n        res <<= 1\n        res |= n & 1\n        n >>= 1\n    return res\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseBits(n) {\n    let res = 0;\n    for (let i = 0; i < 32; ++i) {\n        res <<= 1;\n        res |= n & 1;\n        n >>= 1;\n    }\n    return res >>> 0;\n}\n```\n    \n    The algorithm iterates through all 32 bits of the given unsigned 32-bit integer, and for each bit, it shifts the result variable `res` one position to the left, and then performs a bitwise OR with the given number `n` ANDed with 1. This operation adds the least significant bit of `n` to the most significant bit of `res`. Then, the given number `n` is shifted one position to the right. The process is repeated for all 32 bits, and in each step, the result variable `res` accumulates the reversed bits of the input number.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 00000010100101000001111010011100",
                    "output": "    964176192 (00111001011110000010100101000000)",
                    "explanation": " The input binary string **00000010100101000001111010011100** represents the unsigned integer 43261596, so return 964176192 which its binary representation is **00111001011110000010100101000000**."
                },
                {
                    "input": " n = 11111111111111111111111111111101",
                    "output": "   3221225471 (10111111111111111111111111111111)",
                    "explanation": " The input binary string **11111111111111111111111111111101** represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is **10111111111111111111111111111111**."
                }
            ],
            "function_input": [
                {
                    "input": "00000010100101000001111010011100",
                    "output": "964176192"
                },
                {
                    "input": "11111111111111111111111111111101",
                    "output": "3221225471"
                }
            ]
        },
        "task_id": "leetcode-benchmark-28",
        "prompt": "Reverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above, the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`."
    },
    "leetcode-benchmark-29": {
        "id": "leetcode-benchmark-29",
        "title": "Number of 1 Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 00000000000000000000000000001011\n**Output:** 3\n**Explanation:** The input binary string **00000000000000000000000000001011** has a total of three '1' bits.\n\n",
                "**Example 2:**\n\n**Input:** n = 00000000000000000000000010000000\n**Output:** 1\n**Explanation:** The input binary string **00000000000000000000000010000000** has a total of one '1' bit.\n\n",
                "**Example 3:**\n\n**Input:** n = 11111111111111111111111111111101\n**Output:** 31\n**Explanation:** The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits."
            ],
            "constraints": "**Constraints:**\n\n*   The input must be a **binary string** of length `32`.\n\n**",
            "follow_up": "Follow up:** If this function is called many times, how would you optimize it?"
        },
        "java": "\n    ```java\npublic int hammingWeight(int n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "c++": "\n    ```cpp\nint hammingWeight(uint32_t n) {\n    int count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "python": "\n    ```python\ndef hamming_weight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "javascript": "\n    ```javascript\nfunction hammingWeight(n) {\n    let count = 0;\n    while (n != 0) {\n        count += n & 1;\n        n >>>= 1;\n    }\n    return count;\n}\n```\n    \n    The algorithm for this problem is straightforward. We use a bitwise AND operation with 1 to check the rightmost bit of the input integer `n`. If the result is 1, then the rightmost bit is a '1', and we increment the `count`. We continue to check the rest of the bits by shifting `n` to the right (`>>` in C++/Python or `>>>` in Java/JavaScript, since Java/JavaScript use signed right shift) to remove the rightmost bit. The loop continues until `n` becomes 0, which means there are no more '1' bits. Finally, we return the `count` of 1 bits.\n\nNote that the '>>>=' unary operator in Java and JavaScript is used to avoid sign extension when shifting right. This ensures that the shift is done in an unsigned manner.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 00000000000000000000000000001011",
                    "output": " 3",
                    "explanation": " The input binary string **00000000000000000000000000001011** has a total of three '1' bits."
                },
                {
                    "input": " n = 00000000000000000000000010000000",
                    "output": " 1",
                    "explanation": " The input binary string **00000000000000000000000010000000** has a total of one '1' bit."
                },
                {
                    "input": " n = 11111111111111111111111111111101",
                    "output": " 31",
                    "explanation": " The input binary string **11111111111111111111111111111101** has a total of thirty one '1' bits."
                }
            ],
            "function_input": [
                {
                    "input": "00000000000000000000000000001011",
                    "output": "3"
                },
                {
                    "input": "00000000000000000000000010000000",
                    "output": "1"
                },
                {
                    "input": "11111111111111111111111111111101",
                    "output": "31"
                }
            ]
        },
        "task_id": "leetcode-benchmark-29",
        "prompt": "Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the [Hamming weight](http://en.wikipedia.org/wiki/Hamming_weight)).\n\n**Note:**\n\n*   Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n*   In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3**, the input represents the signed integer. `-3`."
    },
    "leetcode-benchmark-30": {
        "id": "leetcode-benchmark-30",
        "title": "Happy Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Write an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 19\n**Output:** true\n**Explanation:**\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\npublic boolean isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "c++": "\n    ```cpp\nint getNext(int n) {\n    int sum = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        sum += digit * digit;\n        n /= 10;\n    }\n    return sum;\n}\n\nbool isHappy(int n) {\n    int slow = n, fast = getNext(n);\n    while (fast != 1 && slow != fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast == 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "python": "\n    ```python\ndef get_next(n):\n    sum = 0\n    while n > 0:\n        digit = n % 10\n        sum += digit * digit\n        n //= 10\n    return sum\n\ndef is_happy(n):\n    slow, fast = n, get_next(n)\n    while fast != 1 and slow != fast:\n        slow = get_next(slow)\n        fast = get_next(get_next(fast))\n    return fast == 1\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "javascript": "\n    ```javascript\nfunction getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        let digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n, fast = getNext(n);\n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    return fast === 1;\n}\n```\n    \n    The algorithm to determine if a number is happy repeatedly performs the sum of the squares of its digits. We can use the slow and fast pointer method (also called the Floyd's cycle-finding algorithm). In this method, we have two pointers (`slow` and `fast`), both initially pointing to the input number `n`. In each iteration, the `slow` pointer moves to the next number in the sequence (by calling `getNext()`) while the `fast` pointer moves to the next of next number in the sequence. If at any point, we find that the `fast` pointer becomes 1, it implies that the number is a happy number. If the `slow` and `fast` pointers become equal and it is not 1, it implies that there is a cycle and the number is not a happy number.\n\n`getNext(n)` function calculates the next number in the sequence by summing the squares of the digits of the current number `n`. This function is called in the main `isHappy(n)` function for updating `slow` and `fast` pointers.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 19",
                    "output": " True",
                    "explanation": "\n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1"
                },
                {
                    "input": " n = 2",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "19",
                    "output": "True"
                },
                {
                    "input": "2",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-30",
        "prompt": "Write an algorithm to determine if a number `n` is happy.\n\nA **happy number** is a number defined by the following process:\n\n*   Starting with any positive integer, replace the number by the sum of the squares of its digits.\n*   Repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1.\n*   Those numbers for which this process **ends in 1** are happy.\n\nReturn `true` _if_ `n` _is a happy number, and_ `false` _if not_."
    },
    "leetcode-benchmark-31": {
        "id": "leetcode-benchmark-31",
        "title": "Isomorphic Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"egg\", t = \"add\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"foo\", t = \"bar\"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s = \"paper\", t = \"title\"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `t.length == s.length`\n*   `s` and `t` consist of any valid ascii character.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean isIsomorphic(String s, String t) {\n    HashMap<Character, Character> map1 = new HashMap<>();\n    HashMap<Character, Character> map2 = new HashMap<>();\n    \n    for (int i = 0; i < s.length(); i++) {\n        char sChar = s.charAt(i);\n        char tChar = t.charAt(i);\n        \n        if (!map1.containsKey(sChar)) {\n            map1.put(sChar, tChar);\n        }\n        if (!map2.containsKey(tChar)) {\n            map2.put(tChar, sChar);\n        }\n        \n        if (map1.get(sChar) != tChar || map2.get(tChar) != sChar) {\n           return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    std::unordered_map<char, char> map1, map2;\n    for (size_t i = 0; i < s.size(); ++i) {\n        if (map1.find(s[i]) == map1.end()) {\n            map1[s[i]] = t[i];\n        }\n        if (map2.find(t[i]) == map2.end()) {\n            map2[t[i]] = s[i];\n        }\n        if (map1[s[i]] != t[i] || map2[t[i]] != s[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "python": "\n    ```python\ndef is_isomorphic(s: str, t: str) -> bool:\n    map1, map2 = {}, {}\n    for char_s, char_t in zip(s, t):\n        if char_s not in map1:\n            map1[char_s] = char_t\n        if char_t not in map2:\n            map2[char_t] = char_s\n        if map1[char_s] != char_t or map2[char_t] != char_s:\n            return False\n    return True\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "javascript": "\n    ```javascript\nfunction isIsomorphic(s, t) {\n    let map1 = new Map();\n    let map2 = new Map();\n    for (let i = 0; i < s.length; i++) {\n        let sChar = s[i];\n        let tChar = t[i];\n\n        if (!map1.has(sChar)) {\n            map1.set(sChar, tChar);\n        }\n        if (!map2.has(tChar)) {\n            map2.set(tChar, sChar);\n        }\n\n        if (map1.get(sChar) !== tChar || map2.get(tChar) !== sChar) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    - Create two maps (or hash_maps) to store the mappings for characters in `s` to `t` and characters in `t` to `s`.\n- Iterate through the characters of `s` and `t`.\n- If the current character of `s` is not a key in the first map, add it with the corresponding character of `t` as the value.\n- If the current character of `t` is not a key in the second map, add it with the corresponding character of `s` as the value.\n- If the maps have inconsistent mappings, return false (they are not isomorphic).\n- If the loop is over without finding inconsistent mappings, return true (the strings are isomorphic).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"egg\", t = \"add\"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s = \"foo\", t = \"bar\"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " s = \"paper\", t = \"title\"",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"egg\",\"add\"",
                    "output": "True"
                },
                {
                    "input": "\"foo\",\"bar\"",
                    "output": "False"
                },
                {
                    "input": "\"paper\",\"title\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-31",
        "prompt": "Given two strings `s` and `t`, _determine if they are isomorphic_.\n\nTwo strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself."
    },
    "leetcode-benchmark-32": {
        "id": "leetcode-benchmark-32",
        "title": "Contains Duplicate",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,3,3,4,3,2,4,2\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean containsDuplicate(int[] nums) {\n    Set<Integer> set = new HashSet<Integer>();\n    for (int num : nums) {\n        if (!set.add(num)) {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool containsDuplicate(vector<int>& nums) {\n    unordered_set<int> s;\n    for (int num : nums) {\n        if (s.find(num) != s.end()) {\n            return true;\n        }\n        s.insert(num);\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef containsDuplicate(nums):\n    return len(nums) != len(set(nums))\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "javascript": "\n    ```javascript\nfunction containsDuplicate(nums) {\n    const set = new Set();\n    for (const num of nums) {\n        if (set.has(num)) {\n            return true;\n        }\n        set.add(num);\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts by creating an empty set. Then it iterates through the input array. For each number in the array, it checks if the number is already in the set. If the number is in the set, it means there's a duplicate, so it returns true. If the number is not in the set, it adds the number to the set. If the function has not returned true after iterating through the entire array, it means that there are no duplicates, so it returns false.\n\nIn Python, we use the fact that sets don't allow duplicates, so we can directly compare the length of the original list with the length of the set created from the list. If they are not equal, it means there are duplicates in the list, and the function returns true. Otherwise, it returns false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,1]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2,3,4]",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " nums = [1,1,1,3,3,4,3,2,4,2]",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,1]",
                    "output": "True"
                },
                {
                    "input": "[1,2,3,4]",
                    "output": "False"
                },
                {
                    "input": "[1,1,1,3,3,4,3,2,4,2]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-32",
        "prompt": "Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct."
    },
    "leetcode-benchmark-33": {
        "id": "leetcode-benchmark-33",
        "title": "Contains Duplicate II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return `true` _if there are two **distinct indices**_ `i` _and_ `j` _in the array such that_ `nums[i] == nums[j]` _and_ `abs(i - j) <= k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\], k = 3\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1\\], k = 1\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,1,2,3\\], k = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `0 <= k <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean containsNearbyDuplicate(int[] nums, int k) {\n    HashMap<Integer, Integer> valueIndexMap = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        if (valueIndexMap.containsKey(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.put(nums[i], i);\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "c++": "\n    ```cpp\nbool containsNearbyDuplicate(vector<int>& nums, int k) {\n    unordered_map<int, int> valueIndexMap;\n    for (int i = 0; i < nums.size(); i++) {\n        if (valueIndexMap.find(nums[i]) != valueIndexMap.end() && i - valueIndexMap[nums[i]] <= k) {\n            return true;\n        }\n        valueIndexMap[nums[i]] = i;\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "python": "\n    ```python\ndef containsNearbyDuplicate(nums, k):\n    value_index_map = {}\n    for i, num in enumerate(nums):\n        if num in value_index_map and i - value_index_map[num] <= k:\n            return True\n        value_index_map[num] = i\n    return False\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "javascript": "\n    ```javascript\nfunction containsNearbyDuplicate(nums, k) {\n    const valueIndexMap = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        if (valueIndexMap.has(nums[i]) && i - valueIndexMap.get(nums[i]) <= k) {\n            return true;\n        }\n        valueIndexMap.set(nums[i], i);\n    }\n    return false;\n}\n```\n    \n    The algorithm utilizes a Hashtable, in which we store the integer value present in the array as the key and its latest index position as the value. For each element in the array, we first check if the current number is already in the Hashtable. If it is, we also check if the difference between the current index and the latest index stored in the Hashtable is less than or equal to k. If both conditions are met, we return `true` because there are two repeating integers having an index difference less than or equal to k. Otherwise, we add the number along with its latest index to the Hashtable and continue with the next element. If the loop finishes without finding such a pair, we return `false`.\n\nNote: The algorithm's time complexity is O(n), where n is the length of the input array, and the space complexity is O(min(n, k)).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,1], k = 3",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " nums = [1,0,1,1], k = 1",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2,3,1,2,3], k = 2",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,1],3",
                    "output": "True"
                },
                {
                    "input": "[1,0,1,1],1",
                    "output": "True"
                },
                {
                    "input": "[1,2,3,1,2,3],2",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-33",
        "prompt": "Given an integer array `nums` and an integer `k`, return `true` _if there are two **distinct indices**_ `i` _and_ `j` _in the array such that_ `nums[i] == nums[j]` _and_ `abs(i - j) <= k`."
    },
    "leetcode-benchmark-34": {
        "id": "leetcode-benchmark-34",
        "title": "Power of Two",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of two. Otherwise, return `false`_.\n\nAn integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 20 = 1\n\n",
                "**Example 2:**\n\n**Input:** n = 16\n**Output:** true\n**Explanation:** 24 = 16\n\n",
                "**Example 3:**\n\n**Input:** n = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "java": "\n    ```java\nboolean isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfTwo(int n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "python": "\n    ```python\ndef is_power_of_two(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "javascript": "\n    ```javascript\nfunction isPowerOfTwo(n) {\n    if (n <= 0) {\n        return false;\n    }\n    return (n & (n - 1)) == 0;\n}\n```\n    \n    The algorithm checks if the given integer n is a power of two. First, we check if n is a negative number or zero, in which case it cannot be a power of two, so we return false. \n\nIf n is positive, we can use bitwise manipulation to check if it's a power of two. A power of two in binary representation has only one bit set to 1 (e.g., 1: 001, 2: 010, 4: 100, 8: 1000). When we subtract 1 from a power of two, all the bits from the right of the set bit become 1 (e.g., 1-1: 000, 2-1: 001, 4-1: 011, 8-1: 0111). \n\nBy performing bitwise AND operation (n & (n-1)) between n and (n-1), we can check if there is only one bit set in n. If the result is 0, that means there is no overlapping bit between n and (n-1), indicating that n is a power of two; returning true. Otherwise, return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 1",
                    "output": " True",
                    "explanation": " 20 = 1"
                },
                {
                    "input": " n = 16",
                    "output": " True",
                    "explanation": " 24 = 16"
                },
                {
                    "input": " n = 3",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1",
                    "output": "True"
                },
                {
                    "input": "16",
                    "output": "True"
                },
                {
                    "input": "3",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-34",
        "prompt": "Given an integer `n`, return _`true` if it is a power of two. Otherwise, return `false`_.\n\nAn integer `n` is a power of two, if there exists an integer `x` such that `n == 2x`."
    },
    "leetcode-benchmark-35": {
        "id": "leetcode-benchmark-35",
        "title": "Valid Anagram",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"anagram\", t = \"nagaram\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"rat\", t = \"car\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 5 * 104`\n*   `s` and `t` consist of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?"
        },
        "java": "\n    ```java\npublic boolean isAnagram(String s, String t) {\n    if(s.length() != t.length())\n        return false;\n\n    int[] counts = new int[26];\n    for(char c : s.toCharArray())\n        counts[c - 'a']++;\n\n    for(char c : t.toCharArray()) {\n        if(counts[c - 'a'] == 0)\n            return false;\n        counts[c - 'a']--;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "c++": "\n    ```cpp\nbool isAnagram(std::string s, std::string t) {\n    if(s.size() != t.size())\n        return false;\n    \n    std::unordered_map<char, int> counts;\n    for(char c : s)\n        counts[c]++;\n        \n    for(char c : t) {\n        if(counts[c] == 0)\n            return false;\n        counts[c]--;\n    }\n    \n    return true;\n}\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "python": "\n    ```python\ndef is_anagram(s, t):\n    if len(s) != len(t):\n        return False\n\n    counts = {}\n    for c in s:\n        if c in counts:\n            counts[c] += 1\n        else:\n            counts[c] = 1\n\n    for c in t:\n        if c not in counts or counts[c] == 0:\n            return False\n        counts[c] -= 1\n\n    return True\n```\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "javascript": "\n    ```javascript\nfunction isAnagram(s, t) {\n    if (s.length !== t.length)\n        return false;\n\n    const counts = {};\n    for (let c of s)\n        counts[c] = (counts[c] || 0) + 1;\n\n    for (let c of t) {\n        if (counts[c] === 0 || !counts[c])\n            return false;\n        counts[c]--;\n    }\n\n    return true;\n}\n```\n\n    \n    The algorithm first checks if the two input strings have the same length. If they do not, it returns `false`, because an anagram of a string would have the same length as the original string.\n\nThen, the algorithm initializes a hash table to store the frequency of each character in the string `s`. It iterates through the string `s`, and for each character, it increments the corresponding frequency count in the hash table.\n\nIt then iterates through the string `t`. For each character in `t`, it checks if the frequency count of that character in the hash table is greater than 0. If it is not, that means the character either wasn't in the string `s`, or has been used up already, so the function returns `false`. Otherwise, it decrements the frequency count for the current character in the hash table.\n\nFinally, if the function has not yet returned `false`, that means that the two strings are anagrams and the function returns `true`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"anagram\", t = \"nagaram\"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s = \"rat\", t = \"car\"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"anagram\",\"nagaram\"",
                    "output": "True"
                },
                {
                    "input": "\"rat\",\"car\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-35",
        "prompt": "Given two strings `s` and `t`, return `true` _if_ `t` _is an anagram of_ `s`_, and_ `false` _otherwise_.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once."
    },
    "leetcode-benchmark-36": {
        "id": "leetcode-benchmark-36",
        "title": "Shortest Word Distance",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, return _the shortest distance between these two words in the list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** wordsDict = \\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\], word1 =  \"coding \", word2 =  \"practice \"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** wordsDict = \\[ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"\\], word1 =  \"makes \", word2 =  \"coding \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= wordsDict.length <= 3 * 104`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.\n*   `word1 != word2`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int idx1 = -1, idx2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; i++) {\n        if (word1.equals(wordsDict[i])) idx1 = i;\n        if (word2.equals(wordsDict[i])) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <climits>\n\nint shortestDistance(std::vector<std::string> wordsDict, std::string word1, std::string word2) {\n    int idx1 = -1, idx2 = -1, minDistance = INT_MAX;\n    for (int i = 0; i < wordsDict.size(); i++) {\n        if (wordsDict[i] == word1) idx1 = i;\n        if (wordsDict[i] == word2) idx2 = i;\n        if (idx1 != -1 && idx2 != -1)\n            minDistance = std::min(minDistance, std::abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "python": "\n    ```python\ndef shortestDistance(wordsDict, word1, word2):\n    idx1, idx2, minDistance = -1, -1, float('inf')\n    for i, word in enumerate(wordsDict):\n        if word == word1:\n            idx1 = i\n        if word == word2:\n            idx2 = i\n        if idx1 != -1 and idx2 != -1:\n            minDistance = min(minDistance, abs(idx1 - idx2))\n    return minDistance\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "javascript": "\n    ```javascript\nfunction shortestDistance(wordsDict, word1, word2) {\n    let idx1 = -1, idx2 = -1, minDistance = Number.MAX_VALUE;\n    for (let i = 0; i < wordsDict.length; i++) {\n        if (wordsDict[i] === word1) idx1 = i;\n        if (wordsDict[i] === word2) idx2 = i;\n        if (idx1 !== -1 && idx2 !== -1)\n            minDistance = Math.min(minDistance, Math.abs(idx1 - idx2));\n    }\n    return minDistance;\n}\n```\n    \n    The algorithm iterates through the `wordsDict` list and uses two variables `idx1` and `idx2` to store the indices of the occurrences of `word1` and `word2`. Initially, both indices are set to `-1`. In each iteration, if `word1` or `word2` is found, the corresponding index variable will be updated to store the current index.\n\nAfter each index update, we check if both indices are not `-1`. If both indices are valid, the difference between the indices is computed, and `minDistance` is updated with the minimum value between the previously-stored minimum distance and the new distance.\n\nFinally, the algorithm returns the value of `minDistance`, which represents the shortest distance between `word1` and `word2` in the `wordsDict` list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " wordsDict = [ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"], word1 =  \"coding \", word2 =  \"practice \"",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " wordsDict = [ \"practice \",  \"makes \",  \"perfect \",  \"coding \",  \"makes \"], word1 =  \"makes \", word2 =  \"coding \"",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"coding\",\"practice\"",
                    "output": "3"
                },
                {
                    "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"makes\",\"coding\"",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-36",
        "prompt": "Given an array of strings `wordsDict` and two different strings that already exist in the array `word1` and `word2`, return _the shortest distance between these two words in the list_."
    },
    "leetcode-benchmark-37": {
        "id": "leetcode-benchmark-37",
        "title": "Strobogrammatic Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `num` which represents an integer, return `true` _if_ `num` _is a **strobogrammatic number**_.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"69 \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** num =  \"88 \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** num =  \"962 \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 50`\n*   `num` consists of only digits.\n*   `num` does not contain any leading zeros except for zero itself.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isStrobogrammatic(String num) {\n    HashMap<Character, Character> lookup = new HashMap<Character, Character>() {{\n        put('0', '0');\n        put('1', '1');\n        put('6', '9');\n        put('8', '8');\n        put('9', '6');\n    }};\n    int left = 0, right = num.length() - 1;\n    while(left <= right) {\n        if(!lookup.containsKey(num.charAt(left)) || lookup.get(num.charAt(left)) != num.charAt(right)) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "c++": "\n    ```cpp\nbool isStrobogrammatic(string num) {\n    unordered_map<char, char> lookup {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n    int left = 0, right = num.size() - 1;\n    while(left <= right) {\n        if(lookup[num[left]] != num[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "python": "\n    ```python\ndef isStrobogrammatic(num: str) -> bool:\n    lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    left, right = 0, len(num) - 1\n    while left <= right:\n        if num[left] not in lookup or lookup[num[left]] != num[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "javascript": "\n    ```javascript\nfunction isStrobogrammatic(num) {\n    const lookup = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'};\n    let left = 0, right = num.length - 1;\n    while(left <= right) {\n        if(!(num[left] in lookup) || lookup[num[left]] !== num[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```\n    \n    The algorithm uses a while loop and a dictionary (lookup) to check if the given string is strobogrammatic. The main idea is to iterate through the string with two pointers, `left` and `right`. The `left` pointer starts at the beginning of the string and `right` starts at the end.\n\nFor each step of the while loop:\n1. Check if the character at the `left` pointer is in the `lookup` dictionary, if not, return false.\n2. Check if the mapped (rotated) character of the character at the `left` pointer matches the character at the `right` pointer, if not, return false.\n3. Increment `left` pointer and decrement `right` pointer.\n\nIf the loop finishes iterating through the string without returning false, then return true as the string is strobogrammatic.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num =  \"69 \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " num =  \"88 \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " num =  \"962 \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"69\"",
                    "output": "True"
                },
                {
                    "input": "\"88\"",
                    "output": "True"
                },
                {
                    "input": "\"962\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-37",
        "prompt": "Given a string `num` which represents an integer, return `true` _if_ `num` _is a **strobogrammatic number**_.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down)."
    },
    "leetcode-benchmark-38": {
        "id": "leetcode-benchmark-38",
        "title": "Meeting Rooms",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[0,30\\],\\[5,10\\],\\[15,20\\]\\]\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[7,10\\],\\[2,4\\]\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti < endi <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic boolean canAttendMeetings(int[][] intervals) {\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    \n    for (int i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::vector<int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    \n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "python": "\n    ```python\ndef can_attend_meetings(intervals):\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i - 1][1]:\n            return False\n\n    return True\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "javascript": "\n    ```javascript\nfunction canAttendMeetings(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    \n    for (let i = 1; i < intervals.length; ++i) {\n        if (intervals[i][0] < intervals[i - 1][1])\n            return false;\n    }\n    \n    return true;\n}\n```\n    \n    1. Sort the meeting intervals by their start times.\n2. Iterate through the sorted intervals. \n3. Check if the start time of the current interval is less than the end time of the previous interval. If so, return false, as the person cannot attend both of these meetings.\n4. If all intervals pass the check, return true, as the person can attend all meetings.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " intervals = [[0,30],[5,10],[15,20]]",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " intervals = [[7,10],[2,4]]",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,30],[5,10],[15,20]]",
                    "output": "False"
                },
                {
                    "input": "[[7,10],[2,4]]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-38",
        "prompt": "Given an array of meeting time `intervals` where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings."
    },
    "leetcode-benchmark-39": {
        "id": "leetcode-benchmark-39",
        "title": "Add Digits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 38\n**Output:** 2\n**Explanation:** The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it.\n\n",
                "**Example 2:**\n\n**Input:** num = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= num <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you do it without any loop/recursion in `O(1)` runtime?"
        },
        "java": "\n    ```java\npublic int addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "c++": "\n    ```cpp\nint addDigits(int num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "python": "\n    ```python\ndef addDigits(num: int) -> int:\n    return 1 + (num - 1) % 9\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "javascript": "\n    ```javascript\nfunction addDigits(num) {\n    return 1 + (num - 1) % 9;\n}\n```\n    \n    The idea is to find the pattern for the single digit that will be the outcome of repeatedly summing up a number's digits. Observe that for numbers 1-9, the single digit outcome is the number itself. For numbers 10-18 (i.e., 1+0, 1+1, 1+2, ..., 1+8), the single digit outcome is 1-9 again. This pattern repeats.\n\nIn the given code, we return the value computed from the formula `1 + (num - 1) % 9`. The formula derives from the observation mentioned above. Here's the explanation:\n\n- Subtracting 1 shifts the sequence to range from 0 to 8 instead of 1 to 9.\n- Taking num modulo 9 reveals the repeating 0-8 pattern.\n- Adding 1 offsets the range back to 1-9.\n\nThis algorithm works for all positive integer numbers, and the result is the single digit number that is the outcome of repeatedly summing up the original number's digits.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num = 38",
                    "output": " 2",
                    "explanation": " The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it."
                },
                {
                    "input": " num = 0",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "38",
                    "output": "2"
                },
                {
                    "input": "0",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-39",
        "prompt": "Given an integer `num`, repeatedly add all its digits until the result has only one digit, and return it."
    },
    "leetcode-benchmark-40": {
        "id": "leetcode-benchmark-40",
        "title": "Ugly Number",
        "difficulty": "Easy",
        "content": {
            "problem": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6\n**Output:** true\n**Explanation:** 6 = 2 \\* 3\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n\n",
                "**Example 3:**\n\n**Input:** n = 14\n**Output:** false\n**Explanation:** 14 is not ugly since it includes the prime factor 7."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "c++": "\n    ```cpp\nbool isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "python": "\n    ```python\ndef is_ugly(n: int) -> bool:\n    if n <= 0:\n        return False\n    for factor in [2, 3, 5]:\n        while n % factor == 0:\n            n //= factor\n    return n == 1\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "javascript": "\n    ```javascript\nfunction isUgly(n) {\n    if (n <= 0) return false;\n    while (n % 2 === 0) n /= 2;\n    while (n % 3 === 0) n /= 3;\n    while (n % 5 === 0) n /= 5;\n    return n === 1;\n}\n```\n    \n    The algorithm checks if the number is less than or equal to 0 because only positive integers can be ugly. If the input number is divisible by 2, 3, or 5, we keep dividing it by the respective factor in a loop until it's no longer divisible by that factor. After processing all factors (2, 3, 5), if the remaining number is 1, then the input number had only prime factors of 2, 3, and 5, hence it is an ugly number. Otherwise, it's not an ugly number.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 6",
                    "output": " True",
                    "explanation": " 6 = 2 \\* 3"
                },
                {
                    "input": " n = 1",
                    "output": " True",
                    "explanation": " 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
                },
                {
                    "input": " n = 14",
                    "output": " False",
                    "explanation": " 14 is not ugly since it includes the prime factor 7."
                }
            ],
            "function_input": [
                {
                    "input": "6",
                    "output": "True"
                },
                {
                    "input": "1",
                    "output": "True"
                },
                {
                    "input": "14",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-40",
        "prompt": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return `true` _if_ `n` _is an **ugly number**_."
    },
    "leetcode-benchmark-41": {
        "id": "leetcode-benchmark-41",
        "title": "Palindrome Permutation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return `true` _if a permutation of the string could form a_ _**palindrome**_ _and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"code \"\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aab \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** s =  \"carerac \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5000`\n*   `s` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canPermutePalindrome(String s) {\n    HashMap<Character, Integer> count = new HashMap<>();\n    for(char c : s.toCharArray()) {\n        count.put(c, count.getOrDefault(c, 0) + 1);\n    }\n    int odd_count = 0;\n    for(int value : count.values()) {\n        if (value % 2 != 0) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool canPermutePalindrome(string s) {\n    unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n    int odd_count = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        if (it->second % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef canPermutePalindrome(s: str) -> bool:\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n    odd_count = 0\n    for value in count.values():\n        if value % 2:\n            odd_count += 1\n    return odd_count <= 1\n```\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "javascript": "\n    ```javascript\nfunction canPermutePalindrome(s) {\n    const count = {}\n    for (const c of s) {\n        if (c in count) {\n            count[c]++;\n        } else {\n            count[c] = 1;\n        }\n    }\n    let odd_count = 0;\n    for (const value of Object.values(count)) {\n        if (value % 2) {\n            odd_count++;\n        }\n    }\n    return odd_count <= 1;\n}\n```\n\n    \n    The algorithm counts the occurrences of each character in the string using a hash map (or dictionary for Python). Then, it iterates through the count values in the hash map and checks how many characters have odd occurrences. If the string can form a palindrome, there should be at most one character having an odd number of occurrences.\n\nThe logic is based on the fact that a string can form a palindrome if it meets the following condition: If the string length is even, there should be an even number of occurrences for each character. If the string length is odd, there should be only one character having odd occurrences and the rest should have even occurrences.\n\nThe algorithm simply returns true if the odd_count is less than or equal to 1, indicating the string can form a palindrome; otherwise, it returns false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"code \"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " s =  \"aab \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s =  \"carerac \"",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"code\"",
                    "output": "False"
                },
                {
                    "input": "\"aab\"",
                    "output": "True"
                },
                {
                    "input": "\"carerac\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-41",
        "prompt": "Given a string `s`, return `true` _if a permutation of the string could form a_ _**palindrome**_ _and_ `false` _otherwise_."
    },
    "leetcode-benchmark-42": {
        "id": "leetcode-benchmark-42",
        "title": "Missing Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,0,1\\]\n**Output:** 2\n**Explanation:** n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** 2\n**Explanation:** n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[9,6,4,2,3,5,7,0,1\\]\n**Output:** 8\n**Explanation:** n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `0 <= nums[i] <= n`\n*   All the numbers of `nums` are **unique**.\n\n**",
            "follow_up": "Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?"
        },
        "java": "\n    ```java\npublic int missingNumber(int[] nums) {\n    int n = nums.length;\n    int expectedSum = (n * (n + 1)) / 2;\n    int actualSum = 0;\n    for (int num : nums) {\n        actualSum += num;\n    }\n    return expectedSum - actualSum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "c++": "\n    ```cpp\nint missingNumber(vector<int>& nums) {\n    int n = nums.size();\n    int expected_sum = (n * (n + 1)) / 2;\n    int actual_sum = 0;\n    for (int num : nums) {\n        actual_sum += num;\n    }\n    return expected_sum - actual_sum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "python": "\n    ```python\ndef missingNumber(nums):\n    n = len(nums)\n    expected_sum = (n * (n + 1)) // 2\n    actual_sum = sum(nums)\n    return expected_sum - actual_sum\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "javascript": "\n    ```javascript\nfunction missingNumber(nums) {\n    const n = nums.length;\n    const expectedSum = (n * (n + 1)) / 2;\n    const actualSum = nums.reduce((acc, num) => acc + num, 0);\n    return expectedSum - actualSum;\n}\n```\n    \n    The algorithm calculates the expected sum of integers in the range [0, n] using the formula n * (n + 1) / 2. Then, it calculates the actual sum of the integers in the given array. Finally, it returns the difference between the expected sum and the actual sum, which represents the missing number in the range.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,0,1]",
                    "output": " 2",
                    "explanation": " n = 3 since there are 3 numbers, so all numbers are in the range \\[0,3\\]. 2 is the missing number in the range since it does not appear in nums."
                },
                {
                    "input": " nums = [0,1]",
                    "output": " 2",
                    "explanation": " n = 2 since there are 2 numbers, so all numbers are in the range \\[0,2\\]. 2 is the missing number in the range since it does not appear in nums."
                },
                {
                    "input": " nums = [9,6,4,2,3,5,7,0,1]",
                    "output": " 8",
                    "explanation": " n = 9 since there are 9 numbers, so all numbers are in the range \\[0,9\\]. 8 is the missing number in the range since it does not appear in nums."
                }
            ],
            "function_input": [
                {
                    "input": "[3,0,1]",
                    "output": "2"
                },
                {
                    "input": "[0,1]",
                    "output": "2"
                },
                {
                    "input": "[9,6,4,2,3,5,7,0,1]",
                    "output": "8"
                }
            ]
        },
        "task_id": "leetcode-benchmark-42",
        "prompt": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return _the only number in the range that is missing from the array._"
    },
    "leetcode-benchmark-43": {
        "id": "leetcode-benchmark-43",
        "title": "First Bad Version",
        "difficulty": "Easy",
        "content": {
            "problem": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "c++": "\n    ```cpp\nint firstBadVersion(int n) {\n    int left = 1;\n    int right = n;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "python": "\n    ```python\ndef first_bad_version(n):\n    left, right = 1, n\n    while left < right:\n        mid = left + (right - left) // 2\n        if is_bad_version(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "javascript": "\n    ```javascript\nfunction firstBadVersion(n) {\n    let left = 1;\n    let right = n;\n    while (left < right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (isBadVersion(mid)) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return left;\n}\n```\n\n    \n    The algorithm used here is a binary search approach which starts with the range from the first to the last version. In each iteration, it takes the middle point and checks if it's a bad version by calling `isBadVersion()` API.\n\nIf the middle version is bad, this means that the first bad version is either the middle version or somewhere on the left side of the range. So, we update the right end of the range to the middle version.\n\nIf the middle version is not bad, the first bad version must be somewhere on the right side of the range. So, we update the left end of the range to the middle version + 1.\n\nThe loop will continue until the left and right pointers converge, indicating that we have found the first bad version. As a result, we return the value of the left pointer.\n\nThis algorithm has a complexity of O(log n), as it reduces the search range by half at each iteration hence minimizing the number of calls to the API.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5, bad = 4",
                    "output": " 4",
                    "explanation": "\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version."
                },
                {
                    "input": " n = 1, bad = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5,4",
                    "output": "4"
                },
                {
                    "input": "1,1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-43",
        "prompt": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API."
    },
    "leetcode-benchmark-44": {
        "id": "leetcode-benchmark-44",
        "title": "Move Zeroes",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n\n**Note** that you must do this in-place without making a copy of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,0,3,12\\]\n**Output:** \\[1,3,12,0,0\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you minimize the total number of operations done?"
        },
        "java": "\n    ```java\npublic void moveZeroes(int[] nums) {\n    int index = 0;\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "c++": "\n    ```cpp\nvoid moveZeroes(vector<int>& nums) {\n    int index = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (int i = index; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "python": "\n    ```python\ndef moveZeroes(nums):\n    index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[index] = nums[i]\n            index += 1\n    for i in range(index, len(nums)):\n        nums[i] = 0\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "javascript": "\n    ```javascript\nfunction moveZeroes(nums) {\n    let index = 0;\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[index++] = nums[i];\n        }\n    }\n    for (let i = index; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}\n```\n    \n    In each language, the algorithm starts by initializing an `index` variable with the value of 0. Next, it loops through the input array `nums`. If the current element is not zero, it assigns the value of the current element to the position indicated by the `index` and then increments the `index`. After the first loop, all non-zero elements are placed before the zero elements in the array.\n\nFinally, in the second loop, it assigns the value of 0 to all remaining positions in the array from the current `index` to the end of the array.\n\nThis algorithm maintains the relative order of non-zero elements as they are moved to the left at the beginning of the array, and ensures that zeros are moved to the end of the array. The algorithm also modifies the given array in-place as required.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [0,1,0,3,12]",
                    "output": " [1,3,12,0,0]",
                    "explanation": null
                },
                {
                    "input": " nums = [0]",
                    "output": " [0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[0,1,0,3,12]",
                    "output": "[1,3,12,0,0]"
                },
                {
                    "input": "[0]",
                    "output": "[0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-44",
        "prompt": "Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.\n\n**Note** that you must do this in-place without making a copy of the array."
    },
    "leetcode-benchmark-45": {
        "id": "leetcode-benchmark-45",
        "title": "Word Pattern",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat dog \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** pattern =  \"abba \", s =  \"dog cat cat fish \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** pattern =  \"aaaa \", s =  \"dog cat cat dog \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pattern.length <= 300`\n*   `pattern` contains only lower-case English letters.\n*   `1 <= s.length <= 3000`\n*   `s` contains only lowercase English letters and spaces `' '`.\n*   `s` **does not contain** any leading or trailing spaces.\n*   All the words in `s` are separated by a **single space**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic boolean wordPattern(String pattern, String s) {\n    String[] words = s.split(\" \");\n    if (pattern.length() != words.length) return false;\n\n    Map<Character, String> charMap = new HashMap<>();\n    Map<String, Character> wordMap = new HashMap<>();\n\n    for (int i = 0; i < pattern.length(); i++) {\n        char c = pattern.charAt(i);\n        String word = words[i];\n        if (!charMap.containsKey(c) && !wordMap.containsKey(word)) {\n            charMap.put(c, word);\n            wordMap.put(word, c);\n        } else {\n            if (!word.equals(charMap.get(c)) || c != wordMap.get(word)) return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <sstream>\nusing namespace std;\n\nbool wordPattern(string pattern, string s) {\n    unordered_map<char, string> char_map;\n    unordered_map<string, char> word_map;\n    stringstream ss(s);\n\n    int i = 0;\n    for (string word; ss >> word; ++i) {\n        if (i == pattern.size()) return false;\n        char c = pattern[i];\n        if (char_map.count(c) == 0 && word_map.count(word) == 0) {\n            char_map[c] = word;\n            word_map[word] = c;\n        } else {\n            if (char_map[c] != word || word_map[word] != c) return false;\n        }\n    }\n\n    return i == pattern.size();\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "python": "\n    ```python\ndef word_pattern(pattern, s):\n    words = s.split()\n    if len(pattern) != len(words):\n        return False\n\n    char_map, word_map = {}, {}\n    for c, word in zip(pattern, words):\n        if c not in char_map and word not in word_map:\n            char_map[c] = word\n            word_map[word] = c\n        else:\n            if char_map.get(c) != word or word_map.get(word) != c:\n                return False\n\n    return True\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "javascript": "\n    ```javascript\nfunction wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const charMap = new Map();\n    const wordMap = new Map();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const c = pattern[i];\n        const word = words[i];\n        if (!charMap.has(c) && !wordMap.has(word)) {\n            charMap.set(c, word);\n            wordMap.set(word, c);\n        } else {\n            if (charMap.get(c) !== word || wordMap.get(word) !== c) return false;\n        }\n    }\n\n    return true;\n}\n```\n\n    \n    1. First, split the string 's' into words array based on the space-delimited words.\n2. Check if the length of the pattern and words array is the same, otherwise return false.\n3. Create two maps (hash tables/dictionaries) - one for storing the mapping from a pattern character to a word, and the other for mapping from a word to a pattern character.\n4. Iterate through the pattern and the words array simultaneously using a loop.\n5. If a pattern character and word are not in the respective maps, save the corresponding mapping in both maps.\n6. If they exist, compare the mappings; if they differ, immediately return false.\n7. After the loop is completed, if there is no mismatch, return true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " pattern =  \"abba \", s =  \"dog cat cat dog \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " pattern =  \"abba \", s =  \"dog cat cat fish \"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " pattern =  \"aaaa \", s =  \"dog cat cat dog \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abba\",\"dogcatcatdog\"",
                    "output": "True"
                },
                {
                    "input": "\"abba\",\"dogcatcatfish\"",
                    "output": "False"
                },
                {
                    "input": "\"aaaa\",\"dogcatcatdog\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-45",
        "prompt": "Given a `pattern` and a string `s`, find if `s` follows the same pattern.\n\nHere **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `s`."
    },
    "leetcode-benchmark-46": {
        "id": "leetcode-benchmark-46",
        "title": "Nim Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are playing the following Nim Game with your friend:\n\n*   Initially, there is a heap of stones on the table.\n*   You and your friend will alternate taking turns, and **you go first**.\n*   On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n*   The one who removes the last stone is the winner.\n\nGiven `n`, the number of stones in the heap, return `true` _if you can win the game assuming both you and your friend play optimally, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** false\n**Explanation:** These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canWinNim(int n) {\n    return n % 4 != 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "c++": "\n    ```cpp\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "python": "\n    ```python\ndef canWinNim(n):\n    return n % 4 != 0\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "javascript": "\n    ```javascript\nfunction canWinNim(n) {\n    return n % 4 !== 0;\n}\n```\n    \n    In the Nim game, the optimal strategy is to make the other player take the last stone. The game is won by the player who can force the opponent to take the last stone. If the current number of stones is divisible by 4, the next player can always make the other player take the last stone. Therefore, whenever the current number of stones is divisible by 4, the player will lose. If the number of stones is not divisible by 4, the player can make the next player play with a number of stones divisible by 4, thus making the next player lose.\n\nIn the code, we simply check if the number of stones `n` is not divisible by 4 (`n % 4 != 0`), and if it is, then the player can win the game.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 4",
                    "output": " False",
                    "explanation": " These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins."
                },
                {
                    "input": " n = 1",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " n = 2",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "4",
                    "output": "False"
                },
                {
                    "input": "1",
                    "output": "True"
                },
                {
                    "input": "2",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-46",
        "prompt": "You are playing the following Nim Game with your friend:\n\n*   Initially, there is a heap of stones on the table.\n*   You and your friend will alternate taking turns, and **you go first**.\n*   On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n*   The one who removes the last stone is the winner.\n\nGiven `n`, the number of stones in the heap, return `true` _if you can win the game assuming both you and your friend play optimally, otherwise return_ `false`."
    },
    "leetcode-benchmark-47": {
        "id": "leetcode-benchmark-47",
        "title": "Flip Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn all possible states of the string `currentState` after **one valid move**. You may return the answer in **any order**. If there is no valid move, return an empty list `[]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** \\[ \"--++ \", \"+--+ \", \"++-- \"\\]\n\n",
                "**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= currentState.length <= 500`\n*   `currentState[i]` is either `'+'` or `'-'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generatePossibleNextMoves(String currentState) {\n    List<String> result = new ArrayList<>();\n    for (int i = 1; i < currentState.length(); i++) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i - 1) == '+') {\n            result.add(currentState.substring(0, i - 1) + \"--\" + currentState.substring(i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> generatePossibleNextMoves(std::string currentState) {\n    std::vector<std::string> result;\n    for (int i = 1; i < currentState.size(); ++i) {\n        if (currentState[i] == '+' && currentState[i - 1] == '+') {\n            currentState[i] = currentState[i - 1] = '-';\n            result.push_back(currentState);\n            currentState[i] = currentState[i - 1] = '+';\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "python": "\n    ```python\ndef generate_possible_next_moves(current_state):\n    result = []\n    for i in range(1, len(current_state)):\n        if current_state[i] == '+' and current_state[i - 1] == '+':\n            result.append(current_state[:i - 1] + '--' + current_state[i + 1:])\n    return result\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "javascript": "\n    ```javascript\nfunction generatePossibleNextMoves(currentState) {\n    const result = [];\n    for (let i = 1; i < currentState.length; i++) {\n        if (currentState[i] === '+' && currentState[i - 1] === '+') {\n            result.push(currentState.slice(0, i - 1) + '--' + currentState.slice(i + 1));\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates through the `currentState` string starting from the second character to check for two consecutive `'+'` characters. When it finds a pair, it flips them to `'-'` and adds the resulting string to the `result` list. After adding the result, it flips the characters back to `'+'` to continue searching for more pairs.\n\nIn Python and JavaScript, the string concatenation is done using slicing and concatenation, while in C++ and Java, the strings are first modified and then restored to their original state after adding the modified result. The final output is a list of all the possible next moves after one valid flip.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " currentState =  \"++++ \"",
                    "output": " [ \"--++ \", \"+--+ \", \"++-- \"]",
                    "explanation": null
                },
                {
                    "input": " currentState =  \"+ \"",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"++++\"",
                    "output": "[\"--++\",\"+--+\",\"++--\"]"
                },
                {
                    "input": "\"+\"",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-47",
        "prompt": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn all possible states of the string `currentState` after **one valid move**. You may return the answer in **any order**. If there is no valid move, return an empty list `[]`."
    },
    "leetcode-benchmark-48": {
        "id": "leetcode-benchmark-48",
        "title": "Power of Three",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of three. Otherwise, return `false`_.\n\nAn integer `n` is a power of three, if there exists an integer `x` such that `n == 3x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 27\n**Output:** true\n**Explanation:** 27 = 33\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** false\n**Explanation:** There is no x where 3x = 0.\n\n",
                "**Example 3:**\n\n**Input:** n = -1\n**Output:** false\n**Explanation:** There is no x where 3x = (-1)."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "java": "\n    ```java\npublic boolean isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfThree(int n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 == 0) {\n        n /= 3;\n    }\n    \n    return n == 1;\n}\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "python": "\n    ```python\ndef is_power_of_three(n: int) -> bool:\n    if n < 1:\n        return False\n    \n    while n % 3 == 0:\n        n //= 3\n    \n    return n == 1\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "javascript": "\n    ```javascript\nfunction isPowerOfThree(n) {\n    if (n < 1) {\n        return false;\n    }\n    \n    while (n % 3 === 0) {\n        n /= 3;\n    }\n    \n    return n === 1;\n}\n```\n    \n    The solution checks if the given number, n, is a power of three as follows:\n\n1. If n is less than 1, return false because powers of 3 are positive integers.\n2. Use a while loop, and keep dividing n by 3 while n is divisible by 3 without a remainder.\n3. After the loop, check if n is equal to 1. If n is 1, it means the original n was a power of 3; otherwise, it was not a power of 3. Return the result accordingly.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 27",
                    "output": " True",
                    "explanation": " 27 = 33"
                },
                {
                    "input": " n = 0",
                    "output": " False",
                    "explanation": " There is no x where 3x = 0."
                },
                {
                    "input": " n = -1",
                    "output": " False",
                    "explanation": " There is no x where 3x = (-1)."
                }
            ],
            "function_input": [
                {
                    "input": "27",
                    "output": "True"
                },
                {
                    "input": "0",
                    "output": "False"
                },
                {
                    "input": "-1",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-48",
        "prompt": "Given an integer `n`, return _`true` if it is a power of three. Otherwise, return `false`_.\n\nAn integer `n` is a power of three, if there exists an integer `x` such that `n == 3x`."
    },
    "leetcode-benchmark-49": {
        "id": "leetcode-benchmark-49",
        "title": "Counting Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,1\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[0,1,1,2,1,2\\]\n**Explanation:**\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 105`\n\n**",
            "follow_up": "Follow up:**\n\n*   It is very easy to come up with a solution with a runtime of `O(n log n)`. Can you do it in linear time `O(n)` and possibly in a single pass?\n*   Can you do it without using any built-in function (i.e., like `__builtin_popcount` in C++)?"
        },
        "java": "\n    ```java\npublic int[] countBits(int n) {\n    int[] ans = new int[n + 1];\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> countBits(int n) {\n    vector<int> ans(n + 1, 0);\n    for (int i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "python": "\n    ```python\ndef countBits(n):\n    ans = [0] * (n + 1)\n    for i in range(1, n + 1):\n        ans[i] = ans[i & (i - 1)] + 1\n    return ans\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "javascript": "\n    ```javascript\nfunction countBits(n) {\n    const ans = new Array(n + 1).fill(0);\n    for (let i = 1; i <= n; ++i) {\n        ans[i] = ans[i & (i - 1)] + 1;\n    }\n    return ans;\n}\n```\n    \n    The algorithm leverages a key observation: `(i & (i - 1))` has the same binary representation as `i`, but with the least significant `1` bit removed. This leads to a fast and efficient way to count the number of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nFor each number `i` in the range `[1, n]`, we calculate `ans[i]` based on `ans[i & (i - 1)]`. Since `ans[i & (i - 1)]` is the count of `1` bits in the binary representation of `(i & (i - 1))`, adding `1` to that count will give us the count of `1` bits in the binary representation of `i`.\n\nThe algorithm iterates through the range `[1, n]` and fills the output array `ans` accordingly. The final array `ans` contains the count of `1` bits in the binary representation of each number in the range `[0, n]`.\n\nThe time complexity of this algorithm is O(n) as it iterates through the range `[1, n]` only once, and the space complexity is O(n + 1) since it creates an array of length `n + 1` to store the results.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " [0,1,1]",
                    "explanation": "\n0 --> 0\n1 --> 1\n2 --> 10"
                },
                {
                    "input": " n = 5",
                    "output": " [0,1,1,2,1,2]",
                    "explanation": "\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "[0,1,1]"
                },
                {
                    "input": "5",
                    "output": "[0,1,1,2,1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-49",
        "prompt": "Given an integer `n`, return _an array_ `ans` _of length_ `n + 1` _such that for each_ `i` (`0 <= i <= n`)_,_ `ans[i]` _is the **number of**_ `1`_**'s** in the binary representation of_ `i`."
    },
    "leetcode-benchmark-50": {
        "id": "leetcode-benchmark-50",
        "title": "Power of Four",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _`true` if it is a power of four. Otherwise, return `false`_.\n\nAn integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 16\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= n <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you solve it without loops/recursion?"
        },
        "java": "\n    ```java\npublic boolean isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool isPowerOfFour(int n) {\n    if (n <= 0) return false;\n    while (n % 4 == 0) {\n        n /= 4;\n    }\n    return n == 1;\n}\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "python": "\n    ```python\ndef isPowerOfFour(n: int) -> bool:\n    if n <= 0:\n        return False\n    while n % 4 == 0:\n        n //= 4\n    return n == 1\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction isPowerOfFour(n) {\n    if (n <= 0) return false;\n    while (n % 4 === 0) {\n        n = Math.floor(n / 4);\n    }\n    return n === 1;\n}\n```\n    \n    The algorithm checks if a given integer `n` is a power of 4 or not. If `n` is less than or equal to 0, it immediately returns `false`. Otherwise, it enters a loop that checks if `n` is divisible by 4. If it is, it keeps dividing the number by 4 until it is no longer divisible by 4. After the loop, the algorithm checks whether the final remainder is 1 or not. If the remainder is 1, the number was initially a power of 4, and it returns `true`. Otherwise, it returns `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 16",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " n = 5",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "16",
                    "output": "True"
                },
                {
                    "input": "5",
                    "output": "False"
                },
                {
                    "input": "1",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-50",
        "prompt": "Given an integer `n`, return _`true` if it is a power of four. Otherwise, return `false`_.\n\nAn integer `n` is a power of four, if there exists an integer `x` such that `n == 4x`."
    },
    "leetcode-benchmark-51": {
        "id": "leetcode-benchmark-51",
        "title": "Reverse String",
        "difficulty": "Easy",
        "content": {
            "problem": "Write a function that reverses a string. The input string is given as an array of characters `s`.\n\nYou must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \\[\"h\",\"e\",\"l\",\"l\",\"o\"\\]\n**Output:** \\[\"o\",\"l\",\"l\",\"e\",\"h\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \\[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"\\]\n**Output:** \\[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a [printable ascii character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void reverseString(char[] s) {\n    int left = 0, right = s.length - 1;\n    while (left < right) {\n        char temp = s[left];\n        s[left++] = s[right];\n        s[right--] = temp;\n    }\n}\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "c++": "\n    ```cpp\nvoid reverseString(vector<char>& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        swap(s[left++], s[right--]);\n    }\n}\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "python": "\n    ```python\ndef reverseString(s: List[str]) -> None:\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left, right = left + 1, right - 1\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseString(s) {\n    let left = 0, right = s.length - 1;\n    while (left < right) {\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}\n```\n    \n    The algorithm follows a two-pointer approach. Initialize two pointers, `left` and `right`, at the beginning and end of the input array. Using a while loop, run until the `left` pointer is greater than or equal to the `right` pointer. In the loop, swap the elements at the `left` and `right` pointers. Increment the `left` pointer and decrement the `right` pointer. Repeat this process until the loop terminates, which means the entire string has been reversed.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = [\"h\",\"e\",\"l\",\"l\",\"o\"]",
                    "output": " [\"o\",\"l\",\"l\",\"e\",\"h\"]",
                    "explanation": null
                },
                {
                    "input": " s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
                    "output": " [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                    "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                },
                {
                    "input": "[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]",
                    "output": "[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-51",
        "prompt": "Write a function that reverses a string. The input string is given as an array of characters `s`.\n\nYou must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory."
    },
    "leetcode-benchmark-52": {
        "id": "leetcode-benchmark-52",
        "title": "Reverse Vowels of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in both lower and upper cases, more than once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"hello\"\n**Output:** \"holle\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"leetcode\"\n**Output:** \"leotcede\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consist of **printable ASCII** characters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic String reverseVowels(String s) {\n    int i = 0, j = s.length() - 1;\n    char[] result = new char[s.length()];\n    Set<Character> vowels = new HashSet<>();\n    for (char c : \"aeiouAEIOU\".toCharArray()) {\n        vowels.add(c);\n    }\n    while (i <= j) {\n        char ci = s.charAt(i);\n        char cj = s.charAt(j);\n        if (!vowels.contains(ci)) {\n            result[i++] = ci;\n        } else if (!vowels.contains(cj)) {\n            result[j--] = cj;\n        } else {\n            result[i++] = cj;\n            result[j--] = ci;\n        }\n    }\n    return new String(result);\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int i = 0, j = s.size() - 1;\n    while (i < j) {\n        if (!isVowel(s[i])) {\n            i++;\n        } else if (!isVowel(s[j])) {\n            j--;\n        } else {\n            std::swap(s[i], s[j]);\n            i++;\n            j--;\n        }\n    }\n    return s;\n}\n\nbool isVowel(char c) {\n    c = std::tolower(c);\n    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "python": "\n    ```python\ndef reverseVowels(s: str) -> str:\n    vowels = set('aeiouAEIOU')\n    s_list = list(s)\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s_list[i] not in vowels:\n            i += 1\n        elif s_list[j] not in vowels:\n            j -= 1\n        else:\n            s_list[i], s_list[j] = s_list[j], s_list[i]\n            i += 1\n            j -= 1\n    return ''.join(s_list)\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseVowels(s) {\n    const vowels = new Set('aeiouAEIOU');\n    let chars = Array.from(s);\n    let i = 0, j = s.length - 1;\n    while (i < j) {\n        if (!vowels.has(chars[i])) {\n            i++;\n        } else if (!vowels.has(chars[j])) {\n            j--;\n        } else {\n            [chars[i], chars[j]] = [chars[j], chars[i]];\n            i++;\n            j--;\n        }\n    }\n    return chars.join('');\n}\n```\n    \n    The algorithm uses two-pointer technique to iterate over the string from both the start and the end. It then checks if the characters at the pointers are vowels or not. If the characters are not vowels, the pointers move accordingly. If both characters are vowels, they are swapped and the pointers move forward. This process continues until the pointers meet in the middle of the string or cross each other. Finally, the modified string is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"hello\"",
                    "output": " \"holle\"",
                    "explanation": null
                },
                {
                    "input": " s = \"leetcode\"",
                    "output": " \"leotcede\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"hello\"",
                    "output": "\"holle\""
                },
                {
                    "input": "\"leetcode\"",
                    "output": "\"leotcede\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-52",
        "prompt": "Given a string `s`, reverse only all the vowels in the string and return it.\n\nThe vowels are `'a'`, `'e'`, `'i'`, `'o'`, and `'u'`, and they can appear in both lower and upper cases, more than once."
    },
    "leetcode-benchmark-53": {
        "id": "leetcode-benchmark-53",
        "title": "Intersection of Two Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must be **unique** and you may return the result in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[9,4\\]\n**Explanation:** \\[4,9\\] is also accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int[] intersection(int[] nums1, int[] nums2) {\n    Set<Integer> set1 = new HashSet<>();\n    for (int num : nums1) {\n        set1.add(num);\n    }\n    \n    Set<Integer> resultSet = new HashSet<>();\n    for (int num : nums2) {\n        if (set1.contains(num)) {\n            resultSet.add(num);\n        }\n    }\n    \n    int[] result = new int[resultSet.size()];\n    int i = 0;\n    for (int num : resultSet) {\n        result[i++] = num;\n    }\n    return result;\n}\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nstd::vector<int> intersection(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::set<int> set1(nums1.begin(), nums1.end());\n    std::set<int> result;\n    for (int num : nums2) {\n        if (set1.count(num)) {\n            result.insert(num);\n        }\n    }\n    return std::vector<int>(result.begin(), result.end());\n}\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "python": "\n    ```python\ndef intersection(nums1, nums2):\n    set1 = set(nums1)\n    result = set1.intersection(nums2)\n    return list(result)\n```\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "javascript": "\n    ```javascript\nfunction intersection(nums1, nums2) {\n    const set1 = new Set(nums1);\n    const resultSet = new Set();\n\n    for (const num of nums2) {\n        if (set1.has(num)) {\n            resultSet.add(num);\n        }\n    }\n\n    return Array.from(resultSet);\n}\n```\n\n    \n    The function first creates a set `set1` from the first array `nums1`, which eliminates duplicate elements in it. Then, the function iterates through the second array `nums2`. For each element in `nums2`, it checks whether it exists in the `set1`. If so, this element is added to the result set `resultSet`. Finally, the result set is converted to an array and returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums1 = [1,2,2,1], nums2 = [2,2]",
                    "output": " [2]",
                    "explanation": null
                },
                {
                    "input": " nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
                    "output": " [9,4]",
                    "explanation": " \\[4,9\\] is also accepted."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,2,1],[2,2]",
                    "output": "[2]"
                },
                {
                    "input": "[4,9,5],[9,4,9,8,4]",
                    "output": "[9,4]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-53",
        "prompt": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must be **unique** and you may return the result in **any order**."
    },
    "leetcode-benchmark-54": {
        "id": "leetcode-benchmark-54",
        "title": "Intersection of Two Arrays II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,2,2,1\\], nums2 = \\[2,2\\]\n**Output:** \\[2,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[4,9,5\\], nums2 = \\[9,4,9,8,4\\]\n**Output:** \\[4,9\\]\n**Explanation:** \\[9,4\\] is also accepted."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length, nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 1000`\n\n**",
            "follow_up": "Follow up:**\n\n*   What if the given array is already sorted? How would you optimize your algorithm?\n*   What if `nums1`'s size is small compared to `nums2`'s size? Which algorithm is better?\n*   What if elements of `nums2` are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?"
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\npublic int[] intersect(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> countMap = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n    \n    for (int num : nums1) {\n        countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n    }\n    \n    for (int num : nums2) {\n        if (countMap.getOrDefault(num, 0) > 0) {\n            result.add(num);\n            countMap.put(num, countMap.get(num) - 1);\n        }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nstd::vector<int> intersect(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> count_map;\n    std::vector<int> result;\n    \n    for (int num : nums1) {\n        count_map[num]++;\n    }\n    \n    for (int num : nums2) {\n        if (count_map[num] > 0) {\n            result.push_back(num);\n            count_map[num]--;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "python": "\n    ```python\ndef intersect(nums1, nums2):\n    count_map = {}\n    result = []\n    \n    for num in nums1:\n        count_map[num] = count_map.get(num, 0) + 1\n    \n    for num in nums2:\n        if count_map.get(num, 0) > 0:\n            result.append(num)\n            count_map[num] -= 1\n\n    return result\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "javascript": "\n    ```javascript\nfunction intersect(nums1, nums2) {\n    const countMap = {};\n    const result = [];\n    \n    for (const num of nums1) {\n        countMap[num] = (countMap[num] || 0) + 1;\n    }\n    \n    for (const num of nums2) {\n        if (countMap[num] > 0) {\n            result.push(num);\n            countMap[num]--;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    1. Create a hashmap (or dictionary) to count the occurrences of each integer in the first input array, nums1.\n2. Iterate through the second input array, nums2.\n   a. For each element in nums2, check if the element exists in the hashmap and has a count greater than 0.\n   b. If yes, append the element to the result array and decrement the count in the hashmap for that element.\n3. Return the result array containing the intersection elements.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums1 = [1,2,2,1], nums2 = [2,2]",
                    "output": " [2,2]",
                    "explanation": null
                },
                {
                    "input": " nums1 = [4,9,5], nums2 = [9,4,9,8,4]",
                    "output": " [4,9]",
                    "explanation": " \\[9,4\\] is also accepted."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,2,1],[2,2]",
                    "output": "[2,2]"
                },
                {
                    "input": "[4,9,5],[9,4,9,8,4]",
                    "output": "[4,9]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-54",
        "prompt": "Given two integer arrays `nums1` and `nums2`, return _an array of their intersection_. Each element in the result must appear as many times as it shows in both arrays and you may return the result in **any order**."
    },
    "leetcode-benchmark-55": {
        "id": "leetcode-benchmark-55",
        "title": "Valid Perfect Square",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer num, return `true` _if_ `num` _is a perfect square or_ `false` _otherwise_.\n\nA **perfect square** is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\nYou must not use any built-in library function, such as `sqrt`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 16\n**Output:** true\n**Explanation:** We return true because 4 \\* 4 = 16 and 4 is an integer.\n\n",
                "**Example 2:**\n\n**Input:** num = 14\n**Output:** false\n**Explanation:** We return false because 3.742 \\* 3.742 = 14 and 3.742 is not an integer."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "c++": "\n    ```cpp\nbool isPerfectSquare(int num) {\n    if (num < 2) return true;\n    long long left = 2, right = num / 2, mid, square;\n    while (left <= right) {\n        mid = left + (right - left) / 2;\n        square = mid * mid;\n        if (square == num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "python": "\n    ```python\ndef is_perfect_square(num: int) -> bool:\n    if num < 2:\n        return True\n    left, right = 2, num // 2\n    while left <= right:\n        mid = left + (right - left) // 2\n        square = mid * mid\n        if square == num:\n            return True\n        if square > num:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "javascript": "\n    ```javascript\nfunction isPerfectSquare(num) {\n    if (num < 2) return true;\n    let left = 2, right = Math.floor(num / 2), mid, square;\n    while (left <= right) {\n        mid = left + Math.floor((right - left) / 2);\n        square = mid * mid;\n        if (square === num) return true;\n        if (square > num) right = mid - 1;\n        else left = mid + 1;\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a binary search approach to find the square root of the given number. It starts with left at 2 and right at half of the input number. It calculates the middle value and squares it. If the squared middle value is equal to the input number, the function returns True; the number is a perfect square. If the squared middle value is greater than the input number, it updates the right to mid - 1; otherwise, it updates the left to mid + 1. The function repeats until the left value is greater than the right value. In that case, the function returns False, indicating that the input number is not a perfect square.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num = 16",
                    "output": " True",
                    "explanation": " We return true because 4 \\* 4 = 16 and 4 is an integer."
                },
                {
                    "input": " num = 14",
                    "output": " False",
                    "explanation": " We return false because 3.742 \\* 3.742 = 14 and 3.742 is not an integer."
                }
            ],
            "function_input": [
                {
                    "input": "16",
                    "output": "True"
                },
                {
                    "input": "14",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-55",
        "prompt": "Given a positive integer num, return `true` _if_ `num` _is a perfect square or_ `false` _otherwise_.\n\nA **perfect square** is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\nYou must not use any built-in library function, such as `sqrt`."
    },
    "leetcode-benchmark-56": {
        "id": "leetcode-benchmark-56",
        "title": "Guess Number Higher or Lower",
        "difficulty": "Easy",
        "content": {
            "problem": "We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int guessNumber(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int result = guess(mid);\n        if (result == 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "c++": "\n    ```cpp\nint guessNumber(int n) {\n    int low = 1, high = n;\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        int result = guess(mid);\n        if (result == 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "python": "\n    ```python\ndef guessNumber(n):\n    low, high = 1, n\n    while low <= high:\n        mid = low + (high - low) // 2\n        result = guess(mid)\n        if result == 0:\n            return mid\n        elif result < 0:\n            high = mid - 1\n        else:\n            low = mid + 1\n    return -1\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "javascript": "\n    ```javascript\nfunction guessNumber(n) {\n    let low = 1, high = n;\n    while (low <= high) {\n        let mid = Math.floor(low + (high - low) / 2);\n        let result = guess(mid);\n        if (result === 0) {\n            return mid;\n        } else if (result < 0) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm uses binary search to find the correct number. The idea is to progressively eliminate half of the remaining options with each guess:\n\n1. Initialize two pointers, `low` and `high`, to 1 and n.\n2. While `low` is less than or equal to `high`:\n   1. Calculate the middle value `mid` between `low` and `high`.\n   2. Call the `guess` function with `mid` as the argument.\n   3. If the `guess` function returns 0, the number has been found, so return `mid`.\n   4. If the `guess` function returns a negative number, the target number is lower than `mid`, so update `high` to `mid - 1`.\n   5. If the `guess` function returns a positive number, the target number is higher than `mid`, so update `low` to `mid + 1`.\n3. If the search is unsuccessful, return -1.\n\nThe guess function is pre-defined and not shown in the code above.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 10, pick = 6",
                    "output": " 6",
                    "explanation": null
                },
                {
                    "input": " n = 1, pick = 1",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " n = 2, pick = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "10,6",
                    "output": "6"
                },
                {
                    "input": "1,1",
                    "output": "1"
                },
                {
                    "input": "2,1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-56",
        "prompt": "We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_."
    },
    "leetcode-benchmark-57": {
        "id": "leetcode-benchmark-57",
        "title": "Ransom Note",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `ransomNote` and `magazine`, return `true` _if_ `ransomNote` _can be constructed by using the letters from_ `magazine` _and_ `false` _otherwise_.\n\nEach letter in `magazine` can only be used once in `ransomNote`.",
            "examples": [
                "**Example 1:**\n\n**Input:** ransomNote = \"a\", magazine = \"b\"\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** ransomNote = \"aa\", magazine = \"ab\"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** ransomNote = \"aa\", magazine = \"aab\"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= ransomNote.length, magazine.length <= 105`\n*   `ransomNote` and `magazine` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic boolean canConstruct(String ransomNote, String magazine) {\n    HashMap<Character, Integer> letterCount = new HashMap<>();\n    \n    for (char c : magazine.toCharArray()) {\n        letterCount.put(c, letterCount.getOrDefault(c, 0) + 1);\n    }\n    \n    for (char c : ransomNote.toCharArray()) {\n        if (!letterCount.containsKey(c) || letterCount.get(c) == 0) {\n            return false;\n        }\n        letterCount.put(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n\nbool canConstruct(std::string ransomNote, std::string magazine) {\n    std::unordered_map<char, int> letterCount;\n    for (char c : magazine) {\n        letterCount[c]++;\n    }\n    \n    for (char c : ransomNote) {\n        if (letterCount[c] == 0) {\n            return false;\n        }\n        letterCount[c]--;\n    }\n\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "python": "\n    ```python\ndef can_construct(ransom_note, magazine):\n    letter_count = {}\n    \n    for c in magazine:\n        letter_count[c] = letter_count.get(c, 0) + 1\n        \n    for c in ransom_note:\n        if c not in letter_count or letter_count[c] == 0:\n            return False\n        letter_count[c] -= 1\n        \n    return True\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "javascript": "\n    ```javascript\nfunction canConstruct(ransomNote, magazine) {\n    let letterCount = new Map();\n    \n    for (const c of magazine) {\n        letterCount.set(c, (letterCount.get(c) || 0) + 1);\n    }\n    \n    for (const c of ransomNote) {\n        if (!letterCount.has(c) || letterCount.get(c) === 0) {\n            return false;\n        }\n        letterCount.set(c, letterCount.get(c) - 1);\n    }\n\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Create a hash map called `letterCount`, which holds the count of each character in the `magazine` string.\n2. Iterate over the characters in `ransomNote`. For each character:\n   a. If the character is not in `letterCount` or its count is 0, return `false`, as the required letter is not available in `magazine`.\n   b. Decrease the count of the character in `letterCount` by 1.\n3. Once the iteration is done, if the entire `ransomNote` string is processed without any issue, return `true`.\n\nThis algorithm checks if the `ransomNote` can be made from the available characters in the `magazine` by using a single pass through each string and maintaining the count of characters in a hash map.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " ransomNote = \"a\", magazine = \"b\"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " ransomNote = \"aa\", magazine = \"ab\"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " ransomNote = \"aa\", magazine = \"aab\"",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"a\",\"b\"",
                    "output": "False"
                },
                {
                    "input": "\"aa\",\"ab\"",
                    "output": "False"
                },
                {
                    "input": "\"aa\",\"aab\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-57",
        "prompt": "Given two strings `ransomNote` and `magazine`, return `true` _if_ `ransomNote` _can be constructed by using the letters from_ `magazine` _and_ `false` _otherwise_.\n\nEach letter in `magazine` can only be used once in `ransomNote`."
    },
    "leetcode-benchmark-58": {
        "id": "leetcode-benchmark-58",
        "title": "First Unique Character in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, _find the first non-repeating character in it and return its index_. If it does not exist, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"leetcode\"\n**Output:** 0\n\n",
                "**Example 2:**\n\n**Input:** s = \"loveleetcode\"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** s = \"aabb\"\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int firstUniqChar(String s) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    for (char c : s.toCharArray())\n        charCount.put(c, charCount.getOrDefault(c, 0) + 1);\n    for (int i = 0; i < s.length(); i++)\n        if (charCount.get(s.charAt(i)) == 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "c++": "\n    ```cpp\nint firstUniqChar(std::string s) {\n    std::unordered_map<char, int> charCount;\n    for (char c : s)\n        charCount[c]++;\n    for (int i = 0; i < s.length(); i++)\n        if (charCount[s[i]] == 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "python": "\n    ```python\ndef firstUniqChar(s):\n    char_count = {}\n    for c in s:\n        char_count[c] = char_count.get(c, 0) + 1\n    for i in range(len(s)):\n        if char_count[s[i]] == 1:\n            return i\n    return -1\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "javascript": "\n    ```javascript\nfunction firstUniqChar(s) {\n    let charCount = {};\n    for (let c of s)\n        charCount[c] = (charCount[c] || 0) + 1;\n    for (let i = 0; i < s.length; i++)\n        if (charCount[s[i]] === 1)\n            return i;\n    return -1;\n}\n```\n\n    \n    The algorithm first creates a dictionary to store the count of each character in the input string 's'. Then, it iterates through the string, counting the occurrences of each character and updating the dictionary accordingly. \n\nAfter that, the algorithm iterates through the input string 's' again, and it checks if the count of the current character in the dictionary is 1. If it is, the algorithm returns the index of the current character as the answer. If no such character is found, the algorithm returns -1 as the answer.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string 's'.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"leetcode\"",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " s = \"loveleetcode\"",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " s = \"aabb\"",
                    "output": " -1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"leetcode\"",
                    "output": "0"
                },
                {
                    "input": "\"loveleetcode\"",
                    "output": "2"
                },
                {
                    "input": "\"aabb\"",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-58",
        "prompt": "Given a string `s`, _find the first non-repeating character in it and return its index_. If it does not exist, return `-1`."
    },
    "leetcode-benchmark-59": {
        "id": "leetcode-benchmark-59",
        "title": "Find the Difference",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two strings `s` and `t`.\n\nString `t` is generated by random shuffling string `s` and then add one more letter at a random position.\n\nReturn the letter that was added to `t`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcd \", t =  \"abcde \"\n**Output:**  \"e \"\n**Explanation:** 'e' is the letter that was added.\n\n",
                "**Example 2:**\n\n**Input:** s =  \" \", t =  \"y \"\n**Output:**  \"y \""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 1000`\n*   `t.length == s.length + 1`\n*   `s` and `t` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic char findTheDifference(String s, String t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s.toCharArray()) sum_s += c;\n    for(char c : t.toCharArray()) sum_t += c;\n    return (char)(sum_t - sum_s);\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "c++": "\n    ```cpp\nchar findTheDifference(std::string s, std::string t) {\n    int sum_s = 0, sum_t = 0;\n    for(char c : s) sum_s += c;\n    for(char c : t) sum_t += c;\n    return sum_t - sum_s;\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "python": "\n    ```python\ndef findTheDifference(s: str, t: str) -> str:\n    return chr(sum(ord(c) for c in t) - sum(ord(c) for c in s))\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "javascript": "\n    ```javascript\nfunction findTheDifference(s, t) {\n    let sum_s = 0, sum_t = 0;\n    for(let c of s) sum_s += c.charCodeAt(0);\n    for(let c of t) sum_t += c.charCodeAt(0);\n    return String.fromCharCode(sum_t - sum_s);\n}\n```\n    \n    The algorithm calculates the sum of the ASCII values of characters in both strings s and t. Since t is a shuffled version of s plus an extra character, the difference in the sums of ASCII values will give us the ASCII value of the added character. Finally, we return the character corresponding to this ASCII value.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"abcd \", t =  \"abcde \"",
                    "output": "  \"e \"",
                    "explanation": " 'e' is the letter that was added."
                },
                {
                    "input": " s =  \" \", t =  \"y \"",
                    "output": "  \"y \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abcd\",\"abcde\"",
                    "output": "\"e\""
                },
                {
                    "input": "\"\",\"y\"",
                    "output": "\"y\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-59",
        "prompt": "You are given two strings `s` and `t`.\n\nString `t` is generated by random shuffling string `s` and then add one more letter at a random position.\n\nReturn the letter that was added to `t`."
    },
    "leetcode-benchmark-60": {
        "id": "leetcode-benchmark-60",
        "title": "Is Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not).",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abc\", t = \"ahbgdc\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"axc\", t = \"ahbgdc\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 100`\n*   `0 <= t.length <= 104`\n*   `s` and `t` consist only of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Suppose there are lots of incoming `s`, say `s1, s2, ..., sk` where `k >= 109`, and you want to check one by one to see if `t` has its subsequence. In this scenario, how would you change your code?"
        },
        "java": "\n    ```java\nboolean isSubsequence(String s, String t) {\n    int si = 0, ti = 0;\n\n    while (si < s.length() && ti < t.length()) {\n        if (s.charAt(si) == t.charAt(ti))\n            si++;\n        ti++;\n    }\n\n    return si == s.length();\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "c++": "\n    ```cpp\nbool isSubsequence(std::string s, std::string t) {\n    int si = 0, ti = 0;\n\n    while (si < s.size() && ti < t.size()) {\n        if (s[si] == t[ti])\n            si++;\n        ti++;\n    }\n\n    return si == s.size();\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "python": "\n    ```python\ndef is_subsequence(s, t):\n    si, ti = 0, 0\n\n    while si < len(s) and ti < len(t):\n        if s[si] == t[ti]:\n            si += 1\n        ti += 1\n\n    return si == len(s)\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "javascript": "\n    ```javascript\nfunction isSubsequence(s, t) {\n    let si = 0, ti = 0;\n\n    while (si < s.length && ti < t.length) {\n        if (s[si] === t[ti])\n            si++;\n        ti++;\n    }\n\n    return si === s.length;\n}\n```\n\n    \n    We use two pointers to iterate through the strings `s` and `t`. The `si` pointer will be used to iterate through the string `s` and the `ti` pointer will be used for `t`. \n\nAt each iteration of the loop, if the character at the current position of both strings is the same, we increment the `si` pointer. We will always increment the `ti` pointer.\n\nThe loop will continue until we have checked all the characters in the `s` string or until we have checked all the characters in the `t` string. If the `si` pointer is equal to the length of the `s` string, it means we've found all the characters in the `t` string and the function returns true. Otherwise, it returns false.\n\nThis algorithm runs with a time complexity of O(max(n, m)) where n and m are the lengths of the strings s and t, respectively.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"abc\", t = \"ahbgdc\"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s = \"axc\", t = \"ahbgdc\"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abc\",\"ahbgdc\"",
                    "output": "True"
                },
                {
                    "input": "\"axc\",\"ahbgdc\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-60",
        "prompt": "Given two strings `s` and `t`, return `true` _if_ `s` _is a **subsequence** of_ `t`_, or_ `false` _otherwise_.\n\nA **subsequence** of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., `\"ace \"` is a subsequence of `\"abcde \"` while `\"aec \"` is not)."
    },
    "leetcode-benchmark-61": {
        "id": "leetcode-benchmark-61",
        "title": "Binary Watch",
        "difficulty": "Easy",
        "content": {
            "problem": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n*   For example, the below binary watch reads `\"4:51 \"`.\n\nGiven an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n*   For example, `\"01:00 \"` is not valid. It should be `\"1:00 \"`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n*   For example, `\"10:2 \"` is not valid. It should be `\"10:02 \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** turnedOn = 1\n**Output:** \\[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"\\]\n\n",
                "**Example 2:**\n\n**Input:** turnedOn = 9\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= turnedOn <= 10`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> readBinaryWatch(int turnedOn) {\n    List<String> times = new ArrayList<>();\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                times.add(String.format(\"%d:%02d\", h, m));\n            }\n        }\n    }\n    return times;\n}\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> readBinaryWatch(int turnedOn) {\n    vector<string> times;\n    for (int h = 0; h < 12; h++) {\n        for (int m = 0; m < 60; m++) {\n            if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {\n                times.push_back(to_string(h) + (m < 10 ? \":0\" : \":\") + to_string(m));\n            }\n        }\n    }\n    return times;\n}\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "python": "\n    ```python\ndef readBinaryWatch(turnedOn: int):\n    def count_bits(n):\n        return bin(n).count('1')\n\n    times = []\n    for h in range(12):\n        for m in range(60):\n            if count_bits(h) + count_bits(m) == turnedOn:\n                times.append(f\"{h}:{m:02d}\")\n    return times\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "javascript": "\n    ```javascript\nfunction readBinaryWatch(turnedOn) {\n    function countBits(n) {\n        return n.toString(2).split('1').length - 1;\n    }\n\n    const times = [];\n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m < 60; m++) {\n            if (countBits(h) + countBits(m) === turnedOn) {\n                times.push(`${h}:${m.toString().padStart(2, '0')}`);\n            }\n        }\n    }\n    return times;\n}\n```\n    \n    The algorithm consists of enumerating all possible hour values (0-11) and minute values (0-59), and checking the number of bits set in both. We have a helper function `count_bits` (or named similarly) in each language to count the number of bits set in the binary representation of a given value. The function either uses the built-in bit counting function (__builtin_popcount in C++, Integer.bitCount in Java), or in Python and JavaScript, we convert the numbers to binary strings and count the number of '1's. \n\nFor each pair (h, m), if the total number of turned-on LEDs is equal to the given integer `turnedOn`, we add the corresponding formatted string to the result list. In the end, we return the list of all possible times.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " turnedOn = 1",
                    "output": " [\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]",
                    "explanation": null
                },
                {
                    "input": " turnedOn = 9",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1",
                    "output": "[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"]"
                },
                {
                    "input": "9",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-61",
        "prompt": "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n*   For example, the below binary watch reads `\"4:51 \"`.\n\nGiven an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n*   For example, `\"01:00 \"` is not valid. It should be `\"1:00 \"`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n*   For example, `\"10:2 \"` is not valid. It should be `\"10:02 \"`."
    },
    "leetcode-benchmark-62": {
        "id": "leetcode-benchmark-62",
        "title": "Valid Word Abbreviation",
        "difficulty": "Easy",
        "content": {
            "problem": "A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.\n\nFor example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nThe following are **not valid** abbreviations:\n\n*   `\"s55n \"` ( `\"s ubsti tutio n \"`, the replaced substrings are adjacent)\n*   `\"s010n \"` (has leading zeros)\n*   `\"s0ubstitution \"` (replaces an empty substring)\n\nGiven a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.\n\nA **substring** is a contiguous **non-empty** sequence of characters within a string.",
            "examples": [
                "**Example 1:**\n\n**Input:** word =  \"internationalization \", abbr =  \"i12iz4n \"\n**Output:** true\n**Explanation:** The word  \"internationalization \" can be abbreviated as  \"i12iz4n \" ( \"i nternational iz atio n \").\n\n",
                "**Example 2:**\n\n**Input:** word =  \"apple \", abbr =  \"a2e \"\n**Output:** false\n**Explanation:** The word  \"apple \" cannot be abbreviated as  \"a2e \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 20`\n*   `word` consists of only lowercase English letters.\n*   `1 <= abbr.length <= 10`\n*   `abbr` consists of lowercase English letters and digits.\n*   All the integers in `abbr` will fit in a 32-bit integer.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean validWordAbbreviation(String word, String abbr) {\n    int i = 0, j = 0;\n    while (i < word.length() && j < abbr.length()) {\n        if (Character.isDigit(abbr.charAt(j))) {\n            if (abbr.charAt(j) == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.length() && Character.isDigit(abbr.charAt(j)))\n                num = num * 10 + (abbr.charAt(j++) - '0');\n            i += num;\n        } else {\n            if (word.charAt(i++) != abbr.charAt(j++)) return false;\n        }\n    }\n    return i == word.length() && j == abbr.length();\n}\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "c++": "\n    ```cpp\nbool validWordAbbreviation(string word, string abbr) {\n    int i = 0, j = 0;\n    while (i < word.size() && j < abbr.size()) {\n        if (isdigit(abbr[j])) {\n            if (abbr[j] == '0') return false; // leading zero\n            int num = 0;\n            while (j < abbr.size() && isdigit(abbr[j]))\n                num = num * 10 + (abbr[j++] - '0');\n            i += num;\n        } else {\n            if (word[i++] != abbr[j++]) return false;\n        }\n    }\n    return i == word.size() && j == abbr.size();\n}\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "python": "\n    ```python\ndef validWordAbbreviation(word, abbr):\n    i, j = 0, 0\n    while i < len(word) and j < len(abbr):\n        if abbr[j].isdigit():\n            if abbr[j] == '0': return False  # leading zero\n            num = 0\n            while j < len(abbr) and abbr[j].isdigit():\n                num = num * 10 + int(abbr[j])\n                j += 1\n            i += num\n        else:\n            if word[i] != abbr[j]: return False\n            i, j = i + 1, j + 1\n    return i == len(word) and j == len(abbr)\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "javascript": "\n    ```javascript\nfunction validWordAbbreviation(word, abbr) {\n    let i = 0, j = 0;\n    while (i < word.length && j < abbr.length) {\n        if (!isNaN(abbr[j])) {\n            if (abbr[j] === '0') return false; // leading zero\n            let num = 0;\n            while (j < abbr.length && !isNaN(abbr[j])) {\n                num = num * 10 + parseInt(abbr[j]);\n                j++;\n            }\n            i += num;\n        } else {\n            if (word[i] !== abbr[j]) return false;\n            i++; j++;\n        }\n    }\n    return i === word.length && j === abbr.length;\n}\n```\n    \n    The algorithm uses two pointers, i and j, to compare the characters in the word and the abbr. If the current character in abbr is a digit, we check if it's a leading zero and return false if so. Then, we sum all the consecutive digits to calculate the number and update i accordingly. If the current character is a letter, we compare the characters in word and abbr and return false if they're not equal. Finally, we check if we've reached the end of both the word and the abbr and return true if so.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " word =  \"internationalization \", abbr =  \"i12iz4n \"",
                    "output": " True",
                    "explanation": " The word  \"internationalization \" can be abbreviated as  \"i12iz4n \" ( \"i nternational iz atio n \")."
                },
                {
                    "input": " word =  \"apple \", abbr =  \"a2e \"",
                    "output": " False",
                    "explanation": " The word  \"apple \" cannot be abbreviated as  \"a2e \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"internationalization\",\"i12iz4n\"",
                    "output": "True"
                },
                {
                    "input": "\"apple\",\"a2e\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-62",
        "prompt": "A string can be **abbreviated** by replacing any number of **non-adjacent**, **non-empty** substrings with their lengths. The lengths **should not** have leading zeros.\n\nFor example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nThe following are **not valid** abbreviations:\n\n*   `\"s55n \"` ( `\"s ubsti tutio n \"`, the replaced substrings are adjacent)\n*   `\"s010n \"` (has leading zeros)\n*   `\"s0ubstitution \"` (replaces an empty substring)\n\nGiven a string `word` and an abbreviation `abbr`, return _whether the string **matches** the given abbreviation_.\n\nA **substring** is a contiguous **non-empty** sequence of characters within a string."
    },
    "leetcode-benchmark-63": {
        "id": "leetcode-benchmark-63",
        "title": "Longest Palindrome",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` which consists of lowercase or uppercase letters, return _the length of the **longest palindrome**_ that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa \"` is not considered a palindrome here.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abccccdd \"\n**Output:** 7\n**Explanation:** One longest palindrome that can be built is  \"dccaccd \", whose length is 7.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 1\n**Explanation:** The longest palindrome that can be built is  \"a \", whose length is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase **and/or** uppercase English letters only.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int longestPalindrome(String s) {\n    int[] charCount = new int[128];\n    int result = 0;\n    for (char c : s.toCharArray())\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "c++": "\n    ```cpp\nint longestPalindrome(string s) {\n    int charCount[128] = {0};\n    int result = 0;\n    for (char c : s)\n        charCount[c]++;\n    for (int count : charCount) {\n        result += count / 2 * 2;\n        if (result % 2 == 0 && count % 2 == 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "python": "\n    ```python\ndef longestPalindrome(s: str) -> int:\n    charCount = [0] * 128\n    result = 0\n    for c in s:\n        charCount[ord(c)] += 1\n    for count in charCount:\n        result += count // 2 * 2\n        if result % 2 == 0 and count % 2 == 1:\n            result += 1\n    return result\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "javascript": "\n    ```javascript\nfunction longestPalindrome(s) {\n    let charCount = new Array(128).fill(0);\n    let result = 0;\n    for (let c of s)\n        charCount[c.charCodeAt(0)]++;\n    for (let count of charCount) {\n        result += Math.floor(count / 2) * 2;\n        if (result % 2 === 0 && count % 2 === 1)\n            result++;\n    }\n    return result;\n}\n```\n    \n    1. Create an array `charCount` of size 128 (to cover the ASCII range of characters) initialized with zeros.\n2. Iterate through each character in the input string `s` and increment the corresponding count in the `charCount` array.\n3. Initialize a variable `result` to store the length of the longest palindrome to be built.\n4. Iterate through the `charCount` array and for each count, add the count divided by 2 (integer division) times 2 to the `result`. This adds the number of pairs of characters that can be used in the palindrome.\n5. If the result so far is even and the count has an odd value, increment the result by 1. This accounts for the center character in an odd-length palindrome.\n6. Return the final result, which is the length of the longest palindrome that can be built.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"abccccdd \"",
                    "output": " 7",
                    "explanation": " One longest palindrome that can be built is  \"dccaccd \", whose length is 7."
                },
                {
                    "input": " s =  \"a \"",
                    "output": " 1",
                    "explanation": " The longest palindrome that can be built is  \"a \", whose length is 1."
                }
            ],
            "function_input": [
                {
                    "input": "\"abccccdd\"",
                    "output": "7"
                },
                {
                    "input": "\"a\"",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-63",
        "prompt": "Given a string `s` which consists of lowercase or uppercase letters, return _the length of the **longest palindrome**_ that can be built with those letters.\n\nLetters are **case sensitive**, for example, `\"Aa \"` is not considered a palindrome here."
    },
    "leetcode-benchmark-64": {
        "id": "leetcode-benchmark-64",
        "title": "Fizz Buzz",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return _a string array_ `answer` _(**1-indexed**) where_:\n\n*   `answer[i] == \"FizzBuzz \"` if `i` is divisible by `3` and `5`.\n*   `answer[i] == \"Fizz \"` if `i` is divisible by `3`.\n*   `answer[i] == \"Buzz \"` if `i` is divisible by `5`.\n*   `answer[i] == i` (as a string) if none of the above conditions are true.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"1\",\"2\",\"Fizz\"\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** \\[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 15\n**Output:** \\[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic ArrayList<String> fizzBuzz(int n) {\n    ArrayList<String> result = new ArrayList<>();\n    for (int i = 1; i <= n; i++) {\n        if (i % 15 == 0) result.add(\"FizzBuzz\");\n        else if (i % 3 == 0) result.add(\"Fizz\");\n        else if (i % 5 == 0) result.add(\"Buzz\");\n        else result.add(Integer.toString(i));\n    }\n    return result;\n}\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> fizzBuzz(int n) {\n    std::vector<std::string> result(n);\n    for(int i = 1; i <= n; ++i) {\n        if (i % 15 == 0) result[i - 1] = \"FizzBuzz\";\n        else if (i % 3 == 0) result[i - 1] = \"Fizz\";\n        else if (i % 5 == 0) result[i - 1] = \"Buzz\";\n        else result[i - 1] = std::to_string(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "python": "\n    ```python\ndef fizzBuzz(n):\n    result = []\n    for i in range(1, n + 1):\n        if i % 15 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "javascript": "\n    ```javascript\nfunction fizzBuzz(n) {\n    let result = [];\n    for (let i = 1; i <= n; i++) {\n        if (i % 15 === 0) result.push(\"FizzBuzz\");\n        else if (i % 3 === 0) result.push(\"Fizz\");\n        else if (i % 5 === 0) result.push(\"Buzz\");\n        else result.push(String(i));\n    }\n    return result;\n}\n```\n    \n    The algorithm for this problem simply consists of iterating over the integers from 1 to n, checking the divisibility rules for FizzBuzz, and inserting the appropriate string into the array for each index. For each number i in the range [1,n], we check if it's divisible by 3 and 5 (i % 15 == 0), just 3 (i % 3 == 0), just 5 (i % 5 == 0), or none of the above. Based on the conditions met, we append the corresponding string to the array (i.e., \"FizzBuzz\", \"Fizz\", \"Buzz\", or the number itself as a string).\n\nThe code implementations in each language follow their respective syntax, but the core logic is the same across all languages.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " [\"1\",\"2\",\"Fizz\"]",
                    "explanation": null
                },
                {
                    "input": " n = 5",
                    "output": " [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
                    "explanation": null
                },
                {
                    "input": " n = 15",
                    "output": " [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "[\"1\",\"2\",\"Fizz\"]"
                },
                {
                    "input": "5",
                    "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                },
                {
                    "input": "15",
                    "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-64",
        "prompt": "Given an integer `n`, return _a string array_ `answer` _(**1-indexed**) where_:\n\n*   `answer[i] == \"FizzBuzz \"` if `i` is divisible by `3` and `5`.\n*   `answer[i] == \"Fizz \"` if `i` is divisible by `3`.\n*   `answer[i] == \"Buzz \"` if `i` is divisible by `5`.\n*   `answer[i] == i` (as a string) if none of the above conditions are true."
    },
    "leetcode-benchmark-65": {
        "id": "leetcode-benchmark-65",
        "title": "Third Maximum Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the **third distinct maximum** number in this array. If the third maximum does not exist, return the **maximum** number_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** 2\n**Explanation:**\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,2,3,1\\]\n**Output:** 1\n**Explanation:**\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Can you find an `O(n)` solution?"
        },
        "java": "\n    ```java\nimport java.util.TreeSet;\n\npublic int thirdMax(int[] nums) {\n    TreeSet<Integer> top3 = new TreeSet<>();\n    for (int num : nums) {\n        top3.add(num);\n        if (top3.size() > 3) {\n            top3.remove(top3.first());\n        }\n    }\n    return top3.size() == 3 ? top3.first() : top3.last();\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n\nint thirdMax(vector<int>& nums) {\n    set<int> top3;\n    for (int num : nums) {\n        top3.insert(num);\n        if (top3.size() > 3) {\n            top3.erase(top3.begin());\n        }\n    }\n    return top3.size() == 3 ? *top3.begin() : *top3.rbegin();\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "python": "\n    ```python\ndef third_max(nums):\n    top3 = set()\n    for num in nums:\n        top3.add(num)\n        if len(top3) > 3:\n            top3.remove(min(top3))\n    return min(top3) if len(top3) == 3 else max(top3)\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "javascript": "\n    ```javascript\nfunction thirdMax(nums) {\n    const top3 = new Set();\n    for (const num of nums) {\n        top3.add(num);\n        if (top3.size > 3) {\n            top3.delete(Math.min(...top3));\n        }\n    }\n    return top3.size === 3 ? Math.min(...top3) : Math.max(...top3);\n}\n```\n    \n    The algorithm to solve the problem is as follows:\n1. Initialize an empty set called `top3` to keep track of the top 3 distinct maximum numbers in the array.\n2. Iterate through the input array, `nums`.\n3. For each number in `nums`, insert it into `top3`.\n4. If the size of `top3` becomes greater than 3, remove the smallest number in `top3`.\n5. If the size of `top3` is 3, which means there are three distinct maximum numbers, return the smallest number in `top3`. Otherwise, return the largest number in `top3`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,2,1]",
                    "output": " 1",
                    "explanation": "\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1."
                },
                {
                    "input": " nums = [1,2]",
                    "output": " 2",
                    "explanation": "\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead."
                },
                {
                    "input": " nums = [2,2,3,1]",
                    "output": " 1",
                    "explanation": "\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,1]",
                    "output": "1"
                },
                {
                    "input": "[1,2]",
                    "output": "2"
                },
                {
                    "input": "[2,2,3,1]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-65",
        "prompt": "Given an integer array `nums`, return _the **third distinct maximum** number in this array. If the third maximum does not exist, return the **maximum** number_."
    },
    "leetcode-benchmark-66": {
        "id": "leetcode-benchmark-66",
        "title": "Add Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two non-negative integers, `num1` and `num2` represented as string, return _the sum of_ `num1` _and_ `num2` _as a string_.\n\nYou must solve the problem without using any built-in library for handling large integers (such as `BigInteger`). You must also not convert the inputs to integers directly.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 =  \"11 \", num2 =  \"123 \"\n**Output:**  \"134 \"\n\n",
                "**Example 2:**\n\n**Input:** num1 =  \"456 \", num2 =  \"77 \"\n**Output:**  \"533 \"\n\n",
                "**Example 3:**\n\n**Input:** num1 =  \"0 \", num2 =  \"0 \"\n**Output:**  \"0 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 104`\n*   `num1` and `num2` consist of only digits.\n*   `num1` and `num2` don't have any leading zeros except for the zero itself.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String addStrings(String num1, String num2) {\n    int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n    StringBuilder result = new StringBuilder();\n\n    while (i >= 0 || j >= 0 || carry != 0) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1.charAt(i) - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2.charAt(j) - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.append(sum % 10);\n    }\n\n    return result.reverse().toString();\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "c++": "\n    ```cpp\nstd::string addStrings(std::string num1, std::string num2) {\n    int i = num1.size() - 1, j = num2.size() - 1, carry = 0;\n    std::string result;\n\n    while (i >= 0 || j >= 0 || carry) {\n        int sum = carry;\n\n        if (i >= 0) {\n            sum += num1[i] - '0';\n            --i;\n        }\n        if (j >= 0) {\n            sum += num2[j] - '0';\n            --j;\n        }\n\n        carry = sum / 10;\n        result.push_back(sum % 10 + '0');\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "python": "\n    ```python\ndef addStrings(num1: str, num2: str) -> str:\n    i, j, carry, result = len(num1) - 1, len(num2) - 1, 0, []\n\n    while i >= 0 or j >= 0 or carry:\n        sum = carry\n\n        if i >= 0:\n            sum += int(num1[i])\n            i -= 1\n        if j >= 0:\n            sum += int(num2[j])\n            j -= 1\n\n        carry = sum // 10\n        result.append(str(sum % 10))\n\n    return ''.join(result[::-1])\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "javascript": "\n    ```javascript\nfunction addStrings(num1, num2) {\n    let i = num1.length - 1, j = num2.length - 1, carry = 0;\n    let result = [];\n\n    while (i >= 0 || j >= 0 || carry) {\n        let sum = carry;\n\n        if (i >= 0) {\n            sum += parseInt(num1[i]);\n            --i;\n        }\n        if (j >= 0) {\n            sum += parseInt(num2[j]);\n            --j;\n        }\n\n        carry = Math.floor(sum / 10);\n        result.push(sum % 10);\n    }\n\n    return result.reverse().join('');\n}\n```\n\n    \n    1. Initialize pointers `i` and `j` to the end of `num1` and `num2`, a `carry` variable to 0, and an empty `result` container.\n2. While there are still digits to process or a carry to propagate:\n   a. Initialize a `sum` variable with the current carry.\n   b. Add the current digits from num`1[i]` and `num2[j]` to `sum` if exist, decreasing `i` and `j` respectively after each addition.\n   c. Update the value of `carry` to be the integer division of `sum` by 10.\n   d. Add the value of `sum % 10` to the `result` container.\n3. Return the reversed `result` container as a string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num1 =  \"11 \", num2 =  \"123 \"",
                    "output": "  \"134 \"",
                    "explanation": null
                },
                {
                    "input": " num1 =  \"456 \", num2 =  \"77 \"",
                    "output": "  \"533 \"",
                    "explanation": null
                },
                {
                    "input": " num1 =  \"0 \", num2 =  \"0 \"",
                    "output": "  \"0 \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"11\",\"123\"",
                    "output": "\"134\""
                },
                {
                    "input": "\"456\",\"77\"",
                    "output": "\"533\""
                },
                {
                    "input": "\"0\",\"0\"",
                    "output": "\"0\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-66",
        "prompt": "Given two non-negative integers, `num1` and `num2` represented as string, return _the sum of_ `num1` _and_ `num2` _as a string_.\n\nYou must solve the problem without using any built-in library for handling large integers (such as `BigInteger`). You must also not convert the inputs to integers directly."
    },
    "leetcode-benchmark-67": {
        "id": "leetcode-benchmark-67",
        "title": "Valid Word Square",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `words`, return `true` _if it forms a valid **word square**_.\n\nA sequence of strings forms a valid **word square** if the `kth` row and column read the same string, where `0 <= k < max(numRows, numColumns)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abcd \", \"bnrt \", \"crmy \", \"dtye \"\\]\n**Output:** true\n**Explanation:**\nThe 1st row and 1st column both read  \"abcd \".\nThe 2nd row and 2nd column both read  \"bnrt \".\nThe 3rd row and 3rd column both read  \"crmy \".\nThe 4th row and 4th column both read  \"dtye \".\nTherefore, it is a valid word square.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"abcd \", \"bnrt \", \"crm \", \"dt \"\\]\n**Output:** true\n**Explanation:**\nThe 1st row and 1st column both read  \"abcd \".\nThe 2nd row and 2nd column both read  \"bnrt \".\nThe 3rd row and 3rd column both read  \"crm \".\nThe 4th row and 4th column both read  \"dt \".\nTherefore, it is a valid word square.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"ball \", \"area \", \"read \", \"lady \"\\]\n**Output:** false\n**Explanation:**\nThe 3rd row reads  \"read \" while the 3rd column reads  \"lead \".\nTherefore, it is NOT a valid word square."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 500`\n*   `1 <= words[i].length <= 500`\n*   `words[i]` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean validWordSquare(List<String> words) {\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = 0; j < words.get(i).length(); j++) {\n            if (j >= words.size() || i >= words.get(j).length() || words.get(i).charAt(j) != words.get(j).charAt(i)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "c++": "\n    ```cpp\nbool validWordSquare(vector<string>& words) {\n    for (int i = 0; i < words.size(); ++i) {\n        for (int j = 0; j < words[i].size(); ++j) {\n            if (j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "python": "\n    ```python\ndef valid_word_square(words):\n    for i in range(len(words)):\n        for j in range(len(words[i])):\n            if j >= len(words) or i >= len(words[j]) or words[i][j] != words[j][i]:\n                return False\n    return True\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "javascript": "\n    ```javascript\nfunction validWordSquare(words) {\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words[i].length; j++) {\n            if (j >= words.length || i >= words[j].length || words[i][j] !== words[j][i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    This solution is based on validating the elements of an array in place. Loop through each row `i` and column `j` of the given array. In the inner loop, check if the condition `j >= words.size() || i >= words[j].size() || words[i][j] != words[j][i]` is true. If the condition is true, that means it's not a valid word square, so return false. If the loop completes without returning false, then it's a valid word square, so return true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"abcd \", \"bnrt \", \"crmy \", \"dtye \"]",
                    "output": " True",
                    "explanation": "\nThe 1st row and 1st column both read  \"abcd \".\nThe 2nd row and 2nd column both read  \"bnrt \".\nThe 3rd row and 3rd column both read  \"crmy \".\nThe 4th row and 4th column both read  \"dtye \".\nTherefore, it is a valid word square."
                },
                {
                    "input": " words = [ \"abcd \", \"bnrt \", \"crm \", \"dt \"]",
                    "output": " True",
                    "explanation": "\nThe 1st row and 1st column both read  \"abcd \".\nThe 2nd row and 2nd column both read  \"bnrt \".\nThe 3rd row and 3rd column both read  \"crm \".\nThe 4th row and 4th column both read  \"dt \".\nTherefore, it is a valid word square."
                },
                {
                    "input": " words = [ \"ball \", \"area \", \"read \", \"lady \"]",
                    "output": " False",
                    "explanation": "\nThe 3rd row reads  \"read \" while the 3rd column reads  \"lead \".\nTherefore, it is NOT a valid word square."
                }
            ],
            "function_input": [
                {
                    "input": "[\"abcd\",\"bnrt\",\"crmy\",\"dtye\"]",
                    "output": "True"
                },
                {
                    "input": "[\"abcd\",\"bnrt\",\"crm\",\"dt\"]",
                    "output": "True"
                },
                {
                    "input": "[\"ball\",\"area\",\"read\",\"lady\"]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-67",
        "prompt": "Given an array of strings `words`, return `true` _if it forms a valid **word square**_.\n\nA sequence of strings forms a valid **word square** if the `kth` row and column read the same string, where `0 <= k < max(numRows, numColumns)`."
    },
    "leetcode-benchmark-68": {
        "id": "leetcode-benchmark-68",
        "title": "Number of Segments in a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the number of segments in the string_.\n\nA **segment** is defined to be a contiguous sequence of **non-space characters**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello, my name is John \"\n**Output:** 5\n**Explanation:** The five segments are \\[ \"Hello, \",  \"my \",  \"name \",  \"is \",  \"John \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"Hello \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 300`\n*   `s` consists of lowercase and uppercase English letters, digits, or one of the following characters `\"!@#$%^&*()_+-=',.: \"`.\n*   The only space character in `s` is `' '`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countSegments(String s) {\n    if (s == null || s.trim().length() == 0) {\n        return 0;\n    }\n    String[] segments = s.trim().split(\"\\\\s+\");\n    return segments.length;\n}\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n\nint countSegments(const std::string& s) {\n    std::stringstream ss(s);\n    int count = 0;\n    std::string temp;\n\n    while (ss >> temp) {\n        ++count;\n    }\n\n    return count;\n}\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "python": "\n    ```python\ndef count_segments(s: str) -> int:\n    return len(s.split())\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "javascript": "\n    ```javascript\nfunction countSegments(s) {\n    if (!s || s.trim().length === 0) {\n        return 0;\n    }\n    const segments = s.trim().split(/\\s+/);\n    return segments.length;\n}\n```\n    \n    The algorithm goes as follows:\n\n1. Remove leading and trailing spaces from the input string.\n2. Split the string on any whitespace into an array or list.\n3. Return the length of the resulting array or list, which corresponds to the number of segments in the input string.\n\nIn C++, the `std::stringstream` is used to read words separated by spaces with the `>>` operator. Java and JavaScript use a regex to match any whitespace, and Python has a built-in `split()` method that splits on any whitespace by default.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"Hello, my name is John \"",
                    "output": " 5",
                    "explanation": " The five segments are \\[ \"Hello, \",  \"my \",  \"name \",  \"is \",  \"John \"\\]"
                },
                {
                    "input": " s =  \"Hello \"",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"Hello,",
                    "output": "5"
                },
                {
                    "input": "\"Hello\"",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-68",
        "prompt": "Given a string `s`, return _the number of segments in the string_.\n\nA **segment** is defined to be a contiguous sequence of **non-space characters**."
    },
    "leetcode-benchmark-69": {
        "id": "leetcode-benchmark-69",
        "title": "Arranging Coins",
        "difficulty": "Easy",
        "content": {
            "problem": "You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.\n\nGiven the integer `n`, return _the number of **complete rows** of the staircase you will build_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** Because the 3rd row is incomplete, we return 2.\n\n",
                "**Example 2:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** Because the 4th row is incomplete, we return 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "c++": "\n    ```cpp\nint arrangeCoins(int n) {\n    int k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "python": "\n    ```python\ndef arrange_coins(n: int) -> int:\n    k = 0\n    while n > k:\n        k += 1\n        n -= k\n    return k\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "javascript": "\n    ```javascript\nfunction arrangeCoins(n) {\n    let k = 0;\n    while (n > k) {\n        k++;\n        n -= k;\n    }\n    return k;\n}\n```\n    \n    The algorithm initializes a variable k, which represents the current row number, to 0. Then it enters a loop where it checks if n is greater than k. If so, it increments k by 1 and subtracts k from n. This process continues until n is no longer greater than k. Finally, the value of k is returned, representing the number of complete rows of the staircase. This approach has a time complexity of O(sqrt(n)) since the number of iterations increases linearly with the size of the staircase.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5",
                    "output": " 2",
                    "explanation": " Because the 3rd row is incomplete, we return 2."
                },
                {
                    "input": " n = 8",
                    "output": " 3",
                    "explanation": " Because the 4th row is incomplete, we return 3."
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "2"
                },
                {
                    "input": "8",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-69",
        "prompt": "You have `n` coins and you want to build a staircase with these coins. The staircase consists of `k` rows where the `ith` row has exactly `i` coins. The last row of the staircase **may be** incomplete.\n\nGiven the integer `n`, return _the number of **complete rows** of the staircase you will build_."
    },
    "leetcode-benchmark-70": {
        "id": "leetcode-benchmark-70",
        "title": "Find All Numbers Disappeared in an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return _an array of all the integers in the range_ `[1, n]` _that do not appear in_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,7,8,2,3,1\\]\n**Output:** \\[5,6\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= n`\n\n**",
            "follow_up": "Follow up:** Could you do it without extra space and in `O(n)` runtime? You may assume the returned list does not count as extra space."
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDisappearedNumbers(int[] nums) {\n    List<Integer> result = new ArrayList<>();\n    \n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.add(i + 1);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findDisappearedNumbers(vector<int> &nums) {\n    vector<int> result;\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        int index = abs(nums[i]) - 1;\n        nums[index] = -abs(nums[index]);\n    }\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "python": "\n    ```python\ndef find_disappeared_numbers(nums):\n    result = []\n    \n    for num in nums:\n        index = abs(num) - 1\n        nums[index] = -abs(nums[index])\n\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n\n    return result\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "javascript": "\n    ```javascript\nfunction findDisappearedNumbers(nums) {\n    const result = [];\n\n    for (let i = 0; i < nums.length; i++) {\n        const index = Math.abs(nums[i]) - 1;\n        nums[index] = -Math.abs(nums[index]);\n    }\n\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. Iterate through the input array.\n2. For each value `nums[i]`, find its index by subtracting 1 (`index = abs(nums[i]) - 1`). This is because the integers in the range are 1 to n, and indices are 0-indexed.\n3. Negate the value at this index (`nums[index] = -abs(nums[index])`). This marks the value as \"found\".\n4. Iterate through the modified array.\n5. If a value is positive, it means the integer corresponding to that index hasn't been found. Add it to the result array.\n\nThis algorithm has a time complexity of O(n) and doesn't use any additional space other than the result array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [4,3,2,7,8,2,3,1]",
                    "output": " [5,6]",
                    "explanation": null
                },
                {
                    "input": " nums = [1,1]",
                    "output": " [2]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[4,3,2,7,8,2,3,1]",
                    "output": "[5,6]"
                },
                {
                    "input": "[1,1]",
                    "output": "[2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-70",
        "prompt": "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return _an array of all the integers in the range_ `[1, n]` _that do not appear in_ `nums`."
    },
    "leetcode-benchmark-71": {
        "id": "leetcode-benchmark-71",
        "title": "Assign Cookies",
        "difficulty": "Easy",
        "content": {
            "problem": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number.",
            "examples": [
                "**Example 1:**\n\n**Input:** g = \\[1,2,3\\], s = \\[1,1\\]\n**Output:** 1\n**Explanation:** You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n\n",
                "**Example 2:**\n\n**Input:** g = \\[1,2\\], s = \\[1,2,3\\]\n**Output:** 2\n**Explanation:** You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= g.length <= 3 * 104`\n*   `0 <= s.length <= 3 * 104`\n*   `1 <= g[i], s[j] <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int findContentChildren(int[] g, int[] s) {\n    Arrays.sort(g);\n    Arrays.sort(s);\n    int i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint findContentChildren(std::vector<int>& g, std::vector<int>& s) {\n    std::sort(g.begin(), g.end());\n    std::sort(s.begin(), s.end());\n    int i = 0, j = 0;\n\n    while (i < g.size() && j < s.size()) {\n      if (s[j] >= g[i]) {\n        i++;\n      }\n\n      j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "python": "\n    ```python\ndef find_content_children(g, s):\n    g.sort()\n    s.sort()\n    i = j = 0\n\n    while i < len(g) and j < len(s):\n        if s[j] >= g[i]:\n            i += 1\n\n        j += 1\n\n    return i\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "javascript": "\n    ```javascript\nfunction findContentChildren(g, s) {\n    g.sort((a, b) => a - b);\n    s.sort((a, b) => a - b);\n    let i = 0, j = 0;\n\n    while (i < g.length && j < s.length) {\n        if (s[j] >= g[i]) {\n            i++;\n        }\n\n        j++;\n    }\n\n    return i;\n}\n```\n\n    \n    The algorithm first sorts both the greed factors of children `g` and the sizes of cookies `s`. Next, two pointers are declared, `i` for the greed factors and `j` for the cookies. \nThe algorithm then iterates through the sorted lists in parallel using a while loop until either the greed factors or the cookies run out. Inside the loop, we check if the current cookie `s[j]` is greater than or equal to the current greed factor `g[i]`. If it is, that means the child is content and we increment the `i` pointer to the next child. In both cases (whether the child is content or not), we move on to the next cookie by incrementing the `j` pointer.\nThe algorithm returns the number of content children (`i`) once the loop is done.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " g = [1,2,3], s = [1,1]",
                    "output": " 1",
                    "explanation": " You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. \nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1."
                },
                {
                    "input": " g = [1,2], s = [1,2,3]",
                    "output": " 2",
                    "explanation": " You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. \nYou have 3 cookies and their sizes are big enough to gratify all of the children, \nYou need to output 2."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3],[1,1]",
                    "output": "1"
                },
                {
                    "input": "[1,2],[1,2,3]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-71",
        "prompt": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\nEach child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with; and each cookie `j` has a size `s[j]`. If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`, and the child `i` will be content. Your goal is to maximize the number of your content children and output the maximum number."
    },
    "leetcode-benchmark-72": {
        "id": "leetcode-benchmark-72",
        "title": "Repeated Substring Pattern",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abab \"\n**Output:** true\n**Explanation:** It is the substring  \"ab \" twice.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abcabcabcabc \"\n**Output:** true\n**Explanation:** It is the substring  \"abc \" four times or the substring  \"abcabc \" twice."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canConstruct(String s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            String substr = s.substring(0, i);\n            boolean flag = true;\n            for (int j = i; j < n; j += i) {\n                if (!s.substring(j, j + i).equals(substr)) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool can_construct(string s) {\n    int n = s.size();\n    for (int i = n / 2; i > 0; --i) {\n        if (n % i == 0) {\n            string substr = s.substr(0, i);\n            bool flag = true;\n            for (int j = i; j < n; j += i) {\n                if (s.substr(j, i) != substr) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "python": "\n    ```python\ndef can_construct(s):\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            substr = s[:i]\n            flag = True\n            for j in range(i, n, i):\n                if s[j:j+i] != substr:\n                    flag = False\n                    break\n\n            if flag:\n                return True\n\n    return False\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction canConstruct(s) {\n    const n = s.length;\n    for (let i = Math.floor(n / 2); i > 0; --i) {\n        if (n % i === 0) {\n            const substr = s.substring(0, i);\n            let flag = true;\n            for (let j = i; j < n; j += i) {\n                if (s.substring(j, j + i) !== substr) {\n                    flag = false;\n                    break;\n                }\n            }\n\n            if (flag) return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm iterates through possible substring lengths from half of the length of the given string down to 1 (inclusive). For each length `i`, it checks if the given string can be divided into substrings of equal length `i`. If yes, it takes the first substring and checks if all the remaining substrings of the same length are equal to the first one.\n\nIf all the substrings are equal, the function returns `true`, meaning the given string can be constructed by appending multiple copies of the substring together. If none of the lengths results in equal substrings, the function returns `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"abab \"",
                    "output": " True",
                    "explanation": " It is the substring  \"ab \" twice."
                },
                {
                    "input": " s =  \"aba \"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " s =  \"abcabcabcabc \"",
                    "output": " True",
                    "explanation": " It is the substring  \"abc \" four times or the substring  \"abcabc \" twice."
                }
            ],
            "function_input": [
                {
                    "input": "\"abab\"",
                    "output": "True"
                },
                {
                    "input": "\"aba\"",
                    "output": "False"
                },
                {
                    "input": "\"abcabcabcabc\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-72",
        "prompt": "Given a string `s`, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together."
    },
    "leetcode-benchmark-73": {
        "id": "leetcode-benchmark-73",
        "title": "Hamming Distance",
        "difficulty": "Easy",
        "content": {
            "problem": "The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers `x` and `y`, return _the **Hamming distance** between them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 1, y = 4\n**Output:** 2\n**Explanation:**\n1   (0 0 0 1)\n4   (0 1 0 0)\n          \nThe above arrows point to positions where the corresponding bits are different.\n\n",
                "**Example 2:**\n\n**Input:** x = 3, y = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= x, y <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "c++": "\n    ```cpp\nint hammingDistance(int x, int y) {\n    int dist = 0, xorResult = x ^ y;\n    while (xorResult) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "python": "\n    ```python\ndef hammingDistance(x: int, y: int) -> int:\n    xorResult = x ^ y\n    dist = 0\n    while xorResult:\n        dist += xorResult & 1\n        xorResult >>= 1\n    return dist\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "javascript": "\n    ```javascript\nfunction hammingDistance(x, y) {\n    let dist = 0;\n    let xorResult = x ^ y;\n    while (xorResult != 0) {\n        dist += xorResult & 1;\n        xorResult >>= 1;\n    }\n    return dist;\n}\n```\n    \n    We can start by taking the XOR of `x` and `y`. A XOR B value will have a bit set only if both A and B bits are different at that position. We then iterate through the bits of the XOR result, counting the number of set bits, which should give us the Hamming distance required.\n\n1. Calculate `xorResult` by XORing `x` and `y`.\n2. Initialize `dist` to 0.\n3. While `xorResult` is not 0, do the following:\n   a. Add the least significant bit of `xorResult` to `dist`.\n   b. Right shift `xorResult` by 1.\n4. Return `dist`.\n\nThis algorithm performs bitwise operations and loops through the bits of `xorResult`, which has a maximum of 31 bits due to the constraint `0 <= x, y <= 2^31 - 1`. Thus, the time complexity is O(31) = O(1).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " x = 1, y = 4",
                    "output": " 2",
                    "explanation": "\n1   (0 0 0 1)\n4   (0 1 0 0)\n          \nThe above arrows point to positions where the corresponding bits are different."
                },
                {
                    "input": " x = 3, y = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,4",
                    "output": "2"
                },
                {
                    "input": "3,1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-73",
        "prompt": "The [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance) between two integers is the number of positions at which the corresponding bits are different.\n\nGiven two integers `x` and `y`, return _the **Hamming distance** between them_."
    },
    "leetcode-benchmark-74": {
        "id": "leetcode-benchmark-74",
        "title": "Island Perimeter",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int islandPerimeter(int[][] grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.length; row++) {\n        for (int col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "c++": "\n    ```cpp\nint islandPerimeter(vector<vector<int>>& grid) {\n    int perimeter = 0;\n    for (int row = 0; row < grid.size(); row++) {\n        for (int col = 0; col < grid[row].size(); col++) {\n            if (grid[row][col] == 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] == 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] == 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "python": "\n    ```python\ndef islandPerimeter(grid):\n    perimeter = 0\n    for row in range(len(grid)):\n        for col in range(len(grid[row])):\n            if grid[row][col] == 1:\n                perimeter += 4\n                if row > 0 and grid[row - 1][col] == 1:\n                    perimeter -= 2\n                if col > 0 and grid[row][col - 1] == 1:\n                    perimeter -= 2\n    return perimeter\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "javascript": "\n    ```javascript\nfunction islandPerimeter(grid) {\n    let perimeter = 0;\n    for (let row = 0; row < grid.length; row++) {\n        for (let col = 0; col < grid[row].length; col++) {\n            if (grid[row][col] === 1) {\n                perimeter += 4;\n                if (row > 0 && grid[row - 1][col] === 1) perimeter -= 2;\n                if (col > 0 && grid[row][col - 1] === 1) perimeter -= 2;\n            }\n        }\n    }\n    return perimeter;\n}\n```\n    \n    The algorithm iterates through each cell in the grid. If a cell contains land, increment the perimeter count by 4 (each side of the square). If there is land in the adjacent cell to the left or above, decrement the perimeter count by 2 for each adjacent land cell as they share a common side. This way, we can calculate the total perimeter of the island without any extra data structures or recursion.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]",
                    "output": " 16",
                    "explanation": " The perimeter is the 16 yellow stripes in the image above."
                },
                {
                    "input": " grid = [[1]]",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " grid = [[1,0]]",
                    "output": " 4",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]",
                    "output": "16"
                },
                {
                    "input": "[[1]]",
                    "output": "4"
                },
                {
                    "input": "[[1,0]]",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-74",
        "prompt": "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island."
    },
    "leetcode-benchmark-75": {
        "id": "leetcode-benchmark-75",
        "title": "Number Complement",
        "difficulty": "Easy",
        "content": {
            "problem": "The **complement** of an integer is the integer you get when you flip all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n*   For example, The integer `5` is `\"101 \"` in binary and its **complement** is `\"010 \"` which is the integer `2`.\n\nGiven an integer `num`, return _its complement_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 5\n**Output:** 2\n**Explanation:** The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.\n\n",
                "**Example 2:**\n\n**Input:** num = 1\n**Output:** 0\n**Explanation:** The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num < 231`\n\n**Note:** This question is the same as 1009: [https://leetcode.com/problems/complement-of-base-10-integer/](https://leetcode.com/problems/complement-of-base-10-integer/)",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "c++": "\n    ```cpp\nint findComplement(int num) {\n    int bitLength = 0;\n    int mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    int allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "python": "\n    ```python\ndef find_complement(num: int) -> int:\n    bit_length = 0\n    mask = num\n    while mask > 0:\n        mask >>= 1\n        bit_length += 1\n    all_ones = (1 << bit_length) - 1\n\n    return num ^ all_ones\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "javascript": "\n    ```javascript\nfunction findComplement(num) {\n    let bitLength = 0;\n    let mask = num;\n    while (mask > 0) {\n        mask >>= 1;\n        bitLength++;\n    }\n    const allOnes = (1 << bitLength) - 1;\n\n    return num ^ allOnes;\n}\n```\n    \n    First, we calculate the number of bits in the binary representation of the input integer `num`. We do this by consecutively right-shifting the number (bitwise operation) and counting the iterations until the number becomes 0. This gives us the length of the binary representation.\n\nOnce we have the length, we create a bitmask of the same length with all bits set to 1 (for example, if the length is 3, the bitmask would be 111 in binary). To get the complement of the input integer, we then XOR (`^` operator) the number with this all-1 mask. The XOR operation returns 1 when the input bits are different and 0 when they are the same, so if we have a 0 in the input, we will get 1 and vice versa. This way, we get the complement of the original number.\n\nFinally, we return the resulting number, which is the complement of the input integer `num`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num = 5",
                    "output": " 2",
                    "explanation": " The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2."
                },
                {
                    "input": " num = 1",
                    "output": " 0",
                    "explanation": " The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "2"
                },
                {
                    "input": "1",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-75",
        "prompt": "The **complement** of an integer is the integer you get when you flip all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n*   For example, The integer `5` is `\"101 \"` in binary and its **complement** is `\"010 \"` which is the integer `2`.\n\nGiven an integer `num`, return _its complement_."
    },
    "leetcode-benchmark-76": {
        "id": "leetcode-benchmark-76",
        "title": "License Key Formatting",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a license key represented as a string `s` that consists of only alphanumeric characters and dashes. The string is separated into `n + 1` groups by `n` dashes. You are also given an integer `k`.\n\nWe want to reformat the string `s` such that each group contains exactly `k` characters, except for the first group, which could be shorter than `k` but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\nReturn _the reformatted license key_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"5F3Z-2e-9-w \", k = 4\n**Output:**  \"5F3Z-2E9W \"\n**Explanation:** The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"2-5g-3-J \", k = 2\n**Output:**  \"2-5G-3J \"\n**Explanation:** The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of English letters, digits, and dashes `'-'`.\n*   `1 <= k <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String licenseKeyFormatting(String s, int k) {\n    StringBuilder result = new StringBuilder();\n    int count = 0;\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s.charAt(i) != '-') {\n            if (count == k) {\n                result.append('-');\n                count = 0;\n            }\n            result.append(Character.toUpperCase(s.charAt(i)));\n            count++;\n        }\n    }\n    return result.reverse().toString();\n}\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <string>\nusing namespace std;\n\nstring licenseKeyFormatting(string s, int k) {\n    string result = \"\";\n    int count = 0;\n    for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] != '-') {\n            if (count == k) {\n                result.push_back('-');\n                count = 0;\n            }\n            result.push_back(toupper(s[i]));\n            count++;\n        }\n    }\n    reverse(result.begin(), result.end());\n    return result;\n}\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "python": "\n    ```python\ndef license_key_formatting(s: str, k: int) -> str:\n    result = []\n    count = 0\n    for c in reversed(s):\n        if c != '-':\n            if count == k:\n                result.append('-')\n                count = 0\n            result.append(c.upper())\n            count += 1\n    return ''.join(reversed(result))\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "javascript": "\n    ```javascript\nfunction licenseKeyFormatting(s, k) {\n    let result = '';\n    let count = 0;\n    for (let i = s.length - 1; i >= 0; i--) {\n        if (s[i] !== '-') {\n            if (count === k) {\n                result = '-' + result;\n                count = 0;\n            }\n            result = s[i].toUpperCase() + result;\n            count++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm starts by iterating the string s from the end to the beginning, skipping the dashes. During the iteration, we check whether the current group has reached k characters. If so, we append a dash to the result string. We then add the current character, converting it to uppercase, to the result string. After the iteration, we reverse the result string for C++, Java, and Python implementations (for JavaScript, we prepend characters so no need to reverse in the end). This is because we built the reformatted license key in reverse order. Finally, we return the result string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"5F3Z-2e-9-w \", k = 4",
                    "output": "  \"5F3Z-2E9W \"",
                    "explanation": " The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed."
                },
                {
                    "input": " s =  \"2-5g-3-J \", k = 2",
                    "output": "  \"2-5G-3J \"",
                    "explanation": " The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above."
                }
            ],
            "function_input": [
                {
                    "input": "\"5F3Z-2e-9-w\",4",
                    "output": "\"5F3Z-2E9W\""
                },
                {
                    "input": "\"2-5g-3-J\",2",
                    "output": "\"2-5G-3J\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-76",
        "prompt": "You are given a license key represented as a string `s` that consists of only alphanumeric characters and dashes. The string is separated into `n + 1` groups by `n` dashes. You are also given an integer `k`.\n\nWe want to reformat the string `s` such that each group contains exactly `k` characters, except for the first group, which could be shorter than `k` but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\nReturn _the reformatted license key_."
    },
    "leetcode-benchmark-77": {
        "id": "leetcode-benchmark-77",
        "title": "Max Consecutive Ones",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,0,1,1,1\\]\n**Output:** 3\n**Explanation:** The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,0,1,1,0,1\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findMaxConsecutiveOnes(int[] nums) {\n    int maxConsecutive = 0, currentConsecutive = 0;\n    for (int num : nums) {\n        currentConsecutive = (num == 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "c++": "\n    ```cpp\nint findMaxConsecutiveOnes(vector<int>& nums) {\n    int max_consecutive = 0, current_consecutive = 0;\n    for (int num : nums) {\n        current_consecutive = (num == 1) ? current_consecutive + 1 : 0;\n        max_consecutive = max(max_consecutive, current_consecutive);\n    }\n    return max_consecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "python": "\n    ```python\ndef findMaxConsecutiveOnes(nums):\n    max_consecutive, current_consecutive = 0, 0\n    for num in nums:\n        current_consecutive = current_consecutive + 1 if num == 1 else 0\n        max_consecutive = max(max_consecutive, current_consecutive)\n    return max_consecutive\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "javascript": "\n    ```javascript\nfunction findMaxConsecutiveOnes(nums) {\n    let maxConsecutive = 0, currentConsecutive = 0;\n    for (let num of nums) {\n        currentConsecutive = (num === 1) ? currentConsecutive + 1 : 0;\n        maxConsecutive = Math.max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n```\n    \n    The algorithm iterates through the given binary array `nums`. For each element, it checks if the current number is 1, then it increments the `current_consecutive` counter; otherwise, it resets the counter to 0. After updating the counter, it compares the current value of `current_consecutive` with the current maximum consecutive ones count (`max_consecutive`) and updates the maximum count if the current count is higher. After iterating through the entire array, the algorithm returns the maximum number of consecutive 1's found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,1,0,1,1,1]",
                    "output": " 3",
                    "explanation": " The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3."
                },
                {
                    "input": " nums = [1,0,1,1,0,1]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,0,1,1,1]",
                    "output": "3"
                },
                {
                    "input": "[1,0,1,1,0,1]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-77",
        "prompt": "Given a binary array `nums`, return _the maximum number of consecutive_ `1`_'s in the array_."
    },
    "leetcode-benchmark-78": {
        "id": "leetcode-benchmark-78",
        "title": "Construct the Rectangle",
        "difficulty": "Easy",
        "content": {
            "problem": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web page's area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n1.  The area of the rectangular web page you designed must equal to the given target area.\n2.  The width `W` should not be larger than the length `L`, which means `L >= W`.\n3.  The difference between length `L` and width `W` should be as small as possible.\n\nReturn _an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence._",
            "examples": [
                "**Example 1:**\n\n**Input:** area = 4\n**Output:** \\[2,2\\]\n**Explanation:** The target area is 4, and all the possible ways to construct it are \\[1,4\\], \\[2,2\\], \\[4,1\\]. \nBut according to requirement 2, \\[1,4\\] is illegal; according to requirement 3,  \\[4,1\\] is not optimal compared to \\[2,2\\]. So the length L is 2, and the width W is 2.\n\n",
                "**Example 2:**\n\n**Input:** area = 37\n**Output:** \\[37,1\\]\n\n",
                "**Example 3:**\n\n**Input:** area = 122122\n**Output:** \\[427,286\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= area <= 107`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] constructRectangle(int area) {\n    int width = (int)Math.sqrt(area);\n    while(area % width != 0) {\n        width--;\n    }\n    int length = area / width;\n    return new int[]{length, width};\n}\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> constructRectangle(int area) {\n    int width = std::sqrt(area);\n    while(area % width != 0) {\n        width -= 1;\n    }\n    int length = area / width;\n    return {length, width};\n}\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "python": "\n    ```python\ndef constructRectangle(area: int) -> List[int]:\n    width = int(area**0.5)\n    while area % width != 0:\n        width -= 1\n    length = area // width\n    return [length, width]\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "javascript": "\n    ```javascript\nfunction constructRectangle(area) {\n    let width = Math.floor(Math.sqrt(area));\n    while(area % width !== 0) {\n        width--;\n    }\n    let length = area / width;\n    return [length, width];\n}\n```\n    \n    The algorithm starts by calculating the square root of the given area, using the sqrt function in each language. Since web pages with more rectangular shapes are preferred, we start the width from `sqrt(area)` and work our way down.\n\nWe initialize the variable width with the integer value of the square root of the area: `width = sqrt(area)`. This initialization ensures that our width and length will be as close as possible to each other.\n\nWe then use a while loop to check if the current width divides the area evenly (`area % width != 0`). If it doesn't, we decrement the width by one and repeat the loop until we find a width that divides the area evenly.\n\nFinally, we calculate the length by dividing the area with the width: `length = area / width`. We return the length and width as an array in the required sequence: `[length, width]`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " area = 4",
                    "output": " [2,2]",
                    "explanation": " The target area is 4, and all the possible ways to construct it are \\[1,4\\], \\[2,2\\], \\[4,1\\]. \nBut according to requirement 2, \\[1,4\\] is illegal; according to requirement 3,  \\[4,1\\] is not optimal compared to \\[2,2\\]. So the length L is 2, and the width W is 2."
                },
                {
                    "input": " area = 37",
                    "output": " [37,1]",
                    "explanation": null
                },
                {
                    "input": " area = 122122",
                    "output": " [427,286]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "4",
                    "output": "[2,2]"
                },
                {
                    "input": "37",
                    "output": "[37,1]"
                },
                {
                    "input": "122122",
                    "output": "[427,286]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-78",
        "prompt": "A web developer needs to know how to design a web page's size. So, given a specific rectangular web page's area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n1.  The area of the rectangular web page you designed must equal to the given target area.\n2.  The width `W` should not be larger than the length `L`, which means `L >= W`.\n3.  The difference between length `L` and width `W` should be as small as possible.\n\nReturn _an array `[L, W]` where `L` and `W` are the length and width of the web page you designed in sequence._"
    },
    "leetcode-benchmark-79": {
        "id": "leetcode-benchmark-79",
        "title": "Teemo Attacking",
        "difficulty": "Easy",
        "content": {
            "problem": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.\n\nReturn _the **total** number of seconds that Ashe is poisoned_.",
            "examples": [
                "**Example 1:**\n\n**Input:** timeSeries = \\[1,4\\], duration = 2\n**Output:** 4\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n\n",
                "**Example 2:**\n\n**Input:** timeSeries = \\[1,2\\], duration = 2\n**Output:** 3\n**Explanation:** Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= timeSeries.length <= 104`\n*   `0 <= timeSeries[i], duration <= 107`\n*   `timeSeries` is sorted in **non-decreasing** order.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findPoisonedDuration(int[] timeSeries, int duration) {\n    if (timeSeries.length == 0) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "c++": "\n    ```cpp\nint findPoisonedDuration(vector<int>& timeSeries, int duration) {\n    if (timeSeries.empty()) return 0;\n    int total = 0;\n    for (int i = 1; i < timeSeries.size(); ++i) {\n        total += min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "python": "\n    ```python\ndef find_poisoned_duration(time_series, duration):\n    if not time_series:\n        return 0\n    total = 0\n    for i in range(1, len(time_series)):\n        total += min(time_series[i] - time_series[i - 1], duration)\n    return total + duration\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "javascript": "\n    ```javascript\nfunction findPoisonedDuration(timeSeries, duration) {\n    if (timeSeries.length === 0) return 0;\n    let total = 0;\n    for (let i = 1; i < timeSeries.length; ++i) {\n        total += Math.min(timeSeries[i] - timeSeries[i - 1], duration);\n    }\n    return total + duration;\n}\n```\n    \n    Iterate through the `timeSeries` array and for each element, calculate the difference between the current element and the previous element. If the difference is less than `duration`, add that difference to the total time poisoned; otherwise, add the `duration` to the total time poisoned. In the end, add one more `duration` to the total to account for the last attack.\n\nBy doing this, we ensure that we only count the poisoned time without overlapping, since consecutive poisoned times will add up to the original duration.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " timeSeries = [1,4], duration = 2",
                    "output": " 4",
                    "explanation": " Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total."
                },
                {
                    "input": " timeSeries = [1,2], duration = 2",
                    "output": " 3",
                    "explanation": " Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total."
                }
            ],
            "function_input": [
                {
                    "input": "[1,4],2",
                    "output": "4"
                },
                {
                    "input": "[1,2],2",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-79",
        "prompt": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly `duration` seconds. More formally, an attack at second `t` will mean Ashe is poisoned during the **inclusive** time interval `[t, t + duration - 1]`. If Teemo attacks again **before** the poison effect ends, the timer for it is **reset**, and the poison effect will end `duration` seconds after the new attack.\n\nYou are given a **non-decreasing** integer array `timeSeries`, where `timeSeries[i]` denotes that Teemo attacks Ashe at second `timeSeries[i]`, and an integer `duration`.\n\nReturn _the **total** number of seconds that Ashe is poisoned_."
    },
    "leetcode-benchmark-80": {
        "id": "leetcode-benchmark-80",
        "title": "Next Greater Element I",
        "difficulty": "Easy",
        "content": {
            "problem": "The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.\n\nYou are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.\n\nFor each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.\n\nReturn _an array_ `ans` _of length_ `nums1.length` _such that_ `ans[i]` _is the **next greater element** as described above._",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[4,1,2\\], nums2 = \\[1,3,4,2\\]\n**Output:** \\[-1,3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = \\[1,3,4,2\\]. The next greater element is 3.\n- 2 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[2,4\\], nums2 = \\[1,2,3,4\\]\n**Output:** \\[3,-1\\]\n**Explanation:** The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = \\[1,2,3,4\\]. The next greater element is 3.\n- 4 is underlined in nums2 = \\[1,2,3,4\\]. There is no next greater element, so the answer is -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length <= nums2.length <= 1000`\n*   `0 <= nums1[i], nums2[i] <= 104`\n*   All integers in `nums1` and `nums2` are **unique**.\n*   All the integers of `nums1` also appear in `nums2`.\n\n**",
            "follow_up": "Follow up:** Could you find an `O(nums1.length + nums2.length)` solution?"
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> nextGreater = new HashMap<>();\n    Stack<Integer> stack = new Stack<>();\n\n    for (int num : nums2) {\n        while (!stack.isEmpty() && stack.peek() < num) {\n            nextGreater.put(stack.pop(), num);\n        }\n        stack.push(num);\n    }\n\n    int[] result = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        result[i] = nextGreater.getOrDefault(nums1[i], -1);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\n#include <unordered_map>\n\nstd::vector<int> nextGreaterElement(std::vector<int>& nums1, std::vector<int>& nums2) {\n    std::unordered_map<int, int> nextGreater;\n    std::stack<int> stk;\n\n    for (int num : nums2) {\n        while (!stk.empty() && stk.top() < num) {\n            nextGreater[stk.top()] = num;\n            stk.pop();\n        }\n        stk.push(num);\n    }\n\n    std::vector<int> result(nums1.size());\n    for (size_t i = 0; i < nums1.size(); ++i) {\n        result[i] = nextGreater.count(nums1[i]) ? nextGreater[nums1[i]] : -1;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "python": "\n    ```python\ndef next_greater_element(nums1, nums2):\n    next_greater = {}\n    stack = []\n\n    for num in nums2:\n        while stack and stack[-1] < num:\n            next_greater[stack.pop()] = num\n        stack.append(num)\n\n    return [next_greater.get(n, -1) for n in nums1]\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "javascript": "\n    ```javascript\nfunction nextGreaterElement(nums1, nums2) {\n    const nextGreater = new Map();\n    const stack = [];\n\n    nums2.forEach(num => {\n        while (stack.length && stack[stack.length - 1] < num) {\n            nextGreater.set(stack.pop(), num);\n        }\n        stack.push(num);\n    });\n\n    return nums1.map(n => nextGreater.get(n) || -1);\n}\n```\n    \n    The algorithm uses a stack, following these steps:\n1. Initialize an empty stack.\n2. Iterate through nums2 elements:\n   a. While the stack is not empty and the top of the stack is less than the current nums2 element, add the next greater element of the top of the stack as the current nums2 element and pop it.\n   b. Push the current nums2 element into the stack.\n3. For every element in nums1, get the next greater element found in step 2 or -1 if no such element was found.\n4. Return the result array.\n\nThe key point is using the stack to keep track of the previous elements that still need to find their next greater element while iterating nums2 in a single pass. This ensures that the algorithm runs in linear O(n) time complexity.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums1 = [4,1,2], nums2 = [1,3,4,2]",
                    "output": " [-1,3,-1]",
                    "explanation": " The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = \\[1,3,4,2\\]. The next greater element is 3.\n- 2 is underlined in nums2 = \\[1,3,4,2\\]. There is no next greater element, so the answer is -1."
                },
                {
                    "input": " nums1 = [2,4], nums2 = [1,2,3,4]",
                    "output": " [3,-1]",
                    "explanation": " The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = \\[1,2,3,4\\]. The next greater element is 3.\n- 4 is underlined in nums2 = \\[1,2,3,4\\]. There is no next greater element, so the answer is -1."
                }
            ],
            "function_input": [
                {
                    "input": "[4,1,2],[1,3,4,2]",
                    "output": "[-1,3,-1]"
                },
                {
                    "input": "[2,4],[1,2,3,4]",
                    "output": "[3,-1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-80",
        "prompt": "The **next greater element** of some element `x` in an array is the **first greater** element that is **to the right** of `x` in the same array.\n\nYou are given two **distinct 0-indexed** integer arrays `nums1` and `nums2`, where `nums1` is a subset of `nums2`.\n\nFor each `0 <= i < nums1.length`, find the index `j` such that `nums1[i] == nums2[j]` and determine the **next greater element** of `nums2[j]` in `nums2`. If there is no next greater element, then the answer for this query is `-1`.\n\nReturn _an array_ `ans` _of length_ `nums1.length` _such that_ `ans[i]` _is the **next greater element** as described above._"
    },
    "leetcode-benchmark-81": {
        "id": "leetcode-benchmark-81",
        "title": "Keyboard Row",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of strings `words`, return _the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below_.\n\nIn the **American keyboard**:\n\n*   the first row consists of the characters `\"qwertyuiop \"`,\n*   the second row consists of the characters `\"asdfghjkl \"`, and\n*   the third row consists of the characters `\"zxcvbnm \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"Hello \", \"Alaska \", \"Dad \", \"Peace \"\\]\n**Output:** \\[ \"Alaska \", \"Dad \"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"omk \"\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"adsdf \", \"sfd \"\\]\n**Output:** \\[ \"adsdf \", \"sfd \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 20`\n*   `1 <= words[i].length <= 100`\n*   `words[i]` consists of English letters (both lowercase and uppercase).",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\n\npublic class Solution {\n    public String[] findWords(String[] words) {\n        HashSet<Character>[] rows = new HashSet[] {\n            new HashSet<Character>() {{\n                add('q'); add('w'); add('e'); add('r'); add('t');\n                add('y'); add('u'); add('i'); add('o'); add('p');\n            }},\n            new HashSet<Character>() {{\n                add('a'); add('s'); add('d'); add('f'); add('g');\n                add('h'); add('j'); add('k'); add('l');\n            }},\n            new HashSet<Character>() {{\n                add('z'); add('x'); add('c'); add('v'); add('b');\n                add('n'); add('m');\n            }}\n        };\n        List<String> res = new ArrayList<>();\n        \n        for (String word : words) {\n            int row = -1;\n            for (int i = 0; i < 3; i++) {\n                if (rows[i].contains(Character.toLowerCase(word.charAt(0)))) {\n                    row = i;\n                    break;\n                }\n            }\n            \n            boolean isOneRow = true;\n            for (char letter : word.toCharArray()) {\n                if (!rows[row].contains(Character.toLowerCase(letter))) {\n                    isOneRow = false;\n                    break;\n                }\n            }\n            \n            if (isOneRow)\n                res.add(word);\n        }\n        \n        return res.toArray(new String[0]);\n    }\n}\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nvector<string> findWords(vector<string>& words) {\n    vector<unordered_set<char>> rows = {\n        {'q','w','e','r','t','y','u','i','o','p'},\n        {'a','s','d','f','g','h','j','k','l'},\n        {'z','x','c','v','b','n','m'}\n    };\n    vector<string> result;\n    \n    for (const auto& word : words) {\n        int row = -1;\n        for (int i = 0; i < 3; ++i) {\n            if (rows[i].count(tolower(word[0])) > 0) {\n                row = i;\n                break;\n            }\n        }\n        \n        bool isOneRow = true;\n        for (const auto& letter : word) {\n            if (rows[row].count(tolower(letter)) == 0) {\n                isOneRow = false;\n                break;\n            }\n        }\n        \n        if (isOneRow) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "python": "\n    ```python\ndef find_words(words):\n    rows = [\n        set(\"qwertyuiopQWERTYUIOP\"),\n        set(\"asdfghjklASDFGHJKL\"),\n        set(\"zxcvbnmZXCVBNM\")\n    ]\n    res = []\n\n    for word in words:\n        row = -1\n        for i in range(3):\n            if word[0] in rows[i]:\n                row = i\n                break\n\n        if all(c in rows[row] for c in word):\n            res.append(word)\n\n    return res\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "javascript": "\n    ```javascript\nfunction findWords(words) {\n    const rows = [\n        new Set(\"qwertyuiopQWERTYUIOP\".split('')),\n        new Set(\"asdfghjklASDFGHJKL\".split('')),\n        new Set(\"zxcvbnmZXCVBNM\".split(''))\n    ];\n    const res = [];\n\n    for (const word of words) {\n        let row = -1;\n        for (let i = 0; i < 3; i++) {\n            if (rows[i].has(word[0])) {\n                row = i;\n                break;\n            }\n        }\n\n        if (word.split('').every(c => rows[row].has(c))) {\n            res.push(word);\n        }\n    }\n\n    return res;\n}\n```\n\n    \n    1. Create an array of sets representing each row of the American keyboard. Include both uppercase and lowercase letters in the set.\n2. Initialize an empty result list.\n3. Loop through the input words array.\n4. Determine the row of the first character of the current word by checking which of the 3 rows contains it.\n5. Check if all the characters in the current word belong to the same row found in step 4. If yes, append the word to the result list.\n6. Once the loop is done, return the result list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"Hello \", \"Alaska \", \"Dad \", \"Peace \"]",
                    "output": " [ \"Alaska \", \"Dad \"]",
                    "explanation": null
                },
                {
                    "input": " words = [ \"omk \"]",
                    "output": " []",
                    "explanation": null
                },
                {
                    "input": " words = [ \"adsdf \", \"sfd \"]",
                    "output": " [ \"adsdf \", \"sfd \"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"Hello\",\"Alaska\",\"Dad\",\"Peace\"]",
                    "output": "[\"Alaska\",\"Dad\"]"
                },
                {
                    "input": "[\"omk\"]",
                    "output": "[]"
                },
                {
                    "input": "[\"adsdf\",\"sfd\"]",
                    "output": "[\"adsdf\",\"sfd\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-81",
        "prompt": "Given an array of strings `words`, return _the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below_.\n\nIn the **American keyboard**:\n\n*   the first row consists of the characters `\"qwertyuiop \"`,\n*   the second row consists of the characters `\"asdfghjkl \"`, and\n*   the third row consists of the characters `\"zxcvbnm \"`."
    },
    "leetcode-benchmark-82": {
        "id": "leetcode-benchmark-82",
        "title": "Find Mode in Binary Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree (BST) with duplicates, return _all the [mode(s)](https://en.wikipedia.org/wiki/Mode_(statistics)) (i.e., the most frequently occurred element) in it_.\n\nIf the tree has more than one mode, return them in **any order**.\n\nAssume a BST is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n*   Both the left and right subtrees must also be binary search trees.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,null,2,2\\]\n**Output:** \\[2\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-105 <= Node.val <= 105`\n\n**",
            "follow_up": "Follow up:** Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count)."
        },
        "java": "\n    ```java\npublic List<Integer> findMode(TreeNode root) {\n    List<Integer> modes = new ArrayList<>();\n    if (root == null) return modes;\n    \n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n    Stack<TreeNode> stack = new Stack<>();\n    TreeNode currentNode = root;\n    int maxFrequency = 0;\n    \n    while (currentNode != null || !stack.isEmpty()) {\n        while (currentNode != null) {\n            stack.add(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencyMap.put(currentNode.val, frequencyMap.getOrDefault(currentNode.val, 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencyMap.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n        if (entry.getValue() == maxFrequency) modes.add(entry.getKey());\n    }\n    \n    return modes;\n}\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "c++": "\n    ```cpp\nvoid InOrder(TreeNode* root, unordered_map<int, int>& frequencies, int& max_frequency) {\n    if (!root) return;\n    InOrder(root->left, frequencies, max_frequency);\n    frequencies[root->val]++;\n    max_frequency = max(max_frequency, frequencies[root->val]);\n    InOrder(root->right, frequencies, max_frequency);\n}\n\nvector<int> findMode(TreeNode* root) {\n    unordered_map<int, int> frequencies;\n    int max_frequency = 0;\n    InOrder(root, frequencies, max_frequency);\n    vector<int> modes;\n    \n    for (const auto& freq : frequencies) {\n        if (freq.second == max_frequency) modes.push_back(freq.first);\n    }\n    \n    return modes;\n}\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "python": "\n    ```python\ndef findMode(root):\n    def InOrder(node):\n        if not node: return\n        yield from InOrder(node.left)\n        yield node.val\n        yield from InOrder(node.right)\n        \n    counts = collections.Counter(InOrder(root))\n    max_count = max(counts.values(), default=0)\n    return [k for k, v in counts.items() if v == max_count]\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "javascript": "\n    ```javascript\nfunction findMode(root) {\n    if (!root) return [];\n    \n    const frequencies = new Map();\n    const stack = [];\n    let maxFrequency = 0;\n    let currentNode = root;\n    \n    while (currentNode || stack.length) {\n        while (currentNode) {\n            stack.push(currentNode);\n            currentNode = currentNode.left;\n        }\n        currentNode = stack.pop();\n        frequencies.set(currentNode.val, (frequencies.get(currentNode.val) || 0) + 1);\n        maxFrequency = Math.max(maxFrequency, frequencies.get(currentNode.val));\n        currentNode = currentNode.right;\n    }\n    \n    const modes = [];\n    for (const [key, value] of frequencies) {\n        if (value === maxFrequency) modes.push(key);\n    }\n    \n    return modes;\n}\n```\n    \n    The algorithm is based on performing an in-order traversal of the binary search tree (BST). In-order traversal of a BST will visit nodes in ascending order. During the traversal, we count the frequency of each element using a HashMap (in C++ and Java), a Dictionary (in Python), or a Map (in JavaScript) and keep track of the maximum frequency.\n\nOnce the traversal is complete, we iterate through our frequency map/dictionary object, and if an element has a frequency equal to the maximum frequency, we add it to our result list/array.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree, since we visit each node once during the traversal.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,null,2,2]",
                    "output": " [2]",
                    "explanation": null
                },
                {
                    "input": " root = [0]",
                    "output": " [0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,null,2,2]",
                    "output": "[2]"
                },
                {
                    "input": "[0]",
                    "output": "[0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-82",
        "prompt": "Given the `root` of a binary search tree (BST) with duplicates, return _all the [mode(s)](https://en.wikipedia.org/wiki/Mode_(statistics)) (i.e., the most frequently occurred element) in it_.\n\nIf the tree has more than one mode, return them in **any order**.\n\nAssume a BST is defined as follows:\n\n*   The left subtree of a node contains only nodes with keys **less than or equal to** the node's key.\n*   The right subtree of a node contains only nodes with keys **greater than or equal to** the node's key.\n*   Both the left and right subtrees must also be binary search trees."
    },
    "leetcode-benchmark-83": {
        "id": "leetcode-benchmark-83",
        "title": "Base 7",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `num`, return _a string of its **base 7** representation_.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 100\n**Output:** \"202\"\n\n",
                "**Example 2:**\n\n**Input:** num = -7\n**Output:** \"-10\""
            ],
            "constraints": "**Constraints:**\n\n*   `-107 <= num <= 107`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    StringBuilder result = new StringBuilder();\n    boolean negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result.insert(0, num % 7);\n        num /= 7;\n    }\n    return negative ? \"-\" + result.toString() : result.toString();\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "c++": "\n    ```cpp\nstd::string convertToBase7(int num) {\n    if (num == 0) return \"0\";\n    std::string result = \"\";\n    bool negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = std::to_string(num % 7) + result;\n        num /= 7;\n    }\n    return negative ? \"-\" + result : result;\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "python": "\n    ```python\ndef convert_to_base7(num: int) -> str:\n    if num == 0:\n        return \"0\"\n    result = \"\"\n    negative = num < 0\n    if negative:\n        num *= -1\n    while num > 0:\n        result = str(num % 7) + result\n        num //= 7\n    return \"-\" + result if negative else result\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "javascript": "\n    ```javascript\nfunction convertToBase7(num) {\n    if (num === 0) return \"0\";\n    let result = \"\";\n    let negative = num < 0;\n    if (negative) num *= -1;\n    while (num > 0) {\n        result = (num % 7).toString() + result;\n        num = Math.floor(num / 7);\n    }\n    return negative ? \"-\" + result : result;\n}\n```\n    \n    The algorithm first checks if the input number is 0, and if so, it simply returns the base-7 representation as \"0\". If the number is negative, it keeps track of the sign and converts the number to positive. Then, it iteratively divides the number by 7 (integer division) and prepends the remainder (modulus) to the result string. Finally, if the input number was negative, it adds the minus sign back to the result string. The same algorithm is implemented in C++, Java, Python, and JavaScript with minor syntax adjustments.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num = 100",
                    "output": " \"202\"",
                    "explanation": null
                },
                {
                    "input": " num = -7",
                    "output": " \"-10\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "100",
                    "output": "\"202\""
                },
                {
                    "input": "-7",
                    "output": "\"-10\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-83",
        "prompt": "Given an integer `num`, return _a string of its **base 7** representation_."
    },
    "leetcode-benchmark-84": {
        "id": "leetcode-benchmark-84",
        "title": "Relative Ranks",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `score` of size `n`, where `score[i]` is the score of the `ith` athlete in a competition. All the scores are guaranteed to be **unique**.\n\nThe athletes are **placed** based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:\n\n*   The `1st` place athlete's rank is `\"Gold Medal \"`.\n*   The `2nd` place athlete's rank is `\"Silver Medal \"`.\n*   The `3rd` place athlete's rank is `\"Bronze Medal \"`.\n*   For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `\"x \"`).\n\nReturn an array `answer` of size `n` where `answer[i]` is the **rank** of the `ith` athlete.",
            "examples": [
                "**Example 1:**\n\n**Input:** score = \\[5,4,3,2,1\\]\n**Output:** \\[ \"Gold Medal \", \"Silver Medal \", \"Bronze Medal \", \"4 \", \"5 \"\\]\n**Explanation:** The placements are \\[1st, 2nd, 3rd, 4th, 5th\\].\n\n",
                "**Example 2:**\n\n**Input:** score = \\[10,3,8,9,4\\]\n**Output:** \\[ \"Gold Medal \", \"5 \", \"Bronze Medal \", \"Silver Medal \", \"4 \"\\]\n**Explanation:** The placements are \\[1st, 5th, 3rd, 2nd, 4th\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `n == score.length`\n*   `1 <= n <= 104`\n*   `0 <= score[i] <= 106`\n*   All the values in `score` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] findRelativeRanks(int[] score) {\n    Integer[] rank_sort = new Integer[score.length];\n    for(int i = 0; i < score.length; ++i) rank_sort[i] = i;\n    Arrays.sort(rank_sort, (i1, i2) -> Integer.compare(score[i2], score[i1]));\n    int[] result = new int[score.length];\n    for(int i = 0; i < rank_sort.length; ++i) result[rank_sort[i]] = i + 1;\n    return result;\n}\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> findRelativeRanks(std::vector<int>& score) {\n    std::vector<int> rank_sort(score.size());\n    for(int i = 0; i < score.size(); ++i) rank_sort[i] = i;\n    std::sort(rank_sort.begin(), rank_sort.end(), [&](int i1, int i2) { return score[i1] > score[i2]; });\n    std::vector<int>  result(score.size());\n    for(int i = 0; i < rank_sort.size(); ++i) result[rank_sort[i]] = i + 1;\n    return result;\n}\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "python": "\n    ```python\ndef find_relative_ranks(score):\n    rank_sort = sorted(range(len(score)), key=lambda i: score[i], reverse=True)\n    result = [0] * len(score)\n    for i, rank in enumerate(rank_sort):\n        result[rank] = i + 1\n    return result\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "javascript": "\n    ```javascript\nfunction findRelativeRanks(score) {\n    const rankSort = [...Array(score.length).keys()].sort((a, b) => score[b] - score[a]);\n    const result = new Array(score.length);\n    for (let i = 0; i < rankSort.length; ++i) {\n        result[rankSort[i]] = i + 1;\n    }\n    return result;\n}\n```\n\n    \n    The algorithm works in the following steps:\n\n1. Create an array of indices ranging from 0 to n-1, where n is the size of the given score array.\n\n2. Sort the indices array based on their corresponding score values in descending order. So, after sorting, the first element will be the index of the highest score in the original score array.\n\n3. Create a result array of size n.\n\n4. Iterate over the sorted indices array and assign its rank (1-based) to the corresponding index in the result array.\n\n5. Return the result array that now contains the ranks of athletes.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " score = [5,4,3,2,1]",
                    "output": " [ \"Gold Medal \", \"Silver Medal \", \"Bronze Medal \", \"4 \", \"5 \"]",
                    "explanation": " The placements are \\[1st, 2nd, 3rd, 4th, 5th\\]."
                },
                {
                    "input": " score = [10,3,8,9,4]",
                    "output": " [ \"Gold Medal \", \"5 \", \"Bronze Medal \", \"Silver Medal \", \"4 \"]",
                    "explanation": " The placements are \\[1st, 5th, 3rd, 2nd, 4th\\]."
                }
            ],
            "function_input": [
                {
                    "input": "[5,4,3,2,1]",
                    "output": "[\"GoldMedal\",\"SilverMedal\",\"BronzeMedal\",\"4\",\"5\"]"
                },
                {
                    "input": "[10,3,8,9,4]",
                    "output": "[\"GoldMedal\",\"5\",\"BronzeMedal\",\"SilverMedal\",\"4\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-84",
        "prompt": "You are given an integer array `score` of size `n`, where `score[i]` is the score of the `ith` athlete in a competition. All the scores are guaranteed to be **unique**.\n\nThe athletes are **placed** based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:\n\n*   The `1st` place athlete's rank is `\"Gold Medal \"`.\n*   The `2nd` place athlete's rank is `\"Silver Medal \"`.\n*   The `3rd` place athlete's rank is `\"Bronze Medal \"`.\n*   For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `\"x \"`).\n\nReturn an array `answer` of size `n` where `answer[i]` is the **rank** of the `ith` athlete."
    },
    "leetcode-benchmark-85": {
        "id": "leetcode-benchmark-85",
        "title": "Perfect Number",
        "difficulty": "Easy",
        "content": {
            "problem": "A [**perfect number**](https://en.wikipedia.org/wiki/Perfect_number) is a **positive integer** that is equal to the sum of its **positive divisors**, excluding the number itself. A **divisor** of an integer `x` is an integer that can divide `x` evenly.\n\nGiven an integer `n`, return `true` _if_ `n` _is a perfect number, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 28\n**Output:** true\n**Explanation:** 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\n",
                "**Example 2:**\n\n**Input:** num = 7\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 108`",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "c++": "\n    ```cpp\nbool checkPerfectNumber(int num) {\n    if (num <= 1) return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; ++i) {\n        if (num % i == 0) {\n            sum += i;\n            if (i * i != num) sum += num / i;\n        }\n    }\n    return sum == num;\n}\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "python": "\n    ```python\ndef checkPerfectNumber(num: int) -> bool:\n    if num <= 1:\n        return False\n    sum = 1\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            sum += i\n            if i * i != num:\n                sum += num // i\n        i += 1\n    return sum == num\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "javascript": "\n    ```javascript\nfunction checkPerfectNumber(num) {\n    if (num <= 1) return false;\n    let sum = 1;\n    for (let i = 2; i * i <= num; i++) {\n        if (num % i === 0) {\n            sum += i;\n            if (i * i !== num) sum += num / i;\n        }\n    }\n    return sum === num;\n}\n```\n    \n    The algorithm checks if a given number `num` is a perfect number by iterating through the positive divisors of the number and adding them to a sum. If the number is less than or equal to 1, it returns false as these are not perfect numbers. The loop starts from 2 and goes until the square root of the number. If `i` is divisible by `num`, it's added to the sum. Also, check if `i * i` is not equal to `num`, we add `num / i` to the sum, this is because we don't want to add the same divisor twice. In the end, it checks if the calculated sum is equal to the given number. If it is, return true, else return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num = 28",
                    "output": " True",
                    "explanation": " 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28."
                },
                {
                    "input": " num = 7",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "28",
                    "output": "True"
                },
                {
                    "input": "7",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-85",
        "prompt": "A [**perfect number**](https://en.wikipedia.org/wiki/Perfect_number) is a **positive integer** that is equal to the sum of its **positive divisors**, excluding the number itself. A **divisor** of an integer `x` is an integer that can divide `x` evenly.\n\nGiven an integer `n`, return `true` _if_ `n` _is a perfect number, otherwise return_ `false`."
    },
    "leetcode-benchmark-86": {
        "id": "leetcode-benchmark-86",
        "title": "Fibonacci Number",
        "difficulty": "Easy",
        "content": {
            "problem": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 30`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "c++": "\n    ```cpp\nint fib(int n) {\n    if(n < 2) {\n        return n;\n    }\n    int a = 0, b = 1, c;\n    for(int i = 2; i <= n; ++i) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "python": "\n    ```python\ndef fib(n: int) -> int:\n    if n < 2:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "javascript": "\n    ```javascript\nfunction fib(n) {\n    if(n < 2) {\n        return n;\n    }\n    let a = 0, b = 1, c;\n    for(let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm is an iterative approach to calculate the Fibonacci numbers. Instead of using the recursive formula, we maintain two variables `a` and `b` initialized with F(0) and F(1) respectively. On each iteration, we set `c = a + b`, then update `a` with the value of `b` and `b` with the value of `c`. This process increments both the Fibonacci numbers n times and the final result is stored in the variable `b`. This reduces the time complexity of the problem from exponential (recursive) to linear (iterative).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " 1",
                    "explanation": " F(2) = F(1) + F(0) = 1 + 0 = 1."
                },
                {
                    "input": " n = 3",
                    "output": " 2",
                    "explanation": " F(3) = F(2) + F(1) = 1 + 1 = 2."
                },
                {
                    "input": " n = 4",
                    "output": " 3",
                    "explanation": " F(4) = F(3) + F(2) = 2 + 1 = 3."
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "1"
                },
                {
                    "input": "3",
                    "output": "2"
                },
                {
                    "input": "4",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-86",
        "prompt": "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`."
    },
    "leetcode-benchmark-87": {
        "id": "leetcode-benchmark-87",
        "title": "Detect Capital",
        "difficulty": "Easy",
        "content": {
            "problem": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\n*   All letters in this word are capitals, like `\"USA \"`.\n*   All letters in this word are not capitals, like `\"leetcode \"`.\n*   Only the first letter in this word is capital, like `\"Google \"`.\n\nGiven a string `word`, return `true` if the usage of capitals in it is right.",
            "examples": [
                "**Example 1:**\n\n**Input:** word = \"USA\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** word = \"FlaG\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 100`\n*   `word` consists of lowercase and uppercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean detectCapitalUse(String word) {\n    int numCapital = 0;\n    for (char c : word.toCharArray()) {\n        if (Character.isUpperCase(c)) numCapital++;\n    }\n    return numCapital == 0 || numCapital == word.length() || (numCapital == 1 && Character.isUpperCase(word.charAt(0)));\n}\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "c++": "\n    ```cpp\nbool detectCapitalUse(string word) {\n    int numCapital = 0;\n    for (char c : word) {\n        if (isupper(c)) numCapital++;\n    }\n    return numCapital == 0 || numCapital == word.size() || (numCapital == 1 && isupper(word[0]));\n}\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "python": "\n    ```python\ndef detectCapitalUse(word: str) -> bool:\n    numCapital = sum(1 for c in word if c.isupper())\n    return numCapital == 0 or numCapital == len(word) or (numCapital == 1 and word[0].isupper())\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction detectCapitalUse(word) {\n    let numCapital = 0;\n    for (let c of word) {\n        if (c === c.toUpperCase()) numCapital++;\n    }\n    return numCapital === 0 || numCapital === word.length || (numCapital === 1 && word[0] === word[0].toUpperCase());\n}\n```\n\n    \n    The algorithm keeps track of the count of capital letters in the word. It iterates over each character in the word, and if the character is uppercase, it increments the `numCapital` counter.\n\nAfter iterating through the word, the algorithm checks if one of the three conditions holds:\n1. There are no capital letters (`numCapital == 0`)\n2. All letters are capital (`numCapital == word.size()` in C++ / `word.length` in Java and JavaScript / `len(word)` in Python)\n3. Only the first letter is capital (`numCapital == 1` and the first letter is uppercase)\n\nIf any of these conditions hold, the function returns `true`, otherwise `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " word = \"USA\"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " word = \"FlaG\"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"USA\"",
                    "output": "True"
                },
                {
                    "input": "\"FlaG\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-87",
        "prompt": "We define the usage of capitals in a word to be right when one of the following cases holds:\n\n*   All letters in this word are capitals, like `\"USA \"`.\n*   All letters in this word are not capitals, like `\"leetcode \"`.\n*   Only the first letter in this word is capital, like `\"Google \"`.\n\nGiven a string `word`, return `true` if the usage of capitals in it is right."
    },
    "leetcode-benchmark-88": {
        "id": "leetcode-benchmark-88",
        "title": "Longest Uncommon Subsequence I",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `a` and `b`, return _the length of the **longest uncommon subsequence** between_ `a` _and_ `b`. If the longest uncommon subsequence does not exist, return `-1`.\n\nAn **uncommon subsequence** between two strings is a string that is a **subsequence of one but not the other**.\n\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string).",
            "examples": [
                "**Example 1:**\n\n**Input:** a =  \"aba \", b =  \"cdc \"\n**Output:** 3\n**Explanation:** One longest uncommon subsequence is  \"aba \" because  \"aba \" is a subsequence of  \"aba \" but not  \"cdc \".\nNote that  \"cdc \" is also a longest uncommon subsequence.\n\n",
                "**Example 2:**\n\n**Input:** a =  \"aaa \", b =  \"bbb \"\n**Output:** 3\n**Explanation:** The longest uncommon subsequences are  \"aaa \" and  \"bbb \".\n\n",
                "**Example 3:**\n\n**Input:** a =  \"aaa \", b =  \"aaa \"\n**Output:** -1\n**Explanation:** Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a.length, b.length <= 100`\n*   `a` and `b` consist of lower-case English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findLUSlength(String a, String b) {\n    if (a.equals(b)) {\n        return -1;\n    }\n    return Math.max(a.length(), b.length());\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "c++": "\n    ```cpp\nint findLUSlength(string a, string b) {\n    if (a == b) {\n        return -1;\n    }\n    return max(a.length(), b.length());\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "python": "\n    ```python\ndef findLUSlength(a: str, b: str) -> int:\n    if a == b:\n        return -1\n    return max(len(a), len(b))\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "javascript": "\n    ```javascript\nfunction findLUSlength(a, b) {\n    if (a === b) {\n        return -1;\n    }\n    return Math.max(a.length, b.length);\n}\n```\n    \n    The algorithm is as follows:\n1. First, we compare if the strings a and b are equal. If they are equal, it means that there is no uncommon subsequence between them, so we return -1.\n2. If the strings are not equal, then we find the length of both strings and return the one with the maximum length. This is because the longest uncommon subsequence can be the longer of the two strings itself (since it is not a subsequence of the other string).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " a =  \"aba \", b =  \"cdc \"",
                    "output": " 3",
                    "explanation": " One longest uncommon subsequence is  \"aba \" because  \"aba \" is a subsequence of  \"aba \" but not  \"cdc \".\nNote that  \"cdc \" is also a longest uncommon subsequence."
                },
                {
                    "input": " a =  \"aaa \", b =  \"bbb \"",
                    "output": " 3",
                    "explanation": " The longest uncommon subsequences are  \"aaa \" and  \"bbb \"."
                },
                {
                    "input": " a =  \"aaa \", b =  \"aaa \"",
                    "output": " -1",
                    "explanation": " Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a."
                }
            ],
            "function_input": [
                {
                    "input": "\"aba\",\"cdc\"",
                    "output": "3"
                },
                {
                    "input": "\"aaa\",\"bbb\"",
                    "output": "3"
                },
                {
                    "input": "\"aaa\",\"aaa\"",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-88",
        "prompt": "Given two strings `a` and `b`, return _the length of the **longest uncommon subsequence** between_ `a` _and_ `b`. If the longest uncommon subsequence does not exist, return `-1`.\n\nAn **uncommon subsequence** between two strings is a string that is a **subsequence of one but not the other**.\n\nA **subsequence** of a string `s` is a string that can be obtained after deleting any number of characters from `s`.\n\n*   For example, `\"abc \"` is a subsequence of `\"aebdc \"` because you can delete the underlined characters in `\"aebdc \"` to get `\"abc \"`. Other subsequences of `\"aebdc \"` include `\"aebdc \"`, `\"aeb \"`, and `\" \"` (empty string)."
    },
    "leetcode-benchmark-89": {
        "id": "leetcode-benchmark-89",
        "title": "Reverse String II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.\n\nIf there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abcdefg\", k = 2\n**Output:** \"bacdfeg\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\", k = 2\n**Output:** \"bacd\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String reverseStr(String s, int k) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i += 2 * k) {\n        int left = i;\n        int right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            char temp = chars[left];\n            chars[left++] = chars[right];\n            chars[right--] = temp;\n        }\n    }\n    return new String(chars);\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nstring reverseStr(string s, int k) {\n    for (int i = 0; i < s.size(); i += 2*k) {\n        if (i + k <= s.size()) {\n            reverse(s.begin() + i, s.begin() + i + k);\n        } else {\n            reverse(s.begin() + i, s.end());\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "python": "\n    ```python\ndef reverseStr(s, k):\n    chars = list(s)\n    for i in range(0, len(chars), 2 * k):\n        chars[i:i + k] = reversed(chars[i:i + k])\n    return \"\".join(chars)\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseStr(s, k) {\n    let chars = s.split(\"\");\n    for (let i = 0; i < chars.length; i += 2 * k) {\n        let left = i;\n        let right = Math.min(i + k - 1, chars.length - 1);\n        while (left < right) {\n            [chars[left++], chars[right--]] = [chars[right], chars[left]];\n        }\n    }\n    return chars.join(\"\");\n}\n```\n    \n    The algorithm first creates a mutable array from the original string. Then, we iterate over every 2k characters. If there are at least k characters remaining from the current position, we reverse the first k characters. Otherwise, we reverse all the remaining characters.\n\nIn C++, we use the `reverse` function that takes iterators as arguments. In Java, JavaScript, and Python, we use custom loops for reversing k characters, taking into account the case when there are fewer than k characters remaining. Then, we join the characters back into a string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"abcdefg\", k = 2",
                    "output": " \"bacdfeg\"",
                    "explanation": null
                },
                {
                    "input": " s = \"abcd\", k = 2",
                    "output": " \"bacd\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abcdefg\",2",
                    "output": "\"bacdfeg\""
                },
                {
                    "input": "\"abcd\",2",
                    "output": "\"bacd\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-89",
        "prompt": "Given a string `s` and an integer `k`, reverse the first `k` characters for every `2k` characters counting from the start of the string.\n\nIf there are fewer than `k` characters left, reverse all of them. If there are less than `2k` but greater than or equal to `k` characters, then reverse the first `k` characters and leave the other as original."
    },
    "leetcode-benchmark-90": {
        "id": "leetcode-benchmark-90",
        "title": "Student Attendance Record I",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nThe student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nReturn `true` _if the student is eligible for an attendance award, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"PPALLP \"\n**Output:** true\n**Explanation:** The student has fewer than 2 absences and was never late 3 or more consecutive days.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"PPALLL \"\n**Output:** false\n**Explanation:** The student was late 3 consecutive days in the last 3 days, so is not eligible for the award."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'A'`, `'L'`, or `'P'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean checkRecord(String s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s.charAt(i) == 'A') {\n            absent++;\n            late = 0;\n        } else if (s.charAt(i) == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nbool checkRecord(std::string s) {\n    int late = 0, absent = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] == 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "python": "\n    ```python\ndef checkRecord(s: str) -> bool:\n    late, absent = 0, 0\n    for c in s:\n        if c == 'A':\n            absent += 1\n            late = 0\n        elif c == 'L':\n            late += 1\n        else:\n            late = 0\n\n        if absent >= 2 or late >= 3:\n            return False\n    return True\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "javascript": "\n    ```javascript\nfunction checkRecord(s) {\n    let late = 0, absent = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === 'A') {\n            absent++;\n            late = 0;\n        } else if (s[i] === 'L') {\n            late++;\n        } else {\n            late = 0;\n        }\n\n        if (absent >= 2 || late >= 3) return false;\n    }\n    return true;\n}\n```\n    \n    The algorithm initializes variables `late` and `absent` as counters for late and absent days, respectively. \n1. Iterate through each character of the string `s`.\n2. If the current character is 'A', increment the `absent` counter and set `late` counter to zero.\n3. If the current character is 'L', increment the `late` counter.\n4. If the current character is 'P', set the `late` counter to zero.\n5. After processing each character, check if `absent` is greater or equal to 2, or if `late` is greater or equal to 3. If either condition is met, return false (ineligible for an attendance award).\n6. If the entire string has been processed without meeting the conditions, return true (eligible for an attendance award). \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"PPALLP \"",
                    "output": " True",
                    "explanation": " The student has fewer than 2 absences and was never late 3 or more consecutive days."
                },
                {
                    "input": " s =  \"PPALLL \"",
                    "output": " False",
                    "explanation": " The student was late 3 consecutive days in the last 3 days, so is not eligible for the award."
                }
            ],
            "function_input": [
                {
                    "input": "\"PPALLP\"",
                    "output": "True"
                },
                {
                    "input": "\"PPALLL\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-90",
        "prompt": "You are given a string `s` representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nThe student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nReturn `true` _if the student is eligible for an attendance award, or_ `false` _otherwise_."
    },
    "leetcode-benchmark-91": {
        "id": "leetcode-benchmark-91",
        "title": "Reverse Words in a String III",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"Let's take LeetCode contest\"\n**Output:** \"s'teL ekat edoCteeL tsetnoc\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"God Ding\"\n**Output:** \"doG gniD\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `s` contains printable **ASCII** characters.\n*   `s` does not contain any leading or trailing spaces.\n*   There is **at least one** word in `s`.\n*   All the words in `s` are separated by a single space.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.StringJoiner;\n\npublic String reverseWordsInString(String s) {\n    String[] words = s.split(\" \");\n    for (int i = 0; i < words.length; i++) {\n        words[i] = new StringBuilder(words[i]).reverse().toString();\n    }\n    return String.join(\" \", words);\n}\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n#include <sstream>\n\nstd::string reverseWordsInString(const std::string& s) {\n    std::istringstream iss(s);\n    std::ostringstream oss;\n    std::string word;\n    while (iss >> word) {\n        std::reverse(word.begin(), word.end());\n        oss << word << ' ';\n    }\n    std::string result = oss.str();\n    if (!result.empty()) result.pop_back();\n    return result;\n}\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "python": "\n    ```python\ndef reverse_words_in_string(s: str) -> str:\n    return \" \".join(word[::-1] for word in s.split(\" \"))\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseWordsInString(s) {\n    return s.split(' ').map(word => word.split('').reverse().join('')).join(' ');\n}\n```\n    \n    The algorithm first splits the input string `s` into words based on whitespace. Then, for each word, it reverses the order of characters and appends it to the output. Finally, the reversed words are joined with whitespace and returned as the result.\n\nIn each language implementation:\n- C++: The algorithm uses `istringstream` to split the string into words and `ostringstream` to create the output string.\n- Java: The algorithm splits the string using `split`, reverses each word using `StringBuilder` and then `String.join` to join the words with a space delimiter.\n- Python: The algorithm uses a list comprehension to reverse the words in the input string and `join` to concatenate them.\n- JavaScript: The algorithm uses `split`, `map`, and `join` operations on the input string to reverse each word and concatenate them.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"Let's take LeetCode contest\"",
                    "output": " \"s'teL ekat edoCteeL tsetnoc\"",
                    "explanation": null
                },
                {
                    "input": " s = \"God Ding\"",
                    "output": " \"doG gniD\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"Let'stakeLeetCodecontest\"",
                    "output": "\"s'teLekatedoCteeLtsetnoc\""
                },
                {
                    "input": "\"GodDing\"",
                    "output": "\"doGgniD\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-91",
        "prompt": "Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order."
    },
    "leetcode-benchmark-92": {
        "id": "leetcode-benchmark-92",
        "title": "Array Partition",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,4,3,2\\]\n**Output:** 4\n**Explanation:** All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,2,6,5,1,2\\]\n**Output:** 9\n**Explanation:** The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`\n*   `nums.length == 2 * n`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int arrayPairSum(int[] nums) {\n    Arrays.sort(nums);\n    int sum = 0;\n    for (int i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint arrayPairSum(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "python": "\n    ```python\ndef array_pair_sum(nums):\n    nums.sort()\n    return sum(nums[::2])\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "javascript": "\n    ```javascript\nfunction arrayPairSum(nums) {\n    nums.sort((a, b) => a - b);\n    let sum = 0;\n    for (let i = 0; i < nums.length; i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n```\n    \n    1. First, sort the given 'nums' array/vector in ascending order.\n2. Iterate over the sorted array, with a step of 2, starting from index 0.\n3. During the iteration, accumulate the sum of every ith element (from sorted array) to maximize the sum of minimum elements in pairs.\n4. Return the accumulated sum.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,4,3,2]",
                    "output": " 4",
                    "explanation": " All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4."
                },
                {
                    "input": " nums = [6,2,6,5,1,2]",
                    "output": " 9",
                    "explanation": " The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9."
                }
            ],
            "function_input": [
                {
                    "input": "[1,4,3,2]",
                    "output": "4"
                },
                {
                    "input": "[6,2,6,5,1,2]",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-92",
        "prompt": "Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is **maximized**. Return _the maximized sum_."
    },
    "leetcode-benchmark-93": {
        "id": "leetcode-benchmark-93",
        "title": "Binary Tree Tilt",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree, return _the sum of every tree node's **tilt**._\n\nThe **tilt** of a tree node is the **absolute difference** between the sum of all left subtree node **values** and all right subtree node **values**. If a node does not have a left child, then the sum of the left subtree node **values** is treated as `0`. The rule is similar if the node does not have a right child.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1\n\n",
                "**Example 2:**\n\n**Input:** root = \\[4,2,9,3,5,null,7\\]\n**Output:** 15\n**Explanation:** \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15\n\n",
                "**Example 3:**\n\n**Input:** root = \\[21,7,14,1,1,2,2,3,3\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 104]`.\n*   `-1000 <= Node.val <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findTilt(TreeNode root) {\n    int[] tiltSum = new int[] {0};\n    findTiltUtil(root, tiltSum);\n    return tiltSum[0];\n}\n\nprivate int findTiltUtil(TreeNode root, int[] tiltSum) {\n    if (root == null) {\n        return 0;\n    }\n\n    int leftSum = findTiltUtil(root.left, tiltSum);\n    int rightSum = findTiltUtil(root.right, tiltSum);\n\n    tiltSum[0] += Math.abs(leftSum - rightSum);\n    return root.val + leftSum + rightSum;\n}\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "c++": "\n    ```cpp\nint findTiltUtil(TreeNode* root, int& tiltSum) {\n    if (!root) return 0;\n\n    int leftSum = findTiltUtil(root->left, tiltSum);\n    int rightSum = findTiltUtil(root->right, tiltSum);\n\n    tiltSum += abs(leftSum - rightSum);\n    return root->val + leftSum + rightSum;\n}\n\nint findTilt(TreeNode* root) {\n    int tiltSum = 0;\n    findTiltUtil(root, tiltSum);\n    return tiltSum;\n}\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "python": "\n    ```python\ndef findTilt(self, root):\n    def findTiltUtil(node):\n        if not node: return 0, 0\n        \n        leftSum, leftTilt = findTiltUtil(node.left)\n        rightSum, rightTilt = findTiltUtil(node.right)\n    \n        return (node.val + leftSum + rightSum, abs(leftSum - rightSum) + leftTilt + rightTilt)\n\n    return findTiltUtil(root)[1]\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "javascript": "\n    ```javascript\nfunction findTilt(root) {\n    function findTiltUtil(node) {\n        if (!node) return [0, 0];\n        \n        let [leftSum, leftTilt] = findTiltUtil(node.left);\n        let [rightSum, rightTilt] = findTiltUtil(node.right);\n    \n        return [node.val + leftSum + rightSum, Math.abs(leftSum - rightSum) + leftTilt + rightTilt];\n    }\n\n    return findTiltUtil(root)[1];\n};\n```\n\n    \n    The problem can be solved using a bottom-uprecursive algorithm. The helper function `findTiltUtil` should return two values: the sum of the current node and its descendants and the tilt value of the current node and its descendants.\n\nThe base case is when the current node is null, in this case, return [0, 0].\n\nIf the current node is not null, recursively call the `findTiltUtil` for left and right children. Then add the sum of the left child and the right child's sum, plus the value of the current node to get the new sum. For the new tilt value, add the absolute difference between the left and right child's sum to the tilt value of both children.\n\nFinally, return the new sum and tilt value as a tuple or a list. When calling this helper function for the root, the tilt value of the whole tree will be in the second element of the result list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,2,3]",
                    "output": " 1",
                    "explanation": " \nTilt of node 2 : |0-0| = 0 (no children)\nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3)\nSum of every tilt : 0 + 0 + 1 = 1"
                },
                {
                    "input": " root = [4,2,9,3,5,null,7]",
                    "output": " 15",
                    "explanation": " \nTilt of node 3 : |0-0| = 0 (no children)\nTilt of node 5 : |0-0| = 0 (no children)\nTilt of node 7 : |0-0| = 0 (no children)\nTilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5)\nTilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7)\nTilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16)\nSum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15"
                },
                {
                    "input": " root = [21,7,14,1,1,2,2,3,3]",
                    "output": " 9",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "1"
                },
                {
                    "input": "[4,2,9,3,5,null,7]",
                    "output": "15"
                },
                {
                    "input": "[21,7,14,1,1,2,2,3,3]",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-93",
        "prompt": "Given the `root` of a binary tree, return _the sum of every tree node's **tilt**._\n\nThe **tilt** of a tree node is the **absolute difference** between the sum of all left subtree node **values** and all right subtree node **values**. If a node does not have a left child, then the sum of the left subtree node **values** is treated as `0`. The rule is similar if the node does not have a right child."
    },
    "leetcode-benchmark-94": {
        "id": "leetcode-benchmark-94",
        "title": "Reshape the Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "In MATLAB, there is a handy function called `reshape` which can reshape an `m x n` matrix into a new one with a different size `r x c` keeping its original data.\n\nYou are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix.\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\nIf the `reshape` operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat = \\[\\[1,2\\],\\[3,4\\]\\], r = 1, c = 4\n**Output:** \\[\\[1,2,3,4\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat = \\[\\[1,2\\],\\[3,4\\]\\], r = 2, c = 4\n**Output:** \\[\\[1,2\\],\\[3,4\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat.length`\n*   `n == mat[i].length`\n*   `1 <= m, n <= 100`\n*   `-1000 <= mat[i][j] <= 1000`\n*   `1 <= r, c <= 300`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[][] matrixReshape(int[][] mat, int r, int c) {\n    int m = mat.length;\n    int n = mat[0].length;\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    int[][] reshaped = new int[r][c];\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n\n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {\n    int m = mat.size();\n    int n = mat[0].size();\n    if (m * n != r * c) {\n        return mat;\n    }\n\n    vector<vector<int>> reshaped(r, vector<int>(c));\n    for (int i = 0; i < m * n; ++i) {\n        reshaped[i / c][i % c] = mat[i / n][i % n];\n    }\n    \n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "python": "\n    ```python\ndef matrixReshape(mat, r, c):\n    m, n = len(mat), len(mat[0])\n    if m * n != r * c:\n        return mat\n\n    reshaped = [[0] * c for _ in range(r)]\n    for i in range(m * n):\n        reshaped[i // c][i % c] = mat[i // n][i % n]\n\n    return reshaped\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "javascript": "\n    ```javascript\nfunction matrixReshape(mat, r, c) {\n    const m = mat.length;\n    const n = mat[0].length;\n    if (m * n !== r * c) {\n        return mat;\n    }\n\n    const reshaped = new Array(r).fill(null).map(() => new Array(c));\n    for (let i = 0; i < m * n; ++i) {\n        reshaped[Math.floor(i / c)][i % c] = mat[Math.floor(i / n)][i % n];\n    }\n\n    return reshaped;\n}\n```\n    \n    The algorithm works by first checking if the reshape operation is possible. If the total number of elements in the original matrix (m * n) is not equal to the number of elements the reshaped matrix should have (r * c), the original matrix is returned.\n\nIf the reshape operation is possible, we create a new matrix of size r x c. We then iterate through each element index (i) of the original matrix and calculate the corresponding row and column in the reshaped matrix (i / c and i % c), assigning the value from the original matrix (mat[i / n][i % n]) to its position in the reshaped matrix.\n\nFinally, we return the reshaped matrix.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " mat = [[1,2],[3,4]], r = 1, c = 4",
                    "output": " [[1,2,3,4]]",
                    "explanation": null
                },
                {
                    "input": " mat = [[1,2],[3,4]], r = 2, c = 4",
                    "output": " [[1,2],[3,4]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[3,4]],1,4",
                    "output": "[[1,2,3,4]]"
                },
                {
                    "input": "[[1,2],[3,4]],2,4",
                    "output": "[[1,2],[3,4]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-94",
        "prompt": "In MATLAB, there is a handy function called `reshape` which can reshape an `m x n` matrix into a new one with a different size `r x c` keeping its original data.\n\nYou are given an `m x n` matrix `mat` and two integers `r` and `c` representing the number of rows and the number of columns of the wanted reshaped matrix.\n\nThe reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n\nIf the `reshape` operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix."
    },
    "leetcode-benchmark-95": {
        "id": "leetcode-benchmark-95",
        "title": "Distribute Candies",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array `candyType` of length `n`, return _the **maximum** number of different types of candies she can eat if she only eats_ `n / 2` _of them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** candyType = \\[1,1,2,2,3,3\\]\n**Output:** 3\n**Explanation:** Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.\n\n",
                "**Example 2:**\n\n**Input:** candyType = \\[1,1,2,3\\]\n**Output:** 2\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Whether she eats types \\[1,2\\], \\[1,3\\], or \\[2,3\\], she still can only eat 2 different types.\n\n",
                "**Example 3:**\n\n**Input:** candyType = \\[6,6,6,6\\]\n**Output:** 1\n**Explanation:** Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
            ],
            "constraints": "**Constraints:**\n\n*   `n == candyType.length`\n*   `2 <= n <= 104`\n*   `n` is even.\n*   `-105 <= candyType[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int maxNumberOfCandies(int[] candyType) {\n    Set<Integer> uniqueCandies = new HashSet<>();\n    for (int type : candyType) {\n        uniqueCandies.add(type);\n    }\n    return Math.min(uniqueCandies.size(), candyType.length / 2);\n}\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nint maxNumberOfCandies(vector<int>& candyType) {\n    unordered_set<int> uniqueCandies(candyType.begin(), candyType.end());\n    return min(uniqueCandies.size(), candyType.size() / 2);\n}\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "python": "\n    ```python\ndef maxNumberOfCandies(candyType):\n    uniqueCandies = set(candyType)\n    return min(len(uniqueCandies), len(candyType) // 2)\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "javascript": "\n    ```javascript\nfunction maxNumberOfCandies(candyType) {\n    const uniqueCandies = new Set(candyType);\n    return Math.min(uniqueCandies.size, candyType.length / 2);\n}\n```\n\n    \n    The algorithm starts by first creating a set of unique candy types using a hash set (in C++ and Java) or a set (in Python and JavaScript). The uniqueCandies set will only store each type of candy once, no matter how many times it appears in the candyType array. After creating this set, the algorithm compares the number of unique types of candies (size of the set) with half the total number of candies (n / 2). The minimum of these two values is returned as the maximum number of different types of candies Alice can eat. This is because Alice can eat at most n / 2 candies, but if there are fewer unique candies than that, she will eat all the unique types available.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " candyType = [1,1,2,2,3,3]",
                    "output": " 3",
                    "explanation": " Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type."
                },
                {
                    "input": " candyType = [1,1,2,3]",
                    "output": " 2",
                    "explanation": " Alice can only eat 4 / 2 = 2 candies. Whether she eats types \\[1,2\\], \\[1,3\\], or \\[2,3\\], she still can only eat 2 different types."
                },
                {
                    "input": " candyType = [6,6,6,6]",
                    "output": " 1",
                    "explanation": " Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,2,2,3,3]",
                    "output": "3"
                },
                {
                    "input": "[1,1,2,3]",
                    "output": "2"
                },
                {
                    "input": "[6,6,6,6]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-95",
        "prompt": "Alice has `n` candies, where the `ith` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.\n\nThe doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n\nGiven the integer array `candyType` of length `n`, return _the **maximum** number of different types of candies she can eat if she only eats_ `n / 2` _of them_."
    },
    "leetcode-benchmark-96": {
        "id": "leetcode-benchmark-96",
        "title": "Longest Harmonious Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is **exactly** `1`.\n\nGiven an integer array `nums`, return _the length of its longest harmonious subsequence among all its possible subsequences_.\n\nA **subsequence** of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,2,5,2,3,7\\]\n**Output:** 5\n**Explanation:** The longest harmonious subsequence is \\[3,2,2,2,3\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,1,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int findLHS(int[] nums) {\n    HashMap<Integer, Integer> count = new HashMap<>();\n    for (int num : nums)\n        count.put(num, count.getOrDefault(num, 0) + 1);\n\n    int longest_sequence = 0;\n    for (int key : count.keySet()) {\n        if (count.containsKey(key + 1))\n            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n    }\n    \n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint findLHS(vector<int>& nums) {\n    unordered_map<int, int> count;\n    for (int num : nums)\n        count[num]++;\n    \n    int longest_sequence = 0;\n    for (auto &elem : count) {\n        if (count.find(elem.first + 1) != count.end())\n            longest_sequence = max(longest_sequence, elem.second + count[elem.first + 1]);\n    }\n    \n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "python": "\n    ```python\ndef findLHS(nums):\n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n\n    longest_sequence = 0\n    for key in count:\n        if key + 1 in count:\n            longest_sequence = max(longest_sequence, count[key] + count[key + 1])\n\n    return longest_sequence\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "javascript": "\n    ```javascript\nfunction findLHS(nums) {\n    const count = new Map();\n    for (const num of nums) {\n        count.set(num, (count.get(num) || 0) + 1);\n    }\n\n    let longest_sequence = 0;\n    for (const key of count.keys()) {\n        if (count.has(key + 1)) {\n            longest_sequence = Math.max(longest_sequence, count.get(key) + count.get(key + 1));\n        }\n    }\n\n    return longest_sequence;\n}\n```\n    \n    1. Create a hashmap to count the occurrences of each number in the input array.\n2. Iterate through the uniquq elements in the hashmap.\n3. For each element, check if there exists an element that is 1 greater, and if so, record the sum of the element count and the count of the element 1 greater.\n4. Keep track of the maximum harmony sequence found during this iteration.\n5. Return the length of the longest harmonious sequence found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,2,2,5,2,3,7]",
                    "output": " 5",
                    "explanation": " The longest harmonious subsequence is \\[3,2,2,2,3\\]."
                },
                {
                    "input": " nums = [1,2,3,4]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " nums = [1,1,1,1]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,2,2,5,2,3,7]",
                    "output": "5"
                },
                {
                    "input": "[1,2,3,4]",
                    "output": "2"
                },
                {
                    "input": "[1,1,1,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-96",
        "prompt": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is **exactly** `1`.\n\nGiven an integer array `nums`, return _the length of its longest harmonious subsequence among all its possible subsequences_.\n\nA **subsequence** of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements."
    },
    "leetcode-benchmark-97": {
        "id": "leetcode-benchmark-97",
        "title": "Range Addition II",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.\n\nCount and return _the number of maximum integers in the matrix after performing all the operations_.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 4\n**Explanation:** The maximum integer in M is 2, and there are four of it in M. So return 4.\n\n",
                "**Example 2:**\n\n**Input:** m = 3, n = 3, ops = \\[\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\],\\[2,2\\],\\[3,3\\],\\[3,3\\],\\[3,3\\]\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** m = 3, n = 3, ops = \\[\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 4 * 104`\n*   `0 <= ops.length <= 104`\n*   `ops[i].length == 2`\n*   `1 <= ai <= m`\n*   `1 <= bi <= n`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxCount(int m, int n, int[][] ops) {\n    for (int[] op : ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint maxCount(int m, int n, vector<vector<int>>& ops) {\n    for (vector<int>& op : ops) {\n        m = min(m, op[0]);\n        n = min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "python": "\n    ```python\ndef maxCount(m: int, n: int, ops: List[List[int]]) -> int:\n    for op in ops:\n        m = min(m, op[0])\n        n = min(n, op[1])\n    return m * n\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "javascript": "\n    ```javascript\nfunction maxCount(m, n, ops) {\n    for (let op of ops) {\n        m = Math.min(m, op[0]);\n        n = Math.min(n, op[1]);\n    }\n    return m * n;\n}\n```\n    \n    The algorithm consists of iterating through each operation in the ops array and updating the values of m and n to be the minimum of their current value and the corresponding values in the operation. This is because the maximum integers will always be in the top-left corner of the matrix (0 <= x < ai and 0 <= y < bi). Once all operations have been considered, we multiply the final values of m and n to get the count of maximum integers in the matrix.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " m = 3, n = 3, ops = [[2,2],[3,3]]",
                    "output": " 4",
                    "explanation": " The maximum integer in M is 2, and there are four of it in M. So return 4."
                },
                {
                    "input": " m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " m = 3, n = 3, ops = []",
                    "output": " 9",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3,3,[[2,2],[3,3]]",
                    "output": "4"
                },
                {
                    "input": "3,3,[[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]",
                    "output": "4"
                },
                {
                    "input": "3,3,[]",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-97",
        "prompt": "You are given an `m x n` matrix `M` initialized with all `0`'s and an array of operations `ops`, where `ops[i] = [ai, bi]` means `M[x][y]` should be incremented by one for all `0 <= x < ai` and `0 <= y < bi`.\n\nCount and return _the number of maximum integers in the matrix after performing all the operations_."
    },
    "leetcode-benchmark-98": {
        "id": "leetcode-benchmark-98",
        "title": "Can Place Flowers",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.\n\nGiven an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` _if_ `n` _new flowers can be planted in the_ `flowerbed` _without violating the no-adjacent-flowers rule and_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 1\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** flowerbed = \\[1,0,0,0,1\\], n = 2\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= flowerbed.length <= 2 * 104`\n*   `flowerbed[i]` is `0` or `1`.\n*   There are no two adjacent flowers in `flowerbed`.\n*   `0 <= n <= flowerbed.length`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canPlaceFlowers(int[] flowerbed, int n) {\n    int count = 0;\n    for(int i = 0; i < flowerbed.length; i++) {\n        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool canPlaceFlowers(vector<int>& flowerbed, int n) {\n    int count = 0;\n    for(int i = 0; i < flowerbed.size(); i++) {\n        if(flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "python": "\n    ```python\ndef canPlaceFlowers(flowerbed, n):\n    count = 0\n    for i in range(len(flowerbed)):\n        if flowerbed[i] == 0 and (i == 0 or flowerbed[i - 1] == 0) and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n            flowerbed[i] = 1\n            count += 1\n        if count >= n:\n            return True\n    return count >= n\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "javascript": "\n    ```javascript\nfunction canPlaceFlowers(flowerbed, n) {\n    let count = 0;\n    for(let i = 0; i < flowerbed.length; i++) {\n        if(flowerbed[i] === 0 && (i === 0 || flowerbed[i - 1] === 0) && (i === flowerbed.length - 1 || flowerbed[i + 1] === 0)) {\n            flowerbed[i] = 1;\n            count++;\n        }\n        if(count >= n) return true;\n    }\n    return count >= n;\n}\n```\n\n    \n    1. Initialize a variable `count` to keep track of the number of flowers planted.\n2. Iterate through the flowerbed with a variable `i`.\n3. Check the possibility of planting flowers at the current index:\n   - If `flowerbed[i]` is already 0,\n   - `i` is 0 (first plot) or the plot before the current plot is empty,\n   - `i` is the last plot or the plot after the current plot is empty.\n4. If all these conditions are met, plant a flower at the current plot by setting `flowerbed[i]` to 1 and increment the count.\n5. If the count is equal to or greater than `n`, return true.\n6. After iterating through the entire array, if the count is still equal to or greater than `n`, return true; otherwise, return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " flowerbed = [1,0,0,0,1], n = 1",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " flowerbed = [1,0,0,0,1], n = 2",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,0,0,1],1",
                    "output": "True"
                },
                {
                    "input": "[1,0,0,0,1],2",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-98",
        "prompt": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.\n\nGiven an integer array `flowerbed` containing `0`'s and `1`'s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` _if_ `n` _new flowers can be planted in the_ `flowerbed` _without violating the no-adjacent-flowers rule and_ `false` _otherwise_."
    },
    "leetcode-benchmark-99": {
        "id": "leetcode-benchmark-99",
        "title": "Maximum Product of Three Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, _find three numbers whose product is maximum and return the maximum product_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 24\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,-2,-3\\]\n**Output:** -6"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maximumProduct(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "c++": "\n    ```cpp\nint maximumProduct(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    return max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "python": "\n    ```python\ndef maximumProduct(nums):\n    nums.sort()\n    n = len(nums)\n    return max(nums[0] * nums[1] * nums[-1], nums[-1] * nums[-2] * nums[-3])\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "javascript": "\n    ```javascript\nfunction maximumProduct(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    return Math.max(nums[0] * nums[1] * nums[n-1], nums[n-1] * nums[n-2] * nums[n-3]);\n}\n```\n    \n    First, we sort the input array in non-decreasing order. After sorting, we can determine the maximum product using two possible scenarios.\n\n1. The maximum product is formed by the product of the three highest numbers in the array. We can get this by multiplying the last three elements of the sorted array.\n\n2. The maximum product is formed by the product of the two lowest (most negative) numbers and the highest number in the array. We can get this by multiplying the first two elements and the last element of the sorted array.\n\nWe take the maximum of these two results to get the final answer.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3]",
                    "output": " 6",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2,3,4]",
                    "output": " 24",
                    "explanation": null
                },
                {
                    "input": " nums = [-1,-2,-3]",
                    "output": " -6",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "6"
                },
                {
                    "input": "[1,2,3,4]",
                    "output": "24"
                },
                {
                    "input": "[-1,-2,-3]",
                    "output": "-6"
                }
            ]
        },
        "task_id": "leetcode-benchmark-99",
        "prompt": "Given an integer array `nums`, _find three numbers whose product is maximum and return the maximum product_."
    },
    "leetcode-benchmark-100": {
        "id": "leetcode-benchmark-100",
        "title": "Maximum Average Subarray I",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,12,-5,-6,50,3\\], k = 4\n**Output:** 12.75000\n**Explanation:** Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5\\], k = 1\n**Output:** 5.00000"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= k <= n <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic double findMaxAverage(int[] nums, int k) {\n    int n = nums.length;\n    double sum = 0;\n    for (int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n    double max_avg = sum / k;\n    for (int i = k; i < n; i++) {\n        sum = sum - nums[i - k] + nums[i];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    return max_avg;\n}\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "c++": "\n    ```cpp\ndouble findMaxAverage(vector<int>& nums, int k) {\n    int n = nums.size();\n    double sum = 0;\n    for (int i = 0; i < k; ++i) {\n        sum += nums[i];\n    }\n    double max_avg = sum / k;\n    for (int i = k; i < n; ++i) {\n        sum = sum - nums[i - k] + nums[i];\n        max_avg = max(max_avg, sum / k);\n    }\n    return max_avg;\n}\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "python": "\n    ```python\ndef findMaxAverage(nums, k):\n    n = len(nums)\n    sum_ = sum(nums[:k])\n    max_avg = sum_ / k\n    for i in range(k, n):\n        sum_ = sum_ - nums[i - k] + nums[i]\n        max_avg = max(max_avg, sum_ / k)\n    return max_avg\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "javascript": "\n    ```javascript\nfunction findMaxAverage(nums, k) {\n    let n = nums.length;\n    let sum = 0;\n    for (let i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n    let max_avg = sum / k;\n    for (let i = k; i < n; i++) {\n        sum = sum - nums[i - k] + nums[i];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    return max_avg;\n}\n```\n    \n    1. Initialize the sum with the first `k` elements of the input array.\n2. Calculate the average by dividing the sum by `k` and store it in `max_avg`.\n3. Loop through the input array from index `k` to the end.\n4. For each element, update the sum by subtracting the element at the left side of the sliding window (with `k` length) and adding the current element.\n5. Calculate the average again and update the `max_avg` if the current average is higher than the previous `max_avg`.\n6. Return `max_avg` after the loop ends.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,12,-5,-6,50,3], k = 4",
                    "output": " 12.75000",
                    "explanation": " Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75"
                },
                {
                    "input": " nums = [5], k = 1",
                    "output": " 5.00000",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,12,-5,-6,50,3],4",
                    "output": "12.75000"
                },
                {
                    "input": "[5],1",
                    "output": "5.00000"
                }
            ]
        },
        "task_id": "leetcode-benchmark-100",
        "prompt": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted."
    },
    "leetcode-benchmark-101": {
        "id": "leetcode-benchmark-101",
        "title": "Set Mismatch",
        "difficulty": "Easy",
        "content": {
            "problem": "You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.\n\nYou are given an integer array `nums` representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return _them in the form of an array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,4\\]\n**Output:** \\[2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1\\]\n**Output:** \\[1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 104`\n*   `1 <= nums[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] findErrorNums(int[] nums) {\n    int[] result = new int[2];\n    for (int num : nums) {\n        int index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result[0] = index + 1;\n        }\n    }\n    for (int i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result[1] = i + 1;\n            break;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findErrorNums(vector<int>& nums) {\n    vector<int> result;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push_back(index + 1);\n        }\n    }\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "python": "\n    ```python\ndef findErrorNums(nums):\n    result = []\n    for num in nums:\n        index = abs(num) - 1\n        if nums[index] > 0:\n            nums[index] = -nums[index]\n        else:\n            result.append(index + 1)\n    for i, num in enumerate(nums):\n        if num > 0:\n            result.append(i + 1)\n            break\n    return result\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "javascript": "\n    ```javascript\nfunction findErrorNums(nums) {\n    let result = [];\n    for (let num of nums) {\n        let index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        } else {\n            result.push(index + 1);\n        }\n    }\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n            break;\n        }\n    }\n    return result;\n}\n```\n    \n    1. Iterate through the given array, creating and using the index as the absolute value of the current number minus one. By doing this, we visit the indices in a specific order that allows us to mark numbers we have already visited.\n2. If the value at the index is positive, we negate it. If it's negative, it means we found the duplicate number. Store the duplicate number (index + 1) in the result array.\n3. Iterate through the array again to find the first positive value. This index plus one will be the missing number, as others should have been negated in the previous steps.\n4. Add the missing number to the result array and return it.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,2,4]",
                    "output": " [2,3]",
                    "explanation": null
                },
                {
                    "input": " nums = [1,1]",
                    "output": " [1,2]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,2,4]",
                    "output": "[2,3]"
                },
                {
                    "input": "[1,1]",
                    "output": "[1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-101",
        "prompt": "You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.\n\nYou are given an integer array `nums` representing the data status of this set after the error.\n\nFind the number that occurs twice and the number that is missing and return _them in the form of an array_."
    },
    "leetcode-benchmark-102": {
        "id": "leetcode-benchmark-102",
        "title": "Two Sum IV - Input is a BST",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree and an integer `k`, return `true` _if there exist two elements in the BST such that their sum is equal to_ `k`, _or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,3,6,2,4,null,7\\], k = 9\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,3,6,2,4,null,7\\], k = 28\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `-104 <= Node.val <= 104`\n*   `root` is guaranteed to be a **valid** binary search tree.\n*   `-105 <= k <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean findTarget(TreeNode root, int k) {\n    Set<Integer> nodes = new HashSet<>();\n    return findNode(root, k, nodes);\n}\n\npublic boolean findNode(TreeNode root, int k, Set<Integer> nodes) {\n    if (root == null) return false;\n    if (nodes.contains(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "c++": "\n    ```cpp\nbool findTarget(TreeNode* root, int k) {\n    unordered_set<int> nodes;\n    return findNode(root, k, nodes);\n}\n\nbool findNode(TreeNode* root, int k, unordered_set<int>& nodes) {\n    if (!root) return false;\n    if (nodes.count(k - root->val)) return true;\n    nodes.insert(root->val);\n    return findNode(root->left, k, nodes) || findNode(root->right, k, nodes);\n}\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "python": "\n    ```python\ndef findTarget(root, k):\n    nodes = set()\n    return findNode(root, k, nodes)\n\ndef findNode(root, k, nodes):\n    if not root:\n        return False\n    if k - root.val in nodes:\n        return True\n    nodes.add(root.val)\n    return findNode(root.left, k, nodes) or findNode(root.right, k, nodes)\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "javascript": "\n    ```javascript\nfunction findTarget(root, k) {\n    const nodes = new Set();\n    return findNode(root, k, nodes);\n}\n\nfunction findNode(root, k, nodes) {\n    if (!root) return false;\n    if (nodes.has(k - root.val)) return true;\n    nodes.add(root.val);\n    return findNode(root.left, k, nodes) || findNode(root.right, k, nodes);\n}\n```\n    \n    The function takes the root of a binary search tree and a target number `k`. The purpose is to see if there are two elements in the tree that sum up to `k`. We start by initializing a set called `nodes` to keep track of visited values. Then, we create a recursive helper function called `findNode`. \n\nIn the `findNode` function, the base case is when the current root is null, meaning we've reached the end of a branch, and we return false as no such pair of elements found yet. If `k - root.val` is found in our set, that means we've found a pair of elements that sum up to `k`, and we can return true. Otherwise, we proceed with the left and right children of the current root, passing the `nodes` set along to keep track of visited values. This is done using a depth-first search strategy. \n\nThe result is a boolean indicating whether or not two elements in the tree sum up to `k`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [5,3,6,2,4,null,7], k = 9",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " root = [5,3,6,2,4,null,7], k = 28",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[5,3,6,2,4,null,7],9",
                    "output": "True"
                },
                {
                    "input": "[5,3,6,2,4,null,7],28",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-102",
        "prompt": "Given the `root` of a binary search tree and an integer `k`, return `true` _if there exist two elements in the BST such that their sum is equal to_ `k`, _or_ `false` _otherwise_."
    },
    "leetcode-benchmark-103": {
        "id": "leetcode-benchmark-103",
        "title": "Robot Return to Origin",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\n\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\n\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.",
            "examples": [
                "**Example 1:**\n\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n",
                "**Example 2:**\n\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean judgeCircle(String moves) {\n    int x = 0, y = 0;\n    for(char move : moves.toCharArray()) {\n        if(move == 'U') y++;\n        else if(move == 'D') y--;\n        else if(move == 'R') x++;\n        else if(move == 'L') x--;\n    }\n    return x == 0 && y == 0;\n}\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\nbool judgeCircle(string moves) {\n    int x = 0, y = 0;\n    for(char move : moves) {\n        if(move == 'U') y++;\n        else if(move == 'D') y--;\n        else if(move == 'R') x++;\n        else if(move == 'L') x--;\n    }\n    return x == 0 && y == 0;\n}\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef judgeCircle(moves: str) -> bool:\n    x, y = 0, 0\n    for move in moves:\n        if move == 'U': y += 1\n        elif move == 'D': y -= 1\n        elif move == 'R': x += 1\n        elif move == 'L': x -= 1\n    return x == 0 and y == 0\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "javascript": "\n    ```javascript\nfunction judgeCircle(moves) {\n    let x = 0, y = 0;\n    for(let move of moves) {\n        if(move === 'U') y++;\n        else if(move === 'D') y--;\n        else if(move === 'R') x++;\n        else if(move === 'L') x--;\n    }\n    return x === 0 && y === 0;\n}\n```\n    \n    The algorithm keeps track of the robot's position in a 2D plane using two integer variables `x` and `y` initialized to 0. The `x` represents the horizontal position, and `y` represents the vertical position. It then iterates through the given moves string and updates the position based on the current move. If a move is 'R', it increments `x`; if it's 'L', it decrements `x`; if it's 'U', it increments `y`; and if it's 'D', it decrements `y`. After processing all the moves, the algorithm checks if both `x` equals to 0 and `y` equals to 0. If both are 0, it means the robot is back to the origin, and it returns true; otherwise, it returns false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " moves =  \"UD \"",
                    "output": " True",
                    "explanation": ": The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true."
                },
                {
                    "input": " moves =  \"LL \"",
                    "output": " False",
                    "explanation": ": The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves."
                }
            ],
            "function_input": [
                {
                    "input": "\"UD\"",
                    "output": "True"
                },
                {
                    "input": "\"LL\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-103",
        "prompt": "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\n\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\n\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move."
    },
    "leetcode-benchmark-104": {
        "id": "leetcode-benchmark-104",
        "title": "Image Smoother",
        "difficulty": "Easy",
        "content": {
            "problem": "An **image smoother** is a filter of the size `3 x 3` that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\nGiven an `m x n` integer matrix `img` representing the grayscale of an image, return _the image after applying the smoother on each cell of it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** img = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:**\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n",
                "**Example 2:**\n\n**Input:** img = \\[\\[100,200,100\\],\\[200,50,200\\],\\[100,200,100\\]\\]\n**Output:** \\[\\[137,141,137\\],\\[141,138,141\\],\\[137,141,137\\]\\]\n**Explanation:**\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138"
            ],
            "constraints": "**Constraints:**\n\n*   `m == img.length`\n*   `n == img[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= img[i][j] <= 255`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[][] imageSmoother(int[][] img) {\n    int m = img.length, n = img[0].length;\n    int[][] result = new int[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n    int m = img.size(), n = img[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int count = 0, sum = 0;\n            for (int x = i - 1; x <= i + 1; x++) {\n                for (int y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = sum / count;\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "python": "\n    ```python\ndef imageSmoother(img):\n    m, n = len(img), len(img[0])\n    result = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            count, total = 0, 0\n            for x in range(i - 1, i + 2):\n                for y in range(j - 1, j + 2):\n                    if 0 <= x < m and 0 <= y < n:\n                        total += img[x][y]\n                        count += 1\n            result[i][j] = total // count\n\n    return result\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "javascript": "\n    ```javascript\nfunction imageSmoother(img) {\n    const m = img.length, n = img[0].length;\n    const result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let count = 0, sum = 0;\n\n            for (let x = i - 1; x <= i + 1; x++) {\n                for (let y = j - 1; y <= j + 1; y++) {\n                    if (x >= 0 && x < m && y >= 0 && y < n) {\n                        sum += img[x][y];\n                        count++;\n                    }\n                }\n            }\n            result[i][j] = Math.floor(sum / count);\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Find the dimensions (m, n) of the input img array.\n2. Initialize the result array with the same dimensions as img.\n3. Iterate through each cell (i, j) of the img array.\n4. Iterate through 8 neighboring cells with corresponding coordinates (x, y) within a 3x3 grid centered at (i, j).\n5. Check if the neighboring cell (x, y) is within the boundaries of img. If so, add the value of img[x][y] to the sum, and increment the count.\n6. Calculate the average by dividing the sum by count and round down the result.\n7. Set the value of the result[i][j] to the calculated average.\n8. Return the result array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " img = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": " [[0,0,0],[0,0,0],[0,0,0]]",
                    "explanation": "\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0"
                },
                {
                    "input": " img = [[100,200,100],[200,50,200],[100,200,100]]",
                    "output": " [[137,141,137],[141,138,141],[137,141,137]]",
                    "explanation": "\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138"
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "[[0,0,0],[0,0,0],[0,0,0]]"
                },
                {
                    "input": "[[100,200,100],[200,50,200],[100,200,100]]",
                    "output": "[[137,141,137],[141,138,141],[137,141,137]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-104",
        "prompt": "An **image smoother** is a filter of the size `3 x 3` that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\nGiven an `m x n` integer matrix `img` representing the grayscale of an image, return _the image after applying the smoother on each cell of it_."
    },
    "leetcode-benchmark-105": {
        "id": "leetcode-benchmark-105",
        "title": "Longest Continuous Increasing Subsequence",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an unsorted array of integers `nums`, return _the length of the longest **continuous increasing subsequence** (i.e. subarray)_. The subsequence must be **strictly** increasing.\n\nA **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5,4,7\\]\n**Output:** 3\n**Explanation:** The longest continuous increasing subsequence is \\[1,3,5\\] with length 3.\nEven though \\[1,3,5,7\\] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\]\n**Output:** 1\n**Explanation:** The longest continuous increasing subsequence is \\[2\\] with length 1. Note that it must be strictly\nincreasing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findLengthOfLCIS(int[] nums) {\n    if (nums.length == 0) return 0;\n    int result = 1, current = 1;\n    for (int i = 1; i < nums.length; ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = Math.max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint findLengthOfLCIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    int result = 1, current = 1;\n    for (int i = 1; i < nums.size(); ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef findLengthOfLCIS(nums):\n    if not nums:\n        return 0\n    result, current = 1, 1\n    for i in range(1, len(nums)):\n        current = current + 1 if nums[i] > nums[i - 1] else 1\n        result = max(result, current)\n    return result\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "javascript": "\n    ```javascript\nfunction findLengthOfLCIS(nums) {\n    if (nums.length === 0) return 0;\n    let result = 1, current = 1;\n    for (let i = 1; i < nums.length; ++i) {\n        current = nums[i] > nums[i - 1] ? current + 1 : 1;\n        result = Math.max(result, current);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n\n1. If the input array is empty, return 0.\n2. Initialize two variables: `result` (to hold the maximum length found so far) and `current` (to hold the length of the current increasing subsequence). Both are initially set to 1.\n3. Iterate through the array from index 1 to the end.\n4. For each index, if the current element is greater than the previous element, increase the length of the current increasing subsequence by 1. Otherwise, reset it to 1.\n5. Update the result with the maximum value between the current result and the current increasing subsequence length.\n6. Return the result after the iteration completes.\n\nThis algorithm has a linear time complexity, i.e., O(n), where n is the length of the input array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,5,4,7]",
                    "output": " 3",
                    "explanation": " The longest continuous increasing subsequence is \\[1,3,5\\] with length 3.\nEven though \\[1,3,5,7\\] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4."
                },
                {
                    "input": " nums = [2,2,2,2,2]",
                    "output": " 1",
                    "explanation": " The longest continuous increasing subsequence is \\[2\\] with length 1. Note that it must be strictly\nincreasing."
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,5,4,7]",
                    "output": "3"
                },
                {
                    "input": "[2,2,2,2,2]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-105",
        "prompt": "Given an unsorted array of integers `nums`, return _the length of the longest **continuous increasing subsequence** (i.e. subarray)_. The subsequence must be **strictly** increasing.\n\nA **continuous increasing subsequence** is defined by two indices `l` and `r` (`l < r`) such that it is `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` and for each `l <= i < r`, `nums[i] < nums[i + 1]`."
    },
    "leetcode-benchmark-106": {
        "id": "leetcode-benchmark-106",
        "title": "Valid Palindrome II",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return `true` _if the_ `s` _can be palindrome after deleting **at most one** character from it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aba \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abca \"\n**Output:** true\n**Explanation:** You could delete the character 'c'.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"abc \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean validPalindrome(String s) {\n    for (int i = 0, j = s.length() - 1; i < j; i++, j--) {\n        if (s.charAt(i) != s.charAt(j)) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s.charAt(temp1) == s.charAt(temp2)) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "c++": "\n    ```cpp\nbool validPalindrome(string s) {\n    for (int i = 0, j = s.size() - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            int temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "python": "\n    ```python\ndef validPalindrome(s: str) -> bool:\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            temp1, temp2 = i + 1, j\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            temp1, temp2 = i, j - 1\n            while temp1 < temp2 and s[temp1] == s[temp2]:\n                temp1 += 1\n                temp2 -= 1\n            if temp1 >= temp2:\n                return True\n\n            return False\n        i += 1\n        j -= 1\n    return True\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "javascript": "\n    ```javascript\nfunction validPalindrome(s) {\n    for (let i = 0, j = s.length - 1; i < j; i++, j--) {\n        if (s[i] != s[j]) {\n            let temp1 = i + 1, temp2 = j;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n\n            temp1 = i; temp2 = j - 1;\n            while (temp1 < temp2 && s[temp1] == s[temp2]) { temp1++; temp2--; }\n            if (temp1 >= temp2) return true;\n            \n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize two pointers, `i` at the start and `j` at the end of the input string `s`.\n2. Check if characters at positions `i` and `j` are equal. If they are not,\n   1. Check if the resulting substring `s[i+1, j]` is a palindrome.\n   2. If it is not, check if the resulting substring `s[i, j-1]` is a palindrome.\n   3. If neither of the substrings is a palindrome, return false.\n3. Move both pointers towards each other and repeat step 2.\n4. If the pointers crossed each other or met, the entire string `s` can be a palindrome after deleting at most one character, so return true. \n\nThe functions for all four languages follow the same logic as explained above.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aba \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s =  \"abca \"",
                    "output": " True",
                    "explanation": " You could delete the character 'c'."
                },
                {
                    "input": " s =  \"abc \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aba\"",
                    "output": "True"
                },
                {
                    "input": "\"abca\"",
                    "output": "True"
                },
                {
                    "input": "\"abc\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-106",
        "prompt": "Given a string `s`, return `true` _if the_ `s` _can be palindrome after deleting **at most one** character from it_."
    },
    "leetcode-benchmark-107": {
        "id": "leetcode-benchmark-107",
        "title": "Baseball Game",
        "difficulty": "Easy",
        "content": {
            "problem": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:\n\n*   An integer `x`.\n    *   Record a new score of `x`.\n*   `'+'`.\n    *   Record a new score that is the sum of the previous two scores.\n*   `'D'`.\n    *   Record a new score that is the double of the previous score.\n*   `'C'`.\n    *   Invalidate the previous score, removing it from the record.\n\nReturn _the sum of all the scores on the record after applying all the operations_.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer and that all operations are valid.",
            "examples": [
                "**Example 1:**\n\n**Input:** ops = \\[ \"5 \", \"2 \", \"C \", \"D \", \"+ \"\\]\n**Output:** 30\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"2 \" - Add 2 to the record, record is now \\[5, 2\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5\\].\n \"D \" - Add 2 \\* 5 = 10 to the record, record is now \\[5, 10\\].\n \"+ \" - Add 5 + 10 = 15 to the record, record is now \\[5, 10, 15\\].\nThe total sum is 5 + 10 + 15 = 30.\n\n",
                "**Example 2:**\n\n**Input:** ops = \\[ \"5 \", \"-2 \", \"4 \", \"C \", \"D \", \"9 \", \"+ \", \"+ \"\\]\n**Output:** 27\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"-2 \" - Add -2 to the record, record is now \\[5, -2\\].\n \"4 \" - Add 4 to the record, record is now \\[5, -2, 4\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5, -2\\].\n \"D \" - Add 2 \\* -2 = -4 to the record, record is now \\[5, -2, -4\\].\n \"9 \" - Add 9 to the record, record is now \\[5, -2, -4, 9\\].\n \"+ \" - Add -4 + 9 = 5 to the record, record is now \\[5, -2, -4, 9, 5\\].\n \"+ \" - Add 9 + 5 = 14 to the record, record is now \\[5, -2, -4, 9, 5, 14\\].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n",
                "**Example 3:**\n\n**Input:** ops = \\[ \"1 \", \"C \"\\]\n**Output:** 0\n**Explanation:**\n \"1 \" - Add 1 to the record, record is now \\[1\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[\\].\nSince the record is empty, the total sum is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= operations.length <= 1000`\n*   `operations[i]` is `\"C \"`, `\"D \"`, `\"+ \"`, or a string representing an integer in the range `[-3 * 104, 3 * 104]`.\n*   For operation `\"+ \"`, there will always be at least two previous scores on the record.\n*   For operations `\"C \"` and `\"D \"`, there will always be at least one previous score on the record.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int calPoints(String[] ops) {\n        LinkedList<Integer> record = new LinkedList<>();\n        for (String op : ops) {\n            if (op.equals(\"+\")) {\n                record.add(record.getLast() + record.get(record.size() - 2));\n            } else if (op.equals(\"D\")) {\n                record.add(record.getLast() * 2);\n            } else if (op.equals(\"C\")) {\n                record.removeLast();\n            } else {\n                record.add(Integer.parseInt(op));\n            }\n        }\n        return record.stream().mapToInt(Integer::intValue).sum();\n    }\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint calPoints(std::vector<std::string>& ops) {\n    std::vector<int> record;\n    for (const std::string& op : ops) {\n        if (op == \"+\") {\n            record.push_back(record[record.size() - 1] + record[record.size() - 2]);\n        } else if (op == \"D\") {\n            record.push_back(2 * record.back());\n        } else if (op == \"C\") {\n            record.pop_back();\n        } else {\n            record.push_back(stoi(op));\n        }\n    }\n    return std::accumulate(record.begin(), record.end(), 0);\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "python": "\n    ```python\ndef calPoints(ops):\n    record = []\n    for op in ops:\n        if op == '+':\n            record.append(record[-1] + record[-2])\n        elif op == 'D':\n            record.append(record[-1] * 2)\n        elif op == 'C':\n            record.pop()\n        else:\n            record.append(int(op))\n    return sum(record)\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "javascript": "\n    ```javascript\nfunction calPoints(ops) {\n    let record = [];\n    for (let op of ops) {\n        if (op === '+') {\n            record.push(record[record.length - 1] + record[record.length - 2]);\n        } else if (op === 'D') {\n            record.push(record[record.length - 1] * 2);\n        } else if (op === 'C') {\n            record.pop();\n        } else {\n            record.push(parseInt(op));\n        }\n    }\n    return record.reduce((a, b) => a + b, 0);\n}\n```\n\n    \n    We use a dynamic array (in languages other than Java, where we use LinkedList for simplicity) to store the valid scores. We iterate through the given `ops` array of strings, and for each string, we perform the operations as follows:\n\n1. If the operation is '+', we add the last two scores and append the sum to the record.\n2. If the operation is 'D', we double the last score and append it to the record.\n3. If the operation is 'C', we remove the last score from the record.\n4. If the operation is a number, we parse the integer value and append it to the record.\n\nAfter iterating through all operations, we calculate the sum of all the scores in the record and return it.\n\nThe time complexity of this algorithm is O(n) where n is the size of ops, as we iterate once through the array and perform constant-time operations within the loop. The space complexity is also O(n), as we store the valid scores in the record array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " ops = [ \"5 \", \"2 \", \"C \", \"D \", \"+ \"]",
                    "output": " 30",
                    "explanation": "\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"2 \" - Add 2 to the record, record is now \\[5, 2\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5\\].\n \"D \" - Add 2 \\* 5 = 10 to the record, record is now \\[5, 10\\].\n \"+ \" - Add 5 + 10 = 15 to the record, record is now \\[5, 10, 15\\].\nThe total sum is 5 + 10 + 15 = 30."
                },
                {
                    "input": " ops = [ \"5 \", \"-2 \", \"4 \", \"C \", \"D \", \"9 \", \"+ \", \"+ \"]",
                    "output": " 27",
                    "explanation": "\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"-2 \" - Add -2 to the record, record is now \\[5, -2\\].\n \"4 \" - Add 4 to the record, record is now \\[5, -2, 4\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5, -2\\].\n \"D \" - Add 2 \\* -2 = -4 to the record, record is now \\[5, -2, -4\\].\n \"9 \" - Add 9 to the record, record is now \\[5, -2, -4, 9\\].\n \"+ \" - Add -4 + 9 = 5 to the record, record is now \\[5, -2, -4, 9, 5\\].\n \"+ \" - Add 9 + 5 = 14 to the record, record is now \\[5, -2, -4, 9, 5, 14\\].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27."
                },
                {
                    "input": " ops = [ \"1 \", \"C \"]",
                    "output": " 0",
                    "explanation": "\n \"1 \" - Add 1 to the record, record is now \\[1\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[\\].\nSince the record is empty, the total sum is 0."
                }
            ],
            "function_input": [
                {
                    "input": "[\"5\",\"2\",\"C\",\"D\",\"+\"]",
                    "output": "30"
                },
                {
                    "input": "[\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]",
                    "output": "27"
                },
                {
                    "input": "[\"1\",\"C\"]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-107",
        "prompt": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:\n\n*   An integer `x`.\n    *   Record a new score of `x`.\n*   `'+'`.\n    *   Record a new score that is the sum of the previous two scores.\n*   `'D'`.\n    *   Record a new score that is the double of the previous score.\n*   `'C'`.\n    *   Invalidate the previous score, removing it from the record.\n\nReturn _the sum of all the scores on the record after applying all the operations_.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer and that all operations are valid."
    },
    "leetcode-benchmark-108": {
        "id": "leetcode-benchmark-108",
        "title": "Binary Number with Alternating Bits",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** true\n**Explanation:** The binary representation of 5 is: 101\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** false\n**Explanation:** The binary representation of 7 is: 111.\n\n",
                "**Example 3:**\n\n**Input:** n = 11\n**Output:** false\n**Explanation:** The binary representation of 11 is: 1011."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool hasAlternatingBits(int n) {\n    int prevBit = n % 2;\n    n /= 2;\n    while (n > 0) {\n        int currBit = n % 2;\n        if (currBit == prevBit) return false;\n        prevBit = currBit;\n        n /= 2;\n    }\n    return true;\n}\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "python": "\n    ```python\ndef has_alternating_bits(n):\n    prev_bit = n % 2\n    n //= 2\n    while n > 0:\n        curr_bit = n % 2\n        if curr_bit == prev_bit:\n            return False\n        prev_bit = curr_bit\n        n //= 2\n    return True\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "javascript": "\n    ```javascript\nfunction hasAlternatingBits(n) {\n    let prevBit = n % 2;\n    n = Math.floor(n / 2);\n    while (n > 0) {\n        let currBit = n % 2;\n        if (currBit === prevBit) return false;\n        prevBit = currBit;\n        n = Math.floor(n / 2);\n    }\n    return true;\n}\n```\n\n    \n    The algorithm initializes `prevBit` with the least significant bit of `n`. Then, it divides `n` by 2 to eliminate the least significant bit. While `n` is greater than 0, the algorithm retrieves the least significant bit of `n` and compares it to `prevBit`. If they are equal, it means the adjacent bits are not alternating, so the function returns false. Otherwise, it assigns the least significant bit to `prevBit` and divides `n` by 2 again to move on to the next bit. When `n` becomes 0, it means all adjacent bits in the given integer are alternating, and the function returns true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5",
                    "output": " True",
                    "explanation": " The binary representation of 5 is: 101"
                },
                {
                    "input": " n = 7",
                    "output": " False",
                    "explanation": " The binary representation of 7 is: 111."
                },
                {
                    "input": " n = 11",
                    "output": " False",
                    "explanation": " The binary representation of 11 is: 1011."
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "True"
                },
                {
                    "input": "7",
                    "output": "False"
                },
                {
                    "input": "11",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-108",
        "prompt": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values."
    },
    "leetcode-benchmark-109": {
        "id": "leetcode-benchmark-109",
        "title": "Count Binary Substrings",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"00110011 \"\n**Output:** 6\n**Explanation:** There are 6 substrings that have equal number of consecutive 1's and 0's:  \"0011 \",  \"01 \",  \"1100 \",  \"10 \",  \"0011 \", and  \"01 \".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso,  \"00110011 \" is not a valid substring because all the 0's (and 1's) are not grouped together.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10101 \"\n**Output:** 4\n**Explanation:** There are 4 substrings:  \"10 \",  \"01 \",  \"10 \",  \"01 \" that have equal number of consecutive 1's and 0's."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'0'` or `'1'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countBinarySubstrings(String s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "c++": "\n    ```cpp\nint countBinarySubstrings(string s) {\n    int prev = 0, curr = 1, result = 0;\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            curr++;\n        } else {\n            result += min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "python": "\n    ```python\ndef count_binary_substrings(s: str) -> int:\n    prev, curr, result = 0, 1, 0\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            curr += 1\n        else:\n            result += min(prev, curr)\n            prev, curr = curr, 1\n    return result + min(prev, curr)\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "javascript": "\n    ```javascript\nfunction countBinarySubstrings(s) {\n    let prev = 0, curr = 1, result = 0;\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            curr++;\n        } else {\n            result += Math.min(prev, curr);\n            prev = curr;\n            curr = 1;\n        }\n    }\n    return result + Math.min(prev, curr);\n}\n```\n    \n    Iterate through the binary string s. Keep track of the count of consecutive equal characters (curr) and the count of consecutive equal characters in the previous group (prev). When we encounter a character different from the previous one, add the minimum of prev and curr to the result. Update prev to the value of curr and reset curr to 1. After the iteration, add the minimum of prev and curr to the result and return the result. This will count all valid binary substrings with consecutive groups of 0's and 1's.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"00110011 \"",
                    "output": " 6",
                    "explanation": " There are 6 substrings that have equal number of consecutive 1's and 0's:  \"0011 \",  \"01 \",  \"1100 \",  \"10 \",  \"0011 \", and  \"01 \".\nNotice that some of these substrings repeat and are counted the number of times they occur.\nAlso,  \"00110011 \" is not a valid substring because all the 0's (and 1's) are not grouped together."
                },
                {
                    "input": " s =  \"10101 \"",
                    "output": " 4",
                    "explanation": " There are 4 substrings:  \"10 \",  \"01 \",  \"10 \",  \"01 \" that have equal number of consecutive 1's and 0's."
                }
            ],
            "function_input": [
                {
                    "input": "\"00110011\"",
                    "output": "6"
                },
                {
                    "input": "\"10101\"",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-109",
        "prompt": "Given a binary string `s`, return the number of non-empty substrings that have the same number of `0`'s and `1`'s, and all the `0`'s and all the `1`'s in these substrings are grouped consecutively.\n\nSubstrings that occur multiple times are counted the number of times they occur."
    },
    "leetcode-benchmark-110": {
        "id": "leetcode-benchmark-110",
        "title": "Degree of an Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a non-empty array of non-negative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements.\n\nYour task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,2,3,1\\]\n**Output:** 2\n**Explanation:** \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n\\[1, 2, 2, 3, 1\\], \\[1, 2, 2, 3\\], \\[2, 2, 3, 1\\], \\[1, 2, 2\\], \\[2, 2, 3\\], \\[2, 2\\]\nThe shortest length is 2. So return 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,2,3,1,4,2\\]\n**Output:** 6\n**Explanation:** \nThe degree is 3 because the element 2 is repeated 3 times.\nSo \\[2,2,3,1,4,2\\] is the shortest subarray, therefore returning 6."
            ],
            "constraints": "**Constraints:**\n\n*   `nums.length` will be between 1 and 50,000.\n*   `nums[i]` will be an integer between 0 and 49,999.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\nclass Solution {\n    public int findShortestSubArray(int[] nums) {\n        HashMap<Integer, Integer> freq_map = new HashMap<>(), start_map = new HashMap<>();\n        int max_freq = 0, min_length = nums.length;\n        \n        for (int i = 0; i < nums.length; ++i) {\n            if (!start_map.containsKey(nums[i])) {\n                start_map.put(nums[i], i);\n            }\n            freq_map.put(nums[i], freq_map.getOrDefault(nums[i], 0) + 1);\n            \n            int freq = freq_map.get(nums[i]);\n            if (freq > max_freq) {\n                max_freq = freq;\n                min_length = i - start_map.get(nums[i]) + 1;\n            } else if (freq == max_freq) {\n                min_length = Math.min(min_length, i - start_map.get(nums[i]) + 1);\n            }\n        }\n        \n        return min_length;\n    }\n}\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint findShortestSubArray(std::vector<int>& nums) {\n    std::unordered_map<int, int> freq_map, start_map;\n    int max_freq = 0, min_length = nums.size();\n\n    for (int i = 0; i < nums.size(); ++i) {\n        if (start_map.count(nums[i]) == 0) {\n            start_map[nums[i]] = i;\n        }\n        freq_map[nums[i]]++;\n\n        int freq = freq_map[nums[i]];\n        if (freq > max_freq) {\n            max_freq = freq;\n            min_length = i - start_map[nums[i]] + 1;\n        } else if (freq == max_freq) {\n            min_length = std::min(min_length, i - start_map[nums[i]] + 1);\n        }\n    }\n\n    return min_length;\n}\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "python": "\n    ```python\ndef findShortestSubArray(nums):\n    freq_map, start_map = {}, {}\n    max_freq, min_length = 0, len(nums)\n\n    for i, num in enumerate(nums):\n        if num not in start_map:\n            start_map[num] = i\n        freq_map[num] = freq_map.get(num, 0) + 1\n\n        freq = freq_map[num]\n        if freq > max_freq:\n            max_freq = freq\n            min_length = i - start_map[num] + 1\n        elif freq == max_freq:\n            min_length = min(min_length, i - start_map[num] + 1)\n\n    return min_length\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "javascript": "\n    ```javascript\nfunction findShortestSubArray(nums) {\n    const freq_map = {}, start_map = {};\n    let max_freq = 0, min_length = nums.length;\n\n    for (let i = 0; i < nums.length; ++i) {\n        if (!start_map.hasOwnProperty(nums[i])) {\n            start_map[nums[i]] = i;\n        }\n        if (!freq_map.hasOwnProperty(nums[i])) {\n            freq_map[nums[i]] = 0;\n        }\n        freq_map[nums[i]]++;\n\n        const freq = freq_map[nums[i]];\n        if (freq > max_freq) {\n            max_freq = freq;\n            min_length = i - start_map[nums[i]] + 1;\n        } else if (freq === max_freq) {\n            min_length = Math.min(min_length, i - start_map[nums[i]] + 1);\n        }\n    }\n\n    return min_length;\n}\n```\n    \n    The algorithm first initializes two hash maps: `freq_map` to store the frequency count of each element and `start_map` to store the starting index of each unique element in the array. The max frequency `max_freq` and the minimum length `min_length` are initialized to 0 and the length of the input array, respectively.\n\nThen, iterate through the input array, updating the frequency count of each element in `freq_map` and storing the starting index of each unique element in `start_map`.\n\nFor each index, update `max_freq` if a higher frequency is found. If the frequency is equal to `max_freq`, update `min_length` with the minimum length of the subarray having same degree as `nums`.\n\nFinally, the algorithm returns the smallest length of a subarray with the maximum frequency. This approach has a time complexity of O(n), where n is the length of the input array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,2,3,1]",
                    "output": " 2",
                    "explanation": " \nThe input array has a degree of 2 because both elements 1 and 2 appear twice.\nOf the subarrays that have the same degree:\n\\[1, 2, 2, 3, 1\\], \\[1, 2, 2, 3\\], \\[2, 2, 3, 1\\], \\[1, 2, 2\\], \\[2, 2, 3\\], \\[2, 2\\]\nThe shortest length is 2. So return 2."
                },
                {
                    "input": " nums = [1,2,2,3,1,4,2]",
                    "output": " 6",
                    "explanation": " \nThe degree is 3 because the element 2 is repeated 3 times.\nSo \\[2,2,3,1,4,2\\] is the shortest subarray, therefore returning 6."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,2,3,1]",
                    "output": "2"
                },
                {
                    "input": "[1,2,2,3,1,4,2]",
                    "output": "6"
                }
            ]
        },
        "task_id": "leetcode-benchmark-110",
        "prompt": "Given a non-empty array of non-negative integers `nums`, the **degree** of this array is defined as the maximum frequency of any one of its elements.\n\nYour task is to find the smallest possible length of a (contiguous) subarray of `nums`, that has the same degree as `nums`."
    },
    "leetcode-benchmark-111": {
        "id": "leetcode-benchmark-111",
        "title": "Binary Search",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 9\n**Output:** 4\n**Explanation:** 9 exists in nums and its index is 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,0,3,5,9,12\\], target = 2\n**Output:** -1\n**Explanation:** 2 does not exist in nums so return -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 < nums[i], target < 104`\n*   All the integers in `nums` are **unique**.\n*   `nums` is sorted in ascending order.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "c++": "\n    ```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "python": "\n    ```python\ndef search(nums: List[int], target: int) -> int:\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "javascript": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) return mid;\n        if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n```\n\n    \n    The algorithm implements a binary search, since the input array is sorted in ascending order. We start with two pointers, `left` and `right`, representing the beginning and the end of the search range, respectively. We then find the middle element of the array (or subarray) by calculating the average of `left` and `right` and round it down.\n\nIf the middle element matches the target, we return its index. If the middle element is smaller than the target, we set `left` to the next index (`mid + 1`). If the middle element is greater than the target, we set `right` to the previous index (`mid - 1`). We continue iterating until we find the target or the pointers cross (`left > right`), in which case we return `-1` because the target is not in the array. The time complexity of this algorithm is O(log n).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-1,0,3,5,9,12], target = 9",
                    "output": " 4",
                    "explanation": " 9 exists in nums and its index is 4"
                },
                {
                    "input": " nums = [-1,0,3,5,9,12], target = 2",
                    "output": " -1",
                    "explanation": " 2 does not exist in nums so return -1"
                }
            ],
            "function_input": [
                {
                    "input": "[-1,0,3,5,9,12],9",
                    "output": "4"
                },
                {
                    "input": "[-1,0,3,5,9,12],2",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-111",
        "prompt": "Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.\n\nYou must write an algorithm with `O(log n)` runtime complexity."
    },
    "leetcode-benchmark-112": {
        "id": "leetcode-benchmark-112",
        "title": "To Lower Case",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the string after replacing every uppercase letter with the same lowercase letter_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"Hello \"\n**Output:**  \"hello \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"here \"\n**Output:**  \"here \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LOVELY \"\n**Output:**  \"lovely \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of printable ASCII characters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String toLowerCase(String s) {\n    char[] chars = s.toCharArray();\n    for (int i = 0; i < chars.length; i++) {\n        if (chars[i] >= 'A' && chars[i] <= 'Z') {\n            chars[i] = (char)(chars[i] - 'A' + 'a');\n        }\n    }\n    return new String(chars);\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string toLowerCase(std::string s) {\n    for (char& c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "python": "\n    ```python\ndef toLowerCase(s: str) -> str:\n    return s.lower()\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction toLowerCase(s) {\n    let result = '';\n    for (let i = 0; i < s.length; i++) {\n        let charCode = s.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 90) {\n            charCode += 32;\n        }\n        result += String.fromCharCode(charCode);\n    }\n    return result;\n}\n```\n    \n    The algorithm goes through each character in the input string and checks if the character is an uppercase letter. If it is, it converts the letter to lowercase, otherwise it keeps the character unchanged. In C++ and Java, we use a loop to go through each character and update it in-place. In Python, the built-in `str.lower()` function is used. In JavaScript, we need to create a new string by concatenating the resulting characters. For each language, the modified string is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"Hello \"",
                    "output": "  \"hello \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"here \"",
                    "output": "  \"here \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"LOVELY \"",
                    "output": "  \"lovely \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"Hello\"",
                    "output": "\"hello\""
                },
                {
                    "input": "\"here\"",
                    "output": "\"here\""
                },
                {
                    "input": "\"LOVELY\"",
                    "output": "\"lovely\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-112",
        "prompt": "Given a string `s`, return _the string after replacing every uppercase letter with the same lowercase letter_."
    },
    "leetcode-benchmark-113": {
        "id": "leetcode-benchmark-113",
        "title": "1-bit and 2-bit Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "We have two special characters:\n\n*   The first character can be represented by one bit `0`.\n*   The second character can be represented by two bits (`10` or `11`).\n\nGiven a binary array `bits` that ends with `0`, return `true` if the last character must be a one-bit character.",
            "examples": [
                "**Example 1:**\n\n**Input:** bits = \\[1,0,0\\]\n**Output:** true\n**Explanation:** The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character.\n\n",
                "**Example 2:**\n\n**Input:** bits = \\[1,1,1,0\\]\n**Output:** false\n**Explanation:** The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= bits.length <= 1000`\n*   `bits[i]` is either `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isOneBitCharacter(int[] bits) {\n    int i;\n    for (i = 0; i < bits.length - 1; i++) {\n        i += bits[i];\n    }\n    return i == bits.length - 1;\n}\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool isOneBitCharacter(std::vector<int>& bits) {\n    int i;\n    for (i = 0; i < bits.size() - 1; i++) {\n        i += bits[i];\n    }\n    return i == bits.size() - 1;\n}\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "python": "\n    ```python\ndef is_one_bit_character(bits):\n    i = 0\n    while i < len(bits) - 1:\n        i += bits[i] + 1\n    return i == len(bits) - 1\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction isOneBitCharacter(bits) {\n    let i;\n    for (i = 0; i < bits.length - 1; i++) {\n        i += bits[i];\n    }\n    return i === bits.length - 1;\n}\n```\n    \n    The algorithm iterates through the binary array `bits`. If the current element is 1, the next character will be a 2-bit character, so the index `i` will be incremented by 2 (1 from the current iteration and 1 from the 2-bit character). If the current element is 0, it means that the current character is a 1-bit character, so the index `i` is incremented by 1 (from the current iteration). The loop ends either when reaching the last character or when going beyond it.\n\nAfter the loop, if `i` is equal to the last index of the array (i.e., `bits.size() - 1`, `bits.length - 1`, or `len(bits) - 1` depending on the language), it means the last character is a 1-bit character, and the function returns `true`. Otherwise, it returns `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " bits = [1,0,0]",
                    "output": " True",
                    "explanation": " The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character."
                },
                {
                    "input": " bits = [1,1,1,0]",
                    "output": " False",
                    "explanation": " The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character."
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,0]",
                    "output": "True"
                },
                {
                    "input": "[1,1,1,0]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-113",
        "prompt": "We have two special characters:\n\n*   The first character can be represented by one bit `0`.\n*   The second character can be represented by two bits (`10` or `11`).\n\nGiven a binary array `bits` that ends with `0`, return `true` if the last character must be a one-bit character."
    },
    "leetcode-benchmark-114": {
        "id": "leetcode-benchmark-114",
        "title": "Find Pivot Index",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `nums`, calculate the **pivot index** of this array.\n\nThe **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn _the **leftmost pivot index**_. If no such index exists, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,7,3,6,5,6\\]\n**Output:** 3\n**Explanation:**\nThe pivot index is 3.\nLeft sum = nums\\[0\\] + nums\\[1\\] + nums\\[2\\] = 1 + 7 + 3 = 11\nRight sum = nums\\[4\\] + nums\\[5\\] = 5 + 6 = 11\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** -1\n**Explanation:**\nThere is no index that satisfies the conditions in the problem statement.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,1,-1\\]\n**Output:** 0\n**Explanation:**\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums\\[1\\] + nums\\[2\\] = 1 + -1 = 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-1000 <= nums[i] <= 1000`\n\n**Note:** This question is the same as 1991: [https://leetcode.com/problems/find-the-middle-index-in-array/](https://leetcode.com/problems/find-the-middle-index-in-array/)",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int pivotIndex(int[] nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.length; ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "c++": "\n    ```cpp\nint pivotIndex(vector<int>& nums) {\n    int total_sum = 0, left_sum = 0;\n    for (int num : nums)\n        total_sum += num;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (left_sum == total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "python": "\n    ```python\ndef pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i, num in enumerate(nums):\n        if left_sum == total_sum - left_sum - num:\n            return i\n        left_sum += num\n    return -1\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "javascript": "\n    ```javascript\nfunction pivotIndex(nums) {\n    const total_sum = nums.reduce((a, b) => a + b, 0);\n    let left_sum = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (left_sum === total_sum - left_sum - nums[i])\n            return i;\n        left_sum += nums[i];\n    }\n    return -1;\n}\n```\n\n    \n    1. First, find the total sum of the array.\n2. Iterate through the array, maintaining a running sum of the elements to the left of the current index.\n3. For each index, check if the left sum is equal to the total sum minus the left sum and the value at the current index.\n4. If such equality is found, return the index as the pivot index. If not found, return -1. \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,7,3,6,5,6]",
                    "output": " 3",
                    "explanation": "\nThe pivot index is 3.\nLeft sum = nums\\[0\\] + nums\\[1\\] + nums\\[2\\] = 1 + 7 + 3 = 11\nRight sum = nums\\[4\\] + nums\\[5\\] = 5 + 6 = 11"
                },
                {
                    "input": " nums = [1,2,3]",
                    "output": " -1",
                    "explanation": "\nThere is no index that satisfies the conditions in the problem statement."
                },
                {
                    "input": " nums = [2,1,-1]",
                    "output": " 0",
                    "explanation": "\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums\\[1\\] + nums\\[2\\] = 1 + -1 = 0"
                }
            ],
            "function_input": [
                {
                    "input": "[1,7,3,6,5,6]",
                    "output": "3"
                },
                {
                    "input": "[1,2,3]",
                    "output": "-1"
                },
                {
                    "input": "[2,1,-1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-114",
        "prompt": "Given an array of integers `nums`, calculate the **pivot index** of this array.\n\nThe **pivot index** is the index where the sum of all the numbers **strictly** to the left of the index is equal to the sum of all the numbers **strictly** to the index's right.\n\nIf the index is on the left edge of the array, then the left sum is `0` because there are no elements to the left. This also applies to the right edge of the array.\n\nReturn _the **leftmost pivot index**_. If no such index exists, return `-1`."
    },
    "leetcode-benchmark-115": {
        "id": "leetcode-benchmark-115",
        "title": "Self Dividing Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "A **self-dividing number** is a number that is divisible by every digit it contains.\n\n*   For example, `128` is **a self-dividing number** because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`.\n\nA **self-dividing number** is not allowed to contain the digit zero.\n\nGiven two integers `left` and `right`, return _a list of all the **self-dividing numbers** in the range_ `[left, right]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 1, right = 22\n**Output:** \\[1,2,3,4,5,6,7,8,9,11,12,15,22\\]\n\n",
                "**Example 2:**\n\n**Input:** left = 47, right = 85\n**Output:** \\[48,55,66,77\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left <= right <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public static boolean isSelfDividing(int num) {\n        int n = num;\n        while (n != 0) {\n            int digit = n % 10;\n            if (digit == 0 || num % digit != 0)\n                return false;\n            n /= 10;\n        }\n        return true;\n    }\n\n    public static List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = left; i <= right; ++i) {\n            if (isSelfDividing(i))\n                result.add(i);\n        }\n        return result;\n    }\n}\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool isSelfDividing(int num) {\n    int n = num;\n    while (n) {\n        int digit = n % 10;\n        if (digit == 0 || num % digit != 0)\n            return false;\n        n /= 10;\n    }\n    return true;\n}\n\nstd::vector<int> selfDividingNumbers(int left, int right) {\n    std::vector<int> result;\n    for (int i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push_back(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "python": "\n    ```python\ndef is_self_dividing(num):\n    n = num\n    while n:\n        digit = n % 10\n        if digit == 0 or num % digit != 0:\n            return False\n        n //= 10\n    return True\n\ndef self_dividing_numbers(left, right):\n    return [i for i in range(left, right+1) if is_self_dividing(i)]\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction isSelfDividing(num) {\n    let n = num;\n    while (n) {\n        const digit = n % 10;\n        if (digit === 0 || num % digit !== 0)\n            return false;\n        n = Math.floor(n / 10);\n    }\n    return true;\n}\n\nfunction selfDividingNumbers(left, right) {\n    const result = [];\n    for (let i = left; i <= right; ++i) {\n        if (isSelfDividing(i))\n            result.push(i);\n    }\n    return result;\n}\n```\n    \n    The algorithm consists of two functions: `isSelfDividing` and `selfDividingNumbers`. The first function, `isSelfDividing`, takes an integer as input and returns true if it is a self-dividing number and false otherwise. It does this by checking each digit of the number and verifying that they're nonzero and that the number is divisible by that digit. The checking is done by repeatedly dividing the number by 10 and finding the remainder.\n\nThe second function, `selfDividingNumbers`, takes `left` and `right` as input, and returns a list of self-dividing numbers in the given range. It iterates through all the numbers between `left` and `right` (inclusive) and checks if the number is a self-dividing number using the `isSelfDividing` function. If it is, the number is added to the result list. Finally, the result list is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " left = 1, right = 22",
                    "output": " [1,2,3,4,5,6,7,8,9,11,12,15,22]",
                    "explanation": null
                },
                {
                    "input": " left = 47, right = 85",
                    "output": " [48,55,66,77]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,22",
                    "output": "[1,2,3,4,5,6,7,8,9,11,12,15,22]"
                },
                {
                    "input": "47,85",
                    "output": "[48,55,66,77]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-115",
        "prompt": "A **self-dividing number** is a number that is divisible by every digit it contains.\n\n*   For example, `128` is **a self-dividing number** because `128 % 1 == 0`, `128 % 2 == 0`, and `128 % 8 == 0`.\n\nA **self-dividing number** is not allowed to contain the digit zero.\n\nGiven two integers `left` and `right`, return _a list of all the **self-dividing numbers** in the range_ `[left, right]`."
    },
    "leetcode-benchmark-116": {
        "id": "leetcode-benchmark-116",
        "title": "Flood Fill",
        "difficulty": "Easy",
        "content": {
            "problem": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_.",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[1,1,1\\],\\[1,1,0\\],\\[1,0,1\\]\\], sr = 1, sc = 1, color = 2\n**Output:** \\[\\[2,2,2\\],\\[2,2,0\\],\\[2,0,1\\]\\]\n**Explanation:** From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[0,0,0\\],\\[0,0,0\\]\\], sr = 0, sc = 0, color = 0\n**Output:** \\[\\[0,0,0\\],\\[0,0,0\\]\\]\n**Explanation:** The starting pixel is already colored 0, so no changes are made to the image."
            ],
            "constraints": "**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 50`\n*   `0 <= image[i][j], color < 216`\n*   `0 <= sr < m`\n*   `0 <= sc < n`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n    int startColor = image[sr][sc];\n    fill(image, sr, sc, newColor, startColor);\n    return image;\n}\n\nprivate void fill(int[][] image, int sr, int sc, int newColor, int startColor) {\n    if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\n    image[sr][sc] = newColor;\n    fill(image, sr - 1, sc, newColor, startColor);\n    fill(image, sr + 1, sc, newColor, startColor);\n    fill(image, sr, sc - 1, newColor, startColor);\n    fill(image, sr, sc + 1, newColor, startColor);\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvoid fill(vector<vector<int>>& image, int sr, int sc, int newColor, int startColor) {\n    if (sr < 0 || sc < 0 || sr >= image.size() || sc >= image[0].size() || image[sr][sc] != startColor || image[sr][sc] == newColor) return;\n    image[sr][sc] = newColor;\n    fill(image, sr - 1, sc, newColor, startColor);\n    fill(image, sr + 1, sc, newColor, startColor);\n    fill(image, sr, sc - 1, newColor, startColor);\n    fill(image, sr, sc + 1, newColor, startColor);\n}\n\nvector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n    int startColor = image[sr][sc];\n    fill(image, sr, sc, newColor, startColor);\n    return image;\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "python": "\n    ```python\ndef floodFill(image, sr, sc, newColor):\n    startColor = image[sr][sc]\n    def fill(sr, sc):\n        if not (0 <= sr < len(image)) or not (0 <= sc < len(image[0])) or image[sr][sc] != startColor or image[sr][sc] == newColor: \n            return\n        image[sr][sc] = newColor\n        fill(sr - 1, sc)\n        fill(sr + 1, sc)\n        fill(sr, sc - 1)\n        fill(sr, sc + 1)\n    \n    fill(sr, sc)\n    return image\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction floodFill(image, sr, sc, newColor) {\n    let startColor = image[sr][sc];\n    function fill(sr, sc) {\n        if (sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] !== startColor || image[sr][sc] === newColor) return;\n        image[sr][sc] = newColor;\n        fill(sr - 1, sc);\n        fill(sr + 1, sc);\n        fill(sr, sc - 1);\n        fill(sr, sc + 1);\n    }\n    fill(sr, sc);\n    return image;\n}\n```\n\n    \n    To implement the flood-fill algorithm, we create a `fill` function that receives the image, the target position, the new color, and the starting color. It is not necessary to pass the image every time, because it's mutable, but we require the other parameters each time. We then check if the current position is out of bounds or if the current pixel color at the position is not the same as the starting color or if the current pixel color is equal to the new color. If any of these conditions are met, we return without modifying the image. Otherwise, we set the color of the current pixel to the new color and call `fill` function recursively for each adjacent 4-directionally connected pixel. The main function first sets the `startColor` as the color of the pixel image[sr][sc] and then executes the `fill` function with `sr`, `sc`, `newColor`, and `startColor`. Finally, the modified image is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2",
                    "output": " [[2,2,2],[2,2,0],[2,0,1]]",
                    "explanation": " From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel."
                },
                {
                    "input": " image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0",
                    "output": " [[0,0,0],[0,0,0]]",
                    "explanation": " The starting pixel is already colored 0, so no changes are made to the image."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1,1],[1,1,0],[1,0,1]],1,1,2",
                    "output": "[[2,2,2],[2,2,0],[2,0,1]]"
                },
                {
                    "input": "[[0,0,0],[0,0,0]],0,0,0",
                    "output": "[[0,0,0],[0,0,0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-116",
        "prompt": "An image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn _the modified image after performing the flood fill_."
    },
    "leetcode-benchmark-117": {
        "id": "leetcode-benchmark-117",
        "title": "Largest Number At Least Twice of Others",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` where the largest integer is **unique**.\n\nDetermine whether the largest element in the array is **at least twice** as much as every other number in the array. If it is, return _the **index** of the largest element, or return_ `-1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,6,1,0\\]\n**Output:** 1\n**Explanation:** 6 is the largest integer.\nFor every other number in the array x, 6 is at least twice as big as x.\nThe index of value 6 is 1, so we return 1.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** -1\n**Explanation:** 4 is less than twice the value of 3, so we return -1."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 50`\n*   `0 <= nums[i] <= 100`\n*   The largest element in `nums` is unique.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minCostClimbingStairs(int[] cost) {\n    for(int i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "c++": "\n    ```cpp\nint minCostClimbingStairs(vector<int>& cost) {\n    int n = cost.size();\n    for(int i=2; i<n; i++)\n        cost[i] += min(cost[i-1], cost[i-2]);\n    return min(cost[n-1], cost[n-2]);\n}\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "python": "\n    ```python\ndef minCostClimbingStairs(cost):\n    for i in range(2, len(cost)):\n        cost[i] += min(cost[i-1], cost[i-2])\n    return min(cost[-1], cost[-2])\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "javascript": "\n    ```javascript\nfunction minCostClimbingStairs(cost) {\n    for(let i=2; i<cost.length; i++)\n        cost[i] += Math.min(cost[i-1], cost[i-2]);\n    return Math.min(cost[cost.length-1], cost[cost.length-2]);\n}\n```\n    \n    The algorithm is based on dynamic programming. We loop through the array starting from index 2 (since we can start from step 0 or 1 without any cost), and at each step, we add the minimum of the costs of the previous two steps to the current step. We do this to find the optimal path at each step, which eventually leads to the minimum cost to reach the top. After processing the whole array, we return the minimum of the costs of the last two steps as the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,6,1,0]",
                    "output": " 1",
                    "explanation": " 6 is the largest integer.\nFor every other number in the array x, 6 is at least twice as big as x.\nThe index of value 6 is 1, so we return 1."
                },
                {
                    "input": " nums = [1,2,3,4]",
                    "output": " -1",
                    "explanation": " 4 is less than twice the value of 3, so we return -1."
                }
            ],
            "function_input": [
                {
                    "input": "[3,6,1,0]",
                    "output": "1"
                },
                {
                    "input": "[1,2,3,4]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-117",
        "prompt": "You are given an integer array `nums` where the largest integer is **unique**.\n\nDetermine whether the largest element in the array is **at least twice** as much as every other number in the array. If it is, return _the **index** of the largest element, or return_ `-1` _otherwise_."
    },
    "leetcode-benchmark-118": {
        "id": "leetcode-benchmark-118",
        "title": "Shortest Completing Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `licensePlate` and an array of strings `words`, find the **shortest completing** word in `words`.\n\nA **completing** word is a word that **contains all the letters** in `licensePlate`. **Ignore numbers and spaces** in `licensePlate`, and treat letters as **case insensitive**. If a letter appears more than once in `licensePlate`, then it must appear in the word the same number of times or more.\n\nFor example, if `licensePlate` `= \"aBc 12c \"`, then it contains letters `'a'`, `'b'` (ignoring case), and `'c'` twice. Possible **completing** words are `\"abccdef \"`, `\"caaacab \"`, and `\"cbca \"`.\n\nReturn _the shortest **completing** word in_ `words`_._ It is guaranteed an answer exists. If there are multiple shortest **completing** words, return the **first** one that occurs in `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** licensePlate =  \"1s3 PSt \", words = \\[ \"step \", \"steps \", \"stripe \", \"stepple \"\\]\n**Output:**  \"steps \"\n**Explanation:** licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n \"step \" contains 't' and 'p', but only contains 1 's'.\n \"steps \" contains 't', 'p', and both 's' characters.\n \"stripe \" is missing an 's'.\n \"stepple \" is missing an 's'.\nSince  \"steps \" is the only word containing all the letters, that is the answer.\n\n",
                "**Example 2:**\n\n**Input:** licensePlate =  \"1s3 456 \", words = \\[ \"looks \", \"pest \", \"stew \", \"show \"\\]\n**Output:**  \"pest \"\n**Explanation:** licensePlate only contains the letter 's'. All the words contain 's', but among these  \"pest \",  \"stew \", and  \"show \" are shortest. The answer is  \"pest \" because it is the word that appears earliest of the 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= licensePlate.length <= 7`\n*   `licensePlate` contains digits, letters (uppercase or lowercase), or space `' '`.\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length <= 15`\n*   `words[i]` consists of lower case English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String shortestCompletingWord(String licensePlate, String[] words) {\n    HashMap<Character, Integer> lpCount = new HashMap<>();\n    for (char c : licensePlate.toCharArray()) {\n        if (Character.isLetter(c)) {\n            char lower = Character.toLowerCase(c);\n            lpCount.put(lower, lpCount.getOrDefault(lower, 0) + 1);\n        }\n    }\n\n    String result = \"\";\n    for (String word : words) {\n        HashMap<Character, Integer> wordCount = new HashMap<>();\n        for (char c : word.toCharArray()) {\n            wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);\n        }\n\n        boolean valid = true;\n        for (char ch : lpCount.keySet()) {\n            if (wordCount.getOrDefault(ch, 0) < lpCount.get(ch)) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid && (result.isEmpty() || word.length() < result.length())) {\n            result = word;\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nstd::string shortestCompletingWord(std::string licensePlate, std::vector<std::string>& words) {\n    std::unordered_map<char, int> lp_count;\n    for (char c : licensePlate)\n        if (isalpha(c))\n            lp_count[tolower(c)]++;\n\n    std::string result = \"\";\n    for (const std::string& word : words) {\n        std::unordered_map<char, int> word_count;\n        for (char c : word)\n            word_count[c]++;\n\n        bool valid = true;\n        for (const auto& [ch, count] : lp_count)\n            if (word_count[ch] < count) {\n                valid = false;\n                break;\n            }\n\n        if (valid && (result.empty() || word.length() < result.length()))\n            result = word;\n    }\n    return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "python": "\n    ```python\ndef shortestCompletingWord(licensePlate: str, words: list[str]) -> str:\n    from collections import Counter\n\n    lp_count = Counter(c.lower() for c in licensePlate if c.isalpha())\n\n    result = \"\"\n    for word in words:\n        word_count = Counter(word)\n\n        valid = all(word_count[ch] >= count for ch, count in lp_count.items())\n\n        if valid and (not result or len(word) < len(result)):\n            result = word\n\n    return result\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "javascript": "\n    ```javascript\nfunction shortestCompletingWord(licensePlate, words) {\n  const lpCount = new Map();\n  for (const c of licensePlate)\n    if (c.match(/[a-zA-Z]/))\n      lpCount.set(c.toLowerCase(), (lpCount.get(c.toLowerCase()) || 0) + 1);\n\n  let result = \"\";\n  for (const word of words) {\n    const wordCount = new Map();\n    for (const c of word)\n      wordCount.set(c, (wordCount.get(c) || 0) + 1);\n\n    let valid = true;\n    for (const [ch, count] of lpCount)\n      if ((wordCount.get(ch) || 0) < count) {\n        valid = false;\n        break;\n      }\n\n    if (valid && (!result || word.length < result.length))\n      result = word;\n  }\n  return result;\n}\n```\n\n    \n    1. Create a hash map (or dictionary in Python) to store the count of characters in the `licensePlate`.\n2. Iterate through the `words` array.\n   1. For each word, create a hash map storing the count of characters in the current word.\n   2. Check whether the current word is a valid completing word by comparing the counts in both hash maps. It's valid if it has equal or more count of characters compared to the `licensePlate` for each character.\n   3. If the word is valid and the result is empty or the length of the word is shorter than the result's length, update the result with the current word.\n3. Return the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " licensePlate =  \"1s3 PSt \", words = [ \"step \", \"steps \", \"stripe \", \"stepple \"]",
                    "output": "  \"steps \"",
                    "explanation": " licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'.\n \"step \" contains 't' and 'p', but only contains 1 's'.\n \"steps \" contains 't', 'p', and both 's' characters.\n \"stripe \" is missing an 's'.\n \"stepple \" is missing an 's'.\nSince  \"steps \" is the only word containing all the letters, that is the answer."
                },
                {
                    "input": " licensePlate =  \"1s3 456 \", words = [ \"looks \", \"pest \", \"stew \", \"show \"]",
                    "output": "  \"pest \"",
                    "explanation": " licensePlate only contains the letter 's'. All the words contain 's', but among these  \"pest \",  \"stew \", and  \"show \" are shortest. The answer is  \"pest \" because it is the word that appears earliest of the 3."
                }
            ],
            "function_input": [
                {
                    "input": "\"1s3PSt\",[\"step\",\"steps\",\"stripe\",\"stepple\"]",
                    "output": "\"steps\""
                },
                {
                    "input": "\"1s3456\",[\"looks\",\"pest\",\"stew\",\"show\"]",
                    "output": "\"pest\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-118",
        "prompt": "Given a string `licensePlate` and an array of strings `words`, find the **shortest completing** word in `words`.\n\nA **completing** word is a word that **contains all the letters** in `licensePlate`. **Ignore numbers and spaces** in `licensePlate`, and treat letters as **case insensitive**. If a letter appears more than once in `licensePlate`, then it must appear in the word the same number of times or more.\n\nFor example, if `licensePlate` `= \"aBc 12c \"`, then it contains letters `'a'`, `'b'` (ignoring case), and `'c'` twice. Possible **completing** words are `\"abccdef \"`, `\"caaacab \"`, and `\"cbca \"`.\n\nReturn _the shortest **completing** word in_ `words`_._ It is guaranteed an answer exists. If there are multiple shortest **completing** words, return the **first** one that occurs in `words`."
    },
    "leetcode-benchmark-119": {
        "id": "leetcode-benchmark-119",
        "title": "Find Anagram Mappings",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given two integer arrays `nums1` and `nums2` where `nums2` is **an anagram** of `nums1`. Both arrays may contain duplicates.\n\nReturn _an index mapping array_ `mapping` _from_ `nums1` _to_ `nums2` _where_ `mapping[i] = j` _means the_ `ith` _element in_ `nums1` _appears in_ `nums2` _at index_ `j`. If there are multiple answers, return **any of them**.\n\nAn array `a` is **an anagram** of an array `b` means `b` is made by randomizing the order of the elements in `a`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[12,28,46,32,50\\], nums2 = \\[50,12,32,46,28\\]\n**Output:** \\[1,4,3,2,0\\]\n**Explanation:** As mapping\\[0\\] = 1 because the 0th element of nums1 appears at nums2\\[1\\], and mapping\\[1\\] = 4 because the 1st element of nums1 appears at nums2\\[4\\], and so on.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[84,46\\], nums2 = \\[84,46\\]\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums1.length <= 100`\n*   `nums2.length == nums1.length`\n*   `0 <= nums1[i], nums2[i] <= 105`\n*   `nums2` is an anagram of `nums1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic int[] anagramMappings(int[] nums1, int[] nums2) {\n    HashMap<Integer, Integer> num_map = new HashMap<>();\n    for (int i = 0; i < nums2.length; i++) {\n        num_map.put(nums2[i], i);\n    }\n    int[] mapping = new int[nums1.length];\n    for (int i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {\n    unordered_map<int, int> num_map;\n    for (int i = 0; i < nums2.size(); i++) {\n        num_map[nums2[i]] = i;\n    }\n    vector<int> mapping(nums1.size());\n    for (int i = 0; i < nums1.size(); i++) {\n        mapping[i] = num_map[nums1[i]];\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "python": "\n    ```python\ndef anagramMappings(nums1, nums2):\n    num_map = {num: i for i, num in enumerate(nums2)}\n    mapping = [num_map[num] for num in nums1]\n    return mapping\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "javascript": "\n    ```javascript\nfunction anagramMappings(nums1, nums2) {\n    let num_map = new Map();\n    for (let i = 0; i < nums2.length; i++) {\n        num_map.set(nums2[i], i);\n    }\n    let mapping = new Array(nums1.length);\n    for (let i = 0; i < nums1.length; i++) {\n        mapping[i] = num_map.get(nums1[i]);\n    }\n    return mapping;\n}\n```\n\n    \n    The algorithm involves creating a mapping between each value in `nums2` and its index, using a hash map. Then, for each element in `nums1`, get its corresponding index in `nums2` and append that index value into the resulting mapping. This approach has a linear computation complexity (O(n)), as iterating over both `nums1` and `nums2` only occurs once.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums1 = [12,28,46,32,50], nums2 = [50,12,32,46,28]",
                    "output": " [1,4,3,2,0]",
                    "explanation": " As mapping\\[0\\] = 1 because the 0th element of nums1 appears at nums2\\[1\\], and mapping\\[1\\] = 4 because the 1st element of nums1 appears at nums2\\[4\\], and so on."
                },
                {
                    "input": " nums1 = [84,46], nums2 = [84,46]",
                    "output": " [0,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[12,28,46,32,50],[50,12,32,46,28]",
                    "output": "[1,4,3,2,0]"
                },
                {
                    "input": "[84,46],[84,46]",
                    "output": "[0,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-119",
        "prompt": "You are given two integer arrays `nums1` and `nums2` where `nums2` is **an anagram** of `nums1`. Both arrays may contain duplicates.\n\nReturn _an index mapping array_ `mapping` _from_ `nums1` _to_ `nums2` _where_ `mapping[i] = j` _means the_ `ith` _element in_ `nums1` _appears in_ `nums2` _at index_ `j`. If there are multiple answers, return **any of them**.\n\nAn array `a` is **an anagram** of an array `b` means `b` is made by randomizing the order of the elements in `a`."
    },
    "leetcode-benchmark-120": {
        "id": "leetcode-benchmark-120",
        "title": "Prime Number of Set Bits in Binary Representation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two integers `left` and `right`, return _the **count** of numbers in the **inclusive** range_ `[left, right]` _having a **prime number of set bits** in their binary representation_.\n\nRecall that the **number of set bits** an integer has is the number of `1`'s present when written in binary.\n\n*   For example, `21` written in binary is `10101`, which has `3` set bits.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 6, right = 10\n**Output:** 4\n**Explanation:**\n6  -> 110 (2 set bits, 2 is prime)\n7  -> 111 (3 set bits, 3 is prime)\n8  -> 1000 (1 set bit, 1 is not prime)\n9  -> 1001 (2 set bits, 2 is prime)\n10 -> 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits.\n\n",
                "**Example 2:**\n\n**Input:** left = 10, right = 15\n**Output:** 5\n**Explanation:**\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= left <= right <= 106`\n*   `0 <= right - left <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nclass Solution {\n    boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i += 6)\n            if (n % i == 0 || n % (i + 2) == 0) return false;\n        return true;\n    }\n    \n    public int countPrimeSetBits(int left, int right) {\n        int count = 0;\n        for (int i = left; i <= right; ++i)\n            count += isPrime(Integer.bitCount(i)) ? 1 : 0;\n        return count;\n    }\n}\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "c++": "\n    ```cpp\n#include <bitset>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n    for (int i = 5; i * i <= n; i += 6)\n        if (n % i == 0 || n % (i + 2) == 0) return false;\n    return true;\n}\n\nint countPrimeSetBits(int left, int right) {\n    int count = 0;\n    for (int i = left; i <= right; ++i)\n        count += isPrime(std::bitset<32>(i).count());\n    return count;\n}\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "python": "\n    ```python\ndef is_prime(n: int) -> bool:\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef count_prime_set_bits(left: int, right: int) -> int:\n    return sum(is_prime(bin(i).count('1')) for i in range(left, right + 1))\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "javascript": "\n    ```javascript\nfunction isPrime(n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 === 0 || n % 3 === 0) return false;\n    for (let i = 5; i * i <= n; i += 6)\n        if (n % i === 0 || n % (i + 2) === 0) return false;\n    return true;\n}\n\nfunction countPrimeSetBits(left, right) {\n    let count = 0;\n    for (let i = left; i <= right; ++i)\n        count += isPrime(i.toString(2).split('1').length - 1) ? 1 : 0;\n    return count;\n}\n```\n\n    \n    The algorithm first defines a helper function `isPrime` to check if a given number is a prime number. Then, in the main `countPrimeSetBits` function, we iterate through the given range `[left, right]`. For each number, we count the number of 1's in its binary representation and check for primality of that count. If the count is a prime number, we increment the final count of numbers with prime set bits.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " left = 6, right = 10",
                    "output": " 4",
                    "explanation": "\n6  -> 110 (2 set bits, 2 is prime)\n7  -> 111 (3 set bits, 3 is prime)\n8  -> 1000 (1 set bit, 1 is not prime)\n9  -> 1001 (2 set bits, 2 is prime)\n10 -> 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits."
                },
                {
                    "input": " left = 10, right = 15",
                    "output": " 5",
                    "explanation": "\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits."
                }
            ],
            "function_input": [
                {
                    "input": "6,10",
                    "output": "4"
                },
                {
                    "input": "10,15",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-120",
        "prompt": "Given two integers `left` and `right`, return _the **count** of numbers in the **inclusive** range_ `[left, right]` _having a **prime number of set bits** in their binary representation_.\n\nRecall that the **number of set bits** an integer has is the number of `1`'s present when written in binary.\n\n*   For example, `21` written in binary is `10101`, which has `3` set bits."
    },
    "leetcode-benchmark-121": {
        "id": "leetcode-benchmark-121",
        "title": "Jewels and Stones",
        "difficulty": "Easy",
        "content": {
            "problem": "You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\nLetters are case sensitive, so `\"a \"` is considered a different type of stone from `\"A \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** jewels = \"aA\", stones = \"aAAbbbb\"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** jewels = \"z\", stones = \"ZZ\"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= jewels.length, stones.length <= 50`\n*   `jewels` and `stones` consist of only English letters.\n*   All the characters of `jewels` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char stone : stones.toCharArray()) {\n        if (jewels.indexOf(stone) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "c++": "\n    ```cpp\nint numJewelsInStones(string jewels, string stones) {\n    int count = 0;\n    for (char stone : stones) {\n        if (jewels.find(stone) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "python": "\n    ```python\ndef num_jewels_in_stones(jewels: str, stones: str) -> int:\n    count = 0\n    for stone in stones:\n        if stone in jewels:\n            count += 1\n    return count\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "javascript": "\n    ```javascript\nfunction numJewelsInStones(jewels, stones) {\n    let count = 0;\n    for (let stone of stones) {\n        if (jewels.indexOf(stone) !== -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm is pretty simple, as it iterates through each character (stone) in the `stones` string, and checks if that character is present in the `jewels` string. If it is, increment the counter. Finally, return the counter as the result.\n\nThis method does not require any additional space, except for the counter variable, and its time complexity is O(n*m) where n is the length of `stones` and m is the length of `jewels`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " jewels = \"aA\", stones = \"aAAbbbb\"",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " jewels = \"z\", stones = \"ZZ\"",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aA\",\"aAAbbbb\"",
                    "output": "3"
                },
                {
                    "input": "\"z\",\"ZZ\"",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-121",
        "prompt": "You're given strings `jewels` representing the types of stones that are jewels, and `stones` representing the stones you have. Each character in `stones` is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\nLetters are case sensitive, so `\"a \"` is considered a different type of stone from `\"A \"`."
    },
    "leetcode-benchmark-122": {
        "id": "leetcode-benchmark-122",
        "title": "Rotate String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `goal`, return `true` _if and only if_ `s` _can become_ `goal` _after some number of **shifts** on_ `s`.\n\nA **shift** on `s` consists of moving the leftmost character of `s` to the rightmost position.\n\n*   For example, if `s = \"abcde \"`, then it will be `\"bcdea \"` after one shift.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"abcde\", goal = \"cdeab\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcde\", goal = \"abced\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, goal.length <= 100`\n*   `s` and `goal` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean canTransform(int sx, int sy, int tx, int ty) {\n    while (sx != tx || sy != ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx < tx) {\n            tx -= ty;\n        } else {\n            ty -= sx;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool canTransform(int sx, int sy, int tx, int ty) {\n    while (sx != tx || sy != ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx < tx) {\n            tx -= ty;\n        } else {\n            ty -= sx;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "python": "\n    ```python\ndef can_transform(sx, sy, tx, ty):\n    while sx != tx or sy != ty:\n        if sx > tx or sy > ty:\n            return False\n        if sx < tx:\n            tx -= ty\n        else:\n            ty -= sx\n    return True\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "javascript": "\n    ```javascript\nfunction canTransform(sx, sy, tx, ty) {\n    while (sx !== tx || sy !== ty) {\n        if (sx > tx || sy > ty) return false;\n        if (sx < tx) {\n            tx -= ty;\n        } else {\n            ty -= sx;\n        }\n    }\n    return true;\n}\n```\n    \n    The algorithm starts with the target coordinates (tx, ty), and works its way backward by performing the inverse operations to approach the source point (sx, sy). In each iteration, check if sx > tx or sy > ty, meaning the target point cannot be reached (return false). Depending on whether tx > sx or ty > sy, subtract the smaller coordinate from the larger one. If (tx and ty) become equal to (sx and sy), the target point can be reached, and the function returns true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"abcde\", goal = \"cdeab\"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " s = \"abcde\", goal = \"abced\"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abcde\",\"cdeab\"",
                    "output": "True"
                },
                {
                    "input": "\"abcde\",\"abced\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-122",
        "prompt": "Given two strings `s` and `goal`, return `true` _if and only if_ `s` _can become_ `goal` _after some number of **shifts** on_ `s`.\n\nA **shift** on `s` consists of moving the leftmost character of `s` to the rightmost position.\n\n*   For example, if `s = \"abcde \"`, then it will be `\"bcdea \"` after one shift."
    },
    "leetcode-benchmark-123": {
        "id": "leetcode-benchmark-123",
        "title": "Similar RGB Color",
        "difficulty": "Easy",
        "content": {
            "problem": "The red-green-blue color `\"#AABBCC \"` can be written as `\"#ABC \"` in shorthand.\n\n*   For example, `\"#15c \"` is shorthand for the color `\"#1155cc \"`.\n\nThe similarity between the two colors `\"#ABCDEF \"` and `\"#UVWXYZ \"` is `-(AB - UV)2 - (CD - WX)2 - (EF - YZ)2`.\n\nGiven a string `color` that follows the format `\"#ABCDEF \"`, return a string represents the color that is most similar to the given color and has a shorthand (i.e., it can be represented as some `\"#XYZ \"`).\n\n**Any answer** which has the same highest similarity as the best answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** color =  \"#09f166 \"\n**Output:**  \"#11ee66 \"\n**Explanation:** \nThe similarity is -(0x09 - 0x11)2 -(0xf1 - 0xee)2 - (0x66 - 0x66)2 = -64 -9 -0 = -73.\nThis is the highest among any shorthand color.\n\n",
                "**Example 2:**\n\n**Input:** color =  \"#4e3fe1 \"\n**Output:**  \"#5544dd \""
            ],
            "constraints": "**Constraints:**\n\n*   `color.length == 7`\n*   `color[0] == '#'`\n*   `color[i]` is either digit or character in the range `['a', 'f']` for `i > 0`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> letterCasePermutation(String s) {\n    List<String> result = new ArrayList<>();\n    backtrack(s.toCharArray(), 0, result);\n    return result;\n}\n\nprivate void backtrack(char[] s, int index, List<String> result) {\n    if (index == s.length) {\n        result.add(new String(s));\n        return;\n    }\n    backtrack(s, index + 1, result);\n    if (Character.isLetter(s[index])) {\n        s[index] ^= (1 << 5);\n        backtrack(s, index + 1, result);\n        s[index] ^= (1 << 5);\n    }\n}\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid backtrack(std::string s, int index, std::vector<std::string>& result) {\n    if (index == s.length()) {\n        result.push_back(s);\n        return;\n    }\n    backtrack(s, index + 1, result);\n    if (isalpha(s[index])) {\n        s[index] ^= (1 << 5);\n        backtrack(s, index + 1, result);\n    }\n}\n\nstd::vector<std::string> letterCasePermutation(std::string s) {\n    std::vector<std::string> result;\n    backtrack(s, 0, result);\n    return result;\n}\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "python": "\n    ```python\ndef letterCasePermutation(s):\n    def backtrack(index):\n        if index == len(s):\n            result.append(\"\".join(s))\n            return\n        backtrack(index + 1)\n        if s[index].isalpha():\n            s[index] = s[index].swapcase()\n            backtrack(index + 1)\n            s[index] = s[index].swapcase()\n\n    result = []\n    s = list(s)\n    backtrack(0)\n    return result\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "javascript": "\n    ```javascript\nfunction letterCasePermutation(s) {\n    const result = [];\n    function backtrack(index) {\n        if (index === s.length) {\n            result.push(s.join(''));\n            return;\n        }\n        backtrack(index + 1);\n        if (s[index] !== s[index].toUpperCase() || s[index] !== s[index].toLowerCase()) {\n            s[index] = flipCase(s[index]);\n            backtrack(index + 1);\n            s[index] = flipCase(s[index]);\n        }\n    }\n    s = s.split('');\n    backtrack(0);\n    return result;\n}\n\nfunction flipCase(c) {\n    return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();\n}\n```\n    \n    The algorithm here is a simple backtracking algorithm. We traverse every character in the input string starting from the first character. For each character, we recursively call the backtrack function considering two cases, one without changing the case, and the other one changing the case, if it is an alphabet.\n\nBefore the call, we change the case of the character and change it back after the function call to backtrack to the previous state when exploring other branches of the solution tree.\n\nAt the base case, when we reach the end of the input string after considering all characters, we construct the string from the character array and add it to the result list.\n\nThe time complexity of this algorithm is O(2^N * N) where N is the length of the string: 2^N is the number of possible solutions, and for each solution, we use O(N) time to construct the string. The space complexity is O(N) due to the function call stack size.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " color =  \"#09f166 \"",
                    "output": "  \"#11ee66 \"",
                    "explanation": " \nThe similarity is -(0x09 - 0x11)2 -(0xf1 - 0xee)2 - (0x66 - 0x66)2 = -64 -9 -0 = -73.\nThis is the highest among any shorthand color."
                },
                {
                    "input": " color =  \"#4e3fe1 \"",
                    "output": "  \"#5544dd \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"#09f166\"",
                    "output": "\"#11ee66\""
                },
                {
                    "input": "\"#4e3fe1\"",
                    "output": "\"#5544dd\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-123",
        "prompt": "The red-green-blue color `\"#AABBCC \"` can be written as `\"#ABC \"` in shorthand.\n\n*   For example, `\"#15c \"` is shorthand for the color `\"#1155cc \"`.\n\nThe similarity between the two colors `\"#ABCDEF \"` and `\"#UVWXYZ \"` is `-(AB - UV)2 - (CD - WX)2 - (EF - YZ)2`.\n\nGiven a string `color` that follows the format `\"#ABCDEF \"`, return a string represents the color that is most similar to the given color and has a shorthand (i.e., it can be represented as some `\"#XYZ \"`).\n\n**Any answer** which has the same highest similarity as the best answer will be accepted."
    },
    "leetcode-benchmark-124": {
        "id": "leetcode-benchmark-124",
        "title": "Unique Morse Code Words",
        "difficulty": "Easy",
        "content": {
            "problem": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n*   `'a'` maps to `\".- \"`,\n*   `'b'` maps to `\"-... \"`,\n*   `'c'` maps to `\"-.-. \"`, and so on.\n\nFor convenience, the full table for the `26` letters of the English alphabet is given below:\n\n\\[ \".- \", \"-... \", \"-.-. \", \"-.. \", \". \", \"..-. \", \"--. \", \".... \", \".. \", \".--- \", \"-.- \", \".-.. \", \"-- \", \"-. \", \"--- \", \".--. \", \"--.- \", \".-. \", \"... \", \"- \", \"..- \", \"...- \", \".-- \", \"-..- \", \"-.-- \", \"--.. \"\\]\n\nGiven an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter.\n\n*   For example, `\"cab \"` can be written as `\"-.-..--... \"`, which is the concatenation of `\"-.-. \"`, `\".- \"`, and `\"-... \"`. We will call such a concatenation the **transformation** of a word.\n\nReturn _the number of different **transformations** among all words we have_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"gin \", \"zen \", \"gig \", \"msg \"\\]\n**Output:** 2\n**Explanation:** The transformation of each word is:\n \"gin \" ->  \"--...-. \"\n \"zen \" ->  \"--...-. \"\n \"gig \" ->  \"--...--. \"\n \"msg \" ->  \"--...--. \"\nThere are 2 different transformations:  \"--...-. \" and  \"--...--. \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \"\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 12`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nint rotatedDigits(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        boolean isValidAfterRotation = true;\n        boolean isDifferentAfterRotation = false;\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digit == 3 || digit == 4 || digit == 7) {\n                isValidAfterRotation = false;\n                break;\n            }\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\n                isDifferentAfterRotation = true;\n            }\n            num /= 10;\n        }\n        if (isValidAfterRotation && isDifferentAfterRotation) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "c++": "\n    ```cpp\nint rotatedDigits(int n) {\n    int count = 0;\n    for (int i = 1; i <= n; ++i) {\n        bool is_valid_after_rotation = true;\n        bool is_different_after_rotation = false;\n        int num = i;\n        while (num != 0) {\n            int digit = num % 10;\n            if (digit == 3 || digit == 4 || digit == 7) {\n                is_valid_after_rotation = false;\n                break;\n            }\n            if (digit == 2 || digit == 5 || digit == 6 || digit == 9) {\n                is_different_after_rotation = true;\n            }\n            num /= 10;\n        }\n        if (is_valid_after_rotation && is_different_after_rotation) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "python": "\n    ```python\ndef rotated_digits(n):\n    count = 0\n    for i in range(1, n + 1):\n        is_valid_after_rotation = True\n        is_different_after_rotation = False\n        num = i\n        while num:\n            digit = num % 10\n            if digit in {3, 4, 7}:\n                is_valid_after_rotation = False\n                break\n            if digit in {2, 5, 6, 9}:\n                is_different_after_rotation = True\n            num //= 10\n        if is_valid_after_rotation and is_different_after_rotation:\n            count += 1\n    return count\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "javascript": "\n    ```javascript\nfunction rotatedDigits(n) {\n    let count = 0;\n    for (let i = 1; i <= n; ++i) {\n        let isValidAfterRotation = true;\n        let isDifferentAfterRotation = false;\n        let num = i;\n        while (num !== 0) {\n            let digit = num % 10;\n            if (digit === 3 || digit === 4 || digit === 7) {\n                isValidAfterRotation = false;\n                break;\n            }\n            if (digit === 2 || digit === 5 || digit === 6 || digit === 9) {\n                isDifferentAfterRotation = true;\n            }\n            num = Math.floor(num / 10);\n        }\n        if (isValidAfterRotation && isDifferentAfterRotation) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm loops through all the integers from 1 to n, for each integer it checks if it is a good integer (valid and different after rotation). For checking if the integer is good, we loop through each digit of the integer and check if the digit remains valid after rotation and if it changes or not. If all digits are valid after rotation and at least one digit is different, the integer is a good integer, and we increment the count.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"gin \", \"zen \", \"gig \", \"msg \"]",
                    "output": " 2",
                    "explanation": " The transformation of each word is:\n \"gin \" ->  \"--...-. \"\n \"zen \" ->  \"--...-. \"\n \"gig \" ->  \"--...--. \"\n \"msg \" ->  \"--...--. \"\nThere are 2 different transformations:  \"--...-. \" and  \"--...--. \"."
                },
                {
                    "input": " words = [ \"a \"]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"gin\",\"zen\",\"gig\",\"msg\"]",
                    "output": "2"
                },
                {
                    "input": "[\"a\"]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-124",
        "prompt": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n*   `'a'` maps to `\".- \"`,\n*   `'b'` maps to `\"-... \"`,\n*   `'c'` maps to `\"-.-. \"`, and so on.\n\nFor convenience, the full table for the `26` letters of the English alphabet is given below:\n\n\\[ \".- \", \"-... \", \"-.-. \", \"-.. \", \". \", \"..-. \", \"--. \", \".... \", \".. \", \".--- \", \"-.- \", \".-.. \", \"-- \", \"-. \", \"--- \", \".--. \", \"--.- \", \".-. \", \"... \", \"- \", \"..- \", \"...- \", \".-- \", \"-..- \", \"-.-- \", \"--.. \"\\]\n\nGiven an array of strings `words` where each word can be written as a concatenation of the Morse code of each letter.\n\n*   For example, `\"cab \"` can be written as `\"-.-..--... \"`, which is the concatenation of `\"-.-. \"`, `\".- \"`, and `\"-... \"`. We will call such a concatenation the **transformation** of a word.\n\nReturn _the number of different **transformations** among all words we have_."
    },
    "leetcode-benchmark-125": {
        "id": "leetcode-benchmark-125",
        "title": "Number of Lines To Write String",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `s` of lowercase English letters and an array `widths` denoting **how many pixels wide** each lowercase English letter is. Specifically, `widths[0]` is the width of `'a'`, `widths[1]` is the width of `'b'`, and so on.\n\nYou are trying to write `s` across several lines, where **each line is no longer than** `100` **pixels**. Starting at the beginning of `s`, write as many letters on the first line such that the total width does not exceed `100` pixels. Then, from where you stopped in `s`, continue writing as many letters as you can on the second line. Continue this process until you have written all of `s`.\n\nReturn _an array_ `result` _of length 2 where:_\n\n*   `result[0]` _is the total number of lines._\n*   `result[1]` _is the width of the last line in pixels._",
            "examples": [
                "**Example 1:**\n\n**Input:** widths = \\[10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10\\], s =  \"abcdefghijklmnopqrstuvwxyz \"\n**Output:** \\[3,60\\]\n**Explanation:** You can write s as follows:\nabcdefghij  // 100 pixels wide\nklmnopqrst  // 100 pixels wide\nuvwxyz      // 60 pixels wide\nThere are a total of 3 lines, and the last line is 60 pixels wide.\n\n",
                "**Example 2:**\n\n**Input:** widths = \\[4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10\\], s =  \"bbbcccdddaaa \"\n**Output:** \\[2,4\\]\n**Explanation:** You can write s as follows:\nbbbcccdddaa  // 98 pixels wide\na            // 4 pixels wide\nThere are a total of 2 lines, and the last line is 4 pixels wide."
            ],
            "constraints": "**Constraints:**\n\n*   `widths.length == 26`\n*   `2 <= widths[i] <= 10`\n*   `1 <= s.length <= 1000`\n*   `s` contains only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numberOfWays(int n) {\n    int MOD = 1000000007;\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; i++)\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\n    return dp[n];\n}\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "c++": "\n    ```c++\nint numberOfWays(int n) {\n    int MOD = 1000000007;\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (int i = 2; i <= n; ++i)\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\n    return dp[n];\n}\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "python": "\n    ```python\ndef numberOfWays(n):\n    MOD = 1000000007\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n\n    for i in range(2, n + 1):\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n    return dp[n]\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "javascript": "\n    ```javascript\nfunction numberOfWays(n) {\n    const MOD = 1000000007;\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n\n    for (let i = 2; i <= n; i++)\n        dp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\n    return dp[n];\n}\n```\n\n    \n    The optimal way to solve this problem is to use dynamic programming. The idea is to maintain a dp array where dp[i] holds the number of ways to tile a 2 x i board. Initialize dp[0] and dp[1] to 1 (base cases). Then, for each i from 2 to n, we calculate dp[i] as the sum of dp[i - 1] and dp[i - 2]. For each i, two cases are possible:\n- Place a 2 x 1 domino tile vertically at position i to fill the 2 x i-1 board (use the last solution at dp[i-1]).\n- Place two 2 x 1 domino tiles horizontally at position i-1 and i (use the second last solution at dp[i-2]).\n\nAfter iterating through the entire dp array, the result will be in dp[n]. Return this value modulo 109 + 7.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s =  \"abcdefghijklmnopqrstuvwxyz \"",
                    "output": " [3,60]",
                    "explanation": " You can write s as follows:\nabcdefghij  // 100 pixels wide\nklmnopqrst  // 100 pixels wide\nuvwxyz      // 60 pixels wide\nThere are a total of 3 lines, and the last line is 60 pixels wide."
                },
                {
                    "input": " widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s =  \"bbbcccdddaaa \"",
                    "output": " [2,4]",
                    "explanation": " You can write s as follows:\nbbbcccdddaa  // 98 pixels wide\na            // 4 pixels wide\nThere are a total of 2 lines, and the last line is 4 pixels wide."
                }
            ],
            "function_input": [
                {
                    "input": "[10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],\"abcdefghijklmnopqrstuvwxyz\"",
                    "output": "[3,60]"
                },
                {
                    "input": "[4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10],\"bbbcccdddaaa\"",
                    "output": "[2,4]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-125",
        "prompt": "You are given a string `s` of lowercase English letters and an array `widths` denoting **how many pixels wide** each lowercase English letter is. Specifically, `widths[0]` is the width of `'a'`, `widths[1]` is the width of `'b'`, and so on.\n\nYou are trying to write `s` across several lines, where **each line is no longer than** `100` **pixels**. Starting at the beginning of `s`, write as many letters on the first line such that the total width does not exceed `100` pixels. Then, from where you stopped in `s`, continue writing as many letters as you can on the second line. Continue this process until you have written all of `s`.\n\nReturn _an array_ `result` _of length 2 where:_\n\n*   `result[0]` _is the total number of lines._\n*   `result[1]` _is the width of the last line in pixels._"
    },
    "leetcode-benchmark-126": {
        "id": "leetcode-benchmark-126",
        "title": "Largest Triangle Area",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,1\\],\\[1,0\\],\\[0,2\\],\\[2,0\\]\\]\n**Output:** 2.00000\n**Explanation:** The five points are shown in the above figure. The red triangle is the largest.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,0\\],\\[0,0\\],\\[0,1\\]\\]\n**Output:** 0.50000"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= points.length <= 50`\n*   `-50 <= xi, yi <= 50`\n*   All the given points are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isShifted(String s, String goal) {\n    if(s.length() != goal.length()) return false;\n    \n    s = s + s;\n    return s.contains(goal);\n}\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "c++": "\n    ```cpp\nbool isShifted(string s, string goal) {\n    if(s.length() != goal.length()) return false;\n\n    s = s + s;\n    return s.find(goal) != string::npos;\n}\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "python": "\n    ```python\ndef is_shifted(s, goal):\n    if len(s) != len(goal): return False\n\n    s = s + s\n    return goal in s\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "javascript": "\n    ```javascript\nfunction isShifted(s, goal) {\n    if (s.length !== goal.length) return false;\n    \n    s = s + s;\n    return s.includes(goal);\n}\n```\n    \n    The algorithm first checks if the length of both input strings is not equal, in which case it returns false as they can't possibly be shifted versions of each other. If they are of the same length, it concatenates the string `s` with itself, which creates all possible shifted combinations of `s`. Then it checks whether the `goal` is present in this concatenated string or not. If it is present, it returns true (as `s` can be shifted to obtain the `goal`), else it returns false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " points = [[0,0],[0,1],[1,0],[0,2],[2,0]]",
                    "output": " 2.00000",
                    "explanation": " The five points are shown in the above figure. The red triangle is the largest."
                },
                {
                    "input": " points = [[1,0],[0,0],[0,1]]",
                    "output": " 0.50000",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,0],[0,1],[1,0],[0,2],[2,0]]",
                    "output": "2.00000"
                },
                {
                    "input": "[[1,0],[0,0],[0,1]]",
                    "output": "0.50000"
                }
            ]
        },
        "task_id": "leetcode-benchmark-126",
        "prompt": "Given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `10-5` of the actual answer will be accepted."
    },
    "leetcode-benchmark-127": {
        "id": "leetcode-benchmark-127",
        "title": "Most Common Word",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `paragraph` and a string array of the banned words `banned`, return _the most frequent word that is not banned_. It is **guaranteed** there is **at least one word** that is not banned, and that the answer is **unique**.\n\nThe words in `paragraph` are **case-insensitive** and the answer should be returned in **lowercase**.",
            "examples": [
                "**Example 1:**\n\n**Input:** paragraph =  \"Bob hit a ball, the hit BALL flew far after it was hit. \", banned = \\[ \"hit \"\\]\n**Output:**  \"ball \"\n**Explanation:** \n \"hit \" occurs 3 times, but it is a banned word.\n \"ball \" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as  \"ball, \"), \nand that  \"hit \" isn't the answer even though it occurs more because it is banned.\n\n",
                "**Example 2:**\n\n**Input:** paragraph =  \"a. \", banned = \\[\\]\n**Output:**  \"a \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= paragraph.length <= 1000`\n*   paragraph consists of English letters, space `' '`, or one of the symbols: `\"!?',;. \"`.\n*   `0 <= banned.length <= 100`\n*   `1 <= banned[i].length <= 10`\n*   `banned[i]` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minSwaps(int[] nums1, int[] nums2) {\n    int n = nums1.length;\n    int[] noSwap = new int[n];\n    int[] doSwap = new int[n];\n    Arrays.fill(noSwap, Integer.MAX_VALUE);\n    Arrays.fill(doSwap, Integer.MAX_VALUE);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            noSwap[i] = noSwap[i - 1];\n            doSwap[i] = doSwap[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            noSwap[i] = Math.min(noSwap[i], doSwap[i - 1]);\n            doSwap[i] = Math.min(doSwap[i], noSwap[i - 1] + 1);\n        }\n    }\n\n    return Math.min(noSwap[n - 1], doSwap[n - 1]);\n}\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "c++": "\n    ```cpp\nint minSwaps(vector<int>& nums1, vector<int>& nums2) {\n    int n = nums1.size();\n    vector<int> noSwap(n, INT_MAX);\n    vector<int> doSwap(n, INT_MAX);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            noSwap[i] = noSwap[i - 1];\n            doSwap[i] = doSwap[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            noSwap[i] = min(noSwap[i], doSwap[i - 1]);\n            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1);\n        }\n    }\n\n    return min(noSwap[n - 1], doSwap[n - 1]);\n}\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "python": "\n    ```python\ndef minSwaps(nums1, nums2):\n    n = len(nums1)\n    noSwap = [float('inf')] * n\n    doSwap = [float('inf')] * n\n    noSwap[0] = 0\n    doSwap[0] = 1\n\n    for i in range(1, n):\n        if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n            noSwap[i] = noSwap[i - 1]\n            doSwap[i] = doSwap[i - 1] + 1\n        if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n            noSwap[i] = min(noSwap[i], doSwap[i - 1])\n            doSwap[i] = min(doSwap[i], noSwap[i - 1] + 1)\n\n    return min(noSwap[n - 1], doSwap[n - 1])\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "javascript": "\n    ```javascript\nfunction minSwaps(nums1, nums2) {\n    const n = nums1.length;\n    const noSwap = new Array(n).fill(Infinity);\n    const doSwap = new Array(n).fill(Infinity);\n    noSwap[0] = 0;\n    doSwap[0] = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (nums1[i] > nums1[i - 1] && nums2[i] > nums2[i - 1]) {\n            noSwap[i] = noSwap[i - 1];\n            doSwap[i] = doSwap[i - 1] + 1;\n        }\n        if (nums1[i] > nums2[i - 1] && nums2[i] > nums1[i - 1]) {\n            noSwap[i] = Math.min(noSwap[i], doSwap[i - 1]);\n            doSwap[i] = Math.min(doSwap[i], noSwap[i - 1] + 1);\n        }\n    }\n\n    return Math.min(noSwap[n - 1], doSwap[n - 1]);\n}\n```\n    \n    The algorithm uses dynamic programming. We maintain two arrays `noSwap` and `doSwap` to track the minimum number of swaps needed at each index without swapping and with swapping nums1[i] and nums2[i], respectively. The base cases are `noSwap[0] = 0` and `doSwap[0] = 1`.\n\nFor each index i, we check the following conditions:\n1. If `nums1[i] > nums1[i - 1]` and `nums2[i] > nums2[i - 1]`, we don't need to swap at index i. So, we update `noSwap[i]` and `doSwap[i]` accordingly.\n2. If `nums1[i] > nums2[i - 1]` and `nums2[i] > nums1[i - 1]`, we need to swap either at index i or index i - 1. We update `noSwap[i]` and `doSwap[i]` with the minimum possible value.\n\nFinally, we return the minimum of `noSwap[n - 1]` and `doSwap[n - 1]`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " paragraph =  \"Bob hit a ball, the hit BALL flew far after it was hit. \", banned = [ \"hit \"]",
                    "output": "  \"ball \"",
                    "explanation": " \n \"hit \" occurs 3 times, but it is a banned word.\n \"ball \" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as  \"ball, \"), \nand that  \"hit \" isn't the answer even though it occurs more because it is banned."
                },
                {
                    "input": " paragraph =  \"a. \", banned = []",
                    "output": "  \"a \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"Bobhitaball,[\"hit\"]",
                    "output": "\"ball\""
                },
                {
                    "input": "\"a.\",[]",
                    "output": "\"a\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-127",
        "prompt": "Given a string `paragraph` and a string array of the banned words `banned`, return _the most frequent word that is not banned_. It is **guaranteed** there is **at least one word** that is not banned, and that the answer is **unique**.\n\nThe words in `paragraph` are **case-insensitive** and the answer should be returned in **lowercase**."
    },
    "leetcode-benchmark-128": {
        "id": "leetcode-benchmark-128",
        "title": "Goat Latin",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a string `sentence` that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\nWe would like to convert the sentence to \"Goat Latin \" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\n*   If a word begins with a vowel (`'a'`, `'e'`, `'i'`, `'o'`, or `'u'`), append `\"ma \"` to the end of the word.\n    *   For example, the word `\"apple \"` becomes `\"applema \"`.\n*   If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add `\"ma \"`.\n    *   For example, the word `\"goat \"` becomes `\"oatgma \"`.\n*   Add one letter `'a'` to the end of each word per its word index in the sentence, starting with `1`.\n    *   For example, the first word gets `\"a \"` added to the end, the second word gets `\"aa \"` added to the end, and so on.\n\nReturn _the final sentence representing the conversion from sentence to Goat Latin_.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence = \"I speak Goat Latin\"\n**Output:** \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"\n\n",
                "**Example 2:**\n\n**Input:** sentence = \"The quick brown fox jumped over the lazy dog\"\n**Output:** \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 150`\n*   `sentence` consists of English letters and spaces.\n*   `sentence` has no leading or trailing spaces.\n*   All the words in `sentence` are separated by a single space.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] numberOfLines(int[] widths, String s) {\n    int lines = 1;\n    int currentPixel = 0;\n    for (char c : s.toCharArray()) {\n        int letterPixels = widths[c - 'a'];\n        if (currentPixel + letterPixels > 100) {\n            lines++;\n            currentPixel = 0;\n        }\n        currentPixel += letterPixels;\n    }\n    return new int[]{lines, currentPixel};\n}\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nstd::vector<int> numberOfLines(std::vector<int>& widths, std::string s) {\n    int lines = 1;\n    int currentPixel = 0;\n    for (char c : s) {\n        int letterPixels = widths[c - 'a'];\n        if (currentPixel + letterPixels > 100) {\n            lines++;\n            currentPixel = 0;\n        }\n        currentPixel += letterPixels;\n    }\n    return {lines, currentPixel};\n}\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "python": "\n    ```python\ndef number_of_lines(widths, s):\n    lines = 1\n    current_pixel = 0\n    for c in s:\n        letter_pixels = widths[ord(c) - ord('a')]\n        if current_pixel + letter_pixels > 100:\n            lines += 1\n            current_pixel = 0\n        current_pixel += letter_pixels\n    return [lines, current_pixel]\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "javascript": "\n    ```javascript\nfunction numberOfLines(widths, s) {\n    let lines = 1;\n    let currentPixel = 0;\n    for (let c of s) {\n        let letterPixels = widths[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n        if (currentPixel + letterPixels > 100) {\n            lines++;\n            currentPixel = 0;\n        }\n        currentPixel += letterPixels;\n    }\n    return [lines, currentPixel];\n}\n```\n\n    \n    The algorithm starts by initializing two variables, `lines` and `currentPixel`. `lines` denotes the number of lines it has taken so far to type out the string `s`, and `currentPixel` stores the width of the characters typed on the current line.\n\nThe algorithm iterates through each character `c` in the input string `s`. For each character, it calculates its width in pixels by using its respective entry in the `widths` array. If the addition of the width of the character to the `currentPixel` would cause it go over 100 pixels, it increases the line count by 1, resets the `currentPixel` to 0, and continues processing the rest of the string `s`. Otherwise, add the character width to the `currentPixel`.\n\nFinally, when the loop finishes iterating all characters in the string `s`, the algorithm returns the `lines` and `currentPixel` as a result array of length 2.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " sentence = \"I speak Goat Latin\"",
                    "output": " \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\"",
                    "explanation": null
                },
                {
                    "input": " sentence = \"The quick brown fox jumped over the lazy dog\"",
                    "output": " \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"IspeakGoatLatin\"",
                    "output": "\"ImaapeaksmaaaoatGmaaaaatinLmaaaaa\""
                },
                {
                    "input": "\"Thequickbrownfoxjumpedoverthelazydog\"",
                    "output": "\"heTmaauickqmaaarownbmaaaaoxfmaaaaaumpedjmaaaaaaovermaaaaaaahetmaaaaaaaaazylmaaaaaaaaaogdmaaaaaaaaaa\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-128",
        "prompt": "You are given a string `sentence` that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\nWe would like to convert the sentence to \"Goat Latin \" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n\n*   If a word begins with a vowel (`'a'`, `'e'`, `'i'`, `'o'`, or `'u'`), append `\"ma \"` to the end of the word.\n    *   For example, the word `\"apple \"` becomes `\"applema \"`.\n*   If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add `\"ma \"`.\n    *   For example, the word `\"goat \"` becomes `\"oatgma \"`.\n*   Add one letter `'a'` to the end of each word per its word index in the sentence, starting with `1`.\n    *   For example, the first word gets `\"a \"` added to the end, the second word gets `\"aa \"` added to the end, and so on.\n\nReturn _the final sentence representing the conversion from sentence to Goat Latin_."
    },
    "leetcode-benchmark-129": {
        "id": "leetcode-benchmark-129",
        "title": "Flipping an Image",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an `n x n` binary matrix `image`, flip the image **horizontally**, then invert it, and return _the resulting image_.\n\nTo flip an image horizontally means that each row of the image is reversed.\n\n*   For example, flipping `[1,1,0]` horizontally results in `[0,1,1]`.\n\nTo invert an image means that each `0` is replaced by `1`, and each `1` is replaced by `0`.\n\n*   For example, inverting `[0,1,1]` results in `[1,0,0]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[1,1,0\\],\\[1,0,1\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[1,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Explanation:** First reverse each row: \\[\\[0,1,1\\],\\[1,0,1\\],\\[0,0,0\\]\\].\nThen, invert the image: \\[\\[1,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[1,1,0,0\\],\\[1,0,0,1\\],\\[0,1,1,1\\],\\[1,0,1,0\\]\\]\n**Output:** \\[\\[1,1,0,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\],\\[1,0,1,0\\]\\]\n**Explanation:** First reverse each row: \\[\\[0,0,1,1\\],\\[1,0,0,1\\],\\[1,1,1,0\\],\\[0,1,0,1\\]\\].\nThen invert the image: \\[\\[1,1,0,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\],\\[1,0,1,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == image.length`\n*   `n == image[i].length`\n*   `1 <= n <= 20`\n*   `images[i][j]` is either `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic TreeNode pruneTree(TreeNode root) {\n    if (root == null) return null;\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if (root.val == 0 && root.left == null && root.right == null) return null;\n    return root;\n}\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "c++": "\n    ```cpp\nTreeNode* pruneTree(TreeNode* root) {\n    if (!root) return nullptr;\n    root->left = pruneTree(root->left);\n    root->right = pruneTree(root->right);\n    if (root->val == 0 && !root->left && !root->right) return nullptr;\n    return root;\n}\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "python": "\n    ```python\ndef pruneTree(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    root.left = pruneTree(root.left)\n    root.right = pruneTree(root.right)\n    if root.val == 0 and not root.left and not root.right:\n        return None\n    return root\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "javascript": "\n    ```javascript\nfunction pruneTree(root) {\n    if (!root) return null;\n    root.left = pruneTree(root.left);\n    root.right = pruneTree(root.right);\n    if (root.val === 0 && !root.left && !root.right) return null;\n    return root;\n}\n```\n    \n    The algorithm uses a depth first search approach to traverse the given binary tree recursively. When traversing the tree, the function checks if a node has a value of 1 or has any child nodes with a value of 1.\n\nIn the base case, if the current node is null, return null.\n\nFor each node, the algorithm first checks its left and right subtrees using height-depth traversal through recursion. After checking its left and right subtrees, if the current node has a value of 0 and has no left or right child nodes, the function returns null, effectively pruning the subtree. If any part of the subtree has a value of 1, then the recursion returns the root of that subtree.\n\nIn the end, the algorithm returns the root of the pruned binary tree.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " image = [[1,1,0],[1,0,1],[0,0,0]]",
                    "output": " [[1,0,0],[0,1,0],[1,1,1]]",
                    "explanation": " First reverse each row: \\[\\[0,1,1\\],\\[1,0,1\\],\\[0,0,0\\]\\].\nThen, invert the image: \\[\\[1,0,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]"
                },
                {
                    "input": " image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]",
                    "output": " [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]",
                    "explanation": " First reverse each row: \\[\\[0,0,1,1\\],\\[1,0,0,1\\],\\[1,1,1,0\\],\\[0,1,0,1\\]\\].\nThen invert the image: \\[\\[1,1,0,0\\],\\[0,1,1,0\\],\\[0,0,0,1\\],\\[1,0,1,0\\]\\]"
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1,0],[1,0,1],[0,0,0]]",
                    "output": "[[1,0,0],[0,1,0],[1,1,1]]"
                },
                {
                    "input": "[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]",
                    "output": "[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-129",
        "prompt": "Given an `n x n` binary matrix `image`, flip the image **horizontally**, then invert it, and return _the resulting image_.\n\nTo flip an image horizontally means that each row of the image is reversed.\n\n*   For example, flipping `[1,1,0]` horizontally results in `[0,1,1]`.\n\nTo invert an image means that each `0` is replaced by `1`, and each `1` is replaced by `0`.\n\n*   For example, inverting `[0,1,1]` results in `[1,0,0]`."
    },
    "leetcode-benchmark-130": {
        "id": "leetcode-benchmark-130",
        "title": "Rectangle Overlap",
        "difficulty": "Easy",
        "content": {
            "problem": "An axis-aligned rectangle is represented as a list `[x1, y1, x2, y2]`, where `(x1, y1)` is the coordinate of its bottom-left corner, and `(x2, y2)` is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\nTwo rectangles overlap if the area of their intersection is **positive**. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\nGiven two axis-aligned rectangles `rec1` and `rec2`, return `true` _if they overlap, otherwise return_ `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rec1 = \\[0,0,2,2\\], rec2 = \\[1,1,3,3\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** rec1 = \\[0,0,1,1\\], rec2 = \\[1,0,2,1\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** rec1 = \\[0,0,1,1\\], rec2 = \\[2,2,3,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `rec1.length == 4`\n*   `rec2.length == 4`\n*   `-109 <= rec1[i], rec2[i] <= 109`\n*   `rec1` and `rec2` represent a valid rectangle with a non-zero area.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int racecar(int target) {\n    return racecar(target, new HashMap<>());\n}\n\npublic int racecar(int target, Map<String, Integer> memo) {\n    return dp(0, 1, target, memo);\n}\n\npublic int dp(int pos, int speed, int target, Map<String, Integer> memo) {\n    if (Math.abs(pos) > 2 * target)\n        return Integer.MAX_VALUE - 1;\n\n    if (pos == target)\n        return 0;\n\n    String key = pos + \",\" + speed;\n    if (memo.containsKey(key))\n        return memo.get(key);\n\n    int op1 = dp(pos + speed, speed * 2, target, memo) + 1;\n    int op2 = dp(pos, -speed, target, memo) + 2;\n\n    int ans = Math.min(op1, op2);\n    memo.put(key, ans);\n    return ans;\n}\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "c++": "\n    ```cpp\nint racecar(int target) {\n    unordered_map<int, unordered_map<int, int>> memo;\n    function<int(int, int)> dp = [&](int pos, int speed) {\n        if (pos == target) return 0;\n        if (abs(pos) > 2 * target) return INT_MAX;\n\n        int &ans = memo[pos][speed];\n        if (ans) return ans;\n\n        if (speed == -1) {\n            int op1 = dp(pos + speed, 2 * speed) + 1;\n            int op2 = dp(pos, -speed) + 2;\n\n            ans = min(op1, op2);\n        } else {\n            int op1 = dp(pos - speed, -2 * speed) + 1;\n            int op2 = dp(pos, -speed) + 2;\n\n            ans = min(op1, op2);\n        }\n\n        return ans;\n    };\n\n    return dp(0, target) + 1;\n}\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "python": "\n    ```python\ndef racecar(target: int) -> int:\n    memo = {}\n\n    def dp(pos: int, speed: int) -> int:\n        if pos == target:\n            return 0\n        if abs(pos) > 2 * target:\n            return float('inf')\n\n        key = (pos, speed)\n        if key in memo:\n            return memo[key]\n\n        op1 = dp(pos + speed, speed * 2) + 1\n        op2 = dp(pos, -speed) + 2\n\n        ans = min(op1, op2)\n        memo[key] = ans\n        return ans\n\n    return dp(0, 1)\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "javascript": "\n    ```javascript\nfunction racecar(target) {\n    return dp(0, 1, target, new Map());\n}\n\nfunction dp(position, speed, target, memo) {\n    if (Math.abs(position) > 2 * target)\n        return Infinity - 1;\n\n    if (position === target)\n        return 0;\n\n    let key = position + \",\" + speed;\n    if (memo.has(key))\n        return memo.get(key);\n\n    let op1 = dp(position + speed, speed * 2, target, memo) + 1;\n    let op2 = dp(position, -speed, target, memo) + 2;\n\n    let ans = Math.min(op1, op2);\n    memo.set(key, ans);\n    return ans;\n}\n```\n    \n    The algorithm for solving this problem consists of a dynamic programming approach. We define a helper function called `dp` that receives the current position, speed, target and memoization Map. \n\n1. Starting from position 0 and speed 1, we use the DP function that uses memoization to find the shortest sequence of instructions.\n2. If the current position is equal to the target position, return 0 as no additional operations are needed.\n3. If the absolute value of the current position exceeds twice the target position, we return a large number as the cost of the current path.\n4. We check two operations at each recursive call: accelerating (moving with the current speed) and reversing (changing the sign of the speed). We calculate the cost for each operation, adding 1 for acceleration and 2 for reversing.\n5. We return the minimum cost from these operations and memoize this minimum cost for the current position and speed.\n6. Finally, the algorithm will return the shortest sequence of instructions to reach the target position by adding 1 outside of the DP function.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " rec1 = [0,0,2,2], rec2 = [1,1,3,3]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " rec1 = [0,0,1,1], rec2 = [1,0,2,1]",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " rec1 = [0,0,1,1], rec2 = [2,2,3,3]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[0,0,2,2],[1,1,3,3]",
                    "output": "True"
                },
                {
                    "input": "[0,0,1,1],[1,0,2,1]",
                    "output": "False"
                },
                {
                    "input": "[0,0,1,1],[2,2,3,3]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-130",
        "prompt": "An axis-aligned rectangle is represented as a list `[x1, y1, x2, y2]`, where `(x1, y1)` is the coordinate of its bottom-left corner, and `(x2, y2)` is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\nTwo rectangles overlap if the area of their intersection is **positive**. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\nGiven two axis-aligned rectangles `rec1` and `rec2`, return `true` _if they overlap, otherwise return_ `false`."
    },
    "leetcode-benchmark-131": {
        "id": "leetcode-benchmark-131",
        "title": "Backspace String Compare",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` _if they are equal when both are typed into empty text editors_. `'#'` means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ab#c \", t =  \"ad#c \"\n**Output:** true\n**Explanation:** Both s and t become  \"ac \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ab## \", t =  \"c#d# \"\n**Output:** true\n**Explanation:** Both s and t become  \" \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a#c \", t =  \"b \"\n**Output:** false\n**Explanation:** s becomes  \"c \" while t becomes  \"b \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 200`\n*   `s` and `t` only contain lowercase letters and `'#'` characters.\n\n**",
            "follow_up": "Follow up:** Can you solve it in `O(n)` time and `O(1)` space?"
        },
        "java": "\n    ```java\npublic boolean backspaceCompare(String s, String t) {\n    int i = s.length() - 1, j = t.length() - 1;\n    while (true) {\n        int back;\n        for (back = 0; i >= 0 && (back > 0 || s.charAt(i) == '#'); --i)\n            back += s.charAt(i) == '#' ? 1 : -1;\n        for (back = 0; j >= 0 && (back > 0 || t.charAt(j) == '#'); --j)\n            back += t.charAt(j) == '#' ? 1 : -1;\n        if (i >= 0 && j >= 0 && s.charAt(i) == t.charAt(j))\n            i--, j--;\n        else\n            return i == -1 && j == -1;\n    }\n}\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "c++": "\n    ```cpp\nbool backspaceCompare(string s, string t) {\n    int i = s.length() - 1, j = t.length() - 1;\n    while (true) {\n        int back;\n        for (back = 0; i >= 0 && (back > 0 || s[i] == '#'); --i)\n            back += s[i] == '#' ? 1 : -1;\n        for (back = 0; j >= 0 && (back > 0 || t[j] == '#'); --j)\n            back += t[j] == '#' ? 1 : -1;\n        if (i >= 0 && j >= 0 && s[i] == t[j])\n            i--, j--;\n        else\n            return i == -1 && j == -1;\n    }\n}\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "python": "\n    ```python\ndef backspaceCompare(s: str, t: str) -> bool:\n    i, j = len(s) - 1, len(t) - 1\n    while True:\n        back = 0\n        while i >= 0 and (back > 0 or s[i] == '#'):\n            back = back + 1 if s[i] == '#' else back - 1\n            i -= 1\n        back = 0\n        while j >= 0 and (back > 0 or t[j] == '#'):\n            back = back + 1 if t[j] == '#' else back - 1\n            j -= 1\n        if i >= 0 and j >= 0 and s[i] == t[j]:\n            i, j = i -1, j - 1\n        else:\n            return i == -1 and j == -1\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "javascript": "\n    ```javascript\nvar backspaceCompare = function(s, t) {\n    let i = s.length - 1, j = t.length - 1;\n    while (true) {\n        let back;\n        for (back = 0; i >= 0 && (back > 0 || s[i] === '#'); --i)\n            back += s[i] === '#' ? 1 : -1;\n        for (back = 0; j >= 0 && (back > 0 || t[j] === '#'); --j)\n            back += t[j] === '#' ? 1 : -1;\n        if (i >= 0 && j >= 0 && s[i] === t[j])\n            i--, j--;\n        else\n            return i === -1 && j === -1;\n    }\n};\n```\n    \n    The algorithm implements a two-pointer approach to compare the characters in the given strings `s` and `t`. We initialize two pointers `i` and `j` at the end of the respective strings. We use two nested loops to iterate through the characters from right to left, considering the backspace characters.\n\nIn both loops, we maintain a backspace counter. If we encounter a backspace character, we increment the counter. If we encounter a non-backspace character while the counter is greater than 0, we decrement the counter and continue. This effectively simulates the deletion of characters due to backspace.\n\nWe then compare the characters at positions `i` and `j`. If they are equal, we decrement both pointers. If they are not equal, we break the loop and check if both pointers are equal to -1, indicating that both strings are equal after considering backspaces. If both pointers are equal to -1, we return true; otherwise, we return false.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input strings, and a space complexity of O(1) as we do not use any additional data structures.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"ab#c \", t =  \"ad#c \"",
                    "output": " True",
                    "explanation": " Both s and t become  \"ac \"."
                },
                {
                    "input": " s =  \"ab## \", t =  \"c#d# \"",
                    "output": " True",
                    "explanation": " Both s and t become  \" \"."
                },
                {
                    "input": " s =  \"a#c \", t =  \"b \"",
                    "output": " False",
                    "explanation": " s becomes  \"c \" while t becomes  \"b \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"ab#c\",\"ad#c\"",
                    "output": "True"
                },
                {
                    "input": "\"ab##\",\"c#d#\"",
                    "output": "True"
                },
                {
                    "input": "\"a#c\",\"b\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-131",
        "prompt": "Given two strings `s` and `t`, return `true` _if they are equal when both are typed into empty text editors_. `'#'` means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty."
    },
    "leetcode-benchmark-132": {
        "id": "leetcode-benchmark-132",
        "title": "Transpose Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a 2D integer array `matrix`, return _the **transpose** of_ `matrix`.\n\nThe **transpose** of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[\\[1,4,7\\],\\[2,5,8\\],\\[3,6,9\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** \\[\\[1,4\\],\\[2,5\\],\\[3,6\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `-109 <= matrix[i][j] <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic double new21Game(int n, int k, int maxPts) {\n    if (k == 0 || n >= k + maxPts) {\n        return 1;\n    }\n    \n    double[] dp = new double[n + 1];\n    dp[0] = 1;\n    double sum = 1, ans = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        dp[i] = sum / maxPts;\n        if (i < k) {\n            sum += dp[i];\n        } else {\n            ans += dp[i];\n        }\n        if (i >= maxPts) {\n            sum -= dp[i - maxPts];\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\ndouble new21Game(int n, int k, int maxPts) {\n    if (k == 0 || n >= k + maxPts) {\n        return 1;\n    }\n    \n    vector<double> dp(n + 1, 0);\n    dp[0] = 1;\n    double sum = 1, ans = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        dp[i] = sum / maxPts;\n        if (i < k) {\n            sum += dp[i];\n        } else {\n            ans += dp[i];\n        }\n        if (i >= maxPts) {\n            sum -= dp[i - maxPts];\n        }\n    }\n    \n    return ans;\n}\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "python": "\n    ```python\ndef new21Game(n: int, k: int, maxPts: int) -> float:\n    if k == 0 or n >= k + maxPts:\n        return 1\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    s, ans = 1, 0\n\n    for i in range(1, n + 1):\n        dp[i] = s / maxPts\n        if i < k:\n            s += dp[i]\n        else:\n            ans += dp[i]\n        if i >= maxPts:\n            s -= dp[i - maxPts]\n\n    return ans\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "javascript": "\n    ```javascript\nfunction new21Game(n, k, maxPts) {\n    if (k === 0 || n >= k + maxPts) {\n        return 1;\n    }\n\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    let sum = 1, ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        dp[i] = sum / maxPts;\n        if (i < k) {\n            sum += dp[i];\n        } else {\n            ans += dp[i];\n        }\n        if (i >= maxPts) {\n            sum -= dp[i - maxPts];\n        }\n    }\n\n    return ans;\n}\n```\n\n    \n    1. If Alice has already reached k points or n >= k + maxPts, there is no chance of drawing more cards, so return 1.\n2. Create a dynamic programming array (dp) to store the probability of reaching each point from 0 to n. Initialize dp[0] as 1.\n3. Keep a rolling sum of probabilities and iterate through the range [1, n]. Calculate the probability of reaching points i as the rolling sum divided by maxPts.\n4. If i < k, Alice needs to draw more cards, so update the rolling sum by adding the i-th probability.\n5. If i >= k, Alice already reached the target, so update the answer by adding the i-th probability.\n6. If i >= maxPts, remove the (i-maxPts)-th probability from the rolling sum since it's not in the range of possibilities.\n7. Return the accumulated probability after the iteration.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": " [[1,4,7],[2,5,8],[3,6,9]]",
                    "explanation": null
                },
                {
                    "input": " matrix = [[1,2,3],[4,5,6]]",
                    "output": " [[1,4],[2,5],[3,6]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[[1,4,7],[2,5,8],[3,6,9]]"
                },
                {
                    "input": "[[1,2,3],[4,5,6]]",
                    "output": "[[1,4],[2,5],[3,6]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-132",
        "prompt": "Given a 2D integer array `matrix`, return _the **transpose** of_ `matrix`.\n\nThe **transpose** of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices."
    },
    "leetcode-benchmark-133": {
        "id": "leetcode-benchmark-133",
        "title": "Binary Gap",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a positive integer `n`, find and return _the **longest distance** between any two **adjacent**_ `1`_'s in the binary representation of_ `n`_. If there are no two adjacent_ `1`_'s, return_ `0`_._\n\nTwo `1`'s are **adjacent** if there are only `0`'s separating them (possibly no `0`'s). The **distance** between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `\"1001 \"` have a distance of 3.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 22\n**Output:** 2\n**Explanation:** 22 in binary is  \"10110 \".\nThe first adjacent pair of 1's is  \"10110 \" with a distance of 2.\nThe second adjacent pair of 1's is  \"10110 \" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that  \"10110 \" is not a valid pair since there is a 1 separating the two 1's underlined.\n\n",
                "**Example 2:**\n\n**Input:** n = 8\n**Output:** 0\n**Explanation:** 8 in binary is  \"1000 \".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\n",
                "**Example 3:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 in binary is  \"101 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String pushDominoes(String dominoes) {\n    int n = dominoes.length();\n    String prev;\n    String cur = dominoes;\n    do {\n        prev = cur;\n        StringBuilder sb = new StringBuilder(prev);\n        for (int i = 0; i < n; ++i) {\n            if (prev.charAt(i) == 'L' && i > 0 && prev.charAt(i - 1) == '.')\n                sb.setCharAt(i - 1, 'L');\n            else if (prev.charAt(i) == 'R' && i < n - 1 && prev.charAt(i + 1) == '.')\n                sb.setCharAt(i + 1, 'R');\n        }\n        cur = sb.toString();\n    } while (!prev.equals(cur));\n    return cur;\n}\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring pushDominoes(string dominoes) {\n    int n = dominoes.size();\n    string prev, cur = dominoes;\n    do {\n        prev = cur;\n        for (int i = 0; i < n; ++i) {\n            if (prev[i] == 'L' && i > 0 && prev[i - 1] == '.')\n                cur[i - 1] = 'L';\n            else if (prev[i] == 'R' && i < n - 1 && prev[i + 1] == '.')\n                cur[i + 1] = 'R';\n        }\n    } while (prev != cur);\n    return cur;\n}\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "python": "\n    ```python\ndef push_dominoes(dominoes: str) -> str:\n    prev, cur = None, dominoes\n    while prev != cur:\n        prev = cur\n        cur_lst = list(prev)\n        for i in range(len(cur)):\n            if prev[i] == 'L' and i > 0 and prev[i - 1] == '.':\n                cur_lst[i - 1] = 'L'\n            elif prev[i] == 'R' and i < len(cur) - 1 and prev[i + 1] == '.':\n                cur_lst[i + 1] = 'R'\n        cur = ''.join(cur_lst)\n    return cur\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "javascript": "\n    ```javascript\nfunction pushDominoes(dominoes) {\n    let prev, cur = dominoes;\n    do {\n        prev = cur;\n        let curList = prev.split('');\n        for (let i = 0; i < prev.length; ++i) {\n            if (prev[i] === 'L' && i > 0 && prev[i - 1] === '.')\n                curList[i - 1] = 'L';\n            else if (prev[i] === 'R' && i < prev.length - 1 && prev[i + 1] === '.')\n                curList[i + 1] = 'R';\n        }\n        cur = curList.join('');\n    } while (prev !== cur);\n    return cur;\n}\n```\n    \n    1. Initialize `prev` and `cur` variables to store the state of dominoes. Set `cur` initially to the input string.\n2. Run a loop until the states of dominoes do not change, i.e., `prev != cur`.\n3. Iterate through each character in the `prev` string:\n   - If the character is 'L' and there is a domino to its left, and the left domino is '.', set that domino to 'L'.\n   - If the character is 'R' and there is a domino to its right, and the right domino is '.', set that domino to 'R'.\n4. Concatenate the new state of the dominoes to form the string `cur`.\n5. Continue the loop until there is no change in the states of the dominoes.\n6. Return the final state of the dominoes as a string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 22",
                    "output": " 2",
                    "explanation": " 22 in binary is  \"10110 \".\nThe first adjacent pair of 1's is  \"10110 \" with a distance of 2.\nThe second adjacent pair of 1's is  \"10110 \" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that  \"10110 \" is not a valid pair since there is a 1 separating the two 1's underlined."
                },
                {
                    "input": " n = 8",
                    "output": " 0",
                    "explanation": " 8 in binary is  \"1000 \".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0."
                },
                {
                    "input": " n = 5",
                    "output": " 2",
                    "explanation": " 5 in binary is  \"101 \"."
                }
            ],
            "function_input": [
                {
                    "input": "22",
                    "output": "2"
                },
                {
                    "input": "8",
                    "output": "0"
                },
                {
                    "input": "5",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-133",
        "prompt": "Given a positive integer `n`, find and return _the **longest distance** between any two **adjacent**_ `1`_'s in the binary representation of_ `n`_. If there are no two adjacent_ `1`_'s, return_ `0`_._\n\nTwo `1`'s are **adjacent** if there are only `0`'s separating them (possibly no `0`'s). The **distance** between two `1`'s is the absolute difference between their bit positions. For example, the two `1`'s in `\"1001 \"` have a distance of 3."
    },
    "leetcode-benchmark-134": {
        "id": "leetcode-benchmark-134",
        "title": "Leaf-Similar Trees",
        "difficulty": "Easy",
        "content": {
            "problem": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a **leaf value sequence**_._\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\nTwo binary trees are considered _leaf-similar_ if their leaf value sequence is the same.\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar.",
            "examples": [
                "**Example 1:**\n\n**Input:** root1 = \\[3,5,1,6,2,9,8,null,null,7,4\\], root2 = \\[3,5,1,6,7,4,2,null,null,null,null,null,null,9,8\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root1 = \\[1,2,3\\], root2 = \\[1,3,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in each tree will be in the range `[1, 200]`.\n*   Both of the given trees will have values in the range `[0, 200]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> splitIntoFibonacci(String num) {\n    List<Integer> ans = new ArrayList<>();\n    backtrack(num, ans, 0, 0, 0);\n    return ans;\n}\n\nprivate boolean backtrack(String num, List<Integer> ans, int index, int prev1, int prev2) {\n    if (index == num.length()) {\n        return ans.size() >= 3;\n    }\n    long curr = 0;\n    for (int i = index; i < num.length(); ++i) {\n        if (i > index && num.charAt(index) == '0') {\n            break;\n        }\n        curr = curr * 10 + num.charAt(i) - '0';\n        if (curr > Integer.MAX_VALUE) {\n            break;\n        }\n\n        if (ans.size() >= 2) {\n            long sum = (long) prev1 + prev2;\n            if (curr < sum) {\n                continue;\n            } else if (curr > sum) {\n                break;\n            }\n        }\n\n        ans.add((int) curr);\n        if (backtrack(num, ans, i + 1, prev2, (int) curr)) {\n            return true;\n        }\n        ans.remove(ans.size() - 1);\n    }\n    return false;\n}\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "c++": "\n    ```c++\n#include <vector>\n#include <string>\n\nstd::vector<int> splitIntoFibonacci(std::string num) {\n    std::vector<int> ans;\n    backtrack(num, ans, 0, 0, 0);\n    return ans;\n}\n\nbool backtrack(std::string& num, std::vector<int>& ans, int index, int prev1, int prev2) {\n    if (index == num.size()) {\n        return ans.size() >= 3;\n    }\n    long curr = 0;\n    for (int i = index; i < num.size(); ++i) {\n        if (i > index && num[index] == '0') {\n            break;\n        }\n        curr = curr * 10 + num[i] - '0';\n        if (curr > INT32_MAX) {\n            break;\n        }\n        \n        if (ans.size() >= 2) {\n            long sum = (long)prev1 + prev2;\n            if (curr < sum) {\n                continue;\n            } else if (curr > sum) {\n                break;\n            }\n        }\n        \n        ans.push_back(curr);\n        if (backtrack(num, ans, i + 1, prev2, curr)) {\n            return true;\n        }\n        ans.pop_back();\n    }\n    return false;\n}\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "python": "\n    ```python\ndef splitIntoFibonacci(num):\n    ans = []\n    def backtrack(index, prev1, prev2):\n        if index == len(num):\n            return len(ans) >= 3\n        curr = 0\n        for i in range(index, len(num)):\n            if i > index and num[index] == '0':\n                break\n            curr = curr * 10 + ord(num[i]) - ord('0')\n            if curr > 2**31 - 1:\n                break\n            if len(ans) >= 2:\n                if curr < prev1 + prev2:\n                    continue\n                elif curr > prev1 + prev2:\n                    break\n            ans.append(curr)\n            if backtrack(i + 1, prev2, curr):\n                return True\n            ans.pop()\n        return False\n            \n    backtrack(0, 0, 0)\n    return ans\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "javascript": "\n    ```javascript\nfunction splitIntoFibonacci(num) {\n    const ans = [];\n    const backtrack = (index, prev1, prev2) => {\n        if (index === num.length) {\n            return ans.length >= 3;\n        }\n        let curr = 0;\n        for (let i = index; i < num.length; ++i) {\n            if (i > index && num[index] === '0') {\n                break;\n            }\n            curr = curr * 10 + num.charCodeAt(i) - 48;\n            if (curr > 2**31 - 1) {\n                break;\n            }\n            \n            if (ans.length >= 2) {\n                const sum = prev1 + prev2;\n                if (curr < sum) {\n                    continue;\n                } else if (curr > sum) {\n                    break;\n                }\n            }\n            \n            ans.push(curr);\n            if (backtrack(i + 1, prev2, curr)) {\n                return true;\n            }\n            ans.pop();\n        }\n        return false;\n    }\n    \n    backtrack(0, 0, 0);\n    return ans;\n}\n```\n    \n    The algorithm uses backtracking to solve the problem. It starts by iterating through the input string, parsing every possible length substring as numbers. The algorithm maintains a list, 'ans', to keep track of the Fibonacci-like sequence formed so far and also stores the previous 2 numbers in the sequence.\n\nThe base case is when the entire string has been processed (i.e., index == string length) and the 'ans' list has at least 3 elements. In that case, we return true and stop further processing.\n\nWhile iterating through the string and parsing substrings, we perform the following steps:\n1. Skip the current substring if it has a leading zero but isn't just \"0\".\n2. If the current number is greater than the 32-bit integer limit, break because it can't be a valid Fibonacci number.\n3. If the list 'ans' has at least 2 elements, we check whether the sum of the previous 2 numbers is equal to the current number. If the sum is smaller, we continue to the next substring, whereas if the sum is larger, we break because any larger substring will lead to an invalid sequence.\n4. If the current number is a valid candidate, we add it to the 'ans' list.\n5. Perform backtracking on the next index with the updated values of previous numbers. If the backtracking returns true, exit early; otherwise, we remove the current number from the 'ans' list and continue with the next substring.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " root1 = [1,2,3], root2 = [1,3,2]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,5,1,6,2,9,8,null,null,7,4],[3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]",
                    "output": "True"
                },
                {
                    "input": "[1,2,3],[1,3,2]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-134",
        "prompt": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a **leaf value sequence**_._\n\nFor example, in the given tree above, the leaf value sequence is `(6, 7, 4, 9, 8)`.\n\nTwo binary trees are considered _leaf-similar_ if their leaf value sequence is the same.\n\nReturn `true` if and only if the two given trees with head nodes `root1` and `root2` are leaf-similar."
    },
    "leetcode-benchmark-135": {
        "id": "leetcode-benchmark-135",
        "title": "Projection Area of 3D Shapes",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an `n x n` `grid` where we place some `1 x 1 x 1` cubes that are axis-aligned with the `x`, `y`, and `z` axes.\n\nEach value `v = grid[i][j]` represents a tower of `v` cubes placed on top of the cell `(i, j)`.\n\nWe view the projection of these cubes onto the `xy`, `yz`, and `zx` planes.\n\nA **projection** is like a shadow, that maps our **3-dimensional** figure to a **2-dimensional** plane. We are viewing the \"shadow \" when looking at the cubes from the top, the front, and the side.\n\nReturn _the total area of all three projections_.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,2\\],\\[3,4\\]\\]\n**Output:** 17\n**Explanation:** Here are the three projections ( \"shadows \") of the shape made with each axis-aligned plane.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[2\\]\\]\n**Output:** 5\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,2\\]\\]\n**Output:** 8"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] <= 50`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int carFleet(int target, int[] position, int[] speed) {\n    int n = position.length;\n    Integer[] indices = new Integer[n];\n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n\n    Arrays.sort(indices, (a, b) -> position[b] - position[a]);\n\n    int fleets = 0;\n    double lastArrival = -1;\n    for (int i : indices) {\n        double arrival = (double) (target - position[i]) / speed[i];\n        if (arrival > lastArrival) {\n            fleets++;\n            lastArrival = arrival;\n        }\n    }\n\n    return fleets;\n}\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "c++": "\n    ```cpp\nint carFleet(int target, vector<int>& position, vector<int>& speed) {\n    int n = position.size();\n    vector<pair<int, int>> cars;\n    for (int i = 0; i < n; ++i) {\n        cars.emplace_back(position[i], speed[i]);\n    }\n    sort(cars.begin(), cars.end(), [](const pair<int, int>& a, const pair<int, int>& b) {\n        return a.first > b.first;\n    });\n\n    int fleets = 0;\n    double last_arrival = -1;\n    for (int i = 0; i < n; ++i) {\n        double arrival = (double)(target - cars[i].first) / cars[i].second;\n        if (arrival > last_arrival) {\n            ++fleets;\n            last_arrival = arrival;\n        }\n    }\n\n    return fleets;\n}\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "python": "\n    ```python\ndef carFleet(target: int, position: List[int], speed: List[int]) -> int:\n    cars = sorted(zip(position, speed), reverse=True)\n    fleets = 0\n    last_arrival = -1\n\n    for pos, sp in cars:\n        arrival = (target - pos) / sp\n        if arrival > last_arrival:\n            fleets += 1\n            last_arrival = arrival\n\n    return fleets\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "javascript": "\n    ```javascript\nfunction carFleet(target, position, speed) {\n  const n = position.length;\n  const cars = position.map((pos, i) => [pos, speed[i]]).sort((a, b) => b[0] - a[0]);\n\n  let fleets = 0;\n  let lastArrival = -1;\n\n  for (let i = 0; i < n; i++) {\n    const arrival = (target - cars[i][0]) / cars[i][1];\n    if (arrival > lastArrival) {\n      fleets++;\n      lastArrival = arrival;\n    }\n  }\n\n  return fleets;\n}\n```\n\n    \n    First, we create a `cars` data structure containing the car's position and speed, sorted in descending order by position. This ensures that we examine the cars from the front of the road (i.e., closest to the target) to the back.\n\nNext, we initialize a `fleets` counter and a `last_arrival` variable to keep track of the last car's arrival time at the destination.\n\nThen, we iterate through the sorted cars. For each car, we calculate its arrival time as `(target - position) / speed`. If this car's arrival time is greater than the last car's arrival time (i.e., `arrival > last_arrival`), then it is considered a new car fleet, and we will increment the `fleets` counter. We update the `last_arrival` variable for the next iteration.\n\nFinally, we return the total number of car fleets that will arrive at the destination.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[1,2],[3,4]]",
                    "output": " 17",
                    "explanation": " Here are the three projections ( \"shadows \") of the shape made with each axis-aligned plane."
                },
                {
                    "input": " grid = [[2]]",
                    "output": " 5",
                    "explanation": null
                },
                {
                    "input": " grid = [[1,0],[0,2]]",
                    "output": " 8",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[3,4]]",
                    "output": "17"
                },
                {
                    "input": "[[2]]",
                    "output": "5"
                },
                {
                    "input": "[[1,0],[0,2]]",
                    "output": "8"
                }
            ]
        },
        "task_id": "leetcode-benchmark-135",
        "prompt": "You are given an `n x n` `grid` where we place some `1 x 1 x 1` cubes that are axis-aligned with the `x`, `y`, and `z` axes.\n\nEach value `v = grid[i][j]` represents a tower of `v` cubes placed on top of the cell `(i, j)`.\n\nWe view the projection of these cubes onto the `xy`, `yz`, and `zx` planes.\n\nA **projection** is like a shadow, that maps our **3-dimensional** figure to a **2-dimensional** plane. We are viewing the \"shadow \" when looking at the cubes from the top, the front, and the side.\n\nReturn _the total area of all three projections_."
    },
    "leetcode-benchmark-136": {
        "id": "leetcode-benchmark-136",
        "title": "Uncommon Words from Two Sentences",
        "difficulty": "Easy",
        "content": {
            "problem": "A **sentence** is a string of single-space separated words where each word consists only of lowercase letters.\n\nA word is **uncommon** if it appears exactly once in one of the sentences, and **does not appear** in the other sentence.\n\nGiven two **sentences** `s1` and `s2`, return _a list of all the **uncommon words**_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\n**Output:** \\[\"sweet\",\"sour\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s1 = \"apple apple\", s2 = \"banana\"\n**Output:** \\[\"banana\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 200`\n*   `s1` and `s2` consist of lowercase English letters and spaces.\n*   `s1` and `s2` do not have leading or trailing spaces.\n*   All the words in `s1` and `s2` are separated by a single space.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int kSimilarity(String s1, String s2) {\n    int k = 0;\n    StringBuilder a = new StringBuilder(s1);\n    StringBuilder b = new StringBuilder(s2);\n    for (int i = 0; i < a.length(); ++i) {\n        if (a.charAt(i) != b.charAt(i)) {\n            for (int j = i + 1; j < b.length(); ++j) {\n                if (a.charAt(i) == b.charAt(j) && a.charAt(j) != b.charAt(j)) {\n                    a.setCharAt(i, a.charAt(j));\n                    a.setCharAt(j, b.charAt(j));\n                    k++;\n                    break;\n                }\n            }\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "c++": "\n    ```cpp\nint kSimilarity(const std::string& s1, const std::string& s2) {\n    int k = 0;\n    std::string a = s1, b = s2;\n    for (int i = 0; i < a.size(); ++i) {\n        if (a[i] != b[i]) {\n            for (int j = i + 1; j < b.size(); ++j) {\n                if (a[i] == b[j] && a[j] != b[j]) {\n                    std::swap(a[i], a[j]);\n                    k++;\n                    break;\n                }\n            }\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "python": "\n    ```python\ndef k_similarity(s1, s2):\n    k = 0\n    a, b = list(s1), list(s2)\n    for i in range(len(a)):\n        if a[i] != b[i]:\n            for j in range(i + 1, len(b)):\n                if a[i] == b[j] and a[j] != b[j]:\n                    a[i], a[j] = a[j], a[i]\n                    k += 1\n                    break\n    return k\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "javascript": "\n    ```javascript\nfunction kSimilarity(s1, s2) {\n    let k = 0;\n    let a = Array.from(s1);\n    let b = Array.from(s2);\n    for (let i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) {\n            for (let j = i + 1; j < b.length; ++j) {\n                if (a[i] === b[j] && a[j] !== b[j]) {\n                    [a[i], a[j]] = [a[j], a[i]];\n                    k++;\n                    break;\n                }\n            }\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm begins by initializing the counter `k` to 0. We then create two mutable copies of the inputs: `a` and `b`. We loop through each character in `a` and compare it to its corresponding position in `b`. If they don't match, we look for matching characters in both `b` and the later part of `a`, ensuring that the swap candidate is not 'correct' (i.e., needs to be swapped itself). If we find a good swap candidate, we swap the characters in `a` and increment the `k`. We continue this process until reaching the end of the strings, and return `k` as the final result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s1 = \"this apple is sweet\", s2 = \"this apple is sour\"",
                    "output": " [\"sweet\",\"sour\"]",
                    "explanation": null
                },
                {
                    "input": " s1 = \"apple apple\", s2 = \"banana\"",
                    "output": " [\"banana\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"thisappleissweet\",\"thisappleissour\"",
                    "output": "[\"sweet\",\"sour\"]"
                },
                {
                    "input": "\"appleapple\",\"banana\"",
                    "output": "[\"banana\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-136",
        "prompt": "A **sentence** is a string of single-space separated words where each word consists only of lowercase letters.\n\nA word is **uncommon** if it appears exactly once in one of the sentences, and **does not appear** in the other sentence.\n\nGiven two **sentences** `s1` and `s2`, return _a list of all the **uncommon words**_. You may return the answer in **any order**."
    },
    "leetcode-benchmark-137": {
        "id": "leetcode-benchmark-137",
        "title": "Fair Candy Swap",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice and Bob have a different total number of candies. You are given two integer arrays `aliceSizes` and `bobSizes` where `aliceSizes[i]` is the number of candies of the `ith` box of candy that Alice has and `bobSizes[j]` is the number of candies of the `jth` box of candy that Bob has.\n\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\n\nReturn a_n integer array_ `answer` _where_ `answer[0]` _is the number of candies in the box that Alice must exchange, and_ `answer[1]` _is the number of candies in the box that Bob must exchange_. If there are multiple answers, you may **return any** one of them. It is guaranteed that at least one answer exists.",
            "examples": [
                "**Example 1:**\n\n**Input:** aliceSizes = \\[1,1\\], bobSizes = \\[2,2\\]\n**Output:** \\[1,2\\]\n\n",
                "**Example 2:**\n\n**Input:** aliceSizes = \\[1,2\\], bobSizes = \\[2,3\\]\n**Output:** \\[1,2\\]\n\n",
                "**Example 3:**\n\n**Input:** aliceSizes = \\[2\\], bobSizes = \\[1,3\\]\n**Output:** \\[2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= aliceSizes.length, bobSizes.length <= 104`\n*   `1 <= aliceSizes[i], bobSizes[j] <= 105`\n*   Alice and Bob have a different total number of candies.\n*   There will be at least one valid answer for the given input.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int mirrorReflection(int p, int q) {\n    int m = p, n = q;\n    int gcd;\n    while (n != 0) {\n        gcd = m % n;\n        m = n;\n        n = gcd;\n    }\n\n    if ((p / m) % 2 == 0) return 2;\n    if ((q / m) % 2 == 0) return 0;\n    return 1;\n}\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "c++": "\n    ```cpp\nint mirrorReflection(int p, int q) {\n    int m = p, n = q;\n    int gcd;\n    while (n) {\n        gcd = m % n;\n        m = n;\n        n = gcd;\n    }\n\n    if ((p / m) % 2 == 0) return 2;\n    if ((q / m) % 2 == 0) return 0;\n    return 1;\n}\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "python": "\n    ```python\ndef mirrorReflection(p, q):\n    from math import gcd\n    m = p // gcd(p, q)\n\n    if m % 2 == 0:\n        return 2\n    if (q // gcd(p, q)) % 2 == 0:\n        return 0\n    return 1\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "javascript": "\n    ```javascript\nfunction mirrorReflection(p, q) {\n    function gcd(a, b) {\n        return b === 0 ? a : gcd(b, a % b);\n    }\n    let m = p / gcd(p, q);\n\n    if (m % 2 === 0) return 2;\n    if ((q / gcd(p, q)) % 2 === 0) return 0;\n    return 1;\n}\n```\n    \n    To solve this problem, we first determine the Lowest Common Multiple (LCM) of p and q. However, instead of finding LCM directly, it's simpler to first find the Greatest Common Divisor (GCD) and divide p and q by the GCD.\n\nNext, we check if p divided by the GCD is an even number. If it is, the ray first meets receptor 2. If q divided by the GCD is even, the ray first meets receptor 0. Otherwise, the ray first meets receptor 1.\n\nThe algorithm remains the same across all languages, with only minor syntax differences between them. The key is to find the GCD and then further process p and q to identify which receptor the ray meets first.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " aliceSizes = [1,1], bobSizes = [2,2]",
                    "output": " [1,2]",
                    "explanation": null
                },
                {
                    "input": " aliceSizes = [1,2], bobSizes = [2,3]",
                    "output": " [1,2]",
                    "explanation": null
                },
                {
                    "input": " aliceSizes = [2], bobSizes = [1,3]",
                    "output": " [2,3]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,1],[2,2]",
                    "output": "[1,2]"
                },
                {
                    "input": "[1,2],[2,3]",
                    "output": "[1,2]"
                },
                {
                    "input": "[2],[1,3]",
                    "output": "[2,3]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-137",
        "prompt": "Alice and Bob have a different total number of candies. You are given two integer arrays `aliceSizes` and `bobSizes` where `aliceSizes[i]` is the number of candies of the `ith` box of candy that Alice has and `bobSizes[j]` is the number of candies of the `jth` box of candy that Bob has.\n\nSince they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have.\n\nReturn a_n integer array_ `answer` _where_ `answer[0]` _is the number of candies in the box that Alice must exchange, and_ `answer[1]` _is the number of candies in the box that Bob must exchange_. If there are multiple answers, you may **return any** one of them. It is guaranteed that at least one answer exists."
    },
    "leetcode-benchmark-138": {
        "id": "leetcode-benchmark-138",
        "title": "Increasing Order Search Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary search tree, rearrange the tree in **in-order** so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[5,3,6,2,4,null,8,1,null,null,null,7,9\\]\n**Output:** \\[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,1,7\\]\n**Output:** \\[1,null,5,null,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the given tree will be in the range `[1, 100]`.\n*   `0 <= Node.val <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nboolean isPalindrome(int n) {\n    int rev = 0, orig = n;\n    while (n > 0) {\n        rev = rev * 10 + n % 10;\n        n /= 10;\n    }\n    return orig == rev;\n}\n\nint primePalindrome(int n) {\n    while (true) {\n        if (isPrime(n) && isPalindrome(n)) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "c++": "\n    ```cpp\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nbool isPalindrome(int n) {\n    int rev = 0, orig = n;\n    while (n > 0) {\n        rev = rev * 10 + n % 10;\n        n /= 10;\n    }\n    return orig == rev;\n}\n\nint primePalindrome(int n) {\n    while (true) {\n        if (isPrime(n) && isPalindrome(n)) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "python": "\n    ```python\ndef is_prime(n):\n    if n <= 1:\n        return False\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 1\n    return True\n\ndef is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef prime_palindrome(n):\n    while True:\n        if is_prime(n) and is_palindrome(n):\n            return n\n        n += 1\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "javascript": "\n    ```javascript\nfunction isPrime(n) {\n    if (n <= 1) return false;\n    for (let i = 2; i * i <= n; i++) {\n        if (n % i === 0) return false;\n    }\n    return true;\n}\n\nfunction isPalindrome(n) {\n    const str = n.toString();\n    return str === str.split('').reverse().join('');\n}\n\nfunction primePalindrome(n) {\n    while (true) {\n        if (isPrime(n) && isPalindrome(n)) return n;\n        n++;\n    }\n}\n```\n    \n    The algorithm consists of three functions: isPrime, isPalindrome, and primePalindrome. The first function, isPrime, checks if a given number is prime by iterating from 2 to the square root of the number and checking if the number has any divisors. If not, the function returns true, indicating prime.\n\nThe second function, isPalindrome, checks if a given number is a palindrome by converting the number to a string and then reversing the string. If the original and reversed strings are the same, the function returns true, indicating a palindrome.\n\nThe main function, primePalindrome, takes an integer n as input and iterates from n onward, checking if each number is both prime and a palindrome using the isPrime and isPalindrome helper functions. When a number is found to be both prime and a palindrome, it is returned as the answer.\n\nThe algorithm has a complexity of O(sqrt(n) * n) in the worst case because isPrime has a complexity of O(sqrt(n)) and both isPalindrome and primePalindrome have complexities of O(n).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [5,3,6,2,4,null,8,1,null,null,null,7,9]",
                    "output": " [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
                    "explanation": null
                },
                {
                    "input": " root = [5,1,7]",
                    "output": " [1,null,5,null,7]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[5,3,6,2,4,null,8,1,null,null,null,7,9]",
                    "output": "[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]"
                },
                {
                    "input": "[5,1,7]",
                    "output": "[1,null,5,null,7]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-138",
        "prompt": "Given the `root` of a binary search tree, rearrange the tree in **in-order** so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child."
    },
    "leetcode-benchmark-139": {
        "id": "leetcode-benchmark-139",
        "title": "Sort Array By Parity",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, move all the even integers at the beginning of the array followed by all the odd integers.\n\nReturn _**any array** that satisfies this condition_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,2,4\\]\n**Output:** \\[2,4,3,1\\]\n**Explanation:** The outputs \\[4,2,3,1\\], \\[2,4,1,3\\], and \\[4,2,1,3\\] would also be accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `0 <= nums[i] <= 5000`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int lenLongestFibSubseq(int[] arr) {\n    int n = arr.length;\n    Map<Integer, Integer> index = new HashMap<>();\n    for (int i = 0; i < n; ++i)\n        index.put(arr[i], i);\n\n    Map<Integer, Integer> longest = new HashMap<>();\n    int ans = 0;\n\n    for (int k = 0; k < n; ++k)\n        for (int j = 0; j < k; ++j) {\n            int i = index.getOrDefault(arr[k] - arr[j], -1);\n            if (i >= 0 && i < j) {\n                longest.put(j * n + k, longest.getOrDefault(i * n + j, 1) + 1);\n                ans = Math.max(ans, longest.get(j * n + k) + 1);\n            }\n        }\n\n    return ans >= 3 ? ans : 0;\n}\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\n\nint lenLongestFibSubseq(std::vector<int>& arr) {\n    int n = arr.size();\n    std::unordered_map<int, int> index;\n    for (int i = 0; i < n; ++i)\n        index[arr[i]] = i;\n\n    std::unordered_map<int, int> longest;\n    int ans = 0;\n\n    for (int k = 0; k < n; ++k)\n        for (int j = 0; j < k; ++j) {\n            int i = index.find(arr[k] - arr[j]) == index.end() ? -1 : index[arr[k] - arr[j]];\n            if (i >= 0 && i < j) {\n                longest[j * n + k] = longest.find(i * n + j) == longest.end() ? 2 : longest[i * n + j] + 1;\n                ans = std::max(ans, longest[j * n + k] + 1);\n            }\n        }\n\n    return ans >= 3 ? ans : 0;\n}\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "python": "\n    ```python\ndef lenLongestFibSubseq(arr):\n    index = {x: i for i, x in enumerate(arr)}\n\n    longest = dict()\n    ans = 0\n\n    for k, z in enumerate(arr):\n        for j, y in enumerate(arr[:k]):\n            i = index.get(z - y, None)\n            if i is not None and i < j:\n                longest[j, k] = longest.get((i, j), 1) + 1\n                ans = max(ans, longest[j, k] + 1)\n\n    return ans if ans >= 3 else 0\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "javascript": "\n    ```javascript\nfunction lenLongestFibSubseq(arr) {\n    const index = new Map(arr.map((x, i) => [x, i]));\n\n    const longest = new Map();\n    let ans = 0;\n\n    for (let k = 0; k < arr.length; ++k) {\n        for (let j = 0; j < k; ++j) {\n            const i = index.get(arr[k] - arr[j]) || -1;\n            if (i >= 0 && i < j) {\n                longest.set(j * arr.length + k, (longest.get(i * arr.length + j) || 1) + 1);\n                ans = Math.max(ans, longest.get(j * arr.length + k) + 1);\n            }\n        }\n    }\n\n    return ans >= 3 ? ans : 0;\n}\n```\n    \n    The algorithm first creates an index map/dictionary to store the element and its corresponding index in the given array arr. Then, it initializes an empty map/dictionary for the longest Fibonacci-like subsequence and initializes an answer variable to store the length of the longest subsequence.\n\nThe algorithm then iterates through the array arr using two nested loops. In each iteration, it tries to find whether a Fibonacci-like subsequence can be formed from the given elements. If such a subsequence is found, it updates the length of the longest Fibonacci-like subsequence found so far.\n\nThe algorithm checks if the answer is greater than or equal to 3 (minimum length for a Fibonacci-like sequence), then it returns the answer; otherwise, it returns 0, indicating that no Fibonacci-like subsequence was found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,1,2,4]",
                    "output": " [2,4,3,1]",
                    "explanation": " The outputs \\[4,2,3,1\\], \\[2,4,1,3\\], and \\[4,2,1,3\\] would also be accepted."
                },
                {
                    "input": " nums = [0]",
                    "output": " [0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,1,2,4]",
                    "output": "[2,4,3,1]"
                },
                {
                    "input": "[0]",
                    "output": "[0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-139",
        "prompt": "Given an integer array `nums`, move all the even integers at the beginning of the array followed by all the odd integers.\n\nReturn _**any array** that satisfies this condition_."
    },
    "leetcode-benchmark-140": {
        "id": "leetcode-benchmark-140",
        "title": "Reverse Only Letters",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, reverse the string according to the following rules:\n\n*   All the characters that are not English letters remain in the same position.\n*   All the English letters (lowercase or uppercase) should be reversed.\n\nReturn `s` _after reversing it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"ab-cd\"\n**Output:** \"dc-ba\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"a-bC-dEf-ghIj\"\n**Output:** \"j-Ih-gfE-dCba\"\n\n",
                "**Example 3:**\n\n**Input:** s = \"Test1ng-Leet=code-Q!\"\n**Output:** \"Qedo1ct-eeLg=ntse-T!\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of characters with ASCII values in the range `[33, 122]`.\n*   `s` does not contain `'\\ \"'` or `'\\\\'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int numRescueBoats(int[] people, int limit) {\n    Arrays.sort(people);\n    int left = 0, right = people.length - 1;\n    int boats = 0;\n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    return boats;\n}\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint numRescueBoats(std::vector<int>& people, int limit) {\n    std::sort(people.begin(), people.end());\n    int left = 0, right = people.size() - 1;\n    int boats = 0;\n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    return boats;\n}\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "python": "\n    ```python\ndef num_rescue_boats(people, limit):\n    people.sort()\n    left, right = 0, len(people) - 1\n    boats = 0\n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        boats += 1\n    return boats\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "javascript": "\n    ```javascript\nfunction numRescueBoats(people, limit) {\n    people.sort((a, b) => a - b);\n    let left = 0, right = people.length - 1;\n    let boats = 0;\n    while (left <= right) {\n        if (people[left] + people[right] <= limit) {\n            left++;\n        }\n        right--;\n        boats++;\n    }\n    return boats;\n}\n```\n    \n    The algorithm sorts the weights of the people in ascending order. Then, it uses two pointers, left, starting at the first person, and right, starting at the last person, to assign people to boats efficiently.\n\nIn each iteration, if the person pointed by left and the person pointed by right can fit in the same boat, they are assigned to one. Whether those two people can share a boat or not, we still move the right pointer to the previous person, because the heaviest person will always need a boat.\n\nThis process is repeated until the left pointer and right pointer meet, guaranteeing all people have been assigned to boats. The count of boats used during the process is returned as the minimum number of boats needed.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"ab-cd\"",
                    "output": " \"dc-ba\"",
                    "explanation": null
                },
                {
                    "input": " s = \"a-bC-dEf-ghIj\"",
                    "output": " \"j-Ih-gfE-dCba\"",
                    "explanation": null
                },
                {
                    "input": " s = \"Test1ng-Leet=code-Q!\"",
                    "output": " \"Qedo1ct-eeLg=ntse-T!\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"ab-cd\"",
                    "output": "\"dc-ba\""
                },
                {
                    "input": "\"a-bC-dEf-ghIj\"",
                    "output": "\"j-Ih-gfE-dCba\""
                },
                {
                    "input": "\"Test1ng-Leet=code-Q!\"",
                    "output": "\"Qedo1ct-eeLg=ntse-T!\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-140",
        "prompt": "Given a string `s`, reverse the string according to the following rules:\n\n*   All the characters that are not English letters remain in the same position.\n*   All the English letters (lowercase or uppercase) should be reversed.\n\nReturn `s` _after reversing it_."
    },
    "leetcode-benchmark-141": {
        "id": "leetcode-benchmark-141",
        "title": "Unique Email Addresses",
        "difficulty": "Easy",
        "content": {
            "problem": "Every **valid email** consists of a **local name** and a **domain name**, separated by the `'@'` sign. Besides lowercase letters, the email may contain one or more `'.'` or `'+'`.\n\n*   For example, in `\"alice@leetcode.com \"`, `\"alice \"` is the **local name**, and `\"leetcode.com \"` is the **domain name**.\n\nIf you add periods `'.'` between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule **does not apply** to **domain names**.\n\n*   For example, `\"alice.z@leetcode.com \"` and `\"alicez@leetcode.com \"` forward to the same email address.\n\nIf you add a plus `'+'` in the **local name**, everything after the first plus sign **will be ignored**. This allows certain emails to be filtered. Note that this rule **does not apply** to **domain names**.\n\n*   For example, `\"m.y+name@email.com \"` will be forwarded to `\"my@email.com \"`.\n\nIt is possible to use both of these rules at the same time.\n\nGiven an array of strings `emails` where we send one email to each `emails[i]`, return _the number of different addresses that actually receive mails_.",
            "examples": [
                "**Example 1:**\n\n**Input:** emails = \\[ \"test.email+alex@leetcode.com \", \"test.e.mail+bob.cathy@leetcode.com \", \"testemail+david@lee.tcode.com \"\\]\n**Output:** 2\n**Explanation:**  \"testemail@leetcode.com \" and  \"testemail@lee.tcode.com \" actually receive mails.\n\n",
                "**Example 2:**\n\n**Input:** emails = \\[ \"a@leetcode.com \", \"b@leetcode.com \", \"c@leetcode.com \"\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= emails.length <= 100`\n*   `1 <= emails[i].length <= 100`\n*   `emails[i]` consist of lowercase English letters, `'+'`, `'.'` and `'@'`.\n*   Each `emails[i]` contains exactly one `'@'` character.\n*   All local and domain names are non-empty.\n*   Local names do not start with a `'+'` character.\n*   Domain names end with the `\".com \"` suffix.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Arrays;\n\npublic int numSpecialEquivalentGroups(String[] words) {\n    Set<String> groups = new HashSet<>();\n\n    for (String word : words) {\n        StringBuilder evens = new StringBuilder();\n        StringBuilder odds = new StringBuilder();\n\n        for (int i = 0; i < word.length(); ++i) {\n            if (i % 2 == 0) evens.append(word.charAt(i));\n            else odds.append(word.charAt(i));\n        }\n\n        char[] evenArr = evens.toString().toCharArray();\n        Arrays.sort(evenArr);\n        char[] oddArr = odds.toString().toCharArray();\n        Arrays.sort(oddArr);\n\n        groups.add(new String(evenArr) + new String(oddArr));\n    }\n\n    return groups.size();\n}\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n#include <algorithm>\n\nint numSpecialEquivalentGroups(std::vector<std::string>& words) {\n    std::unordered_set<std::string> groups;\n\n    for (std::string word : words) {\n        std::string evens, odds;\n\n        for (size_t i = 0; i < word.size(); ++i) {\n            if (i % 2 == 0) evens += word[i];\n            else odds += word[i];\n        }\n\n        std::sort(evens.begin(), evens.end());\n        std::sort(odds.begin(), odds.end());\n\n        groups.insert(evens + odds);\n    }\n\n    return groups.size();\n}\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "python": "\n    ```python\ndef num_special_equivalent_groups(words):\n    groups = set()\n\n    for word in words:\n        evens = \"\".join(sorted(word[0::2]))\n        odds = \"\".join(sorted(word[1::2]))\n\n        groups.add(evens + odds)\n\n    return len(groups)\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "javascript": "\n    ```javascript\nfunction numSpecialEquivalentGroups(words) {\n    const groups = new Set();\n\n    for (const word of words) {\n        let evens = \"\";\n        let odds = \"\";\n\n        for (let i = 0; i < word.length; ++i) {\n            if (i % 2 === 0) evens += word[i];\n            else odds += word[i];\n        }\n\n        evens = evens.split(\"\").sort().join(\"\");\n        odds = odds.split(\"\").sort().join(\"\");\n\n        groups.add(evens + odds);\n    }\n\n    return groups.size;\n}\n```\n\n    \n    1. Initialize an empty set to store the unique groups.\n2. For each word in the input list:\n   a. Initialize two empty strings `evens` and `odds` to store even and odd indexed characters.\n   b. Iterate through the word, and for each character, append it to either `evens` or `odds` based on its index being even or odd.\n   c. Sort the `evens` and `odds` strings.\n   d. Concatenate `evens` and `odds`, and insert the result into the set. If this string is already in the set, it doesn't get duplicated.\n3. Return the size of the set, which represents the number of unique groups.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " emails = [ \"test.email+alex@leetcode.com \", \"test.e.mail+bob.cathy@leetcode.com \", \"testemail+david@lee.tcode.com \"]",
                    "output": " 2",
                    "explanation": "  \"testemail@leetcode.com \" and  \"testemail@lee.tcode.com \" actually receive mails."
                },
                {
                    "input": " emails = [ \"a@leetcode.com \", \"b@leetcode.com \", \"c@leetcode.com \"]",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"]",
                    "output": "2"
                },
                {
                    "input": "[\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-141",
        "prompt": "Every **valid email** consists of a **local name** and a **domain name**, separated by the `'@'` sign. Besides lowercase letters, the email may contain one or more `'.'` or `'+'`.\n\n*   For example, in `\"alice@leetcode.com \"`, `\"alice \"` is the **local name**, and `\"leetcode.com \"` is the **domain name**.\n\nIf you add periods `'.'` between some characters in the **local name** part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule **does not apply** to **domain names**.\n\n*   For example, `\"alice.z@leetcode.com \"` and `\"alicez@leetcode.com \"` forward to the same email address.\n\nIf you add a plus `'+'` in the **local name**, everything after the first plus sign **will be ignored**. This allows certain emails to be filtered. Note that this rule **does not apply** to **domain names**.\n\n*   For example, `\"m.y+name@email.com \"` will be forwarded to `\"my@email.com \"`.\n\nIt is possible to use both of these rules at the same time.\n\nGiven an array of strings `emails` where we send one email to each `emails[i]`, return _the number of different addresses that actually receive mails_."
    },
    "leetcode-benchmark-142": {
        "id": "leetcode-benchmark-142",
        "title": "Valid Mountain Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, return _`true` if and only if it is a valid mountain array_.\n\nRecall that arr is a mountain array if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[2,1\\]\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[3,5,5\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[0,3,2,1\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void moveEvenOdd(int[] nums) {\n    int evenIndex = 0;\n    int oddIndex = nums.length - 1;\n\n    while (evenIndex < oddIndex) {\n        if (nums[evenIndex] % 2 == 0) {\n            evenIndex++;\n        } else {\n            int temp = nums[evenIndex];\n            nums[evenIndex] = nums[oddIndex];\n            nums[oddIndex] = temp;\n            oddIndex--;\n        }\n    }\n}\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid moveEvenOdd(vector<int>& nums) {\n    int evenIndex = 0;\n    int oddIndex = nums.size() - 1;\n\n    while (evenIndex < oddIndex) {\n        if (nums[evenIndex] % 2 == 0) {\n            evenIndex++;\n        } else {\n            swap(nums[evenIndex], nums[oddIndex]);\n            oddIndex--;\n        }\n    }\n}\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "python": "\n    ```python\ndef move_even_odd(nums):\n    even_index = 0\n    odd_index = len(nums) - 1\n\n    while even_index < odd_index:\n        if nums[even_index] % 2 == 0:\n            even_index += 1\n        else:\n            nums[even_index], nums[odd_index] = nums[odd_index], nums[even_index]\n            odd_index -= 1\n\n    return nums\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "javascript": "\n    ```javascript\nfunction moveEvenOdd(nums) {\n    let evenIndex = 0;\n    let oddIndex = nums.length - 1;\n\n    while (evenIndex < oddIndex) {\n        if (nums[evenIndex] % 2 === 0) {\n            evenIndex++;\n        } else {\n            [nums[evenIndex], nums[oddIndex]] = [nums[oddIndex], nums[evenIndex]];\n            oddIndex--;\n        }\n    }\n}\n```\n    \n    The algorithm uses two pointers, `evenIndex` and `oddIndex`. `evenIndex` starts from the beginning of the array, whereas `oddIndex` starts from the end. We iterate through the array until `evenIndex` is greater than or equal to `oddIndex`. Inside the loop, if `nums[evenIndex]` is even, we increment `evenIndex` because it's already in the correct position. If `nums[evenIndex]` is odd, we swap it with `nums[oddIndex]` and decrement `oddIndex`. Thus, we move even numbers to the beginning and odd numbers to the end of the array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [2,1]",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " arr = [3,5,5]",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " arr = [0,3,2,1]",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,1]",
                    "output": "False"
                },
                {
                    "input": "[3,5,5]",
                    "output": "False"
                },
                {
                    "input": "[0,3,2,1]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-142",
        "prompt": "Given an array of integers `arr`, return _`true` if and only if it is a valid mountain array_.\n\nRecall that arr is a mountain array if and only if:\n\n*   `arr.length >= 3`\n*   There exists some `i` with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`"
    },
    "leetcode-benchmark-143": {
        "id": "leetcode-benchmark-143",
        "title": "DI String Match",
        "difficulty": "Easy",
        "content": {
            "problem": "A permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` can be represented as a string `s` of length `n` where:\n\n*   `s[i] == 'I'` if `perm[i] < perm[i + 1]`, and\n*   `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s`, reconstruct the permutation `perm` and return it. If there are multiple valid permutations perm, return **any of them**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"IDID\"\n**Output:** \\[0,4,1,3,2\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \"III\"\n**Output:** \\[0,1,2,3\\]\n\n",
                "**Example 3:**\n\n**Input:** s = \"DDI\"\n**Output:** \\[3,2,0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'I'` or `'D'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isPalindrome(long num) {\n    String str = Long.toString(num);\n    String revStr = new StringBuilder(str).reverse().toString();\n    return str.equals(revStr);\n}\n\nint superpalindromesInRange(String left, String right) {\n    long l = Long.parseLong(left);\n    long r = Long.parseLong(right);\n    int cnt = 0;\n    for (long base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "c++": "\n    ```cpp\nbool isPalindrome(long num) {\n    string str = to_string(num);\n    string revStr = str;\n    reverse(revStr.begin(), revStr.end());\n    return str == revStr;\n}\n\nint superpalindromesInRange(string left, string right) {\n    long l = stol(left);\n    long r = stol(right);\n    int cnt = 0;\n    for (long base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "python": "\n    ```python\ndef isPalindrome(num):\n    return str(num) == str(num)[::-1]\n\ndef superpalindromesInRange(left: str, right: str) -> int:\n    l = int(left)\n    r = int(right)\n    cnt = 0\n    base = 1\n    while base * base <= r:\n        if isPalindrome(base) and isPalindrome(base * base):\n            if base * base >= l:\n                cnt += 1\n        base += 1\n    return cnt\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "javascript": "\n    ```javascript\nfunction isPalindrome(num) {\n    const str = num.toString();\n    const revStr = str.split('').reverse().join('');\n    return str === revStr;\n}\n\nfunction superpalindromesInRange(left, right) {\n    const l = parseInt(left);\n    const r = parseInt(right);\n    let cnt = 0;\n    for (let base = 1; base * base <= r; ++base) {\n        if (isPalindrome(base) && isPalindrome(base * base)) {\n            if (base * base >= l) {\n                cnt++;\n            }\n        }\n    }\n    return cnt;\n}\n```\n\n    \n    To solve the problem, we will do the following steps:\n1. Create a helper function `isPalindrome` to check if a given number is a palindrome.\n2. Iterate over all the possible palindrome base numbers. For each base, check if the base and the square of the base are both palindromes. If they are, check if the square of the base is within the range [l, r] and increment a counter for each valid super-palindrome found.\n3. Return the counter as the final result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"IDID\"",
                    "output": " [0,4,1,3,2]",
                    "explanation": null
                },
                {
                    "input": " s = \"III\"",
                    "output": " [0,1,2,3]",
                    "explanation": null
                },
                {
                    "input": " s = \"DDI\"",
                    "output": " [3,2,0,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"IDID\"",
                    "output": "[0,4,1,3,2]"
                },
                {
                    "input": "\"III\"",
                    "output": "[0,1,2,3]"
                },
                {
                    "input": "\"DDI\"",
                    "output": "[3,2,0,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-143",
        "prompt": "A permutation `perm` of `n + 1` integers of all the integers in the range `[0, n]` can be represented as a string `s` of length `n` where:\n\n*   `s[i] == 'I'` if `perm[i] < perm[i + 1]`, and\n*   `s[i] == 'D'` if `perm[i] > perm[i + 1]`.\n\nGiven a string `s`, reconstruct the permutation `perm` and return it. If there are multiple valid permutations perm, return **any of them**."
    },
    "leetcode-benchmark-144": {
        "id": "leetcode-benchmark-144",
        "title": "Delete Columns to Make Sorted",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of `n` strings `strs`, all of the same length.\n\nThe strings can be arranged such that there is one on each line, making a grid.\n\n*   For example, `strs = [ \"abc \", \"bce \", \"cae \"]` can be arranged as follows:\n\nabc\nbce\ncae\n\nYou want to **delete** the columns that are **not sorted lexicographically**. In the above example (**0-indexed**), columns 0 (`'a'`, `'b'`, `'c'`) and 2 (`'c'`, `'e'`, `'e'`) are sorted, while column 1 (`'b'`, `'c'`, `'a'`) is not, so you would delete column 1.\n\nReturn _the number of columns that you will delete_.",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"cba \", \"daf \", \"ghi \"\\]\n**Output:** 1\n**Explanation:** The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column.\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"a \", \"b \"\\]\n**Output:** 0\n**Explanation:** The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns.\n\n",
                "**Example 3:**\n\n**Input:** strs = \\[ \"zyx \", \"wvu \", \"tsr \"\\]\n**Output:** 3\n**Explanation:** The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3."
            ],
            "constraints": "**Constraints:**\n\n*   `n == strs.length`\n*   `1 <= n <= 100`\n*   `1 <= strs[i].length <= 1000`\n*   `strs[i]` consists of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minDifference(int[] nums, int k) {\n    if(nums.length <= 1) return 0;\n    Arrays.sort(nums);\n    int min_diff = nums[nums.length - 1] - nums[0];\n    for(int i = 1; i < nums.length; i++) {\n        int high = Math.max(nums[i - 1] + k, nums[nums.length - 1] - k);\n        int low = Math.min(nums[i] - k, nums[0] + k);\n        min_diff = Math.min(min_diff, high - low);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "c++": "\n    ```cpp\nint minDifference(vector<int>& nums, int k) {\n    if(nums.size() <= 1) return 0;\n    sort(nums.begin(), nums.end());\n    int min_diff = nums.back() - nums.front();\n    for(int i=1; i<nums.size(); i++) {\n        int high = max(nums[i-1] + k, nums.back() - k);\n        int low = min(nums[i] - k, nums.front() + k);\n        min_diff = min(min_diff, high - low);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "python": "\n    ```python\ndef minDifference(nums, k):\n    if len(nums) <= 1: return 0\n    nums.sort()\n    min_diff = nums[-1] - nums[0]\n    for i in range(1, len(nums)):\n        high = max(nums[i-1] + k, nums[-1] - k)\n        low = min(nums[i] - k, nums[0] + k)\n        min_diff = min(min_diff, high - low)\n    return min_diff\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction minDifference(nums, k) {\n    if(nums.length <= 1) return 0;\n    nums.sort((a, b) => a - b);\n    let min_diff = nums[nums.length - 1] - nums[0];\n    for(let i = 1; i < nums.length; i++) {\n        let high = Math.max(nums[i - 1] + k, nums[nums.length - 1] - k);\n        let low = Math.min(nums[i] - k, nums[0] + k);\n        min_diff = Math.min(min_diff, high - low);\n    }\n    return min_diff;\n}\n```\n    \n    The algorithm first sorts the input array nums. If there is only 1 element or no element in the array, then the minimum difference becomes 0. Otherwise, the algorithm initializes the minimum difference as the difference between the maximum and minimum elements. Then, it iterates through the nums array and for each element, selects the highest and lowest values after applying the operation with k. Update the minimum difference as necessary by comparing the current high-low value difference with the minimum difference calculated so far. The algorithm does not modify the original nums array but rather focuses on updating the minimum difference variable. After finishing the iteration, the minimum difference is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " strs = [ \"cba \", \"daf \", \"ghi \"]",
                    "output": " 1",
                    "explanation": " The grid looks as follows:\n  cba\n  daf\n  ghi\nColumns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column."
                },
                {
                    "input": " strs = [ \"a \", \"b \"]",
                    "output": " 0",
                    "explanation": " The grid looks as follows:\n  a\n  b\nColumn 0 is the only column and is sorted, so you will not delete any columns."
                },
                {
                    "input": " strs = [ \"zyx \", \"wvu \", \"tsr \"]",
                    "output": " 3",
                    "explanation": " The grid looks as follows:\n  zyx\n  wvu\n  tsr\nAll 3 columns are not sorted, so you will delete all 3."
                }
            ],
            "function_input": [
                {
                    "input": "[\"cba\",\"daf\",\"ghi\"]",
                    "output": "1"
                },
                {
                    "input": "[\"a\",\"b\"]",
                    "output": "0"
                },
                {
                    "input": "[\"zyx\",\"wvu\",\"tsr\"]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-144",
        "prompt": "You are given an array of `n` strings `strs`, all of the same length.\n\nThe strings can be arranged such that there is one on each line, making a grid.\n\n*   For example, `strs = [ \"abc \", \"bce \", \"cae \"]` can be arranged as follows:\n\nabc\nbce\ncae\n\nYou want to **delete** the columns that are **not sorted lexicographically**. In the above example (**0-indexed**), columns 0 (`'a'`, `'b'`, `'c'`) and 2 (`'c'`, `'e'`, `'e'`) are sorted, while column 1 (`'b'`, `'c'`, `'a'`) is not, so you would delete column 1.\n\nReturn _the number of columns that you will delete_."
    },
    "leetcode-benchmark-145": {
        "id": "leetcode-benchmark-145",
        "title": "Verifying an Alien Dictionary",
        "difficulty": "Easy",
        "content": {
            "problem": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters.\n\nGiven a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographically in this alien language.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"hello \", \"leetcode \"\\], order =  \"hlabcdefgijkmnopqrstuvwxyz \"\n**Output:** true\n**Explanation:** As 'h' comes before 'l' in this language, then the sequence is sorted.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"word \", \"world \", \"row \"\\], order =  \"worldabcefghijkmnpqstuvxyz \"\n**Output:** false\n**Explanation:** As 'd' comes after 'l' in this language, then words\\[0\\] > words\\[1\\], hence the sequence is unsorted.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"apple \", \"app \"\\], order =  \"abcdefghijklmnopqrstuvwxyz \"\n**Output:** false\n**Explanation:** The first three characters  \"app \" match, and the second string is shorter (in size.) According to lexicographical rules  \"apple \" >  \"app \", because 'l' > '', where '' is defined as the blank character which is less than any other character ([More info](https://en.wikipedia.org/wiki/Lexicographical_order))."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `1 <= words[i].length <= 20`\n*   `order.length == 26`\n*   All characters in `words[i]` and `order` are English lowercase letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String reverseString(String s) {\n    StringBuilder result = new StringBuilder(s);\n    return result.reverse().toString();\n}\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\n\nstd::string reverseString(const std::string& s) {\n    std::string result = s;\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "python": "\n    ```python\ndef reverse_string(s):\n    return s[::-1]\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseString(s) {\n    return s.split('').reverse().join('');\n}\n```\n\n    \n    The algorithm to reverse a string is simple. It takes the input string, iterates from the last character to the first, and appends each character to a new string, which is then returned.\n\nIn each of the provided implementations, the language's standard library, or a built-in method, is utilized to achieve the goal, rather than manually writing a loop to iterate over the string.\n\nIn C++, the `std::reverse` function from the `<algorithm>` library is used to reverse the input string.\n\nIn Java, a `StringBuilder` is created from the input string, and then its built-in `reverse` method is called. Finally, the reversed `StringBuilder` is converted back to a `String`.\n\nIn Python, slicing is used to reverse the string with the syntax `s[::-1]`.\n\nIn JavaScript, the `split` method is used to convert the string into an array of characters. Then, the `reverse` method is called on the array, which reverses the order of the elements. Finally, the `join` method is called on the reversed array to convert it back to a string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"hello \", \"leetcode \"], order =  \"hlabcdefgijkmnopqrstuvwxyz \"",
                    "output": " True",
                    "explanation": " As 'h' comes before 'l' in this language, then the sequence is sorted."
                },
                {
                    "input": " words = [ \"word \", \"world \", \"row \"], order =  \"worldabcefghijkmnpqstuvxyz \"",
                    "output": " False",
                    "explanation": " As 'd' comes after 'l' in this language, then words\\[0\\] > words\\[1\\], hence the sequence is unsorted."
                },
                {
                    "input": " words = [ \"apple \", \"app \"], order =  \"abcdefghijklmnopqrstuvwxyz \"",
                    "output": " False",
                    "explanation": " The first three characters  \"app \" match, and the second string is shorter (in size.) According to lexicographical rules  \"apple \" >  \"app \", because 'l' > '', where '' is defined as the blank character which is less than any other character ([More info](https://en.wikipedia.org/wiki/Lexicographical_order))."
                }
            ],
            "function_input": [
                {
                    "input": "[\"hello\",\"leetcode\"],\"hlabcdefgijkmnopqrstuvwxyz\"",
                    "output": "True"
                },
                {
                    "input": "[\"word\",\"world\",\"row\"],\"worldabcefghijkmnpqstuvxyz\"",
                    "output": "False"
                },
                {
                    "input": "[\"apple\",\"app\"],\"abcdefghijklmnopqrstuvwxyz\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-145",
        "prompt": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters.\n\nGiven a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographically in this alien language."
    },
    "leetcode-benchmark-146": {
        "id": "leetcode-benchmark-146",
        "title": "N-Repeated Element in Size 2N Array",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an integer array `nums` with the following properties:\n\n*   `nums.length == 2 * n`.\n*   `nums` contains `n + 1` **unique** elements.\n*   Exactly one element of `nums` is repeated `n` times.\n\nReturn _the element that is repeated_ `n` _times_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,3\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,1,2,5,3,2\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[5,1,5,2,5,3,5,4\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 5000`\n*   `nums.length == 2 * n`\n*   `0 <= nums[i] <= 104`\n*   `nums` contains `n + 1` **unique** elements and one of them is repeated exactly `n` times.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isLongPressedName(String name, String typed) {\n    int i = 0, j = 0;\n    while (j < typed.length()) {\n        if (i < name.length() && name.charAt(i) == typed.charAt(j)) {\n            i++;\n        } else if (j == 0 || typed.charAt(j) != typed.charAt(j - 1)) {\n            return false;\n        }\n        j++;\n    }\n    return i == name.length();\n}\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "c++": "\n    ```cpp\nbool isLongPressedName(string name, string typed) {\n    int i = 0, j = 0;\n    while (j < typed.length()) {\n        if (i < name.length() && name[i] == typed[j]) {\n            i++;\n        } else if (j == 0 || typed[j] != typed[j - 1]) {\n            return false;\n        }\n        j++;\n    }\n    return i == name.length();\n}\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "python": "\n    ```python\ndef isLongPressedName(name: str, typed: str) -> bool:\n    i, j = 0, 0\n    while j < len(typed):\n        if i < len(name) and name[i] == typed[j]:\n            i += 1\n        elif j == 0 or typed[j] != typed[j - 1]:\n            return False\n        j += 1\n    return i == len(name)\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "javascript": "\n    ```javascript\nfunction isLongPressedName(name, typed) {\n    let i = 0, j = 0;\n    while (j < typed.length) {\n        if (i < name.length && name[i] === typed[j]) {\n            i++;\n        } else if (j === 0 || typed[j] !== typed[j - 1]) {\n            return false;\n        }\n        j++;\n    }\n    return i === name.length;\n}\n```\n    \n    We initialize two pointers i and j, pointing to the current characters in the `name` and `typed` strings. We iterate through the `typed` string using the pointer j, and check the following conditions in each iteration:\n\n1. If the current characters at positions i and j are the same, we increment both pointers i and j.\n2. If the current character in the `typed` string (j) does not match the character at position j - 1, it means that there is no long press, and we return False since it cannot be a valid typing.\n\nAfter the loop, we check if the pointer i reached the end of the `name` string. If it did, it means that all characters in the `name` string were found at the `typed` string with some characters possibly being long pressed. If not, it implies that the `typed` string is not a valid typing of the `name` string, and we return False.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,3]",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " nums = [2,1,2,5,3,2]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " nums = [5,1,5,2,5,3,5,4]",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,3]",
                    "output": "3"
                },
                {
                    "input": "[2,1,2,5,3,2]",
                    "output": "2"
                },
                {
                    "input": "[5,1,5,2,5,3,5,4]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-146",
        "prompt": "You are given an integer array `nums` with the following properties:\n\n*   `nums.length == 2 * n`.\n*   `nums` contains `n + 1` **unique** elements.\n*   Exactly one element of `nums` is repeated `n` times.\n\nReturn _the element that is repeated_ `n` _times_."
    },
    "leetcode-benchmark-147": {
        "id": "leetcode-benchmark-147",
        "title": "Univalued Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "A binary tree is **uni-valued** if every node in the tree has the same value.\n\nGiven the `root` of a binary tree, return `true` _if the given tree is **uni-valued**, or_ `false` _otherwise._",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,1,1,1,1,null,1\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** root = \\[2,2,2,5,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 100]`.\n*   `0 <= Node.val < 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int numUniqueEmails(String[] emails) {\n    Set<String> unique_emails = new HashSet<>();\n\n    for (String email : emails) {\n        String[] parts = email.split(\"@\");\n        String local_name = parts[0], domain_name = parts[1];\n\n        local_name = local_name.replaceAll(\"\\\\+\", \"@\").split(\"@\")[0];\n        local_name = local_name.replaceAll(\"\\\\.\", \"\");\n\n        unique_emails.add(local_name + \"@\" + domain_name);\n    }\n\n    return unique_emails.size();\n}\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <set>\n\nint numUniqueEmails(std::vector<std::string>& emails) {\n    std::set<std::string> unique_emails;\n\n    for (auto& email : emails) {\n        std::string local_name, domain_name;\n        bool at_sign_found = false, plus_sign_found = false;\n\n        for (char c : email) {\n            if (!at_sign_found) {\n                if (c == '+') plus_sign_found = true;\n                else if (c == '@') at_sign_found = true;\n                else if (!plus_sign_found && c != '.') local_name += c;\n            }\n            else domain_name += c;\n        }\n\n        unique_emails.insert(local_name + \"@\" + domain_name);\n    }\n\n    return unique_emails.size();\n}\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "python": "\n    ```python\ndef num_unique_emails(emails):\n    unique_emails = set()\n\n    for email in emails:\n        local_name, domain_name = email.split(\"@\")\n        local_name = local_name.split(\"+\")[0]\n        local_name = local_name.replace(\".\", \"\")\n\n        unique_emails.add(local_name + \"@\" + domain_name)\n\n    return len(unique_emails)\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "javascript": "\n    ```javascript\nfunction numUniqueEmails(emails) {\n    let unique_emails = new Set();\n\n    emails.forEach((email) => {\n        let [local_name, domain_name] = email.split(\"@\");\n        local_name = local_name.split(\"+\")[0];\n        local_name = local_name.replace(/\\./g, \"\");\n\n        unique_emails.add(local_name + \"@\" + domain_name);\n    });\n\n    return unique_emails.size;\n}\n```\n    \n    The algorithm iterates through each email in the input array/list. For each email, the local name and domain name are separated based on the '@' sign. Next, the '+' sign is considered, and everything after the first '+' sign is ignored in the local name. Then, all the '.' characters in the local name are removed. Finally, the processed local name and domain name are combined and added to a set, which will hold unique email addresses. After processing all the email addresses, the size of the set represents the number of unique email addresses that actually receive mails.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,1,1,1,1,null,1]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " root = [2,2,2,5,2]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,1,1,1,null,1]",
                    "output": "True"
                },
                {
                    "input": "[2,2,2,5,2]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-147",
        "prompt": "A binary tree is **uni-valued** if every node in the tree has the same value.\n\nGiven the `root` of a binary tree, return `true` _if the given tree is **uni-valued**, or_ `false` _otherwise._"
    },
    "leetcode-benchmark-148": {
        "id": "leetcode-benchmark-148",
        "title": "Largest Perimeter Triangle",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,1,2\\]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,10\\]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `1 <= nums[i] <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int minAreaRect(int[][] points) {\n        Set<Pair<Integer, Integer>> pointSet = new HashSet<>();\n        for (int[] point : points) {\n            pointSet.add(new Pair<>(point[0], point[1]));\n        }\n\n        int minArea = Integer.MAX_VALUE;\n        for (int[] p1 : points) {\n            for (int[] p2 : points) {\n                if (p1[0] != p2[0] && p1[1] != p2[1]) {\n                    if (pointSet.contains(new Pair<>(p1[0], p2[1])) && pointSet.contains(new Pair<>(p2[0], p1[1]))) {\n                        minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));\n                    }\n                }\n            }\n        }\n\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\n    }\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "c++": "\n    ```cpp\n#include <set>\n#include <vector>\n\ndouble minAreaRect(std::vector<std::vector<int>>& points) {\n    std::set<std::pair<int, int>> point_set;\n    for (const auto& point : points) {\n        point_set.emplace(point[0], point[1]);\n    }\n\n    double min_area = INT32_MAX;\n    for (const auto& p1 : point_set) {\n        for (const auto& p2 : point_set) {\n            if (p1.first != p2.first && p1.second != p2.second) {\n                if (point_set.count({p1.first, p2.second}) && point_set.count({p2.first, p1.second})) {\n                    min_area = std::min(min_area, abs((p1.first - p2.first) * (p1.second - p2.second)));\n                }\n            }\n        }\n    }\n\n    return min_area == INT32_MAX ? 0 : min_area;\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "python": "\n    ```python\ndef min_area_rect(points):\n    point_set = {(x, y) for x, y in points}\n    min_area = float('inf')\n\n    for p1 in point_set:\n        for p2 in point_set:\n            if p1[0] != p2[0] and p1[1] != p2[1]:\n                if (p1[0], p2[1]) in point_set and (p2[0], p1[1]) in point_set:\n                    min_area = min(min_area, abs((p1[0] - p2[0]) * (p1[1] - p2[1])))\n\n    return min_area if min_area != float('inf') else 0\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "javascript": "\n    ```javascript\nfunction minAreaRect(points) {\n  const pointSet = new Set(points.map(point => point.join(',')));\n  let minArea = Infinity;\n\n  for (const p1 of points) {\n    for (const p2 of points) {\n      if (p1[0] !== p2[0] && p1[1] !== p2[1]) {\n        if (pointSet.has([p1[0], p2[1]].join(',')) && pointSet.has([p2[0], p1[1]].join(','))) {\n          minArea = Math.min(minArea, Math.abs((p1[0] - p2[0]) * (p1[1] - p2[1])));\n        }\n      }\n    }\n  }\n\n  return minArea === Infinity ? 0 : minArea;\n}\n```\n\n    \n    1. Convert the given points into a set for efficient lookups.\n2. Initialize `min_area` to an infinitely large value initially.\n3. Iterate through each pair of distinct points `p1` and `p2` in the set, and check if two other points `p3` and `p4` exist such that p3.x = p1.x, p3.y = p2.y, p4.x = p2.x, p4.y = p1.y.\n4. If such points exist, calculate the area between `p1` and `p2` and update `min_area` with the minimum value between current `min_area` and calculated area.\n5. After the iteration, if `min_area` still holds the initial value (indicating no rectangles were found), return 0; otherwise, return the `min_area`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,1,2]",
                    "output": " 5",
                    "explanation": " You can form a triangle with three side lengths: 1, 2, and 2."
                },
                {
                    "input": " nums = [1,2,1,10]",
                    "output": " 0",
                    "explanation": " \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0."
                }
            ],
            "function_input": [
                {
                    "input": "[2,1,2]",
                    "output": "5"
                },
                {
                    "input": "[1,2,1,10]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-148",
        "prompt": "Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`."
    },
    "leetcode-benchmark-149": {
        "id": "leetcode-benchmark-149",
        "title": "Squares of a Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in **non-decreasing** order, return _an array of **the squares of each number** sorted in non-decreasing order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-4,-1,0,3,10\\]\n**Output:** \\[0,1,9,16,100\\]\n**Explanation:** After squaring, the array becomes \\[16,1,0,9,100\\].\nAfter sorting, it becomes \\[0,1,9,16,100\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-7,-3,2,3,11\\]\n**Output:** \\[4,9,9,49,121\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in **non-decreasing** order.\n\n**",
            "follow_up": "Follow up:** Squaring each element and sorting the new array is very trivial, could you find an `O(n)` solution using a different approach?"
        },
        "java": "\n    ```java\npublic int distinctSubseqII(String s) {\n    int mod = (int) (1e9 + 7);\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    int[] last = new int[26];\n    Arrays.fill(last, -1);\n\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = (dp[i - 1] * 2) % mod;\n        if (last[s.charAt(i - 1) - 'a'] != -1) {\n            dp[i] = (dp[i] - dp[last[s.charAt(i - 1) - 'a']] + mod) % mod;\n        }\n        last[s.charAt(i - 1) - 'a'] = i - 1;\n    }\n\n    dp[n] = (dp[n] - 1 + mod) % mod;\n    return dp[n];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "c++": "\n    ```cpp\n#include <iostream>\n#include <string>\n\nint distinctSubseqII(std::string s) {\n    int mod = 1e9 + 7;\n    int n = s.size();\n    std::vector<int> dp(n + 1);\n    dp[0] = 1;\n    std::vector<int> last(26, -1); \n\n    for (int i = 1; i <= n; ++i) {\n        dp[i] = (dp[i - 1] * 2) % mod;\n        if (last[s[i - 1] - 'a'] != -1) {\n            dp[i] = (dp[i] - dp[last[s[i - 1] - 'a']] + mod) % mod;\n        }\n        last[s[i - 1] - 'a'] = i - 1;\n    }\n\n    dp[n] = (dp[n] - 1 + mod) % mod;\n    return dp[n];\n}\n```\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "python": "\n    ```python\ndef distinctSubseqII(s):\n    mod = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    last = [-1] * 26\n\n    for i in range(1, n + 1):\n        dp[i] = (dp[i - 1] * 2) % mod\n        if last[ord(s[i - 1]) - ord('a')] != -1:\n            dp[i] = (dp[i] - dp[last[ord(s[i - 1]) - ord('a')]] + mod) % mod\n        last[ord(s[i - 1]) - ord('a')] = i - 1\n\n    dp[n] = (dp[n] - 1 + mod) % mod\n    return dp[n]\n```\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "javascript": "\n    ```javascript\nfunction distinctSubseqII(s) {\n    const mod = 1e9 + 7;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    const last = new Array(26).fill(-1);\n\n    for (let i = 1; i <= n; ++i) {\n        dp[i] = (dp[i - 1] * 2) % mod;\n        if (last[s.charCodeAt(i - 1) - 'a'.charCodeAt()] !== -1) {\n            dp[i] = (dp[i] - dp[last[s.charCodeAt(i - 1) - 'a'.charCodeAt()]] + mod) % mod;\n        }\n        last[s.charCodeAt(i - 1) - 'a'.charCodeAt()] = i - 1;\n    }\n\n    dp[n] = (dp[n] - 1 + mod) % mod;\n    return dp[n];\n}\n```\n\n    \n    1. Initialize a dynamic programming array `dp` with length `n+1` to store the number of distinct subsequences.\n2. Initialize an array `last`, with length 26, to store the last occurrences of each letter 'a'-'z'.\n3. Iterate through the string using the index `i` ranging from `1` to `n`.\n   1. Calculate the number of distinct subsequences of length i by doubling the number of distinct subsequences of length i-1.\n   2. If the last occurrence of the current letter is not `-1`, subtract the number of distinct subsequences at the index of the last occurrence from the current dp[i] value.\n   3. Update the last occurrence array index of the current letter in the string.\n4. Subtract 1 from the number of subsequences of length `n` (removes the empty subsequence) and return the result modulo 1e9+7.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-4,-1,0,3,10]",
                    "output": " [0,1,9,16,100]",
                    "explanation": " After squaring, the array becomes \\[16,1,0,9,100\\].\nAfter sorting, it becomes \\[0,1,9,16,100\\]."
                },
                {
                    "input": " nums = [-7,-3,2,3,11]",
                    "output": " [4,9,9,49,121]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[-4,-1,0,3,10]",
                    "output": "[0,1,9,16,100]"
                },
                {
                    "input": "[-7,-3,2,3,11]",
                    "output": "[4,9,9,49,121]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-149",
        "prompt": "Given an integer array `nums` sorted in **non-decreasing** order, return _an array of **the squares of each number** sorted in non-decreasing order_."
    },
    "leetcode-benchmark-150": {
        "id": "leetcode-benchmark-150",
        "title": "Cousins in Binary Tree",
        "difficulty": "Easy",
        "content": {
            "problem": "Given the `root` of a binary tree with unique values and the values of two different nodes of the tree `x` and `y`, return `true` _if the nodes corresponding to the values_ `x` _and_ `y` _in the tree are **cousins**, or_ `false` _otherwise._\n\nTwo nodes of a binary tree are **cousins** if they have the same depth with different parents.\n\nNote that in a binary tree, the root node is at the depth `0`, and children of each depth `k` node are at the depth `k + 1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4\\], x = 4, y = 3\n**Output:** false\n\n",
                "**Example 2:**\n\n**Input:** root = \\[1,2,3,null,4,null,5\\], x = 5, y = 4\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** root = \\[1,2,3,null,4\\], x = 2, y = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 100]`.\n*   `1 <= Node.val <= 100`\n*   Each node has a **unique** value.\n*   `x != y`\n*   `x` and `y` are exist in the tree.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int tallestBillboard(int[] rods) {\n    int n = rods.length;\n    int totalLength = Arrays.stream(rods).sum();\n    int[][] dp = new int[n + 1][totalLength + 1];\n    for (int i = 0; i < n + 1; i++) {\n        Arrays.fill(dp[i], -1);\n    }\n    dp[0][0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= totalLength; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (rods[i - 1] <= j) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);\n            if (rods[i - 1] <= totalLength - j) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + rods[i - 1]]);\n        }\n    }\n    \n    return dp[n][0] / 2;\n}\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "c++": "\n    ```cpp\nint tallestBillboard(vector<int>& rods) {\n    int n = rods.size();\n    int totalLength = accumulate(rods.begin(), rods.end(), 0);\n    vector<vector<int>> dp(n + 1, vector<int>(totalLength + 1, -1));\n    dp[0][0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= totalLength; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (rods[i - 1] <= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);\n            if (rods[i - 1] <= totalLength - j) dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]]);\n        }\n    }\n    \n    return dp[n][0] / 2;\n}\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "python": "\n    ```python\ndef tallestBillboard(rods):\n    n = len(rods)\n    totalLength = sum(rods)\n    dp = [[-1] * (totalLength + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for j in range(totalLength + 1):\n            dp[i][j] = dp[i - 1][j]\n            if rods[i - 1] <= j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1])\n            if rods[i - 1] <= totalLength - j:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j + rods[i - 1]])\n                \n    return dp[n][0] // 2\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "javascript": "\n    ```javascript\nfunction tallestBillboard(rods) {\n    const n = rods.length;\n    const totalLength = rods.reduce((sum, rod) => sum + rod, 0);\n    const dp = Array.from({length: n + 1}, () => Array(totalLength + 1).fill(-1));\n    \n    dp[0][0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j <= totalLength; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (rods[i - 1] <= j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - rods[i - 1]] + rods[i - 1]);\n            }\n            if (rods[i - 1] <= totalLength - j) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + rods[i - 1]]);\n            }\n        }\n    }\n    \n    return dp[n][0] / 2;\n}\n```\n\n    \n    The given problem can be solved using Dynamic Programming. We calculate the sum of all the lengths of rods available, this will help us in creating an NxM, where N is the number of rods and M is the sum of all lengths, table filled with \"-1\". Then we initialize the first row of this table with 0.\n\nNow, we loop through the table and refer to the previous row while remaining within the boundaries of total sum. We make comparisons with the previous row values by checking if the current rod can be added to the current total length or not. If yes, we check for the maximum value by adding and updating the current value. This approach allows us to deduce the maximum equal length of rods that can be created.\n\nFinally, we return the value at (n,0)th index divided by 2 as our final result. This gives us the largest possible height of the supported billboard. If it's not possible to support the billboard, the function returns 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,2,3,4], x = 4, y = 3",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " root = [1,2,3,null,4,null,5], x = 5, y = 4",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " root = [1,2,3,null,4], x = 2, y = 3",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4],4,3",
                    "output": "False"
                },
                {
                    "input": "[1,2,3,null,4,null,5],5,4",
                    "output": "True"
                },
                {
                    "input": "[1,2,3,null,4],2,3",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-150",
        "prompt": "Given the `root` of a binary tree with unique values and the values of two different nodes of the tree `x` and `y`, return `true` _if the nodes corresponding to the values_ `x` _and_ `y` _in the tree are **cousins**, or_ `false` _otherwise._\n\nTwo nodes of a binary tree are **cousins** if they have the same depth with different parents.\n\nNote that in a binary tree, the root node is at the depth `0`, and children of each depth `k` node are at the depth `k + 1`."
    },
    "leetcode-benchmark-151": {
        "id": "leetcode-benchmark-151",
        "title": "Find the Town Judge",
        "difficulty": "Easy",
        "content": {
            "problem": "In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n\n1.  The town judge trusts nobody.\n2.  Everybody (except for the town judge) trusts the town judge.\n3.  There is exactly one person that satisfies properties **1** and **2**.\n\nYou are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. If a trust relationship does not exist in `trust` array, then such a trust relationship does not exist.\n\nReturn _the label of the town judge if the town judge exists and can be identified, or return_ `-1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2, trust = \\[\\[1,2\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 3, trust = \\[\\[1,3\\],\\[2,3\\]\\]\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** n = 3, trust = \\[\\[1,3\\],\\[2,3\\],\\[3,1\\]\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= trust.length <= 104`\n*   `trust[i].length == 2`\n*   All the pairs of `trust` are **unique**.\n*   `ai != bi`\n*   `1 <= ai, bi <= n`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findJudge(int n, int[][] trust) {\n    int[] trustCounts = new int[n + 1];\n    for (int[] t : trust) {\n        trustCounts[t[0]]--;\n        trustCounts[t[1]]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint findJudge(int n, vector<vector<int>>& trust) {\n    vector<int> trustCounts(n + 1, 0);\n    for (auto& t : trust) {\n        trustCounts[t[0]]--;\n        trustCounts[t[1]]++;\n    }\n    for (int i = 1; i <= n; i++) {\n        if (trustCounts[i] == n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "python": "\n    ```python\ndef findJudge(n, trust):\n    trust_counts = [0] * (n + 1)\n    for a, b in trust:\n        trust_counts[a] -= 1\n        trust_counts[b] += 1\n    for i in range(1, n + 1):\n        if trust_counts[i] == n - 1:\n            return i\n    return -1\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "javascript": "\n    ```javascript\nfunction findJudge(n, trust) {\n    let trustCounts = new Array(n + 1).fill(0);\n    for (let [a, b] of trust) {\n        trustCounts[a]--;\n        trustCounts[b]++;\n    }\n    for (let i = 1; i <= n; i++) {\n        if (trustCounts[i] === n - 1)\n            return i;\n    }\n    return -1;\n}\n```\n    \n    1. Create an array `trustCounts` to store the number of trusts for each person.\n2. Loop through the trust relationships, decrement the count in `trustCounts` for the person who trusts (a), and increment the count for the person being trusted (b).\n3. Loop through the `trustCounts` array and check if any person has a trust count equal to `n - 1`, as this would mean that everyone trusts that person (except for themselves).\n4. If such a person is found, return their index as the town judge. If no such person is found, return -1.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2, trust = [[1,2]]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " n = 3, trust = [[1,3],[2,3]]",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " n = 3, trust = [[1,3],[2,3],[3,1]]",
                    "output": " -1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2,[[1,2]]",
                    "output": "2"
                },
                {
                    "input": "3,[[1,3],[2,3]]",
                    "output": "3"
                },
                {
                    "input": "3,[[1,3],[2,3],[3,1]]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-151",
        "prompt": "In a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n\n1.  The town judge trusts nobody.\n2.  Everybody (except for the town judge) trusts the town judge.\n3.  There is exactly one person that satisfies properties **1** and **2**.\n\nYou are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. If a trust relationship does not exist in `trust` array, then such a trust relationship does not exist.\n\nReturn _the label of the town judge if the town judge exists and can be identified, or return_ `-1` _otherwise_."
    },
    "leetcode-benchmark-152": {
        "id": "leetcode-benchmark-152",
        "title": "Available Captures for Rook",
        "difficulty": "Easy",
        "content": {
            "problem": "On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** In this example, the rook is attacking all the pawns.\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 0\n**Explanation:** The bishops are blocking the rook from attacking any of the pawns.\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"\\],\\[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"\\]\\]\n**Output:** 3\n**Explanation:** The rook is attacking the pawns at positions b5, d6, and f5."
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 8`\n*   `board[i].length == 8`\n*   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`\n*   There is exactly one cell with `board[i][j] == 'R'`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int regionsBySlashes(String[] grid) {\n    int n = grid.length;\n    int[][] graph = new int[n * 3][n * 3];\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i].charAt(j) == '/') {\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;\n            }\n            if (grid[i].charAt(j) == '\\\\') {\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;\n            }\n        }\n    }\n\n    int regions = 0;\n    for (int i = 0; i < n * 3; i++) {\n        for (int j = 0; j < n * 3; j++) {\n            if (graph[i][j] == 0) {\n                regions++;\n                dfs(graph, i, j);\n            }\n        }\n    }\n\n    return regions;\n}\n\nprivate void dfs(int[][] graph, int i, int j) {\n    int n = graph.length;\n    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j] == 1) return;\n\n    graph[i][j] = 1;\n    dfs(graph, i - 1, j);\n    dfs(graph, i + 1, j);\n    dfs(graph, i, j - 1);\n    dfs(graph, i, j + 1);\n}\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint regionsBySlashes(std::vector<std::string>& grid) {\n    int n = grid.size();\n    std::vector<std::vector<int>> graph(n * 3, std::vector<int>(n * 3, 0));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == '/') {\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;\n            }\n            if (grid[i][j] == '\\\\') {\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;\n            }\n        }\n    }\n\n    int regions = 0;\n    for (int i = 0; i < n * 3; ++i) {\n        for (int j = 0; j < n * 3; ++j) {\n            if (!graph[i][j]) {\n                regions++;\n                dfs(graph, i, j);\n            }\n        }\n    }\n\n    return regions;\n}\n\nvoid dfs(std::vector<std::vector<int>>& graph, int i, int j) {\n    int n = graph.size();\n    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j]) return;\n    \n    graph[i][j] = 1;\n    dfs(graph, i - 1, j);\n    dfs(graph, i + 1, j);\n    dfs(graph, i, j - 1);\n    dfs(graph, i, j + 1);\n}\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "python": "\n    ```python\ndef regionsBySlashes(grid):\n    n = len(grid)\n    graph = [[0] * (n * 3) for _ in range(n * 3)]\n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '/':\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1\n            if grid[i][j] == '\\\\':\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1\n\n    regions = 0\n    for i in range(n * 3):\n        for j in range(n * 3):\n            if not graph[i][j]:\n                regions += 1\n                dfs(graph, i, j)\n\n    return regions\n\ndef dfs(graph, i, j):\n    n = len(graph)\n    if i < 0 or j < 0 or i >= n or j >= n or graph[i][j]:\n        return\n\n    graph[i][j] = 1\n    dfs(graph, i - 1, j)\n    dfs(graph, i + 1, j)\n    dfs(graph, i, j - 1)\n    dfs(graph, i, j + 1)\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "javascript": "\n    ```javascript\nfunction regionsBySlashes(grid) {\n    const n = grid.length;\n    const graph = Array.from({ length: n * 3 }, () => Array(n * 3).fill(0));\n\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < n; j++) {\n            if (grid[i][j] === '/') {\n                graph[i * 3][j * 3 + 2] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3] = 1;\n            }\n            if (grid[i][j] === '\\\\') {\n                graph[i * 3][j * 3] = graph[i * 3 + 1][j * 3 + 1] = graph[i * 3 + 2][j * 3 + 2] = 1;\n            }\n        }\n    }\n\n    let regions = 0;\n    for (let i = 0; i < n * 3; i++) {\n        for (let j = 0; j < n * 3; j++) {\n            if (graph[i][j] === 0) {\n                regions++;\n                dfs(graph, i, j);\n            }\n        }\n    }\n\n    return regions;\n}\n\nfunction dfs(graph, i, j) {\n    const n = graph.length;\n    if (i < 0 || j < 0 || i >= n || j >= n || graph[i][j] === 1) return;\n\n    graph[i][j] = 1;\n    dfs(graph, i - 1, j);\n    dfs(graph, i + 1, j);\n    dfs(graph, i, j - 1);\n    dfs(graph, i, j + 1);\n}\n```\n    \n    The algorithm for solving this problem is as follows:\n\n1. Create a graph representation of the n x n grid. The graph will have n * 3 rows and columns. The reason for this size is that we are going to divide the 1 x 1 grid cell with '/', '\\', and ' ' into 9 smaller parts, making it easier to identify regions.\n\n2. Loop through the grid and update the corresponding graph cells based on the '/' and '\\' characters. For example, if we find '/' in grid[i][j], we update the graph at grid[i*3][j*3+2], grid[i*3+1][j*3+1], and grid[i*3+2][j*3] to 1.\n\n3. Perform Depth-First Search (DFS) in the graph to count the number of regions.\n\n4. Loop through the entire graph which represents the n x n grid. Whenever we find a cell with value 0, we increment the regions count and perform a DFS on that cell.\n\n5. The DFS function will take graph, i, and j as input parameters. It will mark the cell as visited and call itself recursively for its neighboring cells.\n\n6. The DFS function will stop when a cell is 1 or out of bounds.\n\n7. Finally, we return the value of regions as the result. This will be the number of contiguous regions in the grid.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"R \", \". \", \". \", \". \", \"p \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"]]",
                    "output": " 3",
                    "explanation": " In this example, the rook is attacking all the pawns."
                },
                {
                    "input": " board = [[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"],[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"],[ \". \", \"p \", \"B \", \"R \", \"B \", \"p \", \". \", \". \"],[ \". \", \"p \", \"p \", \"B \", \"p \", \"p \", \". \", \". \"],[ \". \", \"p \", \"p \", \"p \", \"p \", \"p \", \". \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"]]",
                    "output": " 0",
                    "explanation": " The bishops are blocking the rook from attacking any of the pawns."
                },
                {
                    "input": " board = [[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"],[ \"p \", \"p \", \". \", \"R \", \". \", \"p \", \"B \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"B \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \"p \", \". \", \". \", \". \", \". \"],[ \". \", \". \", \". \", \". \", \". \", \". \", \". \", \". \"]]",
                    "output": " 3",
                    "explanation": " The rook is attacking the pawns at positions b5, d6, and f5."
                }
            ],
            "function_input": [
                {
                    "input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"R\",\".\",\".\",\".\",\"p\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
                    "output": "3"
                },
                {
                    "input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"B\",\"R\",\"B\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"B\",\"p\",\"p\",\".\",\".\"],[\".\",\"p\",\"p\",\"p\",\"p\",\"p\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
                    "output": "0"
                },
                {
                    "input": "[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\"p\",\"p\",\".\",\"R\",\".\",\"p\",\"B\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"B\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"p\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-152",
        "prompt": "On an `8 x 8` chessboard, there is **exactly one** white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.\n\nWhen the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered **attacking** a pawn if the rook can capture the pawn on the rook's turn. The **number of available captures** for the white rook is the number of pawns that the rook is **attacking**.\n\nReturn _the **number of available captures** for the white rook_."
    },
    "leetcode-benchmark-153": {
        "id": "leetcode-benchmark-153",
        "title": "Maximize Sum Of Array After K Negations",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, modify the array in the following way:\n\n*   choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index `i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,2,3\\], k = 1\n**Output:** 5\n**Explanation:** Choose index 1 and nums becomes \\[4,-2,3\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,-1,0,2\\], k = 3\n**Output:** 6\n**Explanation:** Choose indices (1, 2, 2) and nums becomes \\[3,1,0,2\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,-3,-1,5,-4\\], k = 2\n**Output:** 13\n**Explanation:** Choose indices (1, 4) and nums becomes \\[2,3,-1,5,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `-100 <= nums[i] <= 100`\n*   `1 <= k <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isUnivalued(TreeNode root) {\n    return isUnivalued(root, -1);\n}\n\nprivate boolean isUnivalued(TreeNode root, int val) {\n    if (root == null) return true;\n    if (val == -1) val = root.val;\n    return root.val == val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "c++": "\n    ```cpp\nbool isUnivalued(TreeNode* root, int val = -1) {\n    if (!root) return true;\n    if (val == -1) val = root->val;\n    return root->val == val && isUnivalued(root->left, val) && isUnivalued(root->right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "python": "\n    ```python\ndef is_univalued(root, val=None):\n    if not root:\n        return True\n    if val is None:\n        val = root.val\n    return root.val == val and is_univalued(root.left, val) and is_univalued(root.right, val)\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "javascript": "\n    ```javascript\nfunction isUnivalued(root, val = null) {\n    if (!root) return true;\n    if (val === null) val = root.val;\n    return root.val === val && isUnivalued(root.left, val) && isUnivalued(root.right, val);\n}\n```\n    \n    The algorithm first checks if the root node is null, if it is, the function returns true as an empty tree is uni-valued. If this is the first call to the function (indicated by default value for val), it sets the val to the root node's value. For all other calls, val is already set, and it only checks if the current node's value is equal to val. If it is equal, it recursively calls for the left and right sub-trees. If all calls return true, the tree is uni-valued, otherwise it's not.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [4,2,3], k = 1",
                    "output": " 5",
                    "explanation": " Choose index 1 and nums becomes \\[4,-2,3\\]."
                },
                {
                    "input": " nums = [3,-1,0,2], k = 3",
                    "output": " 6",
                    "explanation": " Choose indices (1, 2, 2) and nums becomes \\[3,1,0,2\\]."
                },
                {
                    "input": " nums = [2,-3,-1,5,-4], k = 2",
                    "output": " 13",
                    "explanation": " Choose indices (1, 4) and nums becomes \\[2,3,-1,5,4\\]."
                }
            ],
            "function_input": [
                {
                    "input": "[4,2,3],1",
                    "output": "5"
                },
                {
                    "input": "[3,-1,0,2],3",
                    "output": "6"
                },
                {
                    "input": "[2,-3,-1,5,-4],2",
                    "output": "13"
                }
            ]
        },
        "task_id": "leetcode-benchmark-153",
        "prompt": "Given an integer array `nums` and an integer `k`, modify the array in the following way:\n\n*   choose an index `i` and replace `nums[i]` with `-nums[i]`.\n\nYou should apply this process exactly `k` times. You may choose the same index `i` multiple times.\n\nReturn _the largest possible sum of the array after modifying it in this way_."
    },
    "leetcode-benchmark-154": {
        "id": "leetcode-benchmark-154",
        "title": "Complement of Base 10 Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "The **complement** of an integer is the integer you get when you flip all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n*   For example, The integer `5` is `\"101 \"` in binary and its **complement** is `\"010 \"` which is the integer `2`.\n\nGiven an integer `n`, return _its complement_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation:** 5 is  \"101 \" in binary, with complement  \"010 \" in binary, which is 2 in base-10.\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** 0\n**Explanation:** 7 is  \"111 \" in binary, with complement  \"000 \" in binary, which is 0 in base-10.\n\n",
                "**Example 3:**\n\n**Input:** n = 10\n**Output:** 5\n**Explanation:** 10 is  \"1010 \" in binary, with complement  \"0101 \" in binary, which is 5 in base-10."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n < 109`\n\n**Note:** This question is the same as 476: [https://leetcode.com/problems/number-complement/](https://leetcode.com/problems/number-complement/)",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> pancakeSort(int[] arr) {\n    List<Integer> flips = new ArrayList<>();\n    for (int size = arr.length; size > 1; --size) {\n        int maxIdx = getMaxIdx(arr, size);\n        flips.add(maxIdx + 1);\n        flips.add(size);\n        reverse(arr, 0, maxIdx);\n        reverse(arr, 0, size - 1);\n    }\n    return flips;\n}\n\nprivate int getMaxIdx(int[] arr, int size) {\n    int maxIdx = 0;\n    for (int i = 1; i < size; ++i) {\n        if (arr[i] > arr[maxIdx]) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nprivate void reverse(int[] arr, int start, int end) {\n    while (start < end) {\n        int temp = arr[start];\n        arr[start++] = arr[end];\n        arr[end--] = temp;\n    }\n}\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> pancakeSort(vector<int>& arr) {\n    vector<int> flips;\n    for (int size = arr.size(); size > 1; --size) {\n        int maxIdx = max_element(arr.begin(), arr.begin() + size) - arr.begin();\n        flips.push_back(maxIdx + 1);\n        flips.push_back(size);\n        reverse(arr.begin(), arr.begin() + maxIdx + 1);\n        reverse(arr.begin(), arr.begin() + size);\n    }\n    return flips;\n}\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "python": "\n    ```python\ndef pancakeSort(arr):\n    flips = []\n    for size in range(len(arr), 1, -1):\n        maxIdx = arr.index(max(arr[:size]))\n        flips.extend([maxIdx + 1, size])\n        arr[:maxIdx + 1] = reversed(arr[:maxIdx + 1])\n        arr[:size] = reversed(arr[:size])\n    return flips\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "javascript": "\n    ```javascript\nfunction pancakeSort(arr) {\n    const flips = [];\n    for (let size = arr.length; size > 1; --size) {\n        const maxIdx = getMaxIdx(arr, size);\n        flips.push(maxIdx + 1);\n        flips.push(size);\n        reverse(arr, 0, maxIdx);\n        reverse(arr, 0, size - 1);\n    }\n    return flips;\n}\n\nfunction getMaxIdx(arr, size) {\n    let maxIdx = 0;\n    for (let i = 1; i < size; ++i) {\n        if (arr[i] > arr[maxIdx]) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nfunction reverse(arr, start, end) {\n    while (start < end) {\n        const temp = arr[start];\n        arr[start++] = arr[end];\n        arr[end--] = temp;\n    }\n}\n```\n    \n    The algorithm be:\n1. Iterate over the array from the last element to the first.\n2. During each iteration, find the index of the maximum element in the unsorted part of the array.\n3. Perform a pancake flip at the maximum element index, to move it to the beginning of the array.\n4. Perform a pancake flip for the whole unsorted part of the array to place the maximum element at its correct position.\n5. Add the flip positions in the list of flips.\n6. The algorithm ends when the array is completely sorted.\n\nThis guarantees that the array will be sorted within 2 * arr.length flips.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5",
                    "output": " 2",
                    "explanation": " 5 is  \"101 \" in binary, with complement  \"010 \" in binary, which is 2 in base-10."
                },
                {
                    "input": " n = 7",
                    "output": " 0",
                    "explanation": " 7 is  \"111 \" in binary, with complement  \"000 \" in binary, which is 0 in base-10."
                },
                {
                    "input": " n = 10",
                    "output": " 5",
                    "explanation": " 10 is  \"1010 \" in binary, with complement  \"0101 \" in binary, which is 5 in base-10."
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "2"
                },
                {
                    "input": "7",
                    "output": "0"
                },
                {
                    "input": "10",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-154",
        "prompt": "The **complement** of an integer is the integer you get when you flip all the `0`'s to `1`'s and all the `1`'s to `0`'s in its binary representation.\n\n*   For example, The integer `5` is `\"101 \"` in binary and its **complement** is `\"010 \"` which is the integer `2`.\n\nGiven an integer `n`, return _its complement_."
    },
    "leetcode-benchmark-155": {
        "id": "leetcode-benchmark-155",
        "title": "Partition Array Into Three Parts With Equal Sum",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of integers `arr`, return `true` if we can partition the array into three **non-empty** parts with equal sums.\n\nFormally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[0,2,1,-6,6,-7,9,1,2,0,1\\]\n**Output:** true\n**Explanation:** 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[0,2,1,-6,6,7,9,-1,2,0,1\\]\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[3,3,6,5,-2,2,5,1,-9,4\\]\n**Output:** true\n**Explanation:** 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 5 * 104`\n*   `-104 <= arr[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int fib(int n) {\n    if (n <= 1)\n        return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "c++": "\n    ```cpp\nint fib(int n) {\n    if (n <= 1)\n        return n;\n    int a = 0, b = 1, c;\n    for (int i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "python": "\n    ```python\ndef fib(n):\n    if n <= 1:\n        return n\n    a, b = 0, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "javascript": "\n    ```javascript\nfunction fib(n) {\n    if (n <= 1)\n        return n;\n    let a = 0, b = 1, c;\n    for (let i = 2; i <= n; i++) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b;\n}\n```\n    \n    The algorithm iterates from 2 to n using a loop that calculates the current Fibonacci number by adding the two previous ones. It uses three variables a, b, and c, representing the two previous Fibonacci numbers and the current one, respectively. At each iteration, the algorithm calculates the current Fibonacci number, updates a and b, and repeats. This minimizes the extra space needed and avoids recursion, resulting in an efficient O(n) time complexity solution.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [0,2,1,-6,6,-7,9,1,2,0,1]",
                    "output": " True",
                    "explanation": " 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1"
                },
                {
                    "input": " arr = [0,2,1,-6,6,7,9,-1,2,0,1]",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " arr = [3,3,6,5,-2,2,5,1,-9,4]",
                    "output": " True",
                    "explanation": " 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
                }
            ],
            "function_input": [
                {
                    "input": "[0,2,1,-6,6,-7,9,1,2,0,1]",
                    "output": "True"
                },
                {
                    "input": "[0,2,1,-6,6,7,9,-1,2,0,1]",
                    "output": "False"
                },
                {
                    "input": "[3,3,6,5,-2,2,5,1,-9,4]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-155",
        "prompt": "Given an array of integers `arr`, return `true` if we can partition the array into three **non-empty** parts with equal sums.\n\nFormally, we can partition the array if we can find indexes `i + 1 < j` with `(arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])`"
    },
    "leetcode-benchmark-156": {
        "id": "leetcode-benchmark-156",
        "title": "Binary Prefix Divisible By 5",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given a binary array `nums` (**0-indexed**).\n\nWe define `xi` as the number whose binary representation is the subarray `nums[0..i]` (from most-significant-bit to least-significant-bit).\n\n*   For example, if `nums = [1,0,1]`, then `x0 = 1`, `x1 = 2`, and `x2 = 5`.\n\nReturn _an array of booleans_ `answer` _where_ `answer[i]` _is_ `true` _if_ `xi` _is divisible by_ `5`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[0,1,1\\]\n**Output:** \\[true,false,false\\]\n**Explanation:** The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.\nOnly the first number is divisible by 5, so answer\\[0\\] is true.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\]\n**Output:** \\[false,false,false\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `nums[i]` is either `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int largestPerimeter(int[] nums) {\n    Arrays.sort(nums);\n\n    for (int i = nums.length - 1; i >= 2; --i) {\n        if (nums[i] < nums[i - 1] + nums[i - 2]) {\n            return nums[i] + nums[i - 1] + nums[i - 2];\n        }\n    }\n\n    return 0;\n}\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint largestPerimeter(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\n\n    for (size_t i = 0; i < nums.size() - 2; ++i) {\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\n            return nums[i] + nums[i + 1] + nums[i + 2];\n        }\n    }\n\n    return 0;\n}\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "python": "\n    ```python\ndef largestPerimeter(nums):\n    nums.sort(reverse=True)\n\n    for i in range(len(nums) - 2):\n        if nums[i] < nums[i + 1] + nums[i + 2]:\n            return nums[i] + nums[i + 1] + nums[i + 2]\n\n    return 0\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "javascript": "\n    ```javascript\nfunction largestPerimeter(nums) {\n    nums.sort((a, b) => b - a);\n\n    for (let i = 0; i < nums.length - 2; ++i) {\n        if (nums[i] < nums[i + 1] + nums[i + 2]) {\n            return nums[i] + nums[i + 1] + nums[i + 2];\n        }\n    }\n\n    return 0;\n}\n```\n    \n    To find the largest perimeter of a triangle with a non-zero area, we first sort the array in descending order. This allows us to check if a triangle can be formed by taking the longest possible sides first. Then, we iterate through the sorted array and check if the current element and the next two elements form a triangle of non-zero area. To check if a triangle can be formed, we use the triangle inequality theorem, which states that for any triangle with sides a, b, and c, the sum of any two sides must be greater than the third side (a + b > c, a + c > b, b + c > a). Since we have the array sorted in descending order, we only need to check one case of the inequality (nums[i] < nums[i + 1] + nums[i + 2]) for each iteration. If we find a valid triangle, we return the sum of its sides as the largest perimeter. If no valid triangle is found, we return 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [0,1,1]",
                    "output": " [True,False,False]",
                    "explanation": " The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.\nOnly the first number is divisible by 5, so answer\\[0\\] is true."
                },
                {
                    "input": " nums = [1,1,1]",
                    "output": " [False,False,False]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[0,1,1]",
                    "output": "[True,False,False]"
                },
                {
                    "input": "[1,1,1]",
                    "output": "[False,False,False]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-156",
        "prompt": "You are given a binary array `nums` (**0-indexed**).\n\nWe define `xi` as the number whose binary representation is the subarray `nums[0..i]` (from most-significant-bit to least-significant-bit).\n\n*   For example, if `nums = [1,0,1]`, then `x0 = 1`, `x1 = 2`, and `x2 = 5`.\n\nReturn _an array of booleans_ `answer` _where_ `answer[i]` _is_ `true` _if_ `xi` _is divisible by_ `5`."
    },
    "leetcode-benchmark-157": {
        "id": "leetcode-benchmark-157",
        "title": "Remove Outermost Parentheses",
        "difficulty": "Easy",
        "content": {
            "problem": "A valid parentheses string is either empty `\" \"`, `\"( \" + A + \") \"`, or `A + B`, where `A` and `B` are valid parentheses strings, and `+` represents string concatenation.\n\n*   For example, `\" \"`, `\"() \"`, `\"(())() \"`, and `\"(()(())) \"` are all valid parentheses strings.\n\nA valid parentheses string `s` is primitive if it is nonempty, and there does not exist a way to split it into `s = A + B`, with `A` and `B` nonempty valid parentheses strings.\n\nGiven a valid parentheses string `s`, consider its primitive decomposition: `s = P1 + P2 + ... + Pk`, where `Pi` are primitive valid parentheses strings.\n\nReturn `s` _after removing the outermost parentheses of every primitive string in the primitive decomposition of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(()())(()) \"\n**Output:**  \"()()() \"\n**Explanation:** \nThe input string is  \"(()())(()) \", with primitive decomposition  \"(()()) \" +  \"(()) \".\nAfter removing outer parentheses of each part, this is  \"()() \" +  \"() \" =  \"()()() \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"(()())(())(()(())) \"\n**Output:**  \"()()()()(()) \"\n**Explanation:** \nThe input string is  \"(()())(())(()(())) \", with primitive decomposition  \"(()()) \" +  \"(()) \" +  \"(()(())) \".\nAfter removing outer parentheses of each part, this is  \"()() \" +  \"() \" +  \"()(()) \" =  \"()()()()(()) \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"()() \"\n**Output:**  \" \"\n**Explanation:** \nThe input string is  \"()() \", with primitive decomposition  \"() \" +  \"() \".\nAfter removing outer parentheses of each part, this is  \" \" +  \" \" =  \" \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is either `'('` or `')'`.\n*   `s` is a valid parentheses string.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int distributeCoins(TreeNode root) {\n    int[] moves = new int[1];\n    distributeCoins(root, moves);\n    return moves[0];\n}\n\nprivate int distributeCoins(TreeNode root, int[] moves) {\n    if (root == null) return 0;\n    int left = distributeCoins(root.left, moves);\n    int right = distributeCoins(root.right, moves);\n    moves[0] += Math.abs(left) + Math.abs(right);\n    return root.val + left + right - 1;\n}\n```\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "c++": "\n    ```cpp\nint distributeCoins(TreeNode* root, int &moves) {\n    if (root == nullptr) return 0;\n    int left = distributeCoins(root->left, moves);\n    int right = distributeCoins(root->right, moves);\n    moves += abs(left) + abs(right);\n    return root->val + left + right - 1;\n}\n\nint distributeCoins(TreeNode* root) {\n    int moves = 0;\n    distributeCoins(root, moves);\n    return moves;\n}\n```\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "python": "\n    ```python\ndef distributeCoins(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left, right = dfs(node.left), dfs(node.right)\n        moves[0] += abs(left) + abs(right)\n        return node.val + left + right - 1\n\n    moves = [0]\n    dfs(root)\n    return moves[0]\n```\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "javascript": "\n    ```javascript\nfunction distributeCoins(root) {\n    function dfs(node) {\n        if (!node) return 0;\n        let left = dfs(node.left);\n        let right = dfs(node.right);\n        moves[0] += Math.abs(left) + Math.abs(right);\n        return node.val + left + right - 1;\n    }\n\n    let moves = [0];\n    dfs(root);\n    return moves[0];\n}\n```\n\n    \n    The algorithm uses DFS (Depth-first search) to traverse the binary tree. We start from the root node and move down to the leaf nodes before returning to the parent nodes. In each step, we calculate the number of moves as the absolute difference between the current node's value and 1, because we want every node to have exactly one coin. The total number of moves required is the sum of these absolute differences.\n\nWe use a helper function that takes the current node as its argument and returns its excess coins. In each recursive call, the helper function calls itself for left and right children of the node. The number of moves is then incremented by the absolute values of the returned excess coins from the left and right children.\n\nFinally, we return the total number of moves calculated during the traversal.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"(()())(()) \"",
                    "output": "  \"()()() \"",
                    "explanation": " \nThe input string is  \"(()())(()) \", with primitive decomposition  \"(()()) \" +  \"(()) \".\nAfter removing outer parentheses of each part, this is  \"()() \" +  \"() \" =  \"()()() \"."
                },
                {
                    "input": " s =  \"(()())(())(()(())) \"",
                    "output": "  \"()()()()(()) \"",
                    "explanation": " \nThe input string is  \"(()())(())(()(())) \", with primitive decomposition  \"(()()) \" +  \"(()) \" +  \"(()(())) \".\nAfter removing outer parentheses of each part, this is  \"()() \" +  \"() \" +  \"()(()) \" =  \"()()()()(()) \"."
                },
                {
                    "input": " s =  \"()() \"",
                    "output": "  \" \"",
                    "explanation": " \nThe input string is  \"()() \", with primitive decomposition  \"() \" +  \"() \".\nAfter removing outer parentheses of each part, this is  \" \" +  \" \" =  \" \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"(()())(())\"",
                    "output": "\"()()()\""
                },
                {
                    "input": "\"(()())(())(()(()))\"",
                    "output": "\"()()()()(())\""
                },
                {
                    "input": "\"()()\"",
                    "output": "\"\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-157",
        "prompt": "A valid parentheses string is either empty `\" \"`, `\"( \" + A + \") \"`, or `A + B`, where `A` and `B` are valid parentheses strings, and `+` represents string concatenation.\n\n*   For example, `\" \"`, `\"() \"`, `\"(())() \"`, and `\"(()(())) \"` are all valid parentheses strings.\n\nA valid parentheses string `s` is primitive if it is nonempty, and there does not exist a way to split it into `s = A + B`, with `A` and `B` nonempty valid parentheses strings.\n\nGiven a valid parentheses string `s`, consider its primitive decomposition: `s = P1 + P2 + ... + Pk`, where `Pi` are primitive valid parentheses strings.\n\nReturn `s` _after removing the outermost parentheses of every primitive string in the primitive decomposition of_ `s`."
    },
    "leetcode-benchmark-158": {
        "id": "leetcode-benchmark-158",
        "title": "Sum of Root To Leaf Binary Numbers",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given the `root` of a binary tree where each node has a value `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n*   For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return _the sum of these numbers_.\n\nThe test cases are generated so that the answer fits in a **32-bits** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,0,1,0,1,0,1\\]\n**Output:** 22\n**Explanation:** (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n\n",
                "**Example 2:**\n\n**Input:** root = \\[0\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `Node.val` is `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int uniquePathsIII(int[][] grid) {\n    int x = 0, y = 0, empty = 1;\n    for (int i = 0; i < grid.length; ++i) {\n        for (int j = 0; j < grid[0].length; ++j) {\n            if (grid[i][j] == 1) {\n                x = i;\n                y = j;\n            } else if (grid[i][j] == 0) {\n                empty++;\n            }\n        }\n    }\n    return dfs(grid, x, y, empty);\n}\n\nprivate int dfs(int[][] grid, int x, int y, int empty) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == -1) {\n        return 0;\n    }\n    if (grid[x][y] == 2) {\n        return empty == -1 ? 1 : 0;\n    }\n    grid[x][y] = -1;\n    int paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);\n    grid[x][y] = 0;\n    return paths;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "c++": "\n    ```cpp\nint dfs(vector<vector<int>>& grid, int x, int y, int empty) {\n    if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == -1) {\n        return 0;\n    }\n    if (grid[x][y] == 2) {\n        return empty == -1 ? 1 : 0;\n    }\n    grid[x][y] = -1;\n    int paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);\n    grid[x][y] = 0;\n    return paths;\n}\n\nint uniquePathsIII(vector<vector<int>>& grid) {\n    int x = 0, y = 0, empty = 1;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                x = i, y = j;\n            } else if (grid[i][j] == 0) {\n                empty++;\n            }\n        }\n    }\n    return dfs(grid, x, y, empty);\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "python": "\n    ```python\ndef uniquePathsIII(grid):\n    x, y, empty = 0, 0, 1\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                x, y = i, j\n            elif grid[i][j] == 0:\n                empty += 1\n    return dfs(grid, x, y, empty)\n\ndef dfs(grid, x, y, empty):\n    if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == -1:\n        return 0\n    if grid[x][y] == 2:\n        return 1 if empty == -1 else 0\n    grid[x][y] = -1\n    paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1)\n    grid[x][y] = 0\n    return paths\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "javascript": "\n    ```javascript\nfunction uniquePathsIII(grid) {\n    let x = 0, y = 0, empty = 1;\n    for (let i = 0; i < grid.length; ++i) {\n        for (let j = 0; j < grid[0].length; ++j) {\n            if (grid[i][j] === 1) {\n                x = i;\n                y = j;\n            } else if (grid[i][j] === 0) {\n                empty++;\n            }\n        }\n    }\n    return dfs(grid, x, y, empty);\n}\n\nfunction dfs(grid, x, y, empty) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === -1) {\n        return 0;\n    }\n    if (grid[x][y] === 2) {\n        return empty === -1 ? 1 : 0;\n    }\n    grid[x][y] = -1;\n    let paths = dfs(grid, x + 1, y, empty - 1) + dfs(grid, x - 1, y, empty - 1) + dfs(grid, x, y + 1, empty - 1) + dfs(grid, x, y - 1, empty - 1);\n    grid[x][y] = 0;\n    return paths;\n}\n```\n    \n    The algorithm uses a depth-first search (DFS) to explore all possible paths from the starting square to the ending square while keeping track of the number of non-obstacle squares it has visited. If a path reaches the ending square and has visited all non-obstacle squares exactly once, it counts as a valid path. The algorithm returns the total number of valid paths it finds. It starts by iterating over the grid to find the starting position and count the number of non-obstacle squares. Then it performs the DFS, backtracking when necessary by marking visited squares with -1 and unvisiting them once they have been explored.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,0,1,0,1,0,1]",
                    "output": " 22",
                    "explanation": " (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22"
                },
                {
                    "input": " root = [0]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,1,0,1,0,1]",
                    "output": "22"
                },
                {
                    "input": "[0]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-158",
        "prompt": "You are given the `root` of a binary tree where each node has a value `0` or `1`. Each root-to-leaf path represents a binary number starting with the most significant bit.\n\n*   For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.\n\nFor all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return _the sum of these numbers_.\n\nThe test cases are generated so that the answer fits in a **32-bits** integer."
    },
    "leetcode-benchmark-159": {
        "id": "leetcode-benchmark-159",
        "title": "Divisor Game",
        "difficulty": "Easy",
        "content": {
            "problem": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** true\n**Explanation:** Alice chooses 1, and Bob has no more moves.\n\n",
                "**Example 2:**\n\n**Input:** n = 3\n**Output:** false\n**Explanation:** Alice chooses 1, Bob chooses 1, and Alice has no more moves."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic int mincostTickets(int[] days, int[] costs) {\n  Set<Integer> travelDays = new HashSet<>();\n  for (int day : days) travelDays.add(day);\n  int[] dp = new int[366];\n\n  for (int i = 1; i <= 365; ++i) {\n    if (!travelDays.contains(i)) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = Math.min(dp[i - 1] + costs[0],\n                   Math.min(dp[Math.max(0, i - 7)] + costs[1],\n                            dp[Math.max(0, i - 30)] + costs[2]));\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nint mincostTickets(vector<int>& days, vector<int>& costs) {\n  unordered_set<int> travel_days(days.begin(), days.end());\n  vector<int> dp(366, 0);\n\n  for (int i = 1; i <= 365; ++i) {\n    if (travel_days.count(i) == 0) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = min({dp[i - 1] + costs[0],\n                   dp[max(0, i - 7)] + costs[1],\n                   dp[max(0, i - 30)] + costs[2]});\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "python": "\n    ```python\ndef mincostTickets(days, costs):\n  travel_days = set(days)\n  dp = [0] * 366\n\n  for i in range(1, 366):\n    if i not in travel_days:\n      dp[i] = dp[i - 1]\n    else:\n      dp[i] = min(dp[i - 1] + costs[0],\n                  dp[max(0, i - 7)] + costs[1],\n                  dp[max(0, i - 30)] + costs[2])\n\n  return dp[365]\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "javascript": "\n    ```javascript\nfunction mincostTickets(days, costs) {\n  const travelDays = new Set(days);\n  const dp = new Array(366).fill(0);\n\n  for (let i = 1; i <= 365; ++i) {\n    if (!travelDays.has(i)) {\n      dp[i] = dp[i - 1];\n    } else {\n      dp[i] = Math.min(dp[i - 1] + costs[0],\n                   Math.min(dp[Math.max(0, i - 7)] + costs[1],\n                            dp[Math.max(0, i - 30)] + costs[2]));\n    }\n  }\n\n  return dp[365];\n}\n```\n    \n    1. Create a set of travel days.\n2. Initialize a dynamic programming (dp) array of length 366, where dp[i] will represent the minimum cost to travel on the given days up to the i-th day of the year.\n3. Iterate through the days of the year (1 to 365).\n   a. If the current day is not a travel day, then there's no need to buy a pass for this day, therefore the minimum cost is the same as the previous day.\n   b. If the current day is a travel day, calculate the minimum cost to travel by considering the three options: buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass.\n4. Return the minimum cost to travel on all given days (dp[365]).\n\nThis algorithm leverages dynamic programming to calculate the minimum cost of traveling on the given days. By iterating through each day and updating the dp array based on previous results, the final minimum cost is obtained efficiently.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " True",
                    "explanation": " Alice chooses 1, and Bob has no more moves."
                },
                {
                    "input": " n = 3",
                    "output": " False",
                    "explanation": " Alice chooses 1, Bob chooses 1, and Alice has no more moves."
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "True"
                },
                {
                    "input": "3",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-159",
        "prompt": "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n*   Choosing any `x` with `0 < x < n` and `n % x == 0`.\n*   Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_."
    },
    "leetcode-benchmark-160": {
        "id": "leetcode-benchmark-160",
        "title": "Valid Boomerang",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return `true` _if these points are a **boomerang**_.\n\nA **boomerang** is a set of three points that are **all distinct** and **not in a straight line**.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,3\\],\\[3,2\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `points.length == 3`\n*   `points[i].length == 2`\n*   `0 <= xi, yi <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minKBitFlips(int[] nums, int k) {\n    int n = nums.length, res = 0, flipped = 0;\n    int[] change = new int[n];\n    for (int i = 0; i <= n - k; i++) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) {\n            res++;\n            flipped ^= 1;\n            if (i + k < n) change[i + k] ^= 1;\n        }\n    }\n    for (int i = n - k + 1; i < n; i++) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) return -1;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "c++": "\n    ```cpp\nint minKBitFlips(vector<int>& nums, int k) {\n    int n = nums.size(), res = 0, flipped = 0;\n    vector<int> change(n, 0);\n    for (int i = 0; i <= n - k; i++) {\n        flipped ^= change[i];\n        if (nums[i] ^ flipped == 0) {\n            res++;\n            flipped ^= 1;\n            if (i + k < n) change[i + k] ^= 1;\n        }\n    }\n    for (int i = n - k + 1; i < n; i++) {\n        flipped ^= change[i];\n        if (nums[i] ^ flipped == 0) return -1;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "python": "\n    ```python\ndef min_k_bit_flips(nums, k):\n    n, res, flipped = len(nums), 0, 0\n    change = [0] * n\n    for i in range(n - k + 1):\n        flipped ^= change[i]\n        if nums[i] == flipped:\n            res += 1\n            flipped ^= 1\n            if i + k < n:\n                change[i + k] ^= 1\n    for i in range(n - k + 1, n):\n        flipped ^= change[i]\n        if nums[i] == flipped:\n            return -1\n    return res\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "javascript": "\n    ```javascript\nfunction minKBitFlips(nums, k) {\n    const n = nums.length;\n    let res = 0, flipped = 0;\n    const change = new Array(n).fill(0);\n    for (let i = 0; i <= n - k; ++i) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) {\n            res++;\n            flipped ^= 1;\n            if (i + k < n) change[i + k] ^= 1;\n        }\n    }\n    for (let i = n - k + 1; i < n; ++i) {\n        flipped ^= change[i];\n        if (nums[i] == flipped) return -1;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm iterates through the array and uses a 'greedy' approach. It flips any subarray starting from the left-most index to ensure no zeroes are left in the array. \n\nTo minimize the number of flips, we only flip subarrays if it starts with a 0. We also keep track of previous flips using a separate array (`change`) to reduce redundant flips.\n\nIn the second loop, we check if any 0s are left in the remaining non-flipable part of the array. If so, return -1 as it's not possible to have an all 1s array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " points = [[1,1],[2,3],[3,2]]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " points = [[1,1],[2,2],[3,3]]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1],[2,3],[3,2]]",
                    "output": "True"
                },
                {
                    "input": "[[1,1],[2,2],[3,3]]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-160",
        "prompt": "Given an array `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return `true` _if these points are a **boomerang**_.\n\nA **boomerang** is a set of three points that are **all distinct** and **not in a straight line**."
    },
    "leetcode-benchmark-161": {
        "id": "leetcode-benchmark-161",
        "title": "Last Stone Weight",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the weight of the last remaining stone_. If there are no stones left, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** stones = \\[2,7,4,1,8,1\\]\n**Output:** 1\n**Explanation:** \nWe combine 7 and 8 to get 1 so the array converts to \\[2,4,1,1,1\\] then,\nwe combine 2 and 4 to get 2 so the array converts to \\[2,1,1,1\\] then,\nwe combine 2 and 1 to get 1 so the array converts to \\[1,1,1\\] then,\nwe combine 1 and 1 to get 0 so the array converts to \\[1\\] then that's the value of the last stone.\n\n",
                "**Example 2:**\n\n**Input:** stones = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= stones.length <= 30`\n*   `1 <= stones[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int longestOnes(int[] nums, int k) {\n    int left = 0, right = 0, maxOnes = 0, zeroCount = 0;\n    while (right < nums.length) {\n        if (nums[right] == 0) zeroCount++;\n        while (zeroCount > k) {\n            if (nums[left] == 0) zeroCount--;\n            left++;\n        }\n        maxOnes = Math.max(maxOnes, right - left + 1);\n        right++;\n    }\n    return maxOnes;\n}\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "c++": "\n    ```cpp\nint longestOnes(vector<int>& nums, int k) {\n    int left = 0, right = 0, maxOnes = 0, zeroCount = 0;\n    while (right < nums.size()) {\n        if (nums[right] == 0) zeroCount++;\n        while (zeroCount > k) {\n            if (nums[left] == 0) zeroCount--;\n            left++;\n        }\n        maxOnes = max(maxOnes, right - left + 1);\n        right++;\n    }\n    return maxOnes;\n}\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "python": "\n    ```python\ndef longestOnes(nums, k):\n    left, right, max_ones, zero_count = 0, 0, 0, 0\n    while right < len(nums):\n        if nums[right] == 0:\n            zero_count += 1\n        while zero_count > k:\n            if nums[left] == 0:\n                zero_count -= 1\n            left += 1\n        max_ones = max(max_ones, right - left + 1)\n        right += 1\n    return max_ones\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "javascript": "\n    ```javascript\nfunction longestOnes(nums, k) {\n    let left = 0, right = 0, maxOnes = 0, zeroCount = 0;\n    while (right < nums.length) {\n        if (nums[right] === 0) zeroCount++;\n        while (zeroCount > k) {\n            if (nums[left] === 0) zeroCount--;\n            left++;\n        }\n        maxOnes = Math.max(maxOnes, right - left + 1);\n        right++;\n    }\n    return maxOnes;\n}\n```\n\n    \n    The algorithm for this problem is a sliding window solution. We iterate through the array, and for each iteration, we check if the current element is a 0. If it is, we increment the zeroCount. If the zeroCount exceeds k, we move the left pointer of the sliding window forwards, checking if the element we are leaving is a 0, and decrementing the zeroCount accordingly. We then calculate and store the maximum consecutive 1's within the sliding window for each iteration, incrementing the right pointer of the sliding window at every step. Finally, we return the maximum consecutive 1's after iterating through the whole array. The algorithm focuses on processing the array in a single pass and adjusting window boundaries accordingly. Each language implementation follows this algorithm and uses similar variable names for convenience.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " stones = [2,7,4,1,8,1]",
                    "output": " 1",
                    "explanation": " \nWe combine 7 and 8 to get 1 so the array converts to \\[2,4,1,1,1\\] then,\nwe combine 2 and 4 to get 2 so the array converts to \\[2,1,1,1\\] then,\nwe combine 2 and 1 to get 1 so the array converts to \\[1,1,1\\] then,\nwe combine 1 and 1 to get 0 so the array converts to \\[1\\] then that's the value of the last stone."
                },
                {
                    "input": " stones = [1]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,7,4,1,8,1]",
                    "output": "1"
                },
                {
                    "input": "[1]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-161",
        "prompt": "You are given an array of integers `stones` where `stones[i]` is the weight of the `ith` stone.\n\nWe are playing a game with the stones. On each turn, we choose the **heaviest two stones** and smash them together. Suppose the heaviest two stones have weights `x` and `y` with `x <= y`. The result of this smash is:\n\n*   If `x == y`, both stones are destroyed, and\n*   If `x != y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nAt the end of the game, there is **at most one** stone left.\n\nReturn _the weight of the last remaining stone_. If there are no stones left, return `0`."
    },
    "leetcode-benchmark-162": {
        "id": "leetcode-benchmark-162",
        "title": "Height Checker",
        "difficulty": "Easy",
        "content": {
            "problem": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in **non-decreasing order** by height. Let this ordering be represented by the integer array `expected` where `expected[i]` is the expected height of the `ith` student in line.\n\nYou are given an integer array `heights` representing the **current order** that the students are standing in. Each `heights[i]` is the height of the `ith` student in line (**0-indexed**).\n\nReturn _the **number of indices** where_ `heights[i] != expected[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[1,1,4,2,1,3\\]\n**Output:** 3\n**Explanation:** \nheights:  \\[1,1,4,2,1,3\\]\nexpected: \\[1,1,1,2,3,4\\]\nIndices 2, 4, and 5 do not match.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[5,1,2,3,4\\]\n**Output:** 5\n**Explanation:**\nheights:  \\[5,1,2,3,4\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices do not match.\n\n",
                "**Example 3:**\n\n**Input:** heights = \\[1,2,3,4,5\\]\n**Output:** 0\n**Explanation:**\nheights:  \\[1,2,3,4,5\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices match."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 100`\n*   `1 <= heights[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int heightChecker(int[] heights) {\n    int[] expected = heights.clone();\n    Arrays.sort(expected);\n\n    int count = 0;\n    for (int i = 0; i < heights.length; ++i) {\n        if (heights[i] != expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> expected = heights;\n    std::sort(expected.begin(), expected.end());\n\n    int count = 0;\n    for (int i = 0; i < heights.size(); ++i) {\n        if (heights[i] != expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "python": "\n    ```python\ndef height_checker(heights):\n    expected = sorted(heights)\n    \n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n            \n    return count\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "javascript": "\n    ```javascript\nfunction heightChecker(heights) {\n    const expected = [...heights].sort((a, b) => a - b);\n\n    let count = 0;\n    for (let i = 0; i < heights.length; ++i) {\n        if (heights[i] !== expected[i]) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. Create a copy of the input array called expected.\n2. Sort the expected array in non-decreasing order.\n3. Initialize a counter variable called count to 0.\n4. Iterate through the input array with index i.\n  4.1. If the element at index i in the input array is not equal to the element at index i in the expected array, increment the count.\n5. Return the count.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " heights = [1,1,4,2,1,3]",
                    "output": " 3",
                    "explanation": " \nheights:  \\[1,1,4,2,1,3\\]\nexpected: \\[1,1,1,2,3,4\\]\nIndices 2, 4, and 5 do not match."
                },
                {
                    "input": " heights = [5,1,2,3,4]",
                    "output": " 5",
                    "explanation": "\nheights:  \\[5,1,2,3,4\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices do not match."
                },
                {
                    "input": " heights = [1,2,3,4,5]",
                    "output": " 0",
                    "explanation": "\nheights:  \\[1,2,3,4,5\\]\nexpected: \\[1,2,3,4,5\\]\nAll indices match."
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,4,2,1,3]",
                    "output": "3"
                },
                {
                    "input": "[5,1,2,3,4]",
                    "output": "5"
                },
                {
                    "input": "[1,2,3,4,5]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-162",
        "prompt": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in **non-decreasing order** by height. Let this ordering be represented by the integer array `expected` where `expected[i]` is the expected height of the `ith` student in line.\n\nYou are given an integer array `heights` representing the **current order** that the students are standing in. Each `heights[i]` is the height of the `ith` student in line (**0-indexed**).\n\nReturn _the **number of indices** where_ `heights[i] != expected[i]`."
    },
    "leetcode-benchmark-163": {
        "id": "leetcode-benchmark-163",
        "title": "Fixed Point",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array of distinct integers `arr`, where `arr` is sorted in **ascending order**, return the smallest index `i` that satisfies `arr[i] == i`. If there is no such index, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[-10,-5,0,3,7\\]\n**Output:** 3\n**Explanation:** For the given array, `arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3`, thus the output is 3.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[0,2,5,8,17\\]\n**Output:** 0\n**Explanation:** `arr[0] = 0`, thus the output is 0.\n\n",
                "**Example 3:**\n\n**Input:** arr = \\[-10,-5,3,4,7,9\\]\n**Output:** -1\n**Explanation:** There is no such `i` that `arr[i] == i`, thus the output is -1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length < 104`\n*   `-109 <= arr[i] <= 109`\n\n**",
            "follow_up": "Follow up:** The `O(n)` solution is very straightforward. Can we do better?"
        },
        "java": "\n    ```java\npublic int fixedPoint(int[] arr) {\n    int left = 0, right = arr.length - 1;\n    while (left < right) {\n        int middle = left + (right - left) / 2;\n        if (arr[middle] < middle) {\n            left = middle + 1;\n        } else {\n            right = middle;\n        }\n    }\n    return arr[left] == left ? left : -1;\n}\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "c++": "\n    ```cpp\nint fixedPoint(vector<int>& arr) {\n    int left = 0, right = arr.size() - 1;\n    while (left < right) {\n        int middle = left + (right - left) / 2;\n        if (arr[middle] < middle) {\n            left = middle + 1;\n        } else {\n            right = middle;\n        }\n    }\n    return arr[left] == left ? left : -1;\n}\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "python": "\n    ```python\ndef fixedPoint(arr: List[int]) -> int:\n    left, right = 0, len(arr) - 1\n    while left < right:\n        middle = left + (right - left) // 2\n        if arr[middle] < middle:\n            left = middle + 1\n        else:\n            right = middle\n    return left if arr[left] == left else -1\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "javascript": "\n    ```javascript\nfunction fixedPoint(arr) {\n    let left = 0, right = arr.length - 1;\n    while (left < right) {\n        let middle = left + Math.floor((right - left) / 2);\n        if (arr[middle] < middle) {\n            left = middle + 1;\n        } else {\n            right = middle;\n        }\n    }\n    return arr[left] === left ? left : -1;\n}\n```\n    \n    The algorithm uses binary search to efficiently find the fixed point in the sorted array of distinct integers. Since the array is sorted, when `arr[middle] < middle`, we can conclude that a fixed point (if exists) must be at `middle` or at the right side of `middle`, so we set `left` to `middle + 1`. In other cases, when `arr[middle] >= middle`, we set `right` to `middle`. This process continues until `left` < `right` is no longer true. \n\nAfter exiting the loop, we check if `arr[left]` is equal to `left`. If yes, we return `left` as the fixed point index, otherwise we return `-1`, as no fixed point exists.\n\nThe time complexity of the algorithm is O(log n), as we divide the search interval by half at each step.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [-10,-5,0,3,7]",
                    "output": " 3",
                    "explanation": " For the given array, `arr[0] = -10, arr[1] = -5, arr[2] = 0, arr[3] = 3`, thus the output is 3."
                },
                {
                    "input": " arr = [0,2,5,8,17]",
                    "output": " 0",
                    "explanation": " `arr[0] = 0`, thus the output is 0."
                },
                {
                    "input": " arr = [-10,-5,3,4,7,9]",
                    "output": " -1",
                    "explanation": " There is no such `i` that `arr[i] == i`, thus the output is -1."
                }
            ],
            "function_input": [
                {
                    "input": "[-10,-5,0,3,7]",
                    "output": "3"
                },
                {
                    "input": "[0,2,5,8,17]",
                    "output": "0"
                },
                {
                    "input": "[-10,-5,3,4,7,9]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-163",
        "prompt": "Given an array of distinct integers `arr`, where `arr` is sorted in **ascending order**, return the smallest index `i` that satisfies `arr[i] == i`. If there is no such index, return `-1`."
    },
    "leetcode-benchmark-164": {
        "id": "leetcode-benchmark-164",
        "title": "Index Pairs of a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `text` and an array of strings `words`, return _an array of all index pairs_ `[i, j]` _so that the substring_ `text[i...j]` _is in `words`_.\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate).",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"thestoryofleetcodeandme \", words = \\[ \"story \", \"fleet \", \"leetcode \"\\]\n**Output:** \\[\\[3,7\\],\\[9,13\\],\\[10,17\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** text =  \"ababa \", words = \\[ \"aba \", \"ab \"\\]\n**Output:** \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\]\\]\n**Explanation:** Notice that matches can overlap, see  \"aba \" is found in \\[0,2\\] and \\[2,4\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 100`\n*   `1 <= words.length <= 20`\n*   `1 <= words[i].length <= 50`\n*   `text` and `words[i]` consist of lowercase English letters.\n*   All the strings of `words` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean hasAllCodesInRange(String s, int n) {\n    Set<String> substrings = new HashSet<>();\n    int length = Integer.toBinaryString(n).length();\n    for (int i = 0; i < s.length() - length + 1; ++i) {\n        substrings.add(s.substring(i, i + length));\n    }\n    return substrings.size() == n;\n}\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "c++": "\n    ```cpp\nbool hasAllCodesInRange(const std::string& s, int n) {\n    std::unordered_set<std::string> substrings;\n    int length = std::to_string(n).length();\n    for (int i = 0; i < s.length() - length + 1; ++i) {\n        substrings.insert(s.substr(i, length));\n    }\n    return substrings.size() == n;\n}\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "python": "\n    ```python\ndef has_all_codes_in_range(s: str, n: int) -> bool:\n    substrings = set()\n    length = len(bin(n)) - 2\n    for i in range(len(s) - length + 1):\n        substrings.add(s[i:i + length])\n    return len(substrings) == n\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "javascript": "\n    ```javascript\nfunction hasAllCodesInRange(s, n) {\n    let substrings = new Set();\n    let length = n.toString(2).length;\n    for (let i = 0; i < s.length - length + 1; ++i) {\n        substrings.add(s.substr(i, length));\n    }\n    return substrings.size == n;\n}\n```\n\n    \n    1. Initialize an empty set called `substrings` to store unique binary substrings of length equal to the binary representation of `n`.\n2. Compute the length of the binary representation of `n` and store it in `length`.\n3. Loop through the binary string `s`, starting from index 0 to `len(s) - length`:\n   a. Extract the substring of `s` with length `length` starting at index `i`.\n   b. Add the extracted substring to the `substrings` set.\n4. Check if the size of `substrings` is equal to `n`. If it is, then all integers in the range `[1, n]` had their binary representation in `s`.\n5. Return the result (true if the size is equal to `n`, and false otherwise).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " text =  \"thestoryofleetcodeandme \", words = [ \"story \", \"fleet \", \"leetcode \"]",
                    "output": " [[3,7],[9,13],[10,17]]",
                    "explanation": null
                },
                {
                    "input": " text =  \"ababa \", words = [ \"aba \", \"ab \"]",
                    "output": " [[0,1],[0,2],[2,3],[2,4]]",
                    "explanation": " Notice that matches can overlap, see  \"aba \" is found in \\[0,2\\] and \\[2,4\\]."
                }
            ],
            "function_input": [
                {
                    "input": "\"thestoryofleetcodeandme\",[\"story\",\"fleet\",\"leetcode\"]",
                    "output": "[[3,7],[9,13],[10,17]]"
                },
                {
                    "input": "\"ababa\",[\"aba\",\"ab\"]",
                    "output": "[[0,1],[0,2],[2,3],[2,4]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-164",
        "prompt": "Given a string `text` and an array of strings `words`, return _an array of all index pairs_ `[i, j]` _so that the substring_ `text[i...j]` _is in `words`_.\n\nReturn the pairs `[i, j]` in sorted order (i.e., sort them by their first coordinate, and in case of ties sort them by their second coordinate)."
    },
    "leetcode-benchmark-165": {
        "id": "leetcode-benchmark-165",
        "title": "Greatest Common Divisor of Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "For two strings `s` and `t`, we say \"`t` divides `s` \" if and only if `s = t + ... + t` (i.e., `t` is concatenated with itself one or more times).\n\nGiven two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`.",
            "examples": [
                "**Example 1:**\n\n**Input:** str1 =  \"ABCABC \", str2 =  \"ABC \"\n**Output:**  \"ABC \"\n\n",
                "**Example 2:**\n\n**Input:** str1 =  \"ABABAB \", str2 =  \"ABAB \"\n**Output:**  \"AB \"\n\n",
                "**Example 3:**\n\n**Input:** str1 =  \"LEET \", str2 =  \"CODE \"\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= str1.length, str2.length <= 1000`\n*   `str1` and `str2` consist of English uppercase letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Boolean> prefixesDivBy5(int[] nums) {\n    List<Boolean> result = new ArrayList<>();\n    int current = 0;\n    for (int num : nums) {\n        current = ((current << 1) | num) % 5;\n        result.add(current == 0);\n    }\n    return result;\n}\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.###\n\nEnd ###\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<bool> prefixesDivBy5(std::vector<int>& nums) {\n    std::vector<bool> result;\n    int current = 0;\n    for (int num : nums) {\n        current = ((current << 1) | num) % 5;\n        result.push_back(current == 0);\n    }\n    return result;\n}\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.###\n\nEnd ###\n    ",
        "python": "\n    ```python\ndef prefixesDivBy5(nums):\n    result = []\n    current = 0\n    for num in nums:\n        current = ((current << 1) | num) % 5\n        result.append(current == 0)\n    return result\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.###\n\nEnd ###\n    ",
        "javascript": "\n    ```javascript\nfunction prefixesDivBy5(nums) {\n    let result = [];\n    let current = 0;\n    for (let num of nums) {\n        current = ((current << 1) | num) % 5;\n        result.push(current === 0);\n    }\n    return result;\n}\n```\n    \n    The problem requires to find out if the binary representation of the subarray from 0 to i is divisible by 5. To solve this, we can maintain an integer `current` that keeps track of the value of this binary representation modulo 5.\n\nIterate through the `nums` array, and, for each number in the array, update the running total `current` as follows:\n- Shift `current` one bit to the left (multiply by 2) using the bitwise left shift operator `<< 1`\n- Perform bitwise OR operation with the current number `num` to add it as the least significant bit to the binary representation\n- Compute this binary representation modulo 5\n\nAfter computing the current binary representation (modulo 5), check if it is divisible by 5. If it's divisible, then the value of `current` would be 0. Append the result (true or false) to the answer list or vector.\n\nFinally, return the resultant list of booleans.###\n\nEnd ###\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " str1 =  \"ABCABC \", str2 =  \"ABC \"",
                    "output": "  \"ABC \"",
                    "explanation": null
                },
                {
                    "input": " str1 =  \"ABABAB \", str2 =  \"ABAB \"",
                    "output": "  \"AB \"",
                    "explanation": null
                },
                {
                    "input": " str1 =  \"LEET \", str2 =  \"CODE \"",
                    "output": "  \" \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"ABCABC\",\"ABC\"",
                    "output": "\"ABC\""
                },
                {
                    "input": "\"ABABAB\",\"ABAB\"",
                    "output": "\"AB\""
                },
                {
                    "input": "\"LEET\",\"CODE\"",
                    "output": "\"\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-165",
        "prompt": "For two strings `s` and `t`, we say \"`t` divides `s` \" if and only if `s = t + ... + t` (i.e., `t` is concatenated with itself one or more times).\n\nGiven two strings `str1` and `str2`, return _the largest string_ `x` _such that_ `x` _divides both_ `str1` _and_ `str2`."
    },
    "leetcode-benchmark-166": {
        "id": "leetcode-benchmark-166",
        "title": "Occurrences After Bigram",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two strings `first` and `second`, consider occurrences in some text of the form `\"first second third \"`, where `second` comes immediately after `first`, and `third` comes immediately after `second`.\n\nReturn _an array of all the words_ `third` _for each occurrence of_ `\"first second third \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"\n**Output:** \\[\"girl\",\"student\"\\]\n\n",
                "**Example 2:**\n\n**Input:** text = \"we will we will rock you\", first = \"we\", second = \"will\"\n**Output:** \\[\"we\",\"rock\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 1000`\n*   `text` consists of lowercase English letters and spaces.\n*   All the words in `text` a separated by **a single space**.\n*   `1 <= first.length, second.length <= 10`\n*   `first` and `second` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String removeOuterParentheses(String s) {\n    StringBuilder result = new StringBuilder();\n    int opened = 0;\n\n    for (char c : s.toCharArray()) {\n        if (c == '(' && opened++ > 0) {\n            result.append(c);\n        }\n        if (c == ')' && opened-- > 1) {\n            result.append(c);\n        }\n    }\n    return result.toString();\n}\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string removeOuterParentheses(std::string s) {\n    std::string result;\n    int opened = 0;\n\n    for (char c : s) {\n        if (c == '(' && opened++ > 0) {\n            result += c;\n        }\n        if (c == ')' && opened-- > 1) {\n            result += c;\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "python": "\n    ```python\ndef remove_outer_parentheses(s: str) -> str:\n    result = []\n    opened = 0\n\n    for c in s:\n        if c == '(':\n            if opened > 0:\n                result.append(c)\n            opened += 1\n        elif c == ')':\n            if opened > 1:\n                result.append(c)\n            opened -= 1\n\n    return ''.join(result)\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "javascript": "\n    ```javascript\nfunction removeOuterParentheses(s) {\n    let result = \"\";\n    let opened = 0;\n\n    for (let c of s) {\n        if (c === '(' && opened++ > 0) {\n            result += c;\n        }\n        if (c === ')' && opened-- > 1) {\n            result += c;\n        }\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm is fairly simple. We will iterate through the given string `s`. For each character in the string, we will keep track of the count of open-parentheses encountered so far using the variable `opened`.\n\n- If we find an open-parenthesis `(`, and the value of `opened` is more than 0, we append it to the resulting string. Then, we increment the value of `opened`.\n- If we find a close-parenthesis `)`, and the value of `opened` is more than 1, we append it to the resulting string. Then, we decrement the value of `opened`.\n\nBy doing this, we effectively skip the outermost parentheses of each primitive valid parentheses string, as required by the problem while constructing the result string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\"",
                    "output": " [\"girl\",\"student\"]",
                    "explanation": null
                },
                {
                    "input": " text = \"we will we will rock you\", first = \"we\", second = \"will\"",
                    "output": " [\"we\",\"rock\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aliceisagoodgirlsheisagoodstudent\",\"a\",\"good\"",
                    "output": "[\"girl\",\"student\"]"
                },
                {
                    "input": "\"wewillwewillrockyou\",\"we\",\"will\"",
                    "output": "[\"we\",\"rock\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-166",
        "prompt": "Given two strings `first` and `second`, consider occurrences in some text of the form `\"first second third \"`, where `second` comes immediately after `first`, and `third` comes immediately after `second`.\n\nReturn _an array of all the words_ `third` _for each occurrence of_ `\"first second third \"`."
    },
    "leetcode-benchmark-167": {
        "id": "leetcode-benchmark-167",
        "title": "Sum of Digits in the Minimum Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return `0` _if the sum of the digits of the minimum integer in_ `nums` _is odd, or_ `1` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\]\n**Output:** 0\n**Explanation:** The minimal element is 1, and the sum of those digits is 1 which is odd, so the answer is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[99,77,33,66,55\\]\n**Output:** 1\n**Explanation:** The minimal element is 33, and the sum of those digits is 3 + 3 = 6 which is even, so the answer is 1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int sumOfDigits(int[] nums) {\n    int minVal = Arrays.stream(nums).min().getAsInt();\n    int digitSum = 0;\n    while (minVal > 0) {\n        digitSum += minVal % 10;\n        minVal /= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "c++": "\n    ```cpp\nint sumOfDigits(vector<int>& nums) {\n    int minVal = *min_element(nums.begin(), nums.end());\n    int digitSum = 0;\n    while (minVal > 0) {\n        digitSum += minVal % 10;\n        minVal /= 10;\n    }\n    return digitSum % 2 == 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "python": "\n    ```python\ndef sum_of_digits(nums):\n    min_val = min(nums)\n    digit_sum = sum(int(digit) for digit in str(min_val))\n    return 1 if digit_sum % 2 == 0 else 0\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "javascript": "\n    ```javascript\nfunction sumOfDigits(nums) {\n    const minVal = Math.min(...nums);\n    let digitSum = 0;\n    let temp = minVal;\n    while (temp > 0) {\n        digitSum += temp % 10;\n        temp = Math.floor(temp / 10);\n    }\n    return digitSum % 2 === 0 ? 1 : 0;\n}\n```\n\n    \n    1. Find the minimal element (`minVal`) of given array `nums`.\n2. Calculate the sum of the digits of the minimal element (`digitSum`).\n3. Check if the sum of the digits is odd or even.\n   - If it's even, return 1.\n   - If it's odd, return 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [34,23,1,24,75,33,54,8]",
                    "output": " 0",
                    "explanation": " The minimal element is 1, and the sum of those digits is 1 which is odd, so the answer is 0."
                },
                {
                    "input": " nums = [99,77,33,66,55]",
                    "output": " 1",
                    "explanation": " The minimal element is 33, and the sum of those digits is 3 + 3 = 6 which is even, so the answer is 1."
                }
            ],
            "function_input": [
                {
                    "input": "[34,23,1,24,75,33,54,8]",
                    "output": "0"
                },
                {
                    "input": "[99,77,33,66,55]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-167",
        "prompt": "Given an integer array `nums`, return `0` _if the sum of the digits of the minimum integer in_ `nums` _is odd, or_ `1` _otherwise_."
    },
    "leetcode-benchmark-168": {
        "id": "leetcode-benchmark-168",
        "title": "High Five",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a list of the scores of different students, `items`, where `items[i] = [IDi, scorei]` represents one score from a student with `IDi`, calculate each student's **top five average**.\n\nReturn _the answer as an array of pairs_ `result`_, where_ `result[j] = [IDj, topFiveAveragej]` _represents the student with_ `IDj` _and their **top five average**. Sort_ `result` _by_ `IDj` _in **increasing order**._\n\nA student's **top five average** is calculated by taking the sum of their top five scores and dividing it by `5` using **integer division**.",
            "examples": [
                "**Example 1:**\n\n**Input:** items = \\[\\[1,91\\],\\[1,92\\],\\[2,93\\],\\[2,97\\],\\[1,60\\],\\[2,77\\],\\[1,65\\],\\[1,87\\],\\[1,100\\],\\[2,100\\],\\[2,76\\]\\]\n**Output:** \\[\\[1,87\\],\\[2,88\\]\\]\n**Explanation:** \nThe student with ID = 1 got scores 91, 92, 60, 65, 87, and 100. Their top five average is (100 + 92 + 91 + 87 + 65) / 5 = 87.\nThe student with ID = 2 got scores 93, 97, 77, 100, and 76. Their top five average is (100 + 97 + 93 + 77 + 76) / 5 = 88.6, but with integer division their average converts to 88.\n\n",
                "**Example 2:**\n\n**Input:** items = \\[\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\],\\[1,100\\],\\[7,100\\]\\]\n**Output:** \\[\\[1,100\\],\\[7,100\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= items.length <= 1000`\n*   `items[i].length == 2`\n*   `1 <= IDi <= 1000`\n*   `0 <= scorei <= 100`\n*   For each `IDi`, there will be **at least** five scores.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean aliceWin(int n) {\n    return n % 2 == 0;\n}\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "c++": "\n    ```cpp\nbool aliceWin(int n) {\n    return n % 2 == 0;\n}\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "python": "\n    ```python\ndef alice_win(n):\n    return n % 2 == 0\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "javascript": "\n    ```javascript\nfunction aliceWin(n) {\n    return n % 2 === 0;\n}\n```\n\n    \n    The game is a simple parity-based game, where Alice and Bob alternately change the number on the board. Since Alice goes first, if the number on the board is even initially, Alice has the opportunity to make a move and maintain the even number status of the board. If Alice and Bob are playing optimally, they will always choose a number that is a divisor of the current number by 2, to guarantee they leave an even number on the board. In this way, the parity of the number on the board never changes.\n\nSo, when the number becomes 1, the player whose turn it is will lose, as they cannot choose a divisor of the current number that is less than the current number. Since the number remains even throughout the game, if it starts as an even number, Alice will always win; if it starts as an odd number, Bob will always win. The algorithm simply checks if the given number is even and returns true if Alice wins, and false otherwise. The code implementations for each language perform the modulo operation `%` to check if the given number is even.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " items = [[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]",
                    "output": " [[1,87],[2,88]]",
                    "explanation": " \nThe student with ID = 1 got scores 91, 92, 60, 65, 87, and 100. Their top five average is (100 + 92 + 91 + 87 + 65) / 5 = 87.\nThe student with ID = 2 got scores 93, 97, 77, 100, and 76. Their top five average is (100 + 97 + 93 + 77 + 76) / 5 = 88.6, but with integer division their average converts to 88."
                },
                {
                    "input": " items = [[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100]]",
                    "output": " [[1,100],[7,100]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,91],[1,92],[2,93],[2,97],[1,60],[2,77],[1,65],[1,87],[1,100],[2,100],[2,76]]",
                    "output": "[[1,87],[2,88]]"
                },
                {
                    "input": "[[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100],[1,100],[7,100]]",
                    "output": "[[1,100],[7,100]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-168",
        "prompt": "Given a list of the scores of different students, `items`, where `items[i] = [IDi, scorei]` represents one score from a student with `IDi`, calculate each student's **top five average**.\n\nReturn _the answer as an array of pairs_ `result`_, where_ `result[j] = [IDj, topFiveAveragej]` _represents the student with_ `IDj` _and their **top five average**. Sort_ `result` _by_ `IDj` _in **increasing order**._\n\nA student's **top five average** is calculated by taking the sum of their top five scores and dividing it by `5` using **integer division**."
    },
    "leetcode-benchmark-169": {
        "id": "leetcode-benchmark-169",
        "title": "Duplicate Zeros",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a fixed-length integer array `arr`, duplicate each occurrence of zero, shifting the remaining elements to the right.\n\n**Note** that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[1,0,2,3,0,4,5,0\\]\n**Output:** \\[1,0,0,2,3,0,0,4\\]\n**Explanation:** After calling your function, the input array is modified to: \\[1,0,0,2,3,0,0,4\\]\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,2,3\\]\n**Output:** \\[1,2,3\\]\n**Explanation:** After calling your function, the input array is modified to: \\[1,2,3\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 9`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void duplicateZeros(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] == 0) {\n            for (int j = n - 1; j > i + 1; --j) {\n                arr[j] = arr[j - 1];\n            }\n            arr[++i] = 0;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "c++": "\n    ```cpp\nvoid duplicateZeros(vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; ++i) {\n        if (arr[i] == 0) {\n            for (int j = n - 1; j > i + 1; --j) {\n                arr[j] = arr[j - 1];\n            }\n            arr[++i] = 0;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "python": "\n    ```python\ndef duplicateZeros(arr):\n    n = len(arr)\n    i = 0\n    while i < n - 1:\n        if arr[i] == 0:\n            for j in range(n - 1, i + 1, -1):\n                arr[j] = arr[j - 1]\n            arr[i + 1] = 0\n            i += 1\n        i += 1\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "javascript": "\n    ```javascript\nfunction duplicateZeros(arr) {\n    const n = arr.length;\n    for (let i = 0; i < n - 1; ++i) {\n        if (arr[i] === 0) {\n            for (let j = n - 1; j > i + 1; --j) {\n                arr[j] = arr[j - 1];\n            }\n            arr[++i] = 0;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the input array `arr`. When a zero is encountered at position `i`, a second for loop or equivalent control structure (`for`, `while`, or `range` depending on the language) is used to shift all elements at positions greater than `i` to the right by one. The element at position `i + 1` is then set to zero, and the iterator `i` is incremented to skip the newly added zero. This process is repeated until the end of the array is reached, ensuring that consecutive zeros are processed correctly.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [1,0,2,3,0,4,5,0]",
                    "output": " [1,0,0,2,3,0,0,4]",
                    "explanation": " After calling your function, the input array is modified to: \\[1,0,0,2,3,0,0,4\\]"
                },
                {
                    "input": " arr = [1,2,3]",
                    "output": " [1,2,3]",
                    "explanation": " After calling your function, the input array is modified to: \\[1,2,3\\]"
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,2,3,0,4,5,0]",
                    "output": "[1,0,0,2,3,0,0,4]"
                },
                {
                    "input": "[1,2,3]",
                    "output": "[1,2,3]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-169",
        "prompt": "Given a fixed-length integer array `arr`, duplicate each occurrence of zero, shifting the remaining elements to the right.\n\n**Note** that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything."
    },
    "leetcode-benchmark-170": {
        "id": "leetcode-benchmark-170",
        "title": "Two Sum Less Than K",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[34,23,1,24,75,33,54,8\\], k = 60\n**Output:** 58\n**Explanation:** We can use 34 and 24 to sum 58 which is less than 60.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,20,30\\], k = 15\n**Output:** -1\n**Explanation:** In this case it is not possible to get a pair sum less that 15."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `1 <= nums[i] <= 1000`\n*   `1 <= k <= 2000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxSumUnderK(int[] nums, int k) {\n    int maxSum = -1;\n    for (int i = 0; i < nums.length; i++) {\n        for (int j = i + 1; j < nums.length; j++) {\n            int sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "c++": "\n    ```cpp\nint maxSumUnderK(vector<int>& nums, int k) {\n    int maxSum = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            int sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "python": "\n    ```python\ndef max_sum_under_k(nums, k):\n    max_sum = -1\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            _sum = nums[i] + nums[j]\n            if _sum < k and _sum > max_sum:\n                max_sum = _sum\n    return max_sum\n```\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "javascript": "\n    ```javascript\nfunction maxSumUnderK(nums, k) {\n    let maxSum = -1;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            let sum = nums[i] + nums[j];\n            if (sum < k && sum > maxSum) {\n                maxSum = sum;\n            }\n        }\n    }\n    return maxSum;\n}\n```\n\n    \n    The algorithm contains two nested loops, iterating through all possible combinations of indices `i` and `j` (with `j > i`). For each combination of `i` and `j`, the function calculates the sum of `nums[i]` and `nums[j]`. If the sum is less than `k` and greater than the current `maxSum`, the function updates `maxSum` with the new sum. Finally, the function returns the maximum sum found during the iterations. If no suitable sum was found, the function returns `-1`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [34,23,1,24,75,33,54,8], k = 60",
                    "output": " 58",
                    "explanation": " We can use 34 and 24 to sum 58 which is less than 60."
                },
                {
                    "input": " nums = [10,20,30], k = 15",
                    "output": " -1",
                    "explanation": " In this case it is not possible to get a pair sum less that 15."
                }
            ],
            "function_input": [
                {
                    "input": "[34,23,1,24,75,33,54,8],60",
                    "output": "58"
                },
                {
                    "input": "[10,20,30],15",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-170",
        "prompt": "Given an array `nums` of integers and integer `k`, return the maximum `sum` such that there exists `i < j` with `nums[i] + nums[j] = sum` and `sum < k`. If no `i`, `j` exist satisfying this equation, return `-1`."
    },
    "leetcode-benchmark-171": {
        "id": "leetcode-benchmark-171",
        "title": "Distribute Candies to People",
        "difficulty": "Easy",
        "content": {
            "problem": "We distribute some number of `candies`, to a row of **`n = num_people`** people in the following way:\n\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give `n` candies to the last person.\n\nThen, we go back to the start of the row, giving `n + 1` candies to the first person, `n + 2` candies to the second person, and so on until we give `2 * n` candies to the last person.\n\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\n\nReturn an array (of length `num_people` and sum `candies`) that represents the final distribution of candies.",
            "examples": [
                "**Example 1:**\n\n**Input:** candies = 7, num\\_people = 4\n**Output:** \\[1,2,3,1\\]\n**Explanation:**\nOn the first turn, ans\\[0\\] += 1, and the array is \\[1,0,0,0\\].\nOn the second turn, ans\\[1\\] += 2, and the array is \\[1,2,0,0\\].\nOn the third turn, ans\\[2\\] += 3, and the array is \\[1,2,3,0\\].\nOn the fourth turn, ans\\[3\\] += 1 (because there is only one candy left), and the final array is \\[1,2,3,1\\].\n\n",
                "**Example 2:**\n\n**Input:** candies = 10, num\\_people = 3\n**Output:** \\[5,2,3\\]\n**Explanation:** \nOn the first turn, ans\\[0\\] += 1, and the array is \\[1,0,0\\].\nOn the second turn, ans\\[1\\] += 2, and the array is \\[1,2,0\\].\nOn the third turn, ans\\[2\\] += 3, and the array is \\[1,2,3\\].\nOn the fourth turn, ans\\[0\\] += 4, and the final array is \\[5,2,3\\]."
            ],
            "constraints": "**Constraints:**\n\n*   1 <= candies <= 10^9\n*   1 <= num\\_people <= 1000",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] distributeCandies(int candies, int num_people) {\n    int[] result = new int[num_people];\n    int i = 0, count = 1;\n\n    while (candies > 0) {\n        result[i % num_people] += Math.min(candies, count);\n        candies -= count;\n        count++;\n        i++;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> distributeCandies(int candies, int num_people) {\n    std::vector<int> result(num_people, 0);\n    int i = 0, count = 1;\n\n    while (candies > 0) {\n        result[i % num_people] += std::min(candies, count);\n        candies -= count;\n        count++;\n        i++;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "python": "\n    ```python\ndef distribute_candies(candies, num_people):\n    result = [0] * num_people\n    i = 0\n    count = 1\n\n    while candies > 0:\n        result[i % num_people] += min(candies, count)\n        candies -= count\n        count += 1\n        i += 1\n\n    return result\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "javascript": "\n    ```javascript\nfunction distributeCandies(candies, num_people) {\n    const result = new Array(num_people).fill(0);\n    let i = 0, count = 1;\n\n    while (candies > 0) {\n        result[i % num_people] += Math.min(candies, count);\n        candies -= count;\n        count++;\n        i++;\n    }\n\n    return result;\n}\n```\n\n    \n    The algorithm proceeds as follows:\n\n1. Initialize an array `result` of length `num_people` with 0's.\n2. Initialize two variables `i` and `count`, both with value 0. `i` will iterate through the people and `count` will store how many candies should be given at each step.\n3. Loop until there are no more `candies` left.\n    1. To distribute `candies` among people:\n        - If the remaining `candies` are more than the current `count`, give `count` candies to the current person.\n        - If the remaining `candies` are less than or equal to the current `count`, give the remaining `candies` to the current person and stop the loop.\n    2. Update the remaining `candies` by subtracting the current `count`.\n    3. Increment the current `count` and `i`.\n4. After the loop, return the `result` array as the final distribution of candies.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " candies = 7, num_people = 4",
                    "output": " [1,2,3,1]",
                    "explanation": "\nOn the first turn, ans\\[0\\] += 1, and the array is \\[1,0,0,0\\].\nOn the second turn, ans\\[1\\] += 2, and the array is \\[1,2,0,0\\].\nOn the third turn, ans\\[2\\] += 3, and the array is \\[1,2,3,0\\].\nOn the fourth turn, ans\\[3\\] += 1 (because there is only one candy left), and the final array is \\[1,2,3,1\\]."
                },
                {
                    "input": " candies = 10, num_people = 3",
                    "output": " [5,2,3]",
                    "explanation": " \nOn the first turn, ans\\[0\\] += 1, and the array is \\[1,0,0\\].\nOn the second turn, ans\\[1\\] += 2, and the array is \\[1,2,0\\].\nOn the third turn, ans\\[2\\] += 3, and the array is \\[1,2,3\\].\nOn the fourth turn, ans\\[0\\] += 4, and the final array is \\[5,2,3\\]."
                }
            ],
            "function_input": [
                {
                    "input": "7,4",
                    "output": "[1,2,3,1]"
                },
                {
                    "input": "10,3",
                    "output": "[5,2,3]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-171",
        "prompt": "We distribute some number of `candies`, to a row of **`n = num_people`** people in the following way:\n\nWe then give 1 candy to the first person, 2 candies to the second person, and so on until we give `n` candies to the last person.\n\nThen, we go back to the start of the row, giving `n + 1` candies to the first person, `n + 2` candies to the second person, and so on until we give `2 * n` candies to the last person.\n\nThis process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift).\n\nReturn an array (of length `num_people` and sum `candies`) that represents the final distribution of candies."
    },
    "leetcode-benchmark-172": {
        "id": "leetcode-benchmark-172",
        "title": "Defanging an IP Address",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a valid (IPv4) IP `address`, return a defanged version of that IP address.\n\nA _defanged IP address_ replaces every period `\". \"` with `\"[.] \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** address = \"1.1.1.1\"\n**Output:** \"1\\[.\\]1\\[.\\]1\\[.\\]1\"\n\n",
                "**Example 2:**\n\n**Input:** address = \"255.100.50.0\"\n**Output:** \"255\\[.\\]100\\[.\\]50\\[.\\]0\""
            ],
            "constraints": "**Constraints:**\n\n*   The given `address` is a valid IPv4 address.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String defangIPaddr(String address) {\n    StringBuilder defanged = new StringBuilder();\n    for (char c : address.toCharArray()) {\n        if (c == '.')\n            defanged.append(\"[.]\");\n        else\n            defanged.append(c);\n    }\n    return defanged.toString();\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring defangIPaddr(string address) {\n    string defanged = \"\";\n    for (char c : address) {\n        if (c == '.')\n            defanged += \"[.]\";\n        else\n            defanged += c;\n    }\n    return defanged;\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "python": "\n    ```python\ndef defangIPaddr(address: str) -> str:\n    return address.replace('.', '[.]')\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "javascript": "\n    ```javascript\nfunction defangIPaddr(address) {\n    return address.split('.').join('[.]');\n}\n```\n    \n    The function for each language takes an input address, which is a valid IPv4 address. It iterates through each character of the string, checking for a period ('.'). If a period is found, we replace it with \"[.]\" in the resulting string. For other characters, we just add them to the resulting string.\n\nIn C++, Java, and JavaScript, we iterate over each character using a for loop, appending the processed character to a string object or a StringBuilder object. Java uses a StringBuilder object for more efficient string concatenation.\n\nIn Python, we can directly use the string method `replace()` to replace all occurrences of the period with \"[.]\" in a more concise way.\n\nAt the end of the function, we return the defanged IP address as string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " address = \"1.1.1.1\"",
                    "output": " \"1[.]1[.]1[.]1\"",
                    "explanation": null
                },
                {
                    "input": " address = \"255.100.50.0\"",
                    "output": " \"255[.]100[.]50[.]0\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"1.1.1.1\"",
                    "output": "\"1[.]1[.]1[.]1\""
                },
                {
                    "input": "\"255.100.50.0\"",
                    "output": "\"255[.]100[.]50[.]0\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-172",
        "prompt": "Given a valid (IPv4) IP `address`, return a defanged version of that IP address.\n\nA _defanged IP address_ replaces every period `\". \"` with `\"[.] \"`."
    },
    "leetcode-benchmark-173": {
        "id": "leetcode-benchmark-173",
        "title": "Number of Days in a Month",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a year `year` and a month `month`, return _the number of days of that month_.",
            "examples": [
                "**Example 1:**\n\n**Input:** year = 1992, month = 7\n**Output:** 31\n\n",
                "**Example 2:**\n\n**Input:** year = 2000, month = 2\n**Output:** 29\n\n",
                "**Example 3:**\n\n**Input:** year = 1900, month = 2\n**Output:** 28"
            ],
            "constraints": "**Constraints:**\n\n*   `1583 <= year <= 2100`\n*   `1 <= month <= 12`",
            "follow_up": ""
        },
        "java": "\n    ```java\nint numberOfDays(int year, int month) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "c++": "\n    ```cpp\nint numberOfDays(int year, int month) {\n    if(month == 2) {\n        if((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if(month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "python": "\n    ```python\ndef number_of_days(year, month):\n    if month == 2:\n        if (year % 4 == 0 and year % 100 != 0) or year % 400 == 0:\n            return 29\n        return 28\n    if month in [4, 6, 9, 11]:\n        return 30\n    return 31\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "javascript": "\n    ```javascript\nfunction numberOfDays(year, month) {\n    if (month == 2) {\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n            return 29;\n        return 28;\n    }\n    if (month == 4 || month == 6 || month == 9 || month == 11)\n        return 30;\n    return 31;\n}\n```\n    \n    The algorithm first checks if the given month is February. If it is, then it determines if the given year is a leap year. A leap year is a year that is divisible by 4 and not divisible by 100, or divisible by 400. If it is a leap year, it returns 29 as the number of days in February; otherwise, it returns 28.\n\nIf the given month is April, June, September, or November, the algorithm returns 30 as the number of days in that month. For all other months (January, March, May, July, August, October, and December), the algorithm returns 31 as the number of days in that month.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " year = 1992, month = 7",
                    "output": " 31",
                    "explanation": null
                },
                {
                    "input": " year = 2000, month = 2",
                    "output": " 29",
                    "explanation": null
                },
                {
                    "input": " year = 1900, month = 2",
                    "output": " 28",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1992,7",
                    "output": "31"
                },
                {
                    "input": "2000,2",
                    "output": "29"
                },
                {
                    "input": "1900,2",
                    "output": "28"
                }
            ]
        },
        "task_id": "leetcode-benchmark-173",
        "prompt": "Given a year `year` and a month `month`, return _the number of days of that month_."
    },
    "leetcode-benchmark-174": {
        "id": "leetcode-benchmark-174",
        "title": "Remove Vowels from a String",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, remove the vowels `'a'`, `'e'`, `'i'`, `'o'`, and `'u'` from it, and return the new string.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leetcodeisacommunityforcoders \"\n**Output:**  \"ltcdscmmntyfrcdrs \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aeiou \"\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isRobotBounded(String instructions) {\n    int x = 0, y = 0, dir = 0;\n    int[][] moves = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (char c : instructions.toCharArray()) {\n        if (c == 'G') {\n            x += moves[dir][0];\n            y += moves[dir][1];\n        } else if (c == 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n\n    return (x == 0 && y == 0) || dir != 0;\n}\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "c++": "\n    ```cpp\nbool isRobotBounded(string instructions) {\n    int x = 0, y = 0, dir = 0;\n    vector<vector<int>> moves {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    for (char c : instructions) {\n        if (c == 'G') {\n            x += moves[dir][0];\n            y += moves[dir][1];\n        } else if (c == 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n\n    return (x == 0 && y == 0) || dir != 0;\n}\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "python": "\n    ```python\ndef is_robot_bounded(instructions: str) -> bool:\n    x, y, dir = 0, 0, 0\n    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for c in instructions:\n        if c == 'G':\n            x += moves[dir][0]\n            y += moves[dir][1]\n        elif c == 'L':\n            dir = (dir + 3) % 4\n        else:\n            dir = (dir + 1) % 4\n\n    return (x == 0 and y == 0) or dir != 0\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "javascript": "\n    ```javascript\nfunction isRobotBounded(instructions) {\n    let x = 0, y = 0, dir = 0;\n    const moves = [[0, 1], [1, 0], [0, -1], [-1, 0]];\n\n    for (const c of instructions) {\n        if (c === 'G') {\n            x += moves[dir][0];\n            y += moves[dir][1];\n        } else if (c === 'L') {\n            dir = (dir + 3) % 4;\n        } else {\n            dir = (dir + 1) % 4;\n        }\n    }\n\n    return (x === 0 && y === 0) || dir !== 0;\n}\n```\n    \n    1. Initialize (x, y) as the robot's initial position and direction as dir (0: north, 1: east, 2: south, 3: west).\n2. Declare an array moves, which represents the movement in the x and y directions when going straight.\n3. Iterate through instructions:\n    - If the instruction is 'G', update x and y based on the current direction.\n    - If the instruction is 'L', update dir as (dir + 3) % 4 to turn left (counter-clockwise).\n    - If the instruction is 'R', update dir as (dir + 1) % 4 to turn right (clockwise).\n4. If the robot reaches the starting position (0,0) or its direction is not north (dir != 0), then it stays in a circle. Otherwise, it doesn't.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"leetcodeisacommunityforcoders \"",
                    "output": "  \"ltcdscmmntyfrcdrs \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"aeiou \"",
                    "output": "  \" \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"leetcodeisacommunityforcoders\"",
                    "output": "\"ltcdscmmntyfrcdrs\""
                },
                {
                    "input": "\"aeiou\"",
                    "output": "\"\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-174",
        "prompt": "Given a string `s`, remove the vowels `'a'`, `'e'`, `'i'`, `'o'`, and `'u'` from it, and return the new string."
    },
    "leetcode-benchmark-175": {
        "id": "leetcode-benchmark-175",
        "title": "Relative Sort Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n\nSort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that do not appear in `arr2` should be placed at the end of `arr1` in **ascending** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[2,3,1,3,2,4,6,7,9,2,19\\], arr2 = \\[2,1,4,3,9,6\\]\n**Output:** \\[2,2,2,1,4,3,3,9,6,7,19\\]\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[28,6,22,8,44,17\\], arr2 = \\[22,28,8,6\\]\n**Output:** \\[22,28,8,6,17,44\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length <= 1000`\n*   `0 <= arr1[i], arr2[i] <= 1000`\n*   All the elements of `arr2` are **distinct**.\n*   Each `arr2[i]` is in `arr1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String longestDupSubstring(String s) {\n    int n = s.length();\n    String longest_duplicate = \"\";\n    for (int length = n - 1; length > 0; --length) {\n        for (int i = 0; i <= n - length; ++i) {\n            String substring = s.substring(i, i + length);\n            if (s.indexOf(substring, i + 1) != -1) {\n                longest_duplicate = substring;\n                return longest_duplicate;\n            }\n        }\n    }\n    return longest_duplicate;\n}\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string longestDupSubstring(std::string s) {\n    int n = s.length();\n    std::string longest_duplicate;\n    for (int length = n - 1; length > 0; --length) {\n        for (int i = 0; i <= n - length; ++i) {\n            std::string substring = s.substr(i, length);\n            if (s.find(substring, i + 1) != std::string::npos) {\n                longest_duplicate = substring;\n                return longest_duplicate;\n            }\n        }\n    }\n    return longest_duplicate;\n}\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "python": "\n    ```python\ndef longest_dup_substring(s):\n    n = len(s)\n    longest_duplicate = \"\"\n    for length in range(n - 1, 0, -1):\n        for i in range(n - length + 1):\n            substring = s[i:i + length]\n            if s.find(substring, i + 1) != -1:\n                longest_duplicate = substring\n                return longest_duplicate\n    return longest_duplicate\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "javascript": "\n    ```javascript\nfunction longestDupSubstring(s) {\n    const n = s.length;\n    let longest_duplicate = \"\";\n    for (let length = n - 1; length > 0; --length) {\n        for (let i = 0; i <= n - length; ++i) {\n            const substring = s.substring(i, i + length);\n            if (s.indexOf(substring, i + 1) !== -1) {\n                longest_duplicate = substring;\n                return longest_duplicate;\n            }\n        }\n    }\n    return longest_duplicate;\n}\n```\n\n    \n    The algorithm starts with defining the longest possible duplicate string length which is the length of the input string minus one. Then, we iterate through all possible substring lengths from the longest to the shortest.\n\nFor each substring length, we iterate through the input string to check if there's a duplicate substring. We obtain a substring with the starting position `i` and the current length, then find if there's another occurrence of this substring in the input string. If there's one, we return the current substring as the longest duplicate substring.\n\nIf we finish iterating through all possible substring lengths without finding any duplicate substrings, we return an empty string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]",
                    "output": " [2,2,2,1,4,3,3,9,6,7,19]",
                    "explanation": null
                },
                {
                    "input": " arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]",
                    "output": " [22,28,8,6,17,44]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,1,3,2,4,6,7,9,2,19],[2,1,4,3,9,6]",
                    "output": "[2,2,2,1,4,3,3,9,6,7,19]"
                },
                {
                    "input": "[28,6,22,8,44,17],[22,28,8,6]",
                    "output": "[22,28,8,6,17,44]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-175",
        "prompt": "Given two arrays `arr1` and `arr2`, the elements of `arr2` are distinct, and all elements in `arr2` are also in `arr1`.\n\nSort the elements of `arr1` such that the relative ordering of items in `arr1` are the same as in `arr2`. Elements that do not appear in `arr2` should be placed at the end of `arr1` in **ascending** order."
    },
    "leetcode-benchmark-176": {
        "id": "leetcode-benchmark-176",
        "title": "Number of Equivalent Domino Pairs",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a list of `dominoes`, `dominoes[i] = [a, b]` is **equivalent to** `dominoes[j] = [c, d]` if and only if either (`a == c` and `b == d`), or (`a == d` and `b == c`) - that is, one domino can be rotated to be equal to another domino.\n\nReturn _the number of pairs_ `(i, j)` _for which_ `0 <= i < j < dominoes.length`_, and_ `dominoes[i]` _is **equivalent to**_ `dominoes[j]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** dominoes = \\[\\[1,2\\],\\[2,1\\],\\[3,4\\],\\[5,6\\]\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** dominoes = \\[\\[1,2\\],\\[1,2\\],\\[1,1\\],\\[1,2\\],\\[2,2\\]\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= dominoes.length <= 4 * 104`\n*   `dominoes[i].length == 2`\n*   `1 <= dominoes[i][j] <= 9`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String removeDuplicates(String s) {\n    StringBuilder sb = new StringBuilder();\n    for (char c : s.toCharArray()) {\n        if (sb.length() > 0 && sb.charAt(sb.length() - 1) == c) {\n            sb.setLength(sb.length() - 1);\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string removeDuplicates(std::string s) {\n    std::stack<char> st;\n    for (char c : s) {\n        if (!st.empty() && st.top() == c) {\n            st.pop();\n        } else {\n            st.push(c);\n        }\n    }\n    \n    std::string result;\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "python": "\n    ```python\ndef remove_duplicates(s: str) -> str:\n    stack = []\n    for c in s:\n        if stack and stack[-1] == c:\n            stack.pop()\n        else:\n            stack.append(c)\n    return \"\".join(stack)\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "javascript": "\n    ```javascript\nfunction removeDuplicates(s) {\n    const stack = [];\n    for (const c of s) {\n        if (stack.length > 0 && stack[stack.length - 1] === c) {\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n    return stack.join('');\n}\n```\n    \n    The algorithm uses a stack data structure to process the input string 's'. Iterate through the string from left to right, if the current character 'c' is equal to the character at the top of the stack, pop the character from the top of the stack, otherwise, push the current character onto the stack.\n\nAfter processing the entire string 's', the stack will contain the characters left after all the duplicate removals. Then, convert the stack to the resulting string in the respective language (in C++, Java, and JavaScript, we convert the stack to a string by iterating through it, and in Python, we use the built-in join function).\n\nThe time complexity of the algorithm is O(n), where n is the length of the input string 's', and the space complexity is O(n) considering the stack that can be as big as the input string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " dominoes = [[1,2],[2,1],[3,4],[5,6]]",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[2,1],[3,4],[5,6]]",
                    "output": "1"
                },
                {
                    "input": "[[1,2],[1,2],[1,1],[1,2],[2,2]]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-176",
        "prompt": "Given a list of `dominoes`, `dominoes[i] = [a, b]` is **equivalent to** `dominoes[j] = [c, d]` if and only if either (`a == c` and `b == d`), or (`a == d` and `b == c`) - that is, one domino can be rotated to be equal to another domino.\n\nReturn _the number of pairs_ `(i, j)` _for which_ `0 <= i < j < dominoes.length`_, and_ `dominoes[i]` _is **equivalent to**_ `dominoes[j]`."
    },
    "leetcode-benchmark-177": {
        "id": "leetcode-benchmark-177",
        "title": "Largest Unique Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums`, return _the largest integer that only occurs once_. If no integer occurs once, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,7,3,9,4,9,8,3,1\\]\n**Output:** 8\n**Explanation:** The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it is the answer.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9,9,8,8\\]\n**Output:** -1\n**Explanation:** There is no number that occurs only once."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2000`\n*   `0 <= nums[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\nString lastSubstring(String s) {\n    int i = 0, j = 1, k = 0, n = s.length();\n    while (j + k < n) {\n        if (s.charAt(i + k) == s.charAt(j + k)) {\n            k++;\n        } else if (s.charAt(i + k) < s.charAt(j + k)) {\n            i = j;\n            j++;\n            k = 0;\n        } else {\n            j++;\n            k = 0;\n        }\n    }\n    return s.substring(i);\n}\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "c++": "\n    ```cpp\nstd::string lastSubstring(std::string s) {\n    int i = 0, j = 1, k = 0, n = s.length();\n    while (j + k < n) {\n        if (s[i + k] == s[j + k]) {\n            k++;\n        } else if (s[i + k] < s[j + k]) {\n            i = j;\n            j++;\n            k = 0;\n        } else {\n            j++;\n            k = 0;\n        }\n    }\n    return s.substr(i);\n}\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "python": "\n    ```python\ndef last_substring(s: str) -> str:\n    i, j, k, n = 0, 1, 0, len(s)\n    while j + k < n:\n        if s[i + k] == s[j + k]:\n            k += 1\n        elif s[i + k] < s[j + k]:\n            i = j\n            j += 1\n            k = 0\n        else:\n            j += 1\n            k = 0\n    return s[i:]\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "javascript": "\n    ```javascript\nfunction lastSubstring(s) {\n    let i = 0, j = 1, k = 0, n = s.length;\n    while (j + k < n) {\n        if (s.charAt(i + k) === s.charAt(j + k)) {\n            k++;\n        } else if (s.charAt(i + k) < s.charAt(j + k)) {\n            i = j;\n            j++;\n            k = 0;\n        } else {\n            j++;\n            k = 0;\n        }\n    }\n    return s.substring(i);\n}\n```\n    \n    Iterate through the string using three pointers i, j, and k. At each step, compare s[i+k] and s[j+k]. If s[i+k] < s[j+k], set i=j and increment j. If s[i+k] == s[j+k], increment k to continue comparing the next characters. If s[i+k] > s[j+k], just increment j. When j+k reaches the end of the string, the last substring in lexicographical order will start at index i.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [5,7,3,9,4,9,8,3,1]",
                    "output": " 8",
                    "explanation": " The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it is the answer."
                },
                {
                    "input": " nums = [9,9,8,8]",
                    "output": " -1",
                    "explanation": " There is no number that occurs only once."
                }
            ],
            "function_input": [
                {
                    "input": "[5,7,3,9,4,9,8,3,1]",
                    "output": "8"
                },
                {
                    "input": "[9,9,8,8]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-177",
        "prompt": "Given an integer array `nums`, return _the largest integer that only occurs once_. If no integer occurs once, return `-1`."
    },
    "leetcode-benchmark-178": {
        "id": "leetcode-benchmark-178",
        "title": "Armstrong Number",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer `n`, return `true` _if and only if it is an **Armstrong number**_.\n\nThe `k`\\-digit number `n` is an Armstrong number if and only if the `kth` power of each digit sums to `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 153\n**Output:** true\n**Explanation:** 153 is a 3-digit number, and 153 = 13 + 53 + 33.\n\n",
                "**Example 2:**\n\n**Input:** n = 123\n**Output:** false\n**Explanation:** 123 is a 3-digit number, and 123 != 13 + 23 + 33 = 36."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 108`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isArmstrong(int n) {\n    int power_sum = 0;\n    int original = n;\n    int k = String.valueOf(n).length();\n    while (n > 0) {\n        int digit = n % 10;\n        power_sum += Math.pow(digit, k);\n        n /= 10;\n    }\n    return power_sum == original;\n}\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "c++": "\n    ```cpp\nbool isArmstrong(int n) {\n    int power_sum = 0, original = n;\n    int k = to_string(n).length();\n    while (n > 0) {\n        int digit = n % 10;\n        power_sum += pow(digit, k);\n        n /= 10;\n    }\n    return power_sum == original;\n}\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "python": "\n    ```python\ndef is_armstrong(n: int) -> bool:\n    power_sum = 0\n    original = n\n    k = len(str(n))\n    while n > 0:\n        digit = n % 10\n        power_sum += digit ** k\n        n //= 10\n    return power_sum == original\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction isArmstrong(n) {\n    let power_sum = 0;\n    let original = n;\n    let k = n.toString().length;\n    while (n > 0) {\n        let digit = n % 10;\n        power_sum += Math.pow(digit, k);\n        n = Math.floor(n / 10);\n    }\n    return power_sum === original;\n}\n```\n    \n    1. Initialize `power_sum` to 0 and store the input number into a variable called `original`.\n2. Calculate the length of the number (number of digits) and store it in variable `k`.\n3. Use a while loop to iterate through each digit of the number.\n   - In each iteration, extract the last digit of the number.\n   - Add the `k`th power of the digit to `power_sum`.\n   - Remove the last digit from the number.\n4. After the loop, check if `power_sum` is equal to the original number. If it is, then the number is an Armstrong number, so return `true`, otherwise return `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 153",
                    "output": " True",
                    "explanation": " 153 is a 3-digit number, and 153 = 13 + 53 + 33."
                },
                {
                    "input": " n = 123",
                    "output": " False",
                    "explanation": " 123 is a 3-digit number, and 123 != 13 + 23 + 33 = 36."
                }
            ],
            "function_input": [
                {
                    "input": "153",
                    "output": "True"
                },
                {
                    "input": "123",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-178",
        "prompt": "Given an integer `n`, return `true` _if and only if it is an **Armstrong number**_.\n\nThe `k`\\-digit number `n` is an Armstrong number if and only if the `kth` power of each digit sums to `n`."
    },
    "leetcode-benchmark-179": {
        "id": "leetcode-benchmark-179",
        "title": "N-th Tribonacci Number",
        "difficulty": "Easy",
        "content": {
            "problem": "The Tribonacci sequence Tn is defined as follows:\n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 4\n**Explanation:**\nT\\_3 = 0 + 1 + 1 = 2\nT\\_4 = 1 + 1 + 2 = 4\n\n",
                "**Example 2:**\n\n**Input:** n = 25\n**Output:** 1389537"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 37`\n*   The answer is guaranteed to fit within a 32-bit integer, ie. `answer <= 2^31 - 1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int heightChecker(int[] heights) {\n    int[] expected = heights.clone();\n    Arrays.sort(expected);\n    int count = 0;\n    for (int i = 0; i < heights.length; i++) {\n        if (heights[i] != expected[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> expected = heights;\n    std::sort(expected.begin(), expected.end());\n    int count = 0;\n    for (size_t i = 0; i < heights.size(); i++) {\n        if (heights[i] != expected[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "python": "\n    ```python\ndef height_checker(heights):\n    expected = sorted(heights)\n    count = 0\n    for i in range(len(heights)):\n        if heights[i] != expected[i]:\n            count += 1\n    return count\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "javascript": "\n    ```javascript\nfunction heightChecker(heights) {\n    const studentsInTheWrongLine = heights\n        .slice()\n        .sort((a, b) => a - b)\n        .reduce((count, height, idx) => {\n            return height === heights[idx] ? count : count + 1;\n        }, 0);\n\n    return studentsInTheWrongLine;\n}\n```\n    \n    The algorithm consists of the following steps:\n1. Create a copy of the given `heights` array and sort it in non-decreasing order to create the `expected` array.\n2. Iterate through both `heights` and `expected` arrays simultaneously and compare the corresponding elements.\n3. If `heights[i]` is not equal to `expected[i]`, increment the counter.\n4. Return the counter as the final answer.\n\nThis algorithm has time complexity O(n log n) due to the sorting step, where n is the number of students.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 4",
                    "output": " 4",
                    "explanation": "\nT\\_3 = 0 + 1 + 1 = 2\nT\\_4 = 1 + 1 + 2 = 4"
                },
                {
                    "input": " n = 25",
                    "output": " 1389537",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "4",
                    "output": "4"
                },
                {
                    "input": "25",
                    "output": "1389537"
                }
            ]
        },
        "task_id": "leetcode-benchmark-179",
        "prompt": "The Tribonacci sequence Tn is defined as follows:\n\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\n\nGiven `n`, return the value of Tn."
    },
    "leetcode-benchmark-180": {
        "id": "leetcode-benchmark-180",
        "title": "Check If a Number Is Majority Element in a Sorted Array",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer array `nums` sorted in non-decreasing order and an integer `target`, return `true` _if_ `target` _is a **majority** element, or_ `false` _otherwise_.\n\nA **majority** element in an array `nums` is an element that appears more than `nums.length / 2` times in the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,5,5,5,5,5,6,6\\], target = 5\n**Output:** true\n**Explanation:** The value 5 appears 5 times and the length of the array is 9.\nThus, 5 is a majority element because 5 > 9/2 is true.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10,100,101,101\\], target = 101\n**Output:** false\n**Explanation:** The value 101 appears 2 times and the length of the array is 4.\nThus, 101 is not a majority element because 2 > 4/2 is false."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i], target <= 109`\n*   `nums` is sorted in non-decreasing order.",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean isMajorityElement(int[] nums, int target) {\n    int count = 0;\n    for (int num : nums) {\n        if (num == target) count++;\n        if (count > nums.length / 2) return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "c++": "\n    ```cpp\nbool isMajorityElement(vector<int>& nums, int target) {\n    int count = 0;\n    for (int num : nums) {\n        if (num == target) count++;\n        if (count > nums.size() / 2) return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "python": "\n    ```python\ndef is_majority_element(nums, target):\n    count = 0\n    for num in nums:\n        if num == target: count += 1\n        if count > len(nums) / 2: return True\n    return False\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "javascript": "\n    ```javascript\nfunction isMajorityElement(nums, target) {\n    let count = 0;\n    for (const num of nums) {\n        if (num === target) count++;\n        if (count > nums.length / 2) return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm is simple, we iterate through the array, and when we find the target number, we increment the count variable. If the count variable ever becomes greater than `nums.length / 2`, we return true because the target is a majority element. Otherwise, after iterating through the array, we return false because the target is not a majority element. This approach has a linear time complexity of O(n), where n is the length of the array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,4,5,5,5,5,5,6,6], target = 5",
                    "output": " True",
                    "explanation": " The value 5 appears 5 times and the length of the array is 9.\nThus, 5 is a majority element because 5 > 9/2 is true."
                },
                {
                    "input": " nums = [10,100,101,101], target = 101",
                    "output": " False",
                    "explanation": " The value 101 appears 2 times and the length of the array is 4.\nThus, 101 is not a majority element because 2 > 4/2 is false."
                }
            ],
            "function_input": [
                {
                    "input": "[2,4,5,5,5,5,5,6,6],5",
                    "output": "True"
                },
                {
                    "input": "[10,100,101,101],101",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-180",
        "prompt": "Given an integer array `nums` sorted in non-decreasing order and an integer `target`, return `true` _if_ `target` _is a **majority** element, or_ `false` _otherwise_.\n\nA **majority** element in an array `nums` is an element that appears more than `nums.length / 2` times in the array."
    },
    "leetcode-benchmark-181": {
        "id": "leetcode-benchmark-181",
        "title": "Day of the Year",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `date` representing a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) date formatted as `YYYY-MM-DD`, return _the day number of the year_.",
            "examples": [
                "**Example 1:**\n\n**Input:** date =  \"2019-01-09 \"\n**Output:** 9\n**Explanation:** Given date is the 9th day of the year in 2019.\n\n",
                "**Example 2:**\n\n**Input:** date =  \"2019-02-10 \"\n**Output:** 41"
            ],
            "constraints": "**Constraints:**\n\n*   `date.length == 10`\n*   `date[4] == date[7] == '-'`, and all other `date[i]`'s are digits\n*   `date` represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int dayOfYear(String date) {\n    int[] daysInMonth = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int year = Integer.parseInt(date.substring(0, 4));\n    int month = Integer.parseInt(date.substring(5, 7));\n    int day = Integer.parseInt(date.substring(8, 10));\n\n    if (isLeapYear(year)) {\n        daysInMonth[1] = 29;\n    }\n\n    int result = 0;\n    for (int i = 0; i < month - 1; ++i) {\n        result += daysInMonth[i];\n    }\n\n    return result + day;\n}\n\npublic boolean isLeapYear(int year) {\n    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n}\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nbool is_leap_year(int year) {\n    return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n}\n\nint day_of_year(string date) {\n    vector<int> days_in_month = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n    int year = stoi(date.substr(0, 4));\n    int month = stoi(date.substr(5, 2));\n    int day = stoi(date.substr(8, 2));\n    \n    if (is_leap_year(year)) {\n        days_in_month[1] = 29;\n    }\n\n    int result = 0;\n    for (int i = 0; i < month - 1; ++i) {\n        result += days_in_month[i];\n    }\n\n    return result + day;\n}\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "python": "\n    ```python\ndef is_leap_year(year: int) -> bool:\n    return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\ndef day_of_year(date: str) -> int:\n    days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    year, month, day = int(date[:4]), int(date[5:7]), int(date[8:])\n\n    if is_leap_year(year):\n        days_in_month[1] = 29\n\n    return sum(days_in_month[:month-1]) + day\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "javascript": "\n    ```javascript\nfunction isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\nfunction dayOfYear(date) {\n    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    var year = parseInt(date.substr(0, 4));\n    var month = parseInt(date.substr(5, 2));\n    var day = parseInt(date.substr(8, 2));\n    \n    if (isLeapYear(year)) {\n        daysInMonth[1] = 29;\n    }\n\n    var result = 0;\n    for (var i = 0; i < month - 1; ++i) {\n        result += daysInMonth[i];\n    }\n    \n    return result + day;\n}\n```\n\n    \n    The algorithm is straightforward. First, we extract the `year`, `month`, and `day` from the input date string. Then, we determine if the year is a leap year by checking if it's evenly divisible by 4 and not evenly divisible by 100, or evenly divisible by 400.\n\nIf the year is a leap year, we update the number of days in February (the second month) to be 29 days. Finally, we iterate over the months that have already passed, summing the number of days in each and add the `day` of the input month. The result is the day number of the year.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " date =  \"2019-01-09 \"",
                    "output": " 9",
                    "explanation": " Given date is the 9th day of the year in 2019."
                },
                {
                    "input": " date =  \"2019-02-10 \"",
                    "output": " 41",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"2019-01-09\"",
                    "output": "9"
                },
                {
                    "input": "\"2019-02-10\"",
                    "output": "41"
                }
            ]
        },
        "task_id": "leetcode-benchmark-181",
        "prompt": "Given a string `date` representing a [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) date formatted as `YYYY-MM-DD`, return _the day number of the year_."
    },
    "leetcode-benchmark-182": {
        "id": "leetcode-benchmark-182",
        "title": "Find Words That Can Be Formed by Characters",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array of strings `words` and a string `chars`.\n\nA string is **good** if it can be formed by characters from chars (each character can only be used once).\n\nReturn _the sum of lengths of all good strings in words_.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"bt \", \"hat \", \"tree \"\\], chars =  \"atach \"\n**Output:** 6\n**Explanation:** The strings that can be formed are  \"cat \" and  \"hat \" so the answer is 3 + 3 = 6.\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"hello \", \"world \", \"leetcode \"\\], chars =  \"welldonehoneyr \"\n**Output:** 10\n**Explanation:** The strings that can be formed are  \"hello \" and  \"world \" so the answer is 5 + 5 = 10."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 1000`\n*   `1 <= words[i].length, chars.length <= 100`\n*   `words[i]` and `chars` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numTilePossibilities(String tiles) {\n    int[] freq = new int[26];\n    for (char c : tiles.toCharArray()) {\n        freq[c - 'A']++;\n    }\n\n    return numTilePossibilities(freq);\n}\n\nprivate int numTilePossibilities(int[] freq) {\n    int result = 0;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i] > 0) {\n            freq[i]--;\n            result += 1 + numTilePossibilities(freq);\n            freq[i]++;\n        }\n    }\n    return result;\n}\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint numTilePossibilities(std::string tiles) {\n    std::vector<int> freq(26, 0);\n    for (char c : tiles) {\n        freq[c - 'A']++;\n    }\n\n    int result = 0;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i]) {\n            freq[i]--;\n            result += 1 + numTilePossibilities(tiles);\n            freq[i]++;\n        }\n    }\n    return result;\n}\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "python": "\n    ```python\ndef num_tile_possibilities(tiles: str) -> int:\n    freq = [0] * 26\n    for c in tiles:\n        freq[ord(c) - ord('A')] += 1\n\n    def dfs(freq):\n        result = 0\n        for i in range(26):\n            if freq[i] > 0:\n                freq[i] -= 1\n                result += 1 + dfs(freq)\n                freq[i] += 1\n        return result\n\n    return dfs(freq)\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "javascript": "\n    ```javascript\nfunction numTilePossibilities(tiles) {\n    const freq = new Array(26).fill(0);\n    for (const c of tiles) {\n        freq[c.charCodeAt(0) - 'A'.charCodeAt(0)]++;\n    }\n\n    function dfs(freq) {\n        let result = 0;\n        for (let i = 0; i < 26; i++) {\n            if (freq[i] > 0) {\n                freq[i]--;\n                result += 1 + dfs(freq);\n                freq[i]++;\n            }\n        }\n        return result;\n    }\n\n    return dfs(freq);\n}\n```\n    \n    First, calculate the frequency of each character in the input string `tiles`. Next, use depth-first search to explore all possible combinations of characters by decrementing the frequency of the current character, adding all the possible combinations for the remaining characters, and then restoring the frequency count for backtracking purposes. The final result will be the total count of all possible non-empty sequences.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"cat \", \"bt \", \"hat \", \"tree \"], chars =  \"atach \"",
                    "output": " 6",
                    "explanation": " The strings that can be formed are  \"cat \" and  \"hat \" so the answer is 3 + 3 = 6."
                },
                {
                    "input": " words = [ \"hello \", \"world \", \"leetcode \"], chars =  \"welldonehoneyr \"",
                    "output": " 10",
                    "explanation": " The strings that can be formed are  \"hello \" and  \"world \" so the answer is 5 + 5 = 10."
                }
            ],
            "function_input": [
                {
                    "input": "[\"cat\",\"bt\",\"hat\",\"tree\"],\"atach\"",
                    "output": "6"
                },
                {
                    "input": "[\"hello\",\"world\",\"leetcode\"],\"welldonehoneyr\"",
                    "output": "10"
                }
            ]
        },
        "task_id": "leetcode-benchmark-182",
        "prompt": "You are given an array of strings `words` and a string `chars`.\n\nA string is **good** if it can be formed by characters from chars (each character can only be used once).\n\nReturn _the sum of lengths of all good strings in words_."
    },
    "leetcode-benchmark-183": {
        "id": "leetcode-benchmark-183",
        "title": "Single-Row Keyboard",
        "difficulty": "Easy",
        "content": {
            "problem": "There is a special keyboard with **all keys in a single row**.\n\nGiven a string `keyboard` of length `26` indicating the layout of the keyboard (indexed from `0` to `25`). Initially, your finger is at index `0`. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index `i` to index `j` is `|i - j|`.\n\nYou want to type a string `word`. Write a function to calculate how much time it takes to type it with one finger.",
            "examples": [
                "**Example 1:**\n\n**Input:** keyboard =  \"abcdefghijklmnopqrstuvwxyz \", word =  \"cba \"\n**Output:** 4\n**Explanation:** The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.\nTotal time = 2 + 1 + 1 = 4. \n\n",
                "**Example 2:**\n\n**Input:** keyboard =  \"pqrstuvwxyzabcdefghijklmno \", word =  \"leetcode \"\n**Output:** 73"
            ],
            "constraints": "**Constraints:**\n\n*   `keyboard.length == 26`\n*   `keyboard` contains each English lowercase letter exactly once in some order.\n*   `1 <= word.length <= 104`\n*   `word[i]` is an English lowercase letter.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int calculateTime(String keyboard, String word) {\n    int time = 0;\n    int prevIndex = 0;\n    Map<Character, Integer> charToIndex = new HashMap<>();\n\n    for (int i = 0; i < keyboard.length(); i++) {\n        charToIndex.put(keyboard.charAt(i), i);\n    }\n\n    for (char c : word.toCharArray()) {\n        time += Math.abs(charToIndex.get(c) - prevIndex);\n        prevIndex = charToIndex.get(c);\n    }\n\n    return time;\n}\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "c++": "\n    ```cpp\nint calculateTime(std::string keyboard, std::string word) {\n    int time = 0;\n    int prev_index = 0;\n    std::unordered_map<char, int> char_to_index;\n\n    for (int i = 0; i < keyboard.length(); i++) {\n        char_to_index[keyboard[i]] = i;\n    }\n\n    for (char c : word) {\n        time += std::abs(char_to_index[c] - prev_index);\n        prev_index = char_to_index[c];\n    }\n\n    return time;\n}\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "python": "\n    ```python\ndef calculate_time(keyboard: str, word: str) -> int:\n    time = 0\n    prev_index = 0\n    char_to_index = {char: i for i, char in enumerate(keyboard)}\n\n    for c in word:\n        time += abs(char_to_index[c] - prev_index)\n        prev_index = char_to_index[c]\n\n    return time\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "javascript": "\n    ```javascript\nfunction calculateTime(keyboard, word) {\n    let time = 0;\n    let prevIndex = 0;\n    let charToIndex = {};\n\n    for (let i = 0; i < keyboard.length; i++) {\n        charToIndex[keyboard[i]] = i;\n    }\n\n    for (let c of word) {\n        time += Math.abs(charToIndex[c] - prevIndex);\n        prevIndex = charToIndex[c];\n    }\n\n    return time;\n}\n```\n    \n    1. Initialize the time to 0 and set the current position of the finger to index 0 of the keyboard.\n2. Convert the keyboard layout into a map (hashmap, dictionary, or object) with the characters as keys and their corresponding indices as values.\n3. Loop through each character in the given word and add the absolute difference between the previous index and the current index to the total time.\n4. Update the previous index to the index of the current character.\n5. Return the total time.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " keyboard =  \"abcdefghijklmnopqrstuvwxyz \", word =  \"cba \"",
                    "output": " 4",
                    "explanation": " The index moves from 0 to 2 to write 'c' then to 1 to write 'b' then to 0 again to write 'a'.\nTotal time = 2 + 1 + 1 = 4."
                },
                {
                    "input": " keyboard =  \"pqrstuvwxyzabcdefghijklmno \", word =  \"leetcode \"",
                    "output": " 73",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abcdefghijklmnopqrstuvwxyz\",\"cba\"",
                    "output": "4"
                },
                {
                    "input": "\"pqrstuvwxyzabcdefghijklmno\",\"leetcode\"",
                    "output": "73"
                }
            ]
        },
        "task_id": "leetcode-benchmark-183",
        "prompt": "There is a special keyboard with **all keys in a single row**.\n\nGiven a string `keyboard` of length `26` indicating the layout of the keyboard (indexed from `0` to `25`). Initially, your finger is at index `0`. To type a character, you have to move your finger to the index of the desired character. The time taken to move your finger from index `i` to index `j` is `|i - j|`.\n\nYou want to type a string `word`. Write a function to calculate how much time it takes to type it with one finger."
    },
    "leetcode-benchmark-184": {
        "id": "leetcode-benchmark-184",
        "title": "Prime Arrangements",
        "difficulty": "Easy",
        "content": {
            "problem": "Return the number of permutations of 1 to `n` so that prime numbers are at prime indices (1-indexed.)\n\n_(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)_\n\nSince the answer may be large, return the answer **modulo `10^9 + 7`**.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 12\n**Explanation:** For example \\[1,2,5,4,3\\] is a valid permutation, but \\[5,2,3,4,1\\] is not because the prime number 5 is at index 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 100\n**Output:** 682289015"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numPrimeArrangements(int n) {\n    boolean[] isPrime = new boolean[n + 1];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = false;\n    isPrime[1] = false;\n    for (int i = 2; i * i <= n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    \n    int primeCount = 0;\n    for (int i = 2; i <= n; i++) {\n        if (isPrime[i]) primeCount++;\n    }\n    int compositeCount = n - primeCount;\n    \n    long res = 1;\n    int MOD = 1000000007;\n    for (int i = 1; i <= primeCount; i++) {\n        res = res * i % MOD;\n    }\n    for (int i = 1; i <= compositeCount; i++) {\n        res = res * i % MOD;\n    }\n    return (int) res;\n}\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nint numPrimeArrangements(int n) {\n    vector<bool> is_prime(n + 1, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i <= n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j <= n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    int prime_count = 0;\n    for (int i = 2; i <= n; i++) {\n        if (is_prime[i]) prime_count++;\n    }\n    int composite_count = n - prime_count;\n    \n    long long res = 1;\n    for (int i = 1; i <= prime_count; i++) {\n        res = res * i % MOD;\n    }\n    for (int i = 1; i <= composite_count; i++) {\n        res = res * i % MOD;\n    }\n    return res;\n}\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "python": "\n    ```python\ndef numPrimeArrangements(n: int) -> int:\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    prime_count = sum(1 for i in range(2, n + 1) if is_prime(i))\n    composite_count = n - prime_count\n\n    MOD = 10**9 + 7\n    res = 1\n    for i in range(1, prime_count + 1):\n        res = res * i % MOD\n    for i in range(1, composite_count + 1):\n        res = res * i % MOD\n\n    return res\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "javascript": "\n    ```javascript\nfunction numPrimeArrangements(n) {\n    function isPrime(num) {\n        if (num < 2) return false;\n        for (let i = 2; i * i <= num; i++) {\n            if (num % i === 0) return false;\n        }\n        return true;\n    }\n\n    let primeCount = 0;\n    for (let i = 2; i <= n; i++) {\n        if (isPrime(i)) primeCount++;\n    }\n    let compositeCount = n - primeCount;\n\n    const MOD = 10**9 + 7;\n    let res = 1;\n    for (let i = 1; i <= primeCount; i++) {\n        res = res * i % MOD;\n    }\n    for (let i = 1; i <= compositeCount; i++) {\n        res = res * i % MOD;\n    }\n\n    return res;\n}\n```\n    \n    The algorithm calculates the total number of primes and composites up to the given integer n. Then, it multiplies the factorials of the two counts (mod 10^9 + 7), eventually returning the result as the number of permutations of 1 to n where prime numbers are at the prime indices.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5",
                    "output": " 12",
                    "explanation": " For example \\[1,2,5,4,3\\] is a valid permutation, but \\[5,2,3,4,1\\] is not because the prime number 5 is at index 1."
                },
                {
                    "input": " n = 100",
                    "output": " 682289015",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "12"
                },
                {
                    "input": "100",
                    "output": "682289015"
                }
            ]
        },
        "task_id": "leetcode-benchmark-184",
        "prompt": "Return the number of permutations of 1 to `n` so that prime numbers are at prime indices (1-indexed.)\n\n_(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)_\n\nSince the answer may be large, return the answer **modulo `10^9 + 7`**."
    },
    "leetcode-benchmark-185": {
        "id": "leetcode-benchmark-185",
        "title": "Diet Plan Performance",
        "difficulty": "Easy",
        "content": {
            "problem": "A dieter consumes `calories[i]` calories on the `i`\\-th day.\n\nGiven an integer `k`, for **every** consecutive sequence of `k` days (`calories[i], calories[i+1], ..., calories[i+k-1]` for all `0 <= i <= n-k`), they look at _T_, the total calories consumed during that sequence of `k` days (`calories[i] + calories[i+1] + ... + calories[i+k-1]`):\n\n*   If `T < lower`, they performed poorly on their diet and lose 1 point;\n*   If `T > upper`, they performed well on their diet and gain 1 point;\n*   Otherwise, they performed normally and there is no change in points.\n\nInitially, the dieter has zero points. Return the total number of points the dieter has after dieting for `calories.length` days.\n\nNote that the total points can be negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** calories = \\[1,2,3,4,5\\], k = 1, lower = 3, upper = 3\n**Output:** 0\n**Explanation**: Since k = 1, we consider each element of the array separately and compare it to lower and upper.\ncalories\\[0\\] and calories\\[1\\] are less than lower so 2 points are lost.\ncalories\\[3\\] and calories\\[4\\] are greater than upper so 2 points are gained.\n\n",
                "**Example 2:**\n\n**Input:** calories = \\[3,2\\], k = 2, lower = 0, upper = 1\n**Output:** 1\n**Explanation**: Since k = 2, we consider subarrays of length 2.\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\n\n",
                "**Example 3:**\n\n**Input:** calories = \\[6,5,0,0\\], k = 2, lower = 1, upper = 5\n**Output:** 0\n**Explanation**:\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\nlower <= calories\\[1\\] + calories\\[2\\] <= upper so no change in points.\ncalories\\[2\\] + calories\\[3\\] < lower so 1 point is lost."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= calories.length <= 10^5`\n*   `0 <= calories[i] <= 20000`\n*   `0 <= lower <= upper`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int dietPlanPerformance(int[] calories, int k, int lower, int upper) {\n    int points = 0;\n    int T = 0;\n\n    for(int i = 0; i < calories.length; i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "c++": "\n    ```cpp\nint dietPlanPerformance(vector<int>& calories, int k, int lower, int upper) {\n    int points = 0;\n    int T = 0;\n\n    for(int i = 0; i < calories.size(); i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "python": "\n    ```python\ndef dietPlanPerformance(calories, k, lower, upper):\n    points = 0\n    T = 0\n\n    for i in range(len(calories)):\n        T += calories[i]\n        if i >= k:\n            T -= calories[i-k]\n        if i >= k-1:\n            if T < lower: points -= 1\n            if T > upper: points += 1\n\n    return points\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "javascript": "\n    ```javascript\nfunction dietPlanPerformance(calories, k, lower, upper) {\n    let points = 0;\n    let T = 0;\n\n    for(let i = 0; i < calories.length; i++) {\n        T += calories[i];\n        if(i >= k) {\n            T -= calories[i-k];\n        }\n        if(i >= k-1) {\n            if(T < lower) points--;\n            if(T > upper) points++;\n        }\n    }\n\n    return points;\n}\n```\n    \n    1. Initialize the points and total calories `T` to 0.\n2. Iterate through the given calories list.\n3. Add the current day calories to `T`.\n4. Check if the current index position is greater than or equal to `k`. If so, subtract the calories of the first day of the previous window from `T`.\n5. Check if we have formed a window of size `k`. If so, perform the point calculation:\n   1. If `T` is less than `lower`, decrement the points.\n   2. If `T` is greater than `upper`, increment the points.\n6. Return the total number of points.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " calories = [1,2,3,4,5], k = 1, lower = 3, upper = 3",
                    "output": " 0",
                    "explanation": ": Since k = 1, we consider each element of the array separately and compare it to lower and upper.\ncalories\\[0\\] and calories\\[1\\] are less than lower so 2 points are lost.\ncalories\\[3\\] and calories\\[4\\] are greater than upper so 2 points are gained."
                },
                {
                    "input": " calories = [3,2], k = 2, lower = 0, upper = 1",
                    "output": " 1",
                    "explanation": ": Since k = 2, we consider subarrays of length 2.\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained."
                },
                {
                    "input": " calories = [6,5,0,0], k = 2, lower = 1, upper = 5",
                    "output": " 0",
                    "explanation": ":\ncalories\\[0\\] + calories\\[1\\] > upper so 1 point is gained.\nlower <= calories\\[1\\] + calories\\[2\\] <= upper so no change in points.\ncalories\\[2\\] + calories\\[3\\] < lower so 1 point is lost."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5],1,3,3",
                    "output": "0"
                },
                {
                    "input": "[3,2],2,0,1",
                    "output": "1"
                },
                {
                    "input": "[6,5,0,0],2,1,5",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-185",
        "prompt": "A dieter consumes `calories[i]` calories on the `i`\\-th day.\n\nGiven an integer `k`, for **every** consecutive sequence of `k` days (`calories[i], calories[i+1], ..., calories[i+k-1]` for all `0 <= i <= n-k`), they look at _T_, the total calories consumed during that sequence of `k` days (`calories[i] + calories[i+1] + ... + calories[i+k-1]`):\n\n*   If `T < lower`, they performed poorly on their diet and lose 1 point;\n*   If `T > upper`, they performed well on their diet and gain 1 point;\n*   Otherwise, they performed normally and there is no change in points.\n\nInitially, the dieter has zero points. Return the total number of points the dieter has after dieting for `calories.length` days.\n\nNote that the total points can be negative."
    },
    "leetcode-benchmark-186": {
        "id": "leetcode-benchmark-186",
        "title": "Count Substrings with Only One Distinct Letter",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `s`, return _the number of substrings that have only **one distinct** letter_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaaba \"\n**Output:** 8\n**Explanation:** The substrings with one distinct letter are  \"aaa \",  \"aa \",  \"a \",  \"b \".\n \"aaa \" occurs 1 time.\n \"aa \" occurs 2 times.\n \"a \" occurs 4 times.\n \"b \" occurs 1 time.\nSo the answer is 1 + 2 + 4 + 1 = 8.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaaaaaaaaa \"\n**Output:** 55"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countLetters(String s) {\n    int count = 0, current = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s.charAt(i) == s.charAt(i - 1)) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "c++": "\n    ```cpp\nint countLetters(string s) {\n    int count = 0, current = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == s[i - 1]) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "python": "\n    ```python\ndef count_letters(s: str) -> int:\n    count = 0\n    current = 1\n\n    for i in range(1, len(s)):\n        if s[i] == s[i - 1]:\n            current += 1\n        else:\n            count += (current * (current + 1)) // 2\n            current = 1\n\n    count += (current * (current + 1)) // 2\n    return count\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction countLetters(s) {\n    let count = 0;\n    let current = 1;\n\n    for (let i = 1; i < s.length; i++) {\n        if (s[i] === s[i - 1]) {\n            current++;\n        } else {\n            count += (current * (current + 1)) / 2;\n            current = 1;\n        }\n    }\n\n    count += (current * (current + 1)) / 2;\n    return count;\n}\n```\n    \n    The algorithm iterates through the string `s` and checks if the current character is same as the previous character. If yes, it increments the `current` counter. When it finds a different character, it calculates the count of distinct single-letter substrings ending prior to that character and adds the count to the `count` variable. The formula `(current * (current + 1)) / 2` is the sum of the first `current` positive integers, which is the number of substrings that can be formed with the same character. This process is repeated for each character in the string. Finally, the total count of substrings is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aaaba \"",
                    "output": " 8",
                    "explanation": " The substrings with one distinct letter are  \"aaa \",  \"aa \",  \"a \",  \"b \".\n \"aaa \" occurs 1 time.\n \"aa \" occurs 2 times.\n \"a \" occurs 4 times.\n \"b \" occurs 1 time.\nSo the answer is 1 + 2 + 4 + 1 = 8."
                },
                {
                    "input": " s =  \"aaaaaaaaaa \"",
                    "output": " 55",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aaaba\"",
                    "output": "8"
                },
                {
                    "input": "\"aaaaaaaaaa\"",
                    "output": "55"
                }
            ]
        },
        "task_id": "leetcode-benchmark-186",
        "prompt": "Given a string `s`, return _the number of substrings that have only **one distinct** letter_."
    },
    "leetcode-benchmark-187": {
        "id": "leetcode-benchmark-187",
        "title": "Distance Between Bus Stops",
        "difficulty": "Easy",
        "content": {
            "problem": "A bus has `n` stops numbered from `0` to `n - 1` that form a circle. We know the distance between all pairs of neighboring stops where `distance[i]` is the distance between the stops number `i` and `(i + 1) % n`.\n\nThe bus goes along both directions i.e. clockwise and counterclockwise.\n\nReturn the shortest distance between the given `start` and `destination` stops.",
            "examples": [
                "**Example 1:**\n\n**Input:** distance = \\[1,2,3,4\\], start = 0, destination = 1\n**Output:** 1\n**Explanation:** Distance between 0 and 1 is 1 or 9, minimum is 1.\n\n",
                "**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\], start = 0, destination = 2\n**Output:** 3\n**Explanation:** Distance between 0 and 2 is 3 or 7, minimum is 3.\n\n",
                "**Example 3:**\n\n**Input:** distance = \\[1,2,3,4\\], start = 0, destination = 3\n**Output:** 4\n**Explanation:** Distance between 0 and 3 is 6 or 4, minimum is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 10^4`\n*   `distance.length == n`\n*   `0 <= start, destination < n`\n*   `0 <= distance[i] <= 10^4`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic boolean carPooling(int[][] trips, int capacity) {\n    Map<Integer, Integer> stops = new TreeMap<>();\n    for (int[] t : trips) {\n        stops.put(t[1], stops.getOrDefault(t[1], 0) + t[0]);\n        stops.put(t[2], stops.getOrDefault(t[2], 0) - t[0]);\n    }\n    for (int passengers : stops.values()) {\n        capacity -= passengers;\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool carPooling(std::vector<std::vector<int>>& trips, int capacity) {\n    std::vector<int> stops(1001, 0);\n    for (const std::vector<int>& t : trips) {\n        stops[t[1]] += t[0];\n        stops[t[2]] -= t[0];\n    }\n    for (int i = 0; i < stops.size(); ++i) {\n        capacity -= stops[i];\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "python": "\n    ```python\ndef carPooling(trips, capacity):\n    stops = [0] * 1001\n    for num, start, end in trips:\n        stops[start] += num\n        stops[end] -= num\n    for i in stops:\n        capacity -= i\n        if capacity < 0:\n            return False\n    return True\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "javascript": "\n    ```javascript\nfunction carPooling(trips, capacity) {\n    const stops = new Array(1001).fill(0);\n    for (const [num, start, end] of trips) {\n        stops[start] += num;\n        stops[end] -= num;\n    }\n    for (const passengers of stops) {\n        capacity -= passengers;\n        if (capacity < 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    1. Create an array `stops` of size 1001 (as locations are from 0 to 1000), initialized with zeros.\n2. Iterate through the `trips` array, and for each trip, add `numPassengers` to the `from` index and subtract `numPassengers` from the `to` index in the `stops` array. This will represent the number of passengers to pick up (positive value) or drop off (negative value) at each location.\n3. Iterate through the `stops` array, and for each location, update the `capacity` by subtracting the number of passengers at that location. If the capacity becomes negative at any point, return `false`.\n4. If we have iterated through all the locations in the `stops` array without the capacity becoming negative, return `true`. This means it's possible to pick up and drop off all passengers for all the given trips.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " distance = [1,2,3,4], start = 0, destination = 1",
                    "output": " 1",
                    "explanation": " Distance between 0 and 1 is 1 or 9, minimum is 1."
                },
                {
                    "input": " distance = [1,2,3,4], start = 0, destination = 2",
                    "output": " 3",
                    "explanation": " Distance between 0 and 2 is 3 or 7, minimum is 3."
                },
                {
                    "input": " distance = [1,2,3,4], start = 0, destination = 3",
                    "output": " 4",
                    "explanation": " Distance between 0 and 3 is 6 or 4, minimum is 4."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4],0,1",
                    "output": "1"
                },
                {
                    "input": "[1,2,3,4],0,2",
                    "output": "3"
                },
                {
                    "input": "[1,2,3,4],0,3",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-187",
        "prompt": "A bus has `n` stops numbered from `0` to `n - 1` that form a circle. We know the distance between all pairs of neighboring stops where `distance[i]` is the distance between the stops number `i` and `(i + 1) % n`.\n\nThe bus goes along both directions i.e. clockwise and counterclockwise.\n\nReturn the shortest distance between the given `start` and `destination` stops."
    },
    "leetcode-benchmark-188": {
        "id": "leetcode-benchmark-188",
        "title": "Day of the Week",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a date, return the corresponding day of the week for that date.\n\nThe input is given as three integers representing the `day`, `month` and `year` respectively.\n\nReturn the answer as one of the following values `{ \"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"}`.",
            "examples": [
                "**Example 1:**\n\n**Input:** day = 31, month = 8, year = 2019\n**Output:**  \"Saturday \"\n\n",
                "**Example 2:**\n\n**Input:** day = 18, month = 7, year = 1999\n**Output:**  \"Sunday \"\n\n",
                "**Example 3:**\n\n**Input:** day = 15, month = 8, year = 1993\n**Output:**  \"Sunday \""
            ],
            "constraints": "**Constraints:**\n\n*   The given dates are valid dates between the years `1971` and `2100`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.time.LocalDate;\n\npublic String dayOfTheWeek(int day, int month, int year) {\n    LocalDate date = LocalDate.of(year, month, day);\n    int dayOfWeekIndex = date.getDayOfWeek().getValue() % 7;\n    String[] days = {\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"};\n    return days[dayOfWeekIndex];\n}\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string dayOfTheWeek(int day, int month, int year) {\n    int days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    std::string week[] = {\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"};\n    if (year < 1971) year += (1971 - year) / 400 * 400;\n    int sum = -1;\n    for (int i = 1971; i < year; ++i) {\n        sum += 365;\n        if (i % 4 == 0 && (i % 100 != 0 || i % 400 == 0)) ++sum;\n    }\n    for (int i = 1; i < month; ++i) {\n        sum += days[i];\n        if (i == 2 && year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) ++sum;\n    }\n    return week[(sum + day) % 7];\n}\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "python": "\n    ```python\ndef day_of_the_week(day, month, year):\n    from datetime import date\n    days = [\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"]\n    return days[date(year, month, day).weekday()]\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "javascript": "\n    ```javascript\nfunction dayOfTheWeek(day, month, year) {\n    let days = [\"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"];\n    let date = new Date(year, month - 1, day);\n    return days[date.getDay()];\n}\n```\n    \n    The algorithm calculates the day of the week based on the given day, month, and year. For the C++ implementation, we implement the calculation of days since the year 1971 and then use the modulus operator to determine the day of the week. For Java, Python, and JavaScript implementations, we take advantage of built-in date libraries (LocalDate, datetime, and Date respectively) to calculate the day of the week. All implementations use a string array `days[]` to get the correct day of the week as the output.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " day = 31, month = 8, year = 2019",
                    "output": "  \"Saturday \"",
                    "explanation": null
                },
                {
                    "input": " day = 18, month = 7, year = 1999",
                    "output": "  \"Sunday \"",
                    "explanation": null
                },
                {
                    "input": " day = 15, month = 8, year = 1993",
                    "output": "  \"Sunday \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "31,8,2019",
                    "output": "\"Saturday\""
                },
                {
                    "input": "18,7,1999",
                    "output": "\"Sunday\""
                },
                {
                    "input": "15,8,1993",
                    "output": "\"Sunday\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-188",
        "prompt": "Given a date, return the corresponding day of the week for that date.\n\nThe input is given as three integers representing the `day`, `month` and `year` respectively.\n\nReturn the answer as one of the following values `{ \"Sunday \", \"Monday \", \"Tuesday \", \"Wednesday \", \"Thursday \", \"Friday \", \"Saturday \"}`."
    },
    "leetcode-benchmark-189": {
        "id": "leetcode-benchmark-189",
        "title": "Maximum Number of Balloons",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a string `text`, you want to use the characters of `text` to form as many instances of the word **\"balloon \"** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum number of instances that can be formed.",
            "examples": [
                "**Example 1:**\n\n**Input:** text =  \"nlaebolko \"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** text =  \"loonbalxballpoon \"\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** text =  \"leetcode \"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= text.length <= 104`\n*   `text` consists of lower case English letters only.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxNumberOfBalloons(String text) {\n    int[] letter_count = new int[5];\n    for (char c : text.toCharArray()) {\n        if (c == 'b') letter_count[0]++;\n        if (c == 'a') letter_count[1]++;\n        if (c == 'l') letter_count[2]++;\n        if (c == 'o') letter_count[3]++;\n        if (c == 'n') letter_count[4]++;\n    }\n    letter_count[2] /= 2;\n    letter_count[3] /= 2;\n    return Arrays.stream(letter_count).min().getAsInt();\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "c++": "\n    ```cpp\nint maxNumberOfBalloons(string text) {\n    int letter_count[5] = {0};\n    for (char c : text) {\n        if (c == 'b') letter_count[0]++;\n        if (c == 'a') letter_count[1]++;\n        if (c == 'l') letter_count[2]++;\n        if (c == 'o') letter_count[3]++;\n        if (c == 'n') letter_count[4]++;\n    }\n    letter_count[2] /= 2;\n    letter_count[3] /= 2;\n    return *min_element(letter_count, letter_count + 5);\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "python": "\n    ```python\ndef max_number_of_balloons(text: str) -> int:\n    letter_count = [0] * 5\n    for c in text:\n        if c == 'b': letter_count[0] += 1\n        if c == 'a': letter_count[1] += 1\n        if c == 'l': letter_count[2] += 1\n        if c == 'o': letter_count[3] += 1\n        if c == 'n': letter_count[4] += 1\n    letter_count[2] //= 2\n    letter_count[3] //= 2\n    return min(letter_count)\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "javascript": "\n    ```javascript\nfunction maxNumberOfBalloons(text) {\n    const letter_count = [0, 0, 0, 0, 0];\n    for (let c of text) {\n        if (c === 'b') letter_count[0]++;\n        if (c === 'a') letter_count[1]++;\n        if (c === 'l') letter_count[2]++;\n        if (c === 'o') letter_count[3]++;\n        if (c === 'n') letter_count[4]++;\n    }\n    letter_count[2] = Math.floor(letter_count[2] / 2);\n    letter_count[3] = Math.floor(letter_count[3] / 2);\n    return Math.min(...letter_count);\n}\n```\n    \n    1. First, we initialize an array `letter_count` with a length of 5 to represent each character in the word \"balloon\".\n2. We then loop through each character in the input string `text`.\n3. For each character, we increment the corresponding index in the `letter_count` array if it matches one of the characters in the word \"balloon\".\n4. After the loop, we divide the count of 'l' and 'o' by 2 since they appear twice in the word \"balloon\".\n5. Finally, we return the minimum value in the `letter_count` array, which represents the maximum number of instances of the word \"balloon\" that can be formed.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " text =  \"nlaebolko \"",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " text =  \"loonbalxballpoon \"",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " text =  \"leetcode \"",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"nlaebolko\"",
                    "output": "1"
                },
                {
                    "input": "\"loonbalxballpoon\"",
                    "output": "2"
                },
                {
                    "input": "\"leetcode\"",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-189",
        "prompt": "Given a string `text`, you want to use the characters of `text` to form as many instances of the word **\"balloon \"** as possible.\n\nYou can use each character in `text` **at most once**. Return the maximum number of instances that can be formed."
    },
    "leetcode-benchmark-190": {
        "id": "leetcode-benchmark-190",
        "title": "How Many Apples Can You Put into the Basket",
        "difficulty": "Easy",
        "content": {
            "problem": "You have some apples and a basket that can carry up to `5000` units of weight.\n\nGiven an integer array `weight` where `weight[i]` is the weight of the `ith` apple, return _the maximum number of apples you can put in the basket_.",
            "examples": [
                "**Example 1:**\n\n**Input:** weight = \\[100,200,150,1000\\]\n**Output:** 4\n**Explanation:** All 4 apples can be carried by the basket since their sum of weights is 1450.\n\n",
                "**Example 2:**\n\n**Input:** weight = \\[900,950,800,1000,700,800\\]\n**Output:** 5\n**Explanation:** The sum of weights of the 6 apples exceeds 5000 so we choose any 5 of them."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= weight.length <= 103`\n*   `1 <= weight[i] <= 103`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minHeightShelves(int[][] books, int shelfWidth) {\n    int n = books.length;\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, 1000000);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        int width = 0, height = 0;\n        for (int j = i; j >= 1; j--) {\n            width += books[j - 1][0];\n            height = Math.max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = Math.min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minHeightShelves(std::vector<std::vector<int>>& books, int shelfWidth) {\n    int n = books.size();\n    std::vector<int> dp(n + 1, 1000000);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        int width = 0, height = 0;\n        for (int j = i; j >= 1; --j) {\n            width += books[j - 1][0];\n            height = std::max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = std::min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "python": "\n    ```python\ndef minHeightShelves(books, shelfWidth):\n    n = len(books)\n    dp = [1000000] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        width = 0\n        height = 0\n        j = i\n        while j >= 1:\n            width += books[j - 1][0]\n            height = max(height, books[j - 1][1])\n            \n            if width <= shelfWidth:\n                dp[i] = min(dp[i], dp[j - 1] + height)\n            j -= 1\n    \n    return dp[n]\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "javascript": "\n    ```javascript\nfunction minHeightShelves(books, shelfWidth) {\n    const n = books.length;\n    const dp = new Array(n + 1).fill(1000000);\n    dp[0] = 0;\n    \n    for (let i = 1; i <= n; i++) {\n        let width = 0, height = 0;\n        for (let j = i; j >= 1; j--) {\n            width += books[j - 1][0];\n            height = Math.max(height, books[j - 1][1]);\n            \n            if (width <= shelfWidth)\n                dp[i] = Math.min(dp[i], dp[j - 1] + height);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We can solve this problem using dynamic programming. We create a DP array dp where dp[i] represents the minimum height of the bookshelf after placing the first i books. We initialize the DP array with a large number (e.g., 1000000) except for dp[0], which we set to 0.\n\nWe iterate over the books from 1 to n, and for each book, we go through another loop in reverse order from i to 1. In this inner loop, we keep track of the width and maximum height of the books we've seen so far. We calculate the width by adding the thickness of the current book (books[j - 1][0]) to the width accumulator, and update the maximum height (height) if the height of the current book (books[j - 1][1]) is greater than the previously stored maximum height.\n\nIf the width of the books we've seen does not exceed shelfWidth, we update dp[i] with the minimum between dp[i] and the sum of the height we would get by placing a new bookshelf below the current one (dp[j - 1] + height). We do this for every iteration in both loops.\n\nFinally, we return the value of dp[n], which represents the minimum height of the bookshelf after placing all the books.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " weight = [100,200,150,1000]",
                    "output": " 4",
                    "explanation": " All 4 apples can be carried by the basket since their sum of weights is 1450."
                },
                {
                    "input": " weight = [900,950,800,1000,700,800]",
                    "output": " 5",
                    "explanation": " The sum of weights of the 6 apples exceeds 5000 so we choose any 5 of them."
                }
            ],
            "function_input": [
                {
                    "input": "[100,200,150,1000]",
                    "output": "4"
                },
                {
                    "input": "[900,950,800,1000,700,800]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-190",
        "prompt": "You have some apples and a basket that can carry up to `5000` units of weight.\n\nGiven an integer array `weight` where `weight[i]` is the weight of the `ith` apple, return _the maximum number of apples you can put in the basket_."
    },
    "leetcode-benchmark-191": {
        "id": "leetcode-benchmark-191",
        "title": "Intersection of Three Sorted Arrays",
        "difficulty": "Easy",
        "content": {
            "problem": "Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr1 = \\[1,2,3,4,5\\], arr2 = \\[1,2,5,7,9\\], arr3 = \\[1,3,4,5,8\\]\n**Output:** \\[1,5\\]\n**Explanation:** Only 1 and 5 appeared in the three arrays.\n\n",
                "**Example 2:**\n\n**Input:** arr1 = \\[197,418,523,876,1356\\], arr2 = \\[501,880,1593,1710,1870\\], arr3 = \\[521,682,1337,1395,1764\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr1.length, arr2.length, arr3.length <= 1000`\n*   `1 <= arr1[i], arr2[i], arr3[i] <= 2000`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {\n    int i = 0, j = 0, k = 0;\n    ArrayList<Integer> result = new ArrayList<>();\n    while (i < arr1.length && j < arr2.length && k < arr3.length) {\n        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {\n            result.add(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> arraysIntersection(vector<int>& arr1, vector<int>& arr2, vector<int>& arr3) {\n    int i = 0, j = 0, k = 0;\n    vector<int> result;\n    while (i < arr1.size() && j < arr2.size() && k < arr3.size()) {\n        if (arr1[i] == arr2[j] && arr2[j] == arr3[k]) {\n            result.push_back(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "python": "\n    ```python\ndef arraysIntersection(arr1, arr2, arr3):\n    i, j, k = 0, 0, 0\n    result = []\n    while i < len(arr1) and j < len(arr2) and k < len(arr3):\n        if arr1[i] == arr2[j] and arr2[j] == arr3[k]:\n            result.append(arr1[i])\n            i, j, k = i + 1, j + 1, k + 1\n        else:\n            if arr1[i] <= arr2[j] and arr1[i] <= arr3[k]:\n                i += 1\n            elif arr2[j] <= arr3[k]:\n                j += 1\n            else:\n                k += 1\n    return result\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "javascript": "\n    ```javascript\nfunction arraysIntersection(arr1, arr2, arr3) {\n    let i = 0, j = 0, k = 0;\n    let result = [];\n    while (i < arr1.length && j < arr2.length && k < arr3.length) {\n        if (arr1[i] === arr2[j] && arr2[j] === arr3[k]) {\n            result.push(arr1[i]);\n            i++; j++; k++;\n        } else {\n            if (arr1[i] <= arr2[j] && arr1[i] <= arr3[k]) i++;\n            else if (arr2[j] <= arr3[k]) j++;\n            else k++;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm for finding the intersection of three sorted integer arrays follows these steps:\n\n1. Initialize three pointers, each pointing to the starting index of the three input arrays `arr1`, `arr2`, and `arr3`.\n2. Create an empty result array `result` to store the values found in the intersection.\n3. Use a `while` loop that continues as long as none of the pointers reach the end of their respective arrays.\n4. Inside the loop, compare the values pointed by the three pointers. \n5. If all three values are the same, add the value to the result array and move all three pointers forward by 1.\n6. If the values are not the same, find the minimum of the three values and move the pointer pointing to the minimum value forward by 1.\n7. When the loop ends and any of the pointers have reached the end of their respective arrays, the algorithm is terminated, and the result array is returned.\n\nThis algorithm has a time complexity of O(n), where n is the length of the input arrays since it only iterates once through the arrays. The space complexity is O(m) where m is the number of elements in the intersection.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr1 = [1,2,3,4,5], arr2 = [1,2,5,7,9], arr3 = [1,3,4,5,8]",
                    "output": " [1,5]",
                    "explanation": " Only 1 and 5 appeared in the three arrays."
                },
                {
                    "input": " arr1 = [197,418,523,876,1356], arr2 = [501,880,1593,1710,1870], arr3 = [521,682,1337,1395,1764]",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5],[1,2,5,7,9],[1,3,4,5,8]",
                    "output": "[1,5]"
                },
                {
                    "input": "[197,418,523,876,1356],[501,880,1593,1710,1870],[521,682,1337,1395,1764]",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-191",
        "prompt": "Given three integer arrays `arr1`, `arr2` and `arr3` **sorted** in **strictly increasing** order, return a sorted array of **only** the integers that appeared in **all** three arrays."
    },
    "leetcode-benchmark-192": {
        "id": "leetcode-benchmark-192",
        "title": "Minimum Cost to Move Chips to The Same Position",
        "difficulty": "Easy",
        "content": {
            "problem": "We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position.",
            "examples": [
                "**Example 1:**\n\n**Input:** position = \\[1,2,3\\]\n**Output:** 1\n**Explanation:** First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n",
                "**Example 2:**\n\n**Input:** position = \\[2,2,2,3,3\\]\n**Output:** 2\n**Explanation:** We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n",
                "**Example 3:**\n\n**Input:** position = \\[1,1000000000\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= position.length <= 100`\n*   `1 <= position[i] <= 10^9`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void sortArray(int[] arr1, int[] arr2) {\n    HashMap<Integer, Integer> counts = new HashMap<>();\n\n    for (int num : arr1) {\n        counts.put(num, counts.getOrDefault(num, 0) + 1);\n    }\n\n    int index = 0;\n    for (int num : arr2) {\n        while (counts.get(num) > 0) {\n            arr1[index++] = num;\n            counts.put(num, counts.get(num) - 1);\n        }\n    }\n\n    Arrays.sort(arr1, index, arr1.length);\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n#include <algorithm>\n\nvoid sortArray(vector<int>& arr1, vector<int>& arr2) {\n    map<int, int> counts;\n\n    for (int num : arr1) {\n        counts[num]++;\n    }\n    int index = 0;\n    for (int num : arr2) {\n        while (counts[num]--) {\n            arr1[index++] = num;\n        }\n    }\n    for (auto &pair : counts) {\n        while (pair.second--) {\n            arr1[index++] = pair.first;\n        }\n    }\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "python": "\n    ```python\ndef sort_array(arr1, arr2):\n    counts = {}\n    result = []\n\n    for num in arr1:\n        counts[num] = counts.get(num, 0) + 1\n\n    for num in arr2:\n        if num in counts:\n            result.extend([num] * counts[num])\n            del counts[num]\n\n    for num in sorted(counts.keys()):\n        result.extend([num] * counts[num])\n\n    return result\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "javascript": "\n    ```javascript\nfunction sortArray(arr1, arr2) {\n    const counts = new Map();\n\n    for (const num of arr1) {\n        counts.set(num, (counts.get(num) || 0) + 1);\n    }\n\n    const result = [];\n\n    for (const num of arr2) {\n        while (counts.get(num) > 0) {\n            result.push(num);\n            counts.set(num, counts.get(num) - 1);\n        }\n    }\n\n    Array.from(counts.entries())\n        .sort(([a], [b]) => a - b)\n        .forEach(([num, count]) => {\n            while (count--) {\n                result.push(num);\n            }\n        });\n\n    return result;\n}\n```\n    \n    1. Create a dictionary `counts` to store the count of each number in `arr1`.\n2. Iterate through the elements of `arr2`. For each element, add that element to the result `n` times where `n` is the count of that element in `arr1`. Remove the element from the `counts` dictionary.\n3. Iterate through the sorted keys of the remaining elements in `counts`. For each key, append the key to the result `n` times where `n` is the count of that element in `arr1`.\n4. Return the resulting sorted array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " position = [1,2,3]",
                    "output": " 1",
                    "explanation": " First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1."
                },
                {
                    "input": " position = [2,2,2,3,3]",
                    "output": " 2",
                    "explanation": " We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2."
                },
                {
                    "input": " position = [1,1000000000]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "1"
                },
                {
                    "input": "[2,2,2,3,3]",
                    "output": "2"
                },
                {
                    "input": "[1,1000000000]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-192",
        "prompt": "We have `n` chips, where the position of the `ith` chip is `position[i]`.\n\nWe need to move all the chips to **the same position**. In one step, we can change the position of the `ith` chip from `position[i]` to:\n\n*   `position[i] + 2` or `position[i] - 2` with `cost = 0`.\n*   `position[i] + 1` or `position[i] - 1` with `cost = 1`.\n\nReturn _the minimum cost_ needed to move all the chips to the same position."
    },
    "leetcode-benchmark-193": {
        "id": "leetcode-benchmark-193",
        "title": "Split a String in Balanced Strings",
        "difficulty": "Easy",
        "content": {
            "problem": "**Balanced** strings are those that have an equal quantity of `'L'` and `'R'` characters.\n\nGiven a **balanced** string `s`, split it into some number of substrings such that:\n\n*   Each substring is balanced.\n\nReturn _the **maximum** number of balanced strings you can obtain._",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"RLRRLLRLRL \"\n**Output:** 4\n**Explanation:** s can be split into  \"RL \",  \"RRLL \",  \"RL \",  \"RL \", each substring contains same number of 'L' and 'R'.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"RLRRRLLRLL \"\n**Output:** 2\n**Explanation:** s can be split into  \"RL \",  \"RRRLLRLL \", each substring contains same number of 'L' and 'R'.\nNote that s cannot be split into  \"RL \",  \"RR \",  \"RL \",  \"LR \",  \"LL \", because the 2nd and 5th substrings are not balanced.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LLLLRRRR \"\n**Output:** 1\n**Explanation:** s can be split into  \"LLLLRRRR \"."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= s.length <= 1000`\n*   `s[i]` is either `'L'` or `'R'`.\n*   `s` is a **balanced** string.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findSpecialInteger(int[] arr) {\n    int n = arr.length, requiredCount = n / 4;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "c++": "\n    ```cpp\nint findSpecialInteger(const vector<int>& arr) {\n    int n = arr.size(), requiredCount = n / 4;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "python": "\n    ```python\ndef find_special_integer(arr):\n    n = len(arr)\n    required_count = n // 4\n    for i in range(n):\n        if arr[i] == arr[i + required_count]:\n            return arr[i]\n    return -1\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "javascript": "\n    ```javascript\nfunction findSpecialInteger(arr) {\n    let n = arr.length, requiredCount = Math.floor(n / 4);\n    for (let i = 0; i < n; i++) {\n        if (arr[i] === arr[i + requiredCount]) {\n            return arr[i];\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm iterates through the sorted array once. At each iteration, it compares the current integer with the integer that's \"requiredCount\" positions ahead (where \"requiredCount\" is the number of elements divided by 4). If the two integers are the same, it means that the integer occurs more than 25% of the time in the array, and it is returned. If no such integer is found, the algorithm returns -1, which should not happen according to the problem constraints. The time complexity is O(n), where n is the number of elements in the array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"RLRRLLRLRL \"",
                    "output": " 4",
                    "explanation": " s can be split into  \"RL \",  \"RRLL \",  \"RL \",  \"RL \", each substring contains same number of 'L' and 'R'."
                },
                {
                    "input": " s =  \"RLRRRLLRLL \"",
                    "output": " 2",
                    "explanation": " s can be split into  \"RL \",  \"RRRLLRLL \", each substring contains same number of 'L' and 'R'.\nNote that s cannot be split into  \"RL \",  \"RR \",  \"RL \",  \"LR \",  \"LL \", because the 2nd and 5th substrings are not balanced."
                },
                {
                    "input": " s =  \"LLLLRRRR \"",
                    "output": " 1",
                    "explanation": " s can be split into  \"LLLLRRRR \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"RLRRLLRLRL\"",
                    "output": "4"
                },
                {
                    "input": "\"RLRRRLLRLL\"",
                    "output": "2"
                },
                {
                    "input": "\"LLLLRRRR\"",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-193",
        "prompt": "**Balanced** strings are those that have an equal quantity of `'L'` and `'R'` characters.\n\nGiven a **balanced** string `s`, split it into some number of substrings such that:\n\n*   Each substring is balanced.\n\nReturn _the **maximum** number of balanced strings you can obtain._"
    },
    "leetcode-benchmark-194": {
        "id": "leetcode-benchmark-194",
        "title": "Missing Number In Arithmetic Progression",
        "difficulty": "Easy",
        "content": {
            "problem": "In some array `arr`, the values were in arithmetic progression: the values `arr[i + 1] - arr[i]` are all equal for every `0 <= i < arr.length - 1`.\n\nA value from `arr` was removed that **was not the first or last value in the array**.\n\nGiven `arr`, return _the removed value_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[5,7,11,13\\]\n**Output:** 9\n**Explanation:** The previous array was \\[5,7,**9**,11,13\\].\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[15,13,12\\]\n**Output:** 14\n**Explanation:** The previous array was \\[15,**14**,13,12\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 1000`\n*   `0 <= arr[i] <= 105`\n*   The given array is **guaranteed** to be a valid array.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int mctFromLeafValues(int[] arr) {\n    int n = arr.length;\n    int[][] dp = new int[n][n];\n    int[][] maxs = new int[n][n];\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            maxs[i][j] = Arrays.stream(arr, i, j + 1).max().getAsInt();\n        }\n    }\n\n    for (int len = 1; len < n; ++len) {\n        for (int i = 0; i + len < n; ++i) {\n            int j = i + len;\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "c++": "\n    ```cpp\nint mctFromLeafValues(vector<int>& arr) {\n    int n = arr.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    vector<vector<int>> maxs(n, vector<int>(n, 0));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            maxs[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);\n        }\n    }\n\n    for (int len = 1; len < n; ++len) {\n        for (int i = 0; i + len < n; ++i) {\n            int j = i + len;\n            dp[i][j] = INT_MAX;\n            for (int k = i; k < j; ++k) {\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "python": "\n    ```python\ndef mctFromLeafValues(arr: List[int]) -> int:\n    n = len(arr)\n    dp = [[0] * n for _ in range(n)]\n    maxs = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i, n):\n            maxs[i][j] = max(arr[i:j+1])\n\n    for len_ in range(1, n):\n        for i in range(n - len_):\n            j = i + len_\n            dp[i][j] = float('inf')\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j])\n\n    return dp[0][n - 1]\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "javascript": "\n    ```javascript\nfunction mctFromLeafValues(arr) {\n    const n = arr.length;\n    const dp = Array(n).fill(0).map(() => Array(n).fill(0));\n    const maxs = Array(n).fill(0).map(() => Array(n).fill(0));\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = i; j < n; ++j) {\n            maxs[i][j] = Math.max(...arr.slice(i, j + 1));\n        }\n    }\n\n    for (let len = 1; len < n; ++len) {\n        for (let i = 0; i + len < n; ++i) {\n            let j = i + len;\n            dp[i][j] = Number.MAX_SAFE_INTEGER;\n            for (let k = i; k < j; ++k) {\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + maxs[i][k] * maxs[k + 1][j]);\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the smallest possible sum of non-leaf nodes. The 'dp' matrix stores the minimum sum for each sub-array within the input array 'arr'. The 'maxs' matrix stores the maximum values for each sub-array of 'arr'. To fill up the 'dp' matrix, the code iterates through sub-arrays of increasing length and uses previously computed values to find the minimum sum. It tries all possible binary trees using a nested loop and selects the one with the smallest sum. At the end, it returns the minimum sum of non-leaf nodes for the whole array, which is stored in dp[0][n-1].\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [5,7,11,13]",
                    "output": " 9",
                    "explanation": " The previous array was \\[5,7,**9**,11,13\\]."
                },
                {
                    "input": " arr = [15,13,12]",
                    "output": " 14",
                    "explanation": " The previous array was \\[15,**14**,13,12\\]."
                }
            ],
            "function_input": [
                {
                    "input": "[5,7,11,13]",
                    "output": "9"
                },
                {
                    "input": "[15,13,12]",
                    "output": "14"
                }
            ]
        },
        "task_id": "leetcode-benchmark-194",
        "prompt": "In some array `arr`, the values were in arithmetic progression: the values `arr[i + 1] - arr[i]` are all equal for every `0 <= i < arr.length - 1`.\n\nA value from `arr` was removed that **was not the first or last value in the array**.\n\nGiven `arr`, return _the removed value_."
    },
    "leetcode-benchmark-195": {
        "id": "leetcode-benchmark-195",
        "title": "Check If It Is a Straight Line",
        "difficulty": "Easy",
        "content": {
            "problem": "You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane.",
            "examples": [
                "**Example 1:**\n\n**Input:** coordinates = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[6,7\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** coordinates = \\[\\[1,1\\],\\[2,2\\],\\[3,4\\],\\[4,5\\],\\[5,6\\],\\[7,7\\]\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= coordinates.length <= 1000`\n*   `coordinates[i].length == 2`\n*   `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`\n*   `coordinates` contains no duplicate point.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findBestValue(int[] arr, int target) {\n    int left = 0;\n    int right = 0;\n    for (int num : arr) {\n        right = Math.max(right, num);\n    }\n    int result = -1;\n    int min_diff = Integer.MAX_VALUE;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int sum = 0;\n        for (int num : arr) {\n            sum += Math.min(num, mid);\n        }\n        if (sum == target) {\n            return mid;\n        }\n        else if (sum > target) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n        if (Math.abs(target - sum) < min_diff || Math.abs(target - sum) == min_diff && mid < result) {\n            min_diff = Math.abs(target - sum);\n            result = mid;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "c++": "\n    ```cpp\nint findBestValue(vector<int>& arr, int target) {\n    int left = 0;\n    int right = *max_element(arr.begin(), arr.end());\n    int result, min_diff = INT_MAX;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        int sum = 0;\n        for (int num : arr) {\n            sum += min(num, mid);\n        }\n        if (sum == target) {\n            return mid;\n        }\n        else if (sum > target) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n        if (abs(target - sum) < min_diff || abs(target - sum) == min_diff && mid < result) {\n            min_diff = abs(target - sum);\n            result = mid;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "python": "\n    ```python\ndef findBestValue(arr, target):\n    left = 0\n    right = max(arr)\n    result = -1\n    min_diff = float('inf')\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        total_sum = sum(min(x, mid) for x in arr)\n        if total_sum == target:\n            return mid\n        elif total_sum > target:\n            right = mid - 1\n        else:\n            left = mid + 1\n\n        if abs(target - total_sum) < min_diff or (\n                abs(target - total_sum) == min_diff and mid < result):\n            min_diff = abs(target - total_sum)\n            result = mid\n\n    return result\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "javascript": "\n    ```javascript\nfunction findBestValue(arr, target) {\n    let left = 0;\n    let right = Math.max(...arr);\n    let result = -1;\n    let min_diff = Infinity;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        let sum = 0;\n        for (let num of arr) {\n            sum += Math.min(num, mid);\n        }\n        if (sum === target) {\n            return mid;\n        }\n        else if (sum > target) {\n            right = mid - 1;\n        }\n        else {\n            left = mid + 1;\n        }\n        if (Math.abs(target - sum) < min_diff || (Math.abs(target - sum) === min_diff && mid < result)) {\n            min_diff = Math.abs(target - sum);\n            result = mid;\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm performs a binary search to find the best value. Initially, the search range is [0, max(arr)]. In each step, it calculates the mid-point of the current search range and computes the sum of the array elements after replacing all elements larger than mid with mid itself. If the sum is equal to the target, it returns the mid-point. Otherwise, the algorithm adjusts the search range based on whether the sum is greater than or less than the target.\n\nAt each step, the algorithm also keeps track of the minimum absolute difference between the target and the calculated sum. If a new candidate value (mid-point) is found that would result in a smaller absolute difference or an equal absolute difference and a smaller value, the algorithm updates the result.\n\nOnce the search range is exhausted (left > right), the algorithm returns the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]",
                    "output": "True"
                },
                {
                    "input": "[[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-195",
        "prompt": "You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane."
    },
    "leetcode-benchmark-196": {
        "id": "leetcode-benchmark-196",
        "title": "Array Transformation",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an initial array `arr`, every day you produce a new array using the array of the previous day.\n\nOn the `i`\\-th day, you do the following operations on the array of day `i-1` to produce the array of day `i`:\n\n1.  If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.\n2.  If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.\n3.  The first and last elements never change.\n\nAfter some days, the array does not change. Return that final array.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[6,2,3,4\\]\n**Output:** \\[6,3,3,4\\]\n**Explanation:** \nOn the first day, the array is changed from \\[6,2,3,4\\] to \\[6,3,3,4\\].\nNo more operations can be done to this array.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[1,6,3,4,3,5\\]\n**Output:** \\[1,4,4,4,4,5\\]\n**Explanation:** \nOn the first day, the array is changed from \\[1,6,3,4,3,5\\] to \\[1,5,4,3,4,5\\].\nOn the second day, the array is changed from \\[1,5,4,3,4,5\\] to \\[1,4,4,4,4,5\\].\nNo more operations can be done to this array."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= arr.length <= 100`\n*   `1 <= arr[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int sumEvenGrandparent(TreeNode root) {\n    return sumEvenGrandparent(root, null, null);\n}\n\nprivate int sumEvenGrandparent(TreeNode root, TreeNode parent, TreeNode grandparent) {\n    if (root == null) return 0;\n    int sum = 0;\n    if (grandparent != null && grandparent.val % 2 == 0) {\n        sum += root.val;\n    }\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);\n    return sum;\n}\n```\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "c++": "\n    ```cpp\nint sumEvenGrandparent(TreeNode* root, TreeNode* parent = nullptr, TreeNode* grandparent = nullptr) {\n    if (!root) return 0;\n    int sum = 0;\n    if (grandparent && grandparent->val % 2 == 0) {\n        sum += root->val;\n    }\n    sum += sumEvenGrandparent(root->left, root, parent) + sumEvenGrandparent(root->right, root, parent);\n    return sum;\n}\n```\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "python": "\n    ```python\ndef sumEvenGrandparent(root, parent=None, grandparent=None):\n    if not root:\n        return 0\n    sum = 0\n    if grandparent and grandparent.val % 2 == 0:\n        sum += root.val\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent)\n    return sum\n```\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "javascript": "\n    ```javascript\nfunction sumEvenGrandparent(root, parent = null, grandparent = null) {\n    if (!root) return 0;\n    let sum = 0;\n    if (grandparent && grandparent.val % 2 === 0) {\n        sum += root.val;\n    }\n    sum += sumEvenGrandparent(root.left, root, parent) + sumEvenGrandparent(root.right, root, parent);\n    return sum;\n}\n```\n\n    \n    We perform a depth-first search traversal of the binary tree. \nFor each node, we maintain the current node's parent and grandparent in the traversal.\nWhile traversing the tree, we check if the current node's grandparent has an even value.\nIf yes, we add the current node's value to the sum.\nThe algorithm is the same for all languages, with only syntax differences. \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [6,2,3,4]",
                    "output": " [6,3,3,4]",
                    "explanation": " \nOn the first day, the array is changed from \\[6,2,3,4\\] to \\[6,3,3,4\\].\nNo more operations can be done to this array."
                },
                {
                    "input": " arr = [1,6,3,4,3,5]",
                    "output": " [1,4,4,4,4,5]",
                    "explanation": " \nOn the first day, the array is changed from \\[1,6,3,4,3,5\\] to \\[1,5,4,3,4,5\\].\nOn the second day, the array is changed from \\[1,5,4,3,4,5\\] to \\[1,4,4,4,4,5\\].\nNo more operations can be done to this array."
                }
            ],
            "function_input": [
                {
                    "input": "[6,2,3,4]",
                    "output": "[6,3,3,4]"
                },
                {
                    "input": "[1,6,3,4,3,5]",
                    "output": "[1,4,4,4,4,5]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-196",
        "prompt": "Given an initial array `arr`, every day you produce a new array using the array of the previous day.\n\nOn the `i`\\-th day, you do the following operations on the array of day `i-1` to produce the array of day `i`:\n\n1.  If an element is smaller than both its left neighbor and its right neighbor, then this element is incremented.\n2.  If an element is bigger than both its left neighbor and its right neighbor, then this element is decremented.\n3.  The first and last elements never change.\n\nAfter some days, the array does not change. Return that final array."
    },
    "leetcode-benchmark-197": {
        "id": "leetcode-benchmark-197",
        "title": "Cells with Odd Values in a Matrix",
        "difficulty": "Easy",
        "content": {
            "problem": "There is an `m x n` matrix that is initialized to all `0`'s. There is also a 2D array `indices` where each `indices[i] = [ri, ci]` represents a **0-indexed location** to perform some increment operations on the matrix.\n\nFor each location `indices[i]`, do **both** of the following:\n\n1.  Increment **all** the cells on row `ri`.\n2.  Increment **all** the cells on column `ci`.\n\nGiven `m`, `n`, and `indices`, return _the **number of odd-valued cells** in the matrix after applying the increment to all locations in_ `indices`.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 2, n = 3, indices = \\[\\[0,1\\],\\[1,1\\]\\]\n**Output:** 6\n**Explanation:** Initial matrix = \\[\\[0,0,0\\],\\[0,0,0\\]\\].\nAfter applying first increment it becomes \\[\\[1,2,1\\],\\[0,1,0\\]\\].\nThe final matrix is \\[\\[1,3,1\\],\\[1,3,1\\]\\], which contains 6 odd numbers.\n\n",
                "**Example 2:**\n\n**Input:** m = 2, n = 2, indices = \\[\\[1,1\\],\\[0,0\\]\\]\n**Output:** 0\n**Explanation:** Final matrix = \\[\\[2,2\\],\\[2,2\\]\\]. There are no odd numbers in the final matrix."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 50`\n*   `1 <= indices.length <= 100`\n*   `0 <= ri < m`\n*   `0 <= ci < n`\n\n**",
            "follow_up": "Follow up:** Could you solve this in `O(n + m + indices.length)` time with only `O(n + m)` extra space?"
        },
        "java": "\n    ```java\npublic String breakPalindrome(String palindrome) {\n    int n = palindrome.length();\n    if (n < 2) return \"\";\n    \n    char[] arr = palindrome.toCharArray();\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != 'a') {\n            arr[i] = 'a';\n            return new String(arr);\n        }\n    }\n    \n    arr[n - 1] = 'b';\n    return new String(arr);\n}\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string breakPalindrome(std::string palindrome) {\n    int n = palindrome.size();\n    if (n < 2) return \"\";\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (palindrome[i] != 'a') {\n            palindrome[i] = 'a';\n            return palindrome;\n        }\n    }\n    \n    palindrome[n - 1] = 'b';\n    return palindrome;\n}\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "python": "\n    ```python\ndef break_palindrome(palindrome: str) -> str:\n    n = len(palindrome)\n    if n < 2:\n        return \"\"\n    \n    palindrome = list(palindrome)\n    for i in range(n // 2):\n        if palindrome[i] != 'a':\n            palindrome[i] = 'a'\n            return \"\".join(palindrome)\n    \n    palindrome[-1] = 'b'\n    return \"\".join(palindrome)\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "javascript": "\n    ```javascript\nfunction breakPalindrome(palindrome) {\n    const n = palindrome.length;\n    if (n < 2) return \"\";\n    \n    let arr = palindrome.split(\"\");\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        if (arr[i] !== 'a') {\n            arr[i] = 'a';\n            return arr.join(\"\");\n        }\n    }\n    \n    arr[n - 1] = 'b';\n    return arr.join(\"\");\n}\n```\n    \n    The algorithm starts by checking if the length of the input string is less than 2, in which case it returns an empty string, as there is no way to make it non-palindrome with a single character replacement. \n\nThen, it iterates over the characters of the string up to the middle position (length / 2). If it finds a character different from 'a', it replaces the character with 'a' to ensure lexicographically smallest result, and returns the modified string.\n\nIf the loop ends and all characters up to the middle are 'a's, then it replaces the last character of the string with 'b' and returns the modified string. This ensures that the string is no longer a palindrome, and retains the lexicographically smallest property.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " m = 2, n = 3, indices = [[0,1],[1,1]]",
                    "output": " 6",
                    "explanation": " Initial matrix = \\[\\[0,0,0\\],\\[0,0,0\\]\\].\nAfter applying first increment it becomes \\[\\[1,2,1\\],\\[0,1,0\\]\\].\nThe final matrix is \\[\\[1,3,1\\],\\[1,3,1\\]\\], which contains 6 odd numbers."
                },
                {
                    "input": " m = 2, n = 2, indices = [[1,1],[0,0]]",
                    "output": " 0",
                    "explanation": " Final matrix = \\[\\[2,2\\],\\[2,2\\]\\]. There are no odd numbers in the final matrix."
                }
            ],
            "function_input": [
                {
                    "input": "2,3,[[0,1],[1,1]]",
                    "output": "6"
                },
                {
                    "input": "2,2,[[1,1],[0,0]]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-197",
        "prompt": "There is an `m x n` matrix that is initialized to all `0`'s. There is also a 2D array `indices` where each `indices[i] = [ri, ci]` represents a **0-indexed location** to perform some increment operations on the matrix.\n\nFor each location `indices[i]`, do **both** of the following:\n\n1.  Increment **all** the cells on row `ri`.\n2.  Increment **all** the cells on column `ci`.\n\nGiven `m`, `n`, and `indices`, return _the **number of odd-valued cells** in the matrix after applying the increment to all locations in_ `indices`."
    },
    "leetcode-benchmark-198": {
        "id": "leetcode-benchmark-198",
        "title": "Shift 2D Grid",
        "difficulty": "Easy",
        "content": {
            "problem": "Given a 2D `grid` of size `m x n` and an integer `k`. You need to shift the `grid` `k` times.\n\nIn one shift operation:\n\n*   Element at `grid[i][j]` moves to `grid[i][j + 1]`.\n*   Element at `grid[i][n - 1]` moves to `grid[i + 1][0]`.\n*   Element at `grid[m - 1][n - 1]` moves to `grid[0][0]`.\n\nReturn the _2D grid_ after applying shift operation `k` times.",
            "examples": [
                "**Example 1:**\n\n**Input:** `grid` = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 1\n**Output:** \\[\\[9,1,2\\],\\[3,4,5\\],\\[6,7,8\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** `grid` = \\[\\[3,8,1,9\\],\\[19,7,2,5\\],\\[4,6,11,10\\],\\[12,0,21,13\\]\\], k = 4\n**Output:** \\[\\[12,0,21,13\\],\\[3,8,1,9\\],\\[19,7,2,5\\],\\[4,6,11,10\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** `grid` = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\], k = 9\n**Output:** \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m <= 50`\n*   `1 <= n <= 50`\n*   `-1000 <= grid[i][j] <= 1000`\n*   `0 <= k <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int dayOfYear(String date) {\n    int year = Integer.parseInt(date.substring(0, 4));\n    int month = Integer.parseInt(date.substring(5, 7));\n    int day = Integer.parseInt(date.substring(8, 10));\n\n    int[] daysInMonth = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n        daysInMonth[2] = 29;\n    }\n\n    int dayOfYear = 0;\n    for (int i = 1; i < month; i++) {\n        dayOfYear += daysInMonth[i];\n    }\n    dayOfYear += day;\n\n    return dayOfYear;\n}\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "c++": "\n    ```cpp\nint dayOfYear(std::string date) {\n    int year = stoi(date.substr(0, 4));\n    int month = stoi(date.substr(5, 2));\n    int day = stoi(date.substr(8, 2));\n\n    int daysInMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0)) {\n        daysInMonth[2] = 29;\n    }\n\n    int dayOfYear = 0;\n    for (int i = 1; i < month; ++i) {\n        dayOfYear += daysInMonth[i];\n    }\n    dayOfYear += day;\n\n    return dayOfYear;\n}\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "python": "\n    ```python\ndef dayOfYear(date: str) -> int:\n    year, month, day = map(int, date.split('-'))\n\n    daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n        daysInMonth[2] = 29\n\n    dayOfYear = sum(daysInMonth[:month]) + day\n    return dayOfYear\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "javascript": "\n    ```javascript\nfunction dayOfYear(date) {\n    let [year, month, day] = date.split('-').map(x => parseInt(x, 10));\n\n    let daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {\n        daysInMonth[2] = 29;\n    }\n\n    let dayOfYear = 0;\n    for (let i = 1; i < month; i++) {\n        dayOfYear += daysInMonth[i];\n    }\n    dayOfYear += day;\n\n    return dayOfYear;\n}\n```\n    \n    1. Parse the input string to extract the year, month, and day as integers.\n2. Create an array `daysInMonth` representing the days in each month, with a special case for February in leap years.\n3. Iterate through the `daysInMonth` array up to the given month, accumulating the days in each month.\n4. Add the given day to the accumulated days to get the day number of the year.\n5. Return the resulting day number of the year.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 1",
                    "output": " [[9,1,2],[3,4,5],[6,7,8]]",
                    "explanation": null
                },
                {
                    "input": " `grid` = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4",
                    "output": " [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]",
                    "explanation": null
                },
                {
                    "input": " `grid` = [[1,2,3],[4,5,6],[7,8,9]], k = 9",
                    "output": " [[1,2,3],[4,5,6],[7,8,9]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2,3],[4,5,6],[7,8,9]],1",
                    "output": "[[9,1,2],[3,4,5],[6,7,8]]"
                },
                {
                    "input": "[[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]],4",
                    "output": "[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]"
                },
                {
                    "input": "[[1,2,3],[4,5,6],[7,8,9]],9",
                    "output": "[[1,2,3],[4,5,6],[7,8,9]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-198",
        "prompt": "Given a 2D `grid` of size `m x n` and an integer `k`. You need to shift the `grid` `k` times.\n\nIn one shift operation:\n\n*   Element at `grid[i][j]` moves to `grid[i][j + 1]`.\n*   Element at `grid[i][n - 1]` moves to `grid[i + 1][0]`.\n*   Element at `grid[m - 1][n - 1]` moves to `grid[0][0]`.\n\nReturn the _2D grid_ after applying shift operation `k` times."
    },
    "leetcode-benchmark-199": {
        "id": "leetcode-benchmark-199",
        "title": "Minimum Time Visiting All Points",
        "difficulty": "Easy",
        "content": {
            "problem": "On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`.\n\nYou can move according to these rules:\n\n*   In `1` second, you can either:\n    *   move vertically by one unit,\n    *   move horizontally by one unit, or\n    *   move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).\n*   You have to visit the points in the same order as they appear in the array.\n*   You are allowed to pass through points that appear later in the order, but these do not count as visits.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,4\\],\\[-1,0\\]\\]\n**Output:** 7\n**Explanation:** One optimal path is **\\[1,1\\]** -> \\[2,2\\] -> \\[3,3\\] -> **\\[3,4\\]** \\-> \\[2,3\\] -> \\[1,2\\] -> \\[0,1\\] -> **\\[-1,0\\]**   \nTime from \\[1,1\\] to \\[3,4\\] = 3 seconds \nTime from \\[3,4\\] to \\[-1,0\\] = 4 seconds\nTotal time = 7 seconds\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[3,2\\],\\[-2,2\\]\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `points.length == n`\n*   `1 <= n <= 100`\n*   `points[i].length == 2`\n*   `-1000 <= points[i][0], points[i][1] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minTimeToVisitAllPoints(int[][] points) {\n    int time = 0;\n    for (int i = 1; i < points.length; i++) {\n        int dx = Math.abs(points[i][0] - points[i - 1][0]);\n        int dy = Math.abs(points[i][1] - points[i - 1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "c++": "\n    ```cpp\nint minTimeToVisitAllPoints(vector<vector<int>>& points) {\n    int time = 0;\n    for (int i = 1; i < points.size(); i++) {\n        int dx = abs(points[i][0] - points[i - 1][0]);\n        int dy = abs(points[i][1] - points[i - 1][1]);\n        time += max(dx, dy);\n    }\n    return time;\n}\n```\n\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "python": "\n    ```python\ndef minTimeToVisitAllPoints(points):\n    time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i - 1][0])\n        dy = abs(points[i][1] - points[i - 1][1])\n        time += max(dx, dy)\n    return time\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "javascript": "\n    ```javascript\nfunction minTimeToVisitAllPoints(points) {\n    let time = 0;\n    for (let i = 1; i < points.length; i++) {\n        let dx = Math.abs(points[i][0] - points[i - 1][0]);\n        let dy = Math.abs(points[i][1] - points[i - 1][1]);\n        time += Math.max(dx, dy);\n    }\n    return time;\n}\n```\n    \n    We iterate through every point in the given order. At each point, we calculate the horizontal distance `dx` and the vertical distance `dy` between the current point and the previous point. The minimum time to move between these two points is the maximum of `dx` and `dy`. This is because the diagonal movement can shorten both distances simultaneously. We add this value to the total time and continue until all points are visited.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " points = [[1,1],[3,4],[-1,0]]",
                    "output": " 7",
                    "explanation": " One optimal path is **\\[1,1\\]** -> \\[2,2\\] -> \\[3,3\\] -> **\\[3,4\\]** \\-> \\[2,3\\] -> \\[1,2\\] -> \\[0,1\\] -> **\\[-1,0\\]**   \nTime from \\[1,1\\] to \\[3,4\\] = 3 seconds \nTime from \\[3,4\\] to \\[-1,0\\] = 4 seconds\nTotal time = 7 seconds"
                },
                {
                    "input": " points = [[3,2],[-2,2]]",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1],[3,4],[-1,0]]",
                    "output": "7"
                },
                {
                    "input": "[[3,2],[-2,2]]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-199",
        "prompt": "On a 2D plane, there are `n` points with integer coordinates `points[i] = [xi, yi]`. Return _the **minimum time** in seconds to visit all the points in the order given by_ `points`.\n\nYou can move according to these rules:\n\n*   In `1` second, you can either:\n    *   move vertically by one unit,\n    *   move horizontally by one unit, or\n    *   move diagonally `sqrt(2)` units (in other words, move one unit vertically then one unit horizontally in `1` second).\n*   You have to visit the points in the same order as they appear in the array.\n*   You are allowed to pass through points that appear later in the order, but these do not count as visits."
    },
    "leetcode-benchmark-200": {
        "id": "leetcode-benchmark-200",
        "title": "Hexspeak",
        "difficulty": "Easy",
        "content": {
            "problem": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"257 \"\n**Output:**  \"IOI \"\n**Explanation:** 257 is 101 in hexadecimal.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"3 \"\n**Output:**  \"ERROR \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 12`\n*   `num` does not contain leading zeros.\n*   num represents an integer in the range `[1, 1012]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String toHexspeak(String num) {\n    long n = Long.parseLong(num);\n    StringBuilder hex = new StringBuilder();\n    while (n != 0) {\n        int rem = (int)(n % 16);\n        if (rem == 1) hex.insert(0, 'I');\n        else if (rem == 0) hex.insert(0, 'O');\n        else if (rem > 9) hex.insert(0, (char)(rem - 10 + 'A'));\n        else return \"ERROR\";\n        n /= 16;\n    }\n    return hex.toString();\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string toHexspeak(std::string num) {\n    long n = std::stol(num);\n    std::string hex = \"\";\n    while (n) {\n        int rem = n % 16;\n        if (rem == 1) hex = \"I\" + hex;\n        else if (rem == 0) hex = \"O\" + hex;\n        else if (rem > 9) hex = (char)(rem - 10 + 'A') + hex;\n        else return \"ERROR\";\n        n /= 16;\n    }\n    return hex;\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "python": "\n    ```python\ndef to_hexspeak(num: str) -> str:\n    n = int(num)\n    hex_str = []\n    while n:\n        rem = n % 16\n        if rem == 1: hex_str.insert(0, 'I')\n        elif rem == 0: hex_str.insert(0, 'O')\n        elif rem > 9: hex_str.insert(0, chr(rem - 10 + ord('A')))\n        else: return 'ERROR'\n        n //= 16\n    return ''.join(hex_str)\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "javascript": "\n    ```javascript\nfunction toHexspeak(num) {\n    let n = BigInt(num);\n    let hex = '';\n    while (n) {\n        let rem = Number(n % 16n);\n        if (rem === 1) hex = 'I' + hex;\n        else if (rem === 0) hex = 'O' + hex;\n        else if (rem > 9) hex = String.fromCharCode(rem - 10 + 'A'.charCodeAt(0)) + hex;\n        else return 'ERROR';\n        n /= 16n;\n    }\n    return hex;\n}\n```\n    \n    The algorithm first converts the input number (given as a string) to a long integer (we'll call it `n`). We then use a loop to construct the Hexspeak representation in reverse order. In each iteration, we calculate the remainder `rem` of `n` divided by 16. If `rem` is 1, we append 'I' to the beginning of the string; if it is 0, we append 'O'; if it is greater than 9, we append the corresponding letter ('A' to 'F'); and if it is none of these, then the Hexspeak representation is invalid, and we return \"ERROR\". After processing each character, we update `n` by dividing it by 16. Finally, we return the constructed Hexspeak representation.\n\nThis algorithm runs in O(log(n)) time complexity, as each iteration of the loop reduces `n` by a factor of 16. The space complexity is also O(log(n)), as the constructed Hexspeak representation string has a length proportional to the number of hexadecimal digits in `n`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num =  \"257 \"",
                    "output": "  \"IOI \"",
                    "explanation": " 257 is 101 in hexadecimal."
                },
                {
                    "input": " num =  \"3 \"",
                    "output": "  \"ERROR \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"257\"",
                    "output": "\"IOI\""
                },
                {
                    "input": "\"3\"",
                    "output": "\"ERROR\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-200",
        "prompt": "A decimal number can be converted to its **Hexspeak representation** by first converting it to an uppercase hexadecimal string, then replacing all occurrences of the digit `'0'` with the letter `'O'`, and the digit `'1'` with the letter `'I'`. Such a representation is valid if and only if it consists only of the letters in the set `{'A', 'B', 'C', 'D', 'E', 'F', 'I', 'O'}`.\n\nGiven a string `num` representing a decimal integer `n`, _return the **Hexspeak representation** of_ `n` _if it is valid, otherwise return_ `\"ERROR \"`."
    },
    "leetcode-benchmark-201": {
        "id": "leetcode-benchmark-201",
        "title": "Find Winner on a Tic Tac Toe Game",
        "difficulty": "Easy",
        "content": {
            "problem": "**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The rules of Tic-Tac-Toe are:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player `A` always places `'X'` characters, while the second player `B` always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never on filled ones.\n*   The game ends when there are **three** of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi, coli]` indicates that the `ith` move will be played on `grid[rowi][coli]`. return _the winner of the game if it exists_ (`A` or `B`). In case the game ends in a draw return `\"Draw \"`. If there are still movements to play return `\"Pending \"`.\n\nYou can assume that `moves` is valid (i.e., it follows the rules of **Tic-Tac-Toe**), the grid is initially empty, and `A` will play first.",
            "examples": [
                "**Example 1:**\n\n**Input:** moves = \\[\\[0,0\\],\\[2,0\\],\\[1,1\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:**  \"A \"\n**Explanation:** A wins, they always play first.\n\n",
                "**Example 2:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[0,1\\],\\[0,2\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:**  \"B \"\n**Explanation:** B wins.\n\n",
                "**Example 3:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\],\\[1,0\\],\\[1,2\\],\\[2,1\\],\\[0,1\\],\\[0,2\\],\\[2,2\\]\\]\n**Output:**  \"Draw \"\n**Explanation:** The game ends in a draw since there are no moves to make."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= moves.length <= 9`\n*   `moves[i].length == 2`\n*   `0 <= rowi, coli <= 2`\n*   There are no repeated elements on `moves`.\n*   `moves` follow the rules of tic tac toe.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {\n    int[] parent = new int[n];\n    Arrays.fill(parent, -1);\n    for (int i = 0; i < n; i++) {\n        if (leftChild[i] != -1) {\n            if (parent[leftChild[i]] != -1) return false;\n            parent[leftChild[i]] = i;\n        }\n        if (rightChild[i] != -1) {\n            if (parent[rightChild[i]] != -1) return false;\n            parent[rightChild[i]] = i;\n        }\n    }\n    int root = -1;\n    for (int i = 0; i < n; i++) {\n        if (parent[i] == -1) {\n            if (root != -1) return false;\n            root = i;\n        }\n    }\n    return root != -1;\n}\n```\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "c++": "\n    ```cpp\nbool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n    vector<int> parent(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (leftChild[i] != -1) {\n            if (parent[leftChild[i]] != -1) return false;\n            parent[leftChild[i]] = i;\n        }\n        if (rightChild[i] != -1) {\n            if (parent[rightChild[i]] != -1) return false;\n            parent[rightChild[i]] = i;\n        }\n    }\n    int root = -1;\n    for (int i = 0; i < n; ++i) {\n        if (parent[i] == -1) {\n            if (root != -1) return false;\n            root = i;\n        }\n    }\n    return root != -1;\n}\n```\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "python": "\n    ```python\ndef validateBinaryTreeNodes(n, leftChild, rightChild):\n    parent = [-1] * n\n    for i in range(n):\n        if leftChild[i] != -1:\n            if parent[leftChild[i]] != -1:\n                return False\n            parent[leftChild[i]] = i\n        if rightChild[i] != -1:\n            if parent[rightChild[i]] != -1:\n                return False\n            parent[rightChild[i]] = i\n    \n    root = -1\n    for i in range(n):\n        if parent[i] == -1:\n            if root != -1:\n                return False\n            root = i\n\n    return root != -1\n```\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "javascript": "\n    ```javascript\nfunction validateBinaryTreeNodes(n, leftChild, rightChild) {\n    const parent = new Array(n).fill(-1);\n    for (let i = 0; i < n; i++) {\n        if (leftChild[i] !== -1) {\n            if (parent[leftChild[i]] !== -1) return false;\n            parent[leftChild[i]] = i;\n        }\n        if (rightChild[i] !== -1) {\n            if (parent[rightChild[i]] !== -1) return false;\n            parent[rightChild[i]] = i;\n        }\n    }\n    let root = -1;\n    for (let i = 0; i < n; i++) {\n        if (parent[i] === -1) {\n            if (root !== -1) return false;\n            root = i;\n        }\n    }\n    return root !== -1;\n}\n```\n\n    \n    1. Create an array `parent` to keep track of the parent of each node. Initialize each element to -1.\n2. Iterate through each node i:\n   a. Check the left child of i. If it's not -1, check if it already has a parent. If it does, return false (two parents for a node makes it an invalid tree). Set the parent of the left child to i.\n   b. Do the same for the right child.\n3. Iterate through the parent array to find a node without a parent (root). If a root is found and another node without a parent is found later, return false (more than one tree).\n4. If a root is found, return true (a valid tree). Otherwise, return false (no tree found).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]",
                    "output": "  \"A \"",
                    "explanation": " A wins, they always play first."
                },
                {
                    "input": " moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]",
                    "output": "  \"B \"",
                    "explanation": " B wins."
                },
                {
                    "input": " moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]",
                    "output": "  \"Draw \"",
                    "explanation": " The game ends in a draw since there are no moves to make."
                }
            ],
            "function_input": [
                {
                    "input": "[[0,0],[2,0],[1,1],[2,1],[2,2]]",
                    "output": "\"A\""
                },
                {
                    "input": "[[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]",
                    "output": "\"B\""
                },
                {
                    "input": "[[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]",
                    "output": "\"Draw\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-201",
        "prompt": "**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The rules of Tic-Tac-Toe are:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player `A` always places `'X'` characters, while the second player `B` always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never on filled ones.\n*   The game ends when there are **three** of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi, coli]` indicates that the `ith` move will be played on `grid[rowi][coli]`. return _the winner of the game if it exists_ (`A` or `B`). In case the game ends in a draw return `\"Draw \"`. If there are still movements to play return `\"Pending \"`.\n\nYou can assume that `moves` is valid (i.e., it follows the rules of **Tic-Tac-Toe**), the grid is initially empty, and `A` will play first."
    },
    "leetcode-benchmark-202": {
        "id": "leetcode-benchmark-202",
        "title": "Subtract the Product and Sum of Digits of an Integer",
        "difficulty": "Easy",
        "content": {
            "problem": "Given an integer number `n`, return the difference between the product of its digits and the sum of its digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 234\n**Output:** 15 \n**Explanation:** \nProduct of digits = 2 \\* 3 \\* 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15\n\n",
                "**Example 2:**\n\n**Input:** n = 4421\n**Output:** 21\n**Explanation:** \nProduct of digits = 4 \\* 4 \\* 2 \\* 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 10^5`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Boolean> canMakePaliQueries(String s, int[][] queries) {\n    List<Boolean> result = new ArrayList<>();\n    for (int[] query : queries) {\n        int left = query[0], right = query[1], k = query[2];\n        int[] count = new int[26];\n        for (int i = left; i <= right; i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        int odd_count = 0;\n        for (int i = 0; i < 26; i++) {\n            odd_count += count[i] % 2;\n        }\n        result.add(odd_count / 2 <= k);\n    }\n    return result;\n}\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<bool> canMakePaliQueries(std::string s, std::vector<std::vector<int>>& queries) {\n    std::vector<bool> result;\n    for (auto& query : queries) {\n        int left = query[0], right = query[1], k = query[2];\n        int count[26] = {0};\n        for (int i = left; i <= right; i++) {\n            count[s[i] - 'a']++;\n        }\n        int odd_count = 0;\n        for (int i = 0; i < 26; i++) {\n            odd_count += count[i] % 2;\n        }\n        result.push_back(odd_count / 2 <= k);\n    }\n    return result;\n}\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "python": "\n    ```python\ndef can_make_pali_queries(s, queries):\n    result = []\n    for left, right, k in queries:\n        count = [0] * 26\n        for i in range(left, right + 1):\n            count[ord(s[i]) - ord('a')] += 1\n        odd_count = sum(c % 2 for c in count)\n        result.append(odd_count // 2 <= k)\n    return result\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "javascript": "\n    ```javascript\nfunction canMakePaliQueries(s, queries) {\n    const result = [];\n    for (const query of queries) {\n        const [left, right, k] = query;\n        const count = Array(26).fill(0);\n        for (let i = left; i <= right; i++) {\n            count[s.charCodeAt(i) - 97]++;\n        }\n        const odd_count = count.reduce((acc, val) => acc + (val % 2), 0);\n        result.push(Math.floor(odd_count / 2) <= k);\n    }\n    return result;\n}\n```\n    \n    1. Iterate through each query, and get the values of left, right, and k.\n2. Create an array count with 26 elements for each English lowercase letter.\n3. Iterate from left to right, count occurrences of each letter in the substring s[left...right].\n4. Calculate the number of odd counts of the letters.\n5. Determine if the number of odd counts divided by 2 is less than or equal to k. If true, append true to the result, otherwise append false.\n6. After all queries are processed, return the result array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 234",
                    "output": " 15",
                    "explanation": " \nProduct of digits = 2 \\* 3 \\* 4 = 24 \nSum of digits = 2 + 3 + 4 = 9 \nResult = 24 - 9 = 15"
                },
                {
                    "input": " n = 4421",
                    "output": " 21",
                    "explanation": " \nProduct of digits = 4 \\* 4 \\* 2 \\* 1 = 32 \nSum of digits = 4 + 4 + 2 + 1 = 11 \nResult = 32 - 11 = 21"
                }
            ],
            "function_input": [
                {
                    "input": "234",
                    "output": "15"
                },
                {
                    "input": "4421",
                    "output": "21"
                }
            ]
        },
        "task_id": "leetcode-benchmark-202",
        "prompt": "Given an integer number `n`, return the difference between the product of its digits and the sum of its digits."
    }
}