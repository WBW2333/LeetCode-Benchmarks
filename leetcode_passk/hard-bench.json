{
    "leetcode-benchmark-0": {
        "id": "leetcode-benchmark-0",
        "title": "Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums1 = \\[1,3\\], nums2 = \\[2\\]\n**Output:** 2.00000\n**Explanation:** merged array = \\[1,2,3\\] and median is 2.\n\n",
                "**Example 2:**\n\n**Input:** nums1 = \\[1,2\\], nums2 = \\[3,4\\]\n**Output:** 2.50000\n**Explanation:** merged array = \\[1,2,3,4\\] and median is (2 + 3) / 2 = 2.5."
            ],
            "constraints": "**Constraints:**\n\n*   `nums1.length == m`\n*   `nums2.length == n`\n*   `0 <= m <= 1000`\n*   `0 <= n <= 1000`\n*   `1 <= m + n <= 2000`\n*   `-106 <= nums1[i], nums2[i] <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.length;\n    int y = nums2.length;\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double)(Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "c++": "\n    ```cpp\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    int x = nums1.size();\n    int y = nums2.size();\n    int low = 0;\n    int high = x;\n    \n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n        \n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n        \n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return (double(max(maxLeftX, maxLeftY) + min(minRightX, minRightY))) / 2;\n            } else {\n                return double(max(maxLeftX, maxLeftY));\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "python": "\n    ```python\ndef findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n\n    while low <= high:\n        partition_x = (low + high) // 2\n        partition_y = (x + y + 1) // 2 - partition_x\n\n        max_left_x = float('-inf') if partition_x == 0 else nums1[partition_x - 1]\n        min_right_x = float('inf') if partition_x == x else nums1[partition_x]\n\n        max_left_y = float('-inf') if partition_y == 0 else nums2[partition_y - 1]\n        min_right_y = float('inf') if partition_y == y else nums2[partition_y]\n\n        if max_left_x <= min_right_y and max_left_y <= min_right_x:\n            if (x + y) % 2 == 0:\n                return (max(max_left_x, max_left_y) + min(min_right_x, min_right_y)) / 2\n            else:\n                return max(max_left_x, max_left_y)\n        elif max_left_x > min_right_y:\n            high = partition_x - 1\n        else:\n            low = partition_x + 1\n    \n    return 0\n```\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "javascript": "\n    ```javascript\nfunction findMedianSortedArrays(nums1, nums2) {\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        const maxLeftX = (partitionX === 0) ? Number.NEGATIVE_INFINITY : nums1[partitionX - 1];\n        const minRightX = (partitionX === x) ? Number.POSITIVE_INFINITY : nums1[partitionX];\n        \n        const maxLeftY = (partitionY === 0) ? Number.NEGATIVE_INFINITY : nums2[partitionY - 1];\n        const minRightY = (partitionY === y) ? Number.POSITIVE_INFINITY : nums2[partitionY];\n        \n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 === 0) {\n                return (Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n            } else {\n                return Math.max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }    \n    return 0;\n}\n```\n\n    \n    1. Choose the smaller array as nums1 so that the problem is simpler with less log(n) complexity.\n2. Use Binary Search (BS) to partition the smallest array.\n3. Now we calculate the position of partition in the larger array (nums2) having fetched the smaller one.\n4. Find the four important numbers - maxSize - left and right of partition in the two arrays.\n5. If maxSizeLeft <= minSizeRight and maxSizeLeft2 <= minSizeRight2, then the partition of both arrays is correct, if not, adjust the partition of nums1. If maxLeftX > minRightY, move the BS partition to the left; if maxLeftY > minRightX, move the BS partition to the right.\n6. When the correct partition is found, calculate the median based on the length of the merged array, even or odd.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums1 = [1,3], nums2 = [2]",
                    "output": " 2.00000",
                    "explanation": " merged array = \\[1,2,3\\] and median is 2."
                },
                {
                    "input": " nums1 = [1,2], nums2 = [3,4]",
                    "output": " 2.50000",
                    "explanation": " merged array = \\[1,2,3,4\\] and median is (2 + 3) / 2 = 2.5."
                }
            ],
            "function_input": [
                {
                    "input": "[1,3],[2]",
                    "output": "2.00000"
                },
                {
                    "input": "[1,2],[3,4]",
                    "output": "2.50000"
                }
            ]
        },
        "task_id": "leetcode-benchmark-0",
        "prompt": "Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.\n\nThe overall run time complexity should be `O(log (m+n))`."
    },
    "leetcode-benchmark-1": {
        "id": "leetcode-benchmark-1",
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.​​​​\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"a\\* \"\n**Output:** true\n**Explanation:** '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"ab \", p =  \".\\* \"\n**Output:** true\n**Explanation:**  \".\\* \" means  \"zero or more (\\*) of any character (.) \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= p.length <= 20`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'.'`, and `'*'`.\n*   It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p.charAt(j - 1) == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == s.charAt(i - 1) || p.charAt(j - 1) == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p.charAt(j - 1) == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "c++": "\n    ```cpp\nbool isMatch(std::string s, std::string p) {\n    int m = s.length(), n = p.length();\n    std::vector<std::vector<bool>> dp(m + 1, std::vector<bool>(n + 1, false));\n    dp[0][0] = true;\n\n    for (int j = 1; j <= n; j++) {\n        if (p[j - 1] == '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else if (p[j - 1] == '*') {\n                dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for j in range(1, n + 1):\n        if p[j - 1] == '*' and dp[0][j - 2]:\n            dp[0][j] = True\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if p[j - 1] == s[i - 1] or p[j - 1] == '.':\n                dp[i][j] = dp[i - 1][j - 1]\n            elif p[j - 1] == '*':\n                dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (s[i - 1] == p[j - 2] or p[j - 2] == '.'))\n\n    return dp[m][n]\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "javascript": "\n    ```javascript\nfunction isMatch(s, p) {\n    const m = s.length, n = p.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\n    dp[0][0] = true;\n\n    for (let j = 1; j <= n; j++) {\n        if (p[j - 1] === '*' && dp[0][j - 2]) {\n            dp[0][j] = true;\n        }\n    }\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n          if (p[j - 1] === s[i - 1] || p[j - 1] === '.') {\n              dp[i][j] = dp[i - 1][j - 1];\n          } else if (p[j - 1] === '*') {\n              dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] === p[j - 2] || p[j - 2] === '.'));\n          }\n      }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use Dynamic Programming to solve this problem. We store intermediate results in a 2D boolean array `dp`, where `dp[i][j]` indicates whether the first `i` characters of `s` match the first `j` characters of `p`. We then loop through the characters of both strings and update the `dp` table.\n\nIf the current characters in `s` and `p` are equal or `p` has a '.', we update the `dp[i][j]` to the value `dp[i - 1][j - 1]`, because the match continues.\n\nIf the current character in `p` is '*', we have two options:\n\n1. Consider the matching of the previous character in `p` as 0 occurrences. We update the `dp[i][j]` value to `dp[i][j - 2]`.\n2. Consider the matching of the previous character in `p` as at least 1 occurrence. We update `dp[i][j]` to the value of `dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.')`.\n\nFinally, `dp[m][n]` stores the result, where `m` and `n` are the lengths of strings `s` and `p` respectively.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aa \", p =  \"a \"",
                    "output": " False",
                    "explanation": "  \"a \" does not match the entire string  \"aa \"."
                },
                {
                    "input": " s =  \"aa \", p =  \"a* \"",
                    "output": " True",
                    "explanation": " '\\*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes  \"aa \"."
                },
                {
                    "input": " s =  \"ab \", p =  \".* \"",
                    "output": " True",
                    "explanation": "  \".\\* \" means  \"zero or more (\\*) of any character (.) \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"aa\",\"a\"",
                    "output": "False"
                },
                {
                    "input": "\"aa\",\"a*\"",
                    "output": "True"
                },
                {
                    "input": "\"ab\",\".*\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-1",
        "prompt": "Given an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n*   `'.'` Matches any single character.​​​​\n*   `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial)."
    },
    "leetcode-benchmark-2": {
        "id": "leetcode-benchmark-2",
        "title": "Container With Most Water",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = \\[1,8,6,2,5,4,8,3,7\\]\n**Output:** 49\n**Explanation:** The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49.\n\n",
                "**Example 2:**\n\n**Input:** height = \\[1,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == height.length`\n*   `2 <= n <= 105`\n*   `0 <= height[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxArea(int[] height) {\n    int max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "c++": "\n    ```cpp\nint maxArea(vector<int>& height) {\n    int max_area = 0, left = 0, right = height.size() - 1;\n    while (left < right) {\n        max_area = max(max_area, min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "python": "\n    ```python\ndef max_area(height):\n    max_area, left, right = 0, 0, len(height) - 1\n    while left < right:\n        max_area = max(max_area, min(height[left], height[right]) * (right - left))\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    return max_area\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "javascript": "\n    ```javascript\nfunction maxArea(height) {\n    let max_area = 0, left = 0, right = height.length - 1;\n    while (left < right) {\n        max_area = Math.max(max_area, Math.min(height[left], height[right]) * (right - left));\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return max_area;\n}\n```\n    \n    The algorithm uses a two-pointer approach, with one pointer starting from the left end and the other from the right end. It calculates the area between these two lines and updates the maximum area if the current area is larger than the previously calculated maximum area. If the height at the left pointer is less than the height at the right pointer, it moves the left pointer to the right. Otherwise, it moves the right pointer to the left. The algorithm continues until the pointers meet.\n\nThis algorithm ensures that the maximum area is found without having to check all possible pairs of lines because it always chooses the pair of lines with the maximum possible distance and minimum height difference at each step.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " height = [1,8,6,2,5,4,8,3,7]",
                    "output": " 49",
                    "explanation": " The above vertical lines are represented by array \\[1,8,6,2,5,4,8,3,7\\]. In this case, the max area of water (blue section) the container can contain is 49."
                },
                {
                    "input": " height = [1,1]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,8,6,2,5,4,8,3,7]",
                    "output": "49"
                },
                {
                    "input": "[1,1]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-2",
        "prompt": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\n\nReturn _the maximum amount of water a container can store_.\n\n**Notice** that you may not slant the container."
    },
    "leetcode-benchmark-3": {
        "id": "leetcode-benchmark-3",
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"(() \"\n**Output:** 2\n**Explanation:** The longest valid parentheses substring is  \"() \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \")()()) \"\n**Output:** 4\n**Explanation:** The longest valid parentheses substring is  \"()() \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \" \"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 3 * 104`\n*   `s[i]` is `'('`, or `')'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int longestValidParentheses(String s) {\n    int n = s.length();\n    int result = 0;\n    Stack<Integer> st = new Stack<>();\n\n    for (int i = 0; i < n; ++i) {\n        if (s.charAt(i) == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s.charAt(st.peek()) == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <stack>\n\nint longestValidParentheses(string s) {\n    int n = s.length();\n    int result = 0;\n    std::stack<int> st;\n\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '(') {\n            st.push(i);\n        } else {\n            if (!st.empty() && s[st.top()] == '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.empty()) {\n        result = n;\n    } else {\n        int right = n, left = 0;\n        while (!st.empty()) {\n            left = st.top();\n            st.pop();\n            result = std::max(result, right - left - 1);\n            right = left;\n        }\n        result = std::max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "python": "\n    ```python\ndef longest_valid_parentheses(s: str) -> int:\n    n = len(s)\n    result = 0\n    st = []\n\n    for i in range(n):\n        if s[i] == '(':\n            st.append(i)\n        else:\n            if st and s[st[-1]] == '(':\n                st.pop()\n            else:\n                st.append(i)\n\n    if not st:\n        result = n\n    else:\n        right, left = n, 0\n        while st:\n            left = st.pop()\n            result = max(result, right - left - 1)\n            right = left\n        result = max(result, right)\n\n    return result\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "javascript": "\n    ```javascript\nfunction longestValidParentheses(s) {\n    const n = s.length;\n    let result = 0;\n    const st = [];\n\n    for (let i = 0; i < n; ++i) {\n        if (s[i] === '(') {\n            st.push(i);\n        } else {\n            if (st.length > 0 && s[st[st.length - 1]] === '(') {\n                st.pop();\n            } else {\n                st.push(i);\n            }\n        }\n    }\n\n    if (st.length === 0) {\n        result = n;\n    } else {\n        let right = n, left = 0;\n        while (st.length > 0) {\n            left = st.pop();\n            result = Math.max(result, right - left - 1);\n            right = left;\n        }\n        result = Math.max(result, right);\n    }\n\n    return result;\n}\n```\n    \n    1. Iterate through the string and use a stack to store the indices of unmatched parentheses.\n2. If the current character is '(', push its index onto the stack.\n3. If the current character is ')', check if there's a pair of parentheses. If so, pop the stack, else push the index of unmatched ')'.\n4. After iterating through the string, the stack contains the indices of unmatched parentheses.\n5. Use the indices in the stack to calculate the length of the longest valid parentheses substring.\n6. Return the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"(() \"",
                    "output": " 2",
                    "explanation": " The longest valid parentheses substring is  \"() \"."
                },
                {
                    "input": " s =  \")()()) \"",
                    "output": " 4",
                    "explanation": " The longest valid parentheses substring is  \"()() \"."
                },
                {
                    "input": " s =  \" \"",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"(()\"",
                    "output": "2"
                },
                {
                    "input": "\")()())\"",
                    "output": "4"
                },
                {
                    "input": "\"\"",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-3",
        "prompt": "Given a string containing just the characters `'('` and `')'`, return _the length of the longest valid (well-formed) parentheses_ _substring_."
    },
    "leetcode-benchmark-4": {
        "id": "leetcode-benchmark-4",
        "title": "Sudoku Solver",
        "difficulty": "Hard",
        "content": {
            "problem": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules**:\n\n1.  Each of the digits `1-9` must occur exactly once in each row.\n2.  Each of the digits `1-9` must occur exactly once in each column.\n3.  Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\],\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\],\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\],\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\],\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\],\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\],\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\],\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\],\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** \\[\\[ \"5 \", \"3 \", \"4 \", \"6 \", \"7 \", \"8 \", \"9 \", \"1 \", \"2 \"\\],\\[ \"6 \", \"7 \", \"2 \", \"1 \", \"9 \", \"5 \", \"3 \", \"4 \", \"8 \"\\],\\[ \"1 \", \"9 \", \"8 \", \"3 \", \"4 \", \"2 \", \"5 \", \"6 \", \"7 \"\\],\\[ \"8 \", \"5 \", \"9 \", \"7 \", \"6 \", \"1 \", \"4 \", \"2 \", \"3 \"\\],\\[ \"4 \", \"2 \", \"6 \", \"8 \", \"5 \", \"3 \", \"7 \", \"9 \", \"1 \"\\],\\[ \"7 \", \"1 \", \"3 \", \"9 \", \"2 \", \"4 \", \"8 \", \"5 \", \"6 \"\\],\\[ \"9 \", \"6 \", \"1 \", \"5 \", \"3 \", \"7 \", \"2 \", \"8 \", \"4 \"\\],\\[ \"2 \", \"8 \", \"7 \", \"4 \", \"1 \", \"9 \", \"6 \", \"3 \", \"5 \"\\],\\[ \"3 \", \"4 \", \"5 \", \"2 \", \"8 \", \"6 \", \"1 \", \"7 \", \"9 \"\\]\\]\n**Explanation:** The input board is shown above and the only valid solution is shown below:"
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 9`\n*   `board[i].length == 9`\n*   `board[i][j]` is a digit or `'.'`.\n*   It is **guaranteed** that the input board has only one solution.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public boolean isValid(char[][] board, int row, int col, char c) {\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == c) return false;\n            if (board[row][i] == c) return false;\n            if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false;\n        }\n        return true;\n    }\n\n    public boolean solveSudokuHelper(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') {\n                    for (char c = '1'; c <= '9'; c++) {\n                        if (isValid(board, i, j, c)) {\n                            board[i][j] = c;\n\n                            if (solveSudokuHelper(board)) {\n                                return true;\n                            }\n\n                            board[i][j] = '.';\n                        }\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void solveSudoku(char[][] board) {\n        solveSudokuHelper(board);\n    }\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nbool isValid(vector<vector<char>>& board, int row, int col, char c) {\n    for (int i = 0; i < 9; i++) {\n        if (board[i][col] == c) return false; \n        if (board[row][i] == c) return false; \n        if (board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3] == c) return false; \n    }\n    return true;\n}\n\nbool solveSudokuHelper(vector<vector<char>>& board) {\n    for (int i = 0; i < 9; i++) {\n        for (int j = 0; j < 9; j++) {\n            if (board[i][j] == '.') {\n                for (char c = '1'; c <= '9'; c++) {\n                    if (isValid(board, i, j, c)) {\n                        board[i][j] = c;\n\n                        if (solveSudokuHelper(board))\n                            return true;\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid solveSudoku(vector<vector<char>>& board) {\n    solveSudokuHelper(board);\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "python": "\n    ```python\ndef isValid(board, row, col, c):\n    for i in range(9):\n        if board[i][col] == c:\n            return False\n        if board[row][i] == c:\n            return False\n        if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c:\n            return False\n    return True\n\ndef solveSudokuHelper(board):\n    for i in range(9):\n        for j in range(9):\n            if board[i][j] == '.':\n                for c in '123456789':\n                    if isValid(board, i, j, c):\n                        board[i][j] = c\n\n                        if solveSudokuHelper(board):\n                            return True\n\n                        board[i][j] = '.'\n                return False\n\n    return True\n\ndef solveSudoku(board):\n    solveSudokuHelper(board)\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "javascript": "\n    ```javascript\nfunction isValid(board, row, col, c) {\n    for (let i = 0; i < 9; i++) {\n        if (board[i][col] === c) return false;\n        if (board[row][i] === c) return false;\n        if (board[3 * Math.floor(row / 3) + Math.floor(i / 3)][3 * Math.floor(col / 3) + i % 3] === c) return false;\n    }\n    return true;\n}\n\nfunction solveSudokuHelper(board) {\n    for (let i = 0; i < 9; i++) {\n        for (let j = 0; j < 9; j++) {\n            if (board[i][j] === '.') {\n                for (let c = 1; c <= 9; c++) {\n                    if (isValid(board, i, j, c.toString())) {\n                        board[i][j] = c.toString();\n\n                        if (solveSudokuHelper(board)) {\n                            return true;\n                        }\n\n                        board[i][j] = '.';\n                    }\n                }\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nfunction solveSudoku(board) {\n    solveSudokuHelper(board);\n}\n```\n    \n    1. The algorithm starts by searching for an empty cell (denoted by '.').\n2. Once an empty cell is found, it tries to insert a number from 1 to 9.\n3. For each inserted number, it checks if its placement is valid based on Sudoku rules:\n   - The number must not be present in the same row or column.\n   - The number must not be present in its corresponding 3x3 grid.\n4. It calls itself (backtracks) recursively whenever a valid number is inserted into the cell.\n5. If inserting a number fails to lead to a valid solution, the algorithm reverts that cell to '.' and tries the next number.\n6. The process is repeated until a valid board is created or all possibilities have failed.\n7. Once an empty cell is not found, it considers the board solved and exits the process.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"],[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"],[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"],[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"],[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"],[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"],[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"],[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"],[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"]]",
                    "output": " [[ \"5 \", \"3 \", \"4 \", \"6 \", \"7 \", \"8 \", \"9 \", \"1 \", \"2 \"],[ \"6 \", \"7 \", \"2 \", \"1 \", \"9 \", \"5 \", \"3 \", \"4 \", \"8 \"],[ \"1 \", \"9 \", \"8 \", \"3 \", \"4 \", \"2 \", \"5 \", \"6 \", \"7 \"],[ \"8 \", \"5 \", \"9 \", \"7 \", \"6 \", \"1 \", \"4 \", \"2 \", \"3 \"],[ \"4 \", \"2 \", \"6 \", \"8 \", \"5 \", \"3 \", \"7 \", \"9 \", \"1 \"],[ \"7 \", \"1 \", \"3 \", \"9 \", \"2 \", \"4 \", \"8 \", \"5 \", \"6 \"],[ \"9 \", \"6 \", \"1 \", \"5 \", \"3 \", \"7 \", \"2 \", \"8 \", \"4 \"],[ \"2 \", \"8 \", \"7 \", \"4 \", \"1 \", \"9 \", \"6 \", \"3 \", \"5 \"],[ \"3 \", \"4 \", \"5 \", \"2 \", \"8 \", \"6 \", \"1 \", \"7 \", \"9 \"]]",
                    "explanation": " The input board is shown above and the only valid solution is shown below:"
                }
            ],
            "function_input": [
                {
                    "input": "[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-4",
        "prompt": "Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules**:\n\n1.  Each of the digits `1-9` must occur exactly once in each row.\n2.  Each of the digits `1-9` must occur exactly once in each column.\n3.  Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells."
    },
    "leetcode-benchmark-5": {
        "id": "leetcode-benchmark-5",
        "title": "First Missing Positive",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in `O(n)` time and uses constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,0\\]\n**Output:** 3\n**Explanation:** The numbers in the range \\[1,2\\] are all in the array.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,4,-1,1\\]\n**Output:** 2\n**Explanation:** 1 is in the array but 2 is missing.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,8,9,11,12\\]\n**Output:** 1\n**Explanation:** The smallest positive integer 1 is missing."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int firstMissingPositive(int[] nums) {\n    int n = nums.length;\n    for(int i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            int temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(int i = 0; i < n; i++) {\n        if(nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "c++": "\n    ```cpp\nint firstMissingPositive(vector<int>& nums) {\n    int n = nums.size();\n    for(int i = 0; i < n; ++i)\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i])\n            swap(nums[i], nums[nums[i] - 1]);\n\n    for(int i = 0; i < n; ++i)\n        if(nums[i] != i + 1)\n            return i + 1;\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "python": "\n    ```python\ndef firstMissingPositive(nums):\n    n = len(nums)\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "javascript": "\n    ```javascript\nfunction firstMissingPositive(nums) {\n    let n = nums.length;\n    for(let i = 0; i < n; i++) {\n        while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] !== nums[i]) {\n            let temp = nums[i];\n            nums[i] = nums[temp - 1];\n            nums[temp - 1] = temp;\n        }\n    }\n\n    for(let i = 0; i < n; i++) {\n        if(nums[i] !== i + 1) {\n            return i + 1;\n        }\n    }\n    return n + 1;\n}\n```\n    \n    In this algorithm, the elements are swapped with the values at their correct index if they are positive, in range, and not equal to the value already at that index. After the first loop, the array will have correct values at correct indices where possible (1-based), so we just need to find the index `i` where `nums[i] != i+1`. If not found, return the next positive integer `n + 1`. The loop has O(n) complexity, because each time at least one element gets placed at its correct position, so we need a max of n iterations on average.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,0]",
                    "output": " 3",
                    "explanation": " The numbers in the range \\[1,2\\] are all in the array."
                },
                {
                    "input": " nums = [3,4,-1,1]",
                    "output": " 2",
                    "explanation": " 1 is in the array but 2 is missing."
                },
                {
                    "input": " nums = [7,8,9,11,12]",
                    "output": " 1",
                    "explanation": " The smallest positive integer 1 is missing."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,0]",
                    "output": "3"
                },
                {
                    "input": "[3,4,-1,1]",
                    "output": "2"
                },
                {
                    "input": "[7,8,9,11,12]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-5",
        "prompt": "Given an unsorted integer array `nums`, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in `O(n)` time and uses constant extra space."
    },
    "leetcode-benchmark-6": {
        "id": "leetcode-benchmark-6",
        "title": "Trapping Rain Water",
        "difficulty": "Hard",
        "content": {
            "problem": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.",
            "examples": [
                "**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n",
                "**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int trap(int[] height) {\n    int n = height.length, left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint trap(vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "python": "\n    ```python\ndef trap(height):\n    n = len(height)\n    left, right, max_left, max_right, water = 0, n - 1, 0, 0, 0\n\n    while left < right:\n        if height[left] <= height[right]:\n            max_left = max(max_left, height[left])\n            water += max_left - height[left]\n            left += 1\n        else:\n            max_right = max(max_right, height[right])\n            water += max_right - height[right]\n            right -= 1\n\n    return water\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "javascript": "\n    ```javascript\nfunction trap(height) {\n    const n = height.length;\n    let left = 0, right = n - 1, maxLeft = 0, maxRight = 0, water = 0;\n\n    while (left < right) {\n        if (height[left] <= height[right]) {\n            maxLeft = Math.max(maxLeft, height[left]);\n            water += maxLeft - height[left];\n            left++;\n        } else {\n            maxRight = Math.max(maxRight, height[right]);\n            water += maxRight - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n```\n    \n    The algorithm uses a two-pointer approach, initializing left and right pointers to the beginning and end of the elevation map, respectively. It also initializes two variables `maxLeft` and `maxRight` to keep track of the maximum heights on the left and right of the pointers, as well as a variable `water` to store the trapped water.\n\nThe algorithm iterates through the elevation map until the left pointer is less than the right pointer. In each iteration, it compares the values at both pointers to determine which side is shorter. If the value at the left pointer is less than or equal to the value at the right pointer, it means water can be trapped on the left side up to the height of the shorter bar. The algorithm updates `maxLeft` with the maximum height on the left side and then adds the trapped water (which is the difference between the maximum height and the current height) to the `water` variable. The left pointer is then incremented. If the value at the right pointer is smaller, the same logic is applied to the right side and the right pointer is decremented.\n\nThis process is repeated until the left pointer is no longer less than the right pointer, at which point the total trapped water has been calculated and the `water` variable is returned. This algorithm has a time complexity of O(n) and a space complexity of O(1) as it only uses constant extra space.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " height = [0,1,0,2,1,0,1,3,2,1,2,1]",
                    "output": " 6",
                    "explanation": " The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped."
                },
                {
                    "input": " height = [4,2,0,3,2,5]",
                    "output": " 9",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[0,1,0,2,1,0,1,3,2,1,2,1]",
                    "output": "6"
                },
                {
                    "input": "[4,2,0,3,2,5]",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-6",
        "prompt": "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining."
    },
    "leetcode-benchmark-7": {
        "id": "leetcode-benchmark-7",
        "title": "Wildcard Matching",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial).",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aa \", p =  \"a \"\n**Output:** false\n**Explanation:**  \"a \" does not match the entire string  \"aa \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", p =  \"\\* \"\n**Output:** true\n**Explanation:** '\\*' matches any sequence.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"cb \", p =  \"?a \"\n**Output:** false\n**Explanation:** '?' matches 'c', but the second letter is 'a', which does not match 'b'."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length, p.length <= 2000`\n*   `s` contains only lowercase English letters.\n*   `p` contains only lowercase English letters, `'?'` or `'*'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isMatch(String s, String p) {\n    int m = s.length(), n = p.length();\n    int i = 0, j = 0, asterisk = -1, match = 0;\n    while (i < m) {\n        if (j < n && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {\n            i++; j++;\n        } else if (j < n && p.charAt(j) == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk != -1) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p.charAt(j) == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "c++": "\n    ```cpp\nbool isMatch(const std::string& s, const std::string& p) {\n    int m = s.size(), n = p.size();\n    int i = 0, j = 0, asterisk = -1, match;\n    while (i < m) {\n        if (j < n && (s[i] == p[j] || p[j] == '?')) {\n            i++; j++;\n        } else if (j < n && p[j] == '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] == '*') j++;\n    return j == n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "python": "\n    ```python\ndef is_match(s: str, p: str) -> bool:\n    m, n = len(s), len(p)\n    i = j = 0\n    match = asterisk = -1\n    while i < m:\n        if j < n and (s[i] == p[j] or p[j] == '?'):\n            i, j = i + 1, j + 1\n        elif j < n and p[j] == '*':\n            match, asterisk = i, j\n            j += 1\n        elif asterisk >= 0:\n            i, j = match + 1, asterisk + 1\n            match += 1\n        else:\n            return False\n    while j < n and p[j] == '*':\n        j += 1\n    return j == n\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction isMatch(s, p) {\n    let m = s.length,\n        n = p.length;\n    let i = 0,\n        j = 0,\n        asterisk = -1,\n        match = 0;\n    while (i < m) {\n        if (j < n && (s[i] === p[j] || p[j] === '?')) {\n            i++;\n            j++;\n        } else if (j < n && p[j] === '*') {\n            match = i;\n            asterisk = j++;\n        } else if (asterisk >= 0) {\n            i = ++match;\n            j = asterisk + 1;\n        } else {\n            return false;\n        }\n    }\n    while (j < n && p[j] === '*') j++;\n    return j === n;\n}\n```\n    \n    - Initialize `m` and `n` as the lengths of the input string `s` and pattern `p`. Initialize `i`, `j`, `asterisk`, and `match` to 0.\n- Use a `while` loop with a condition of `i < m`. Loop through the input string and pattern and compare the characters at the corresponding positions.\n  - If the characters are equal or the pattern character is a question mark, increment both `i` and `j`.\n  - If the pattern character is an asterisk, store the current positions in `match` and `asterisk`, then increment `j`.\n  - If there is a stored `asterisk` position and the current characters don't match, increment match, set `i` to the incremented match value, and set `j` to the `asterisk` position plus one.\n  - If none of the above conditions are met, return `false` as the input string and pattern don't match.\n- After the loop, if there are remaining asterisks in the pattern, increment the pointer `j`.\n- Return `true` if the pointer `j` reaches the end of the pattern, otherwise, return `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aa \", p =  \"a \"",
                    "output": " False",
                    "explanation": "  \"a \" does not match the entire string  \"aa \"."
                },
                {
                    "input": " s =  \"aa \", p =  \"* \"",
                    "output": " True",
                    "explanation": " '\\*' matches any sequence."
                },
                {
                    "input": " s =  \"cb \", p =  \"?a \"",
                    "output": " False",
                    "explanation": " '?' matches 'c', but the second letter is 'a', which does not match 'b'."
                }
            ],
            "function_input": [
                {
                    "input": "\"aa\",\"a\"",
                    "output": "False"
                },
                {
                    "input": "\"aa\",\"*\"",
                    "output": "True"
                },
                {
                    "input": "\"cb\",\"?a\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-7",
        "prompt": "Given an input string (`s`) and a pattern (`p`), implement wildcard pattern matching with support for `'?'` and `'*'` where:\n\n*   `'?'` Matches any single character.\n*   `'*'` Matches any sequence of characters (including the empty sequence).\n\nThe matching should cover the **entire** input string (not partial)."
    },
    "leetcode-benchmark-8": {
        "id": "leetcode-benchmark-8",
        "title": "N-Queens",
        "difficulty": "Hard",
        "content": {
            "problem": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** \\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[ \"Q \"\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<String>> solveNQueens(int n) {\n    List<List<String>> result = new ArrayList<>();\n    solve(result, new ArrayList<>(), n, 0);\n    return result;\n}\n\nprivate void solve(List<List<String>> result, List<Integer> current, int n, int col) {\n    if (col == n) {\n        result.add(generateBoard(current, n));\n        return;\n    }\n    for (int row = 0; row < n; row++) {\n        if(isSafe(current, row, col)) {\n            current.add(row);\n            solve(result, current, n, col + 1);\n            current.remove(col);\n        }\n    }\n}\n\nprivate boolean isSafe(List<Integer> current, int row, int col) {\n    for (int i = 0; i < col; i++) {\n        int prevRow = current.get(i);\n        if (prevRow == row || (Math.abs(col - i) == Math.abs(row - prevRow))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nprivate List<String> generateBoard(List<Integer> current, int n) {\n    List<String> board = new ArrayList<>();\n    for (int row : current) {\n        StringBuilder sb = new StringBuilder();\n        for (int col = 0; col < n; col++)\n            sb.append((col == row) ? \"Q\" : \".\");\n        board.add(sb.toString());\n    }\n    return board;\n}\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) {\n    for (int i = 0; i < col; ++i) {\n        if (board[row][i] == 'Q') return false;\n    }\n    for (int i = row, j = col; i >= 0 && j >= 0; --i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    for (int i = row, j = col; i < n && j >= 0; ++i, --j) {\n        if (board[i][j] == 'Q') return false;\n    }\n    return true;\n}\n\nvoid solve(std::vector<std::vector<std::string>>& result, std::vector<std::string>& board, int n, int col) {\n    if (col == n) {\n        result.push_back(board);\n        return;\n    }\n    for (int row = 0; row < n; ++row) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solve(result, board, n, col + 1);\n            board[row][col] = '.';\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> solveNQueens(int n) {\n    std::vector<std::vector<std::string>> result;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solve(result, board, n, 0);\n    return result;\n}\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "python": "\n    ```python\ndef solveNQueens(n):\n    def isSafe(board, row, col):\n        for i in range(col):\n            if board[row][i] == 'Q': return False\n        i, j = row, col\n        while i >= 0 and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i - 1, j - 1\n        i, j = row, col\n        while i < n and j >= 0:\n            if board[i][j] == 'Q': return False\n            i, j = i + 1, j - 1\n        return True\n\n    def solve(result, board, n, col):\n        if col == n:\n            result.append(board.copy())\n            return\n        for row in range(n):\n            if isSafe(board, row, col):\n                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]\n                solve(result, board, n, col + 1)\n                board[row] = board[row][:col] + '.' + board[row][col + 1:]\n\n    result, board = [], ['.' * n for _ in range(n)]\n    solve(result, board, n, 0)\n    return result\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "javascript": "\n    ```javascript\nfunction solveNQueens(n) {\n  function isSafe(board, row, col) {\n    for (let i = 0; i < col; i++)\n      if (board[row][i] == 'Q') return false;\n    for (let i = row, j = col; i >= 0 && j >= 0; i--, j--)\n      if (board[i][j] == 'Q') return false;\n    for (let i = row, j = col; i < n && j >= 0; i++, j--)\n      if (board[i][j] == 'Q') return false;\n    return true;\n  }\n\n  function solve(result, board, n, col) {\n    if (col == n) {\n      result.push(board.map(row => row.join('')));\n      return;\n    }\n    for (let row = 0; row < n; row++) {\n      if (isSafe(board, row, col)) {\n        board[row][col] = 'Q';\n        solve(result, board, n, col + 1);\n        board[row][col] = '.';\n      }\n    }\n  }\n\n  const result = [];\n  const board = Array.from({ length: n }, () => Array(n).fill('.'));\n  solve(result, board, n, 0);\n  return result;\n}\n```\n    \n    The algorithm uses the backtracking approach to solve the N-Queens puzzle. The idea is to place queens one by one in different columns, starting from the leftmost column. When placing a queen, check if that position is safe from all previously placed queens in terms of the horizontal, diagonal, and anti-diagonal directions. If the selected position is safe, move on to the next column and try to place another queen there. If no safe positions are found in the current column, then go back to the previous column and move the queen to another safe position. Repeat this process until all queens are placed in a valid configuration or all possible arrangements have been tried. During the process, whenever we successfully place `n` queens on the board, add that configuration to our result list. Finally, return the list of all unique solutions found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 4",
                    "output": " [[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"],[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"]]",
                    "explanation": " There exist two distinct solutions to the 4-queens puzzle as shown above"
                },
                {
                    "input": " n = 1",
                    "output": " [[ \"Q \"]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "4",
                    "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]"
                },
                {
                    "input": "1",
                    "output": "[[\"Q\"]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-8",
        "prompt": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively."
    },
    "leetcode-benchmark-9": {
        "id": "leetcode-benchmark-9",
        "title": "N-Queens II",
        "difficulty": "Hard",
        "content": {
            "problem": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\n\npublic int totalNQueens(int n) {\n    ArrayList<Integer> cols = new ArrayList<>();\n    return backtrack(n, cols);\n}\n\npublic int backtrack(int n, ArrayList<Integer> cols) {\n    if (cols.size() == n) {\n        return 1;\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.add(i);\n            count += backtrack(n, cols);\n            cols.remove(cols.size() - 1);\n        }\n    }\n    return count;\n}\n\npublic boolean isSafe(ArrayList<Integer> cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols.get(i) == row || Math.abs(i - col) == Math.abs(cols.get(i) - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool isSafe(vector<int> &cols, int row) {\n    int col = cols.size();\n    for (int i = 0; i < cols.size(); i++) {\n        if (cols[i] == row || abs(i - col) == abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtrack(int n, vector<int> &cols, int &count) {\n    if (cols.size() == n) {\n        count++;\n        return;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push_back(i);\n            backtrack(n, cols, count);\n            cols.pop_back();\n        }\n    }\n}\n\nint totalNQueens(int n) {\n    vector<int> cols;\n    int count = 0;\n    backtrack(n, cols, count);\n    return count;\n}\n```\n\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "python": "\n    ```python\ndef is_safe(cols, row):\n    col = len(cols)\n    for i, r in enumerate(cols):\n        if r == row or abs(i - col) == abs(r - row):\n            return False\n    return True\n\n\ndef backtrack(n, cols):\n    if len(cols) == n:\n        return 1\n\n    count = 0\n    for i in range(n):\n        if is_safe(cols, i):\n            cols.append(i)\n            count += backtrack(n, cols)\n            cols.pop()\n\n    return count\n\n\ndef total_n_queens(n):\n    cols = []\n    return backtrack(n, cols)\n```\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "javascript": "\n    ```javascript\nfunction isSafe(cols, row) {\n    let col = cols.length;\n    for (let i = 0; i < cols.length; i++) {\n        if (cols[i] === row || Math.abs(i - col) === Math.abs(cols[i] - row)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction backtrack(n, cols) {\n    if (cols.length === n) {\n        return 1;\n    }\n\n    let count = 0;\n    for (let i = 0; i < n; i++) {\n        if (isSafe(cols, i)) {\n            cols.push(i);\n            count += backtrack(n, cols);\n            cols.pop();\n        }\n    }\n    return count;\n}\n\nfunction totalNQueens(n) {\n    let cols = [];\n    return backtrack(n, cols);\n}\n```\n    \n    The algorithm recursively places queens on columns and checks if the placement is safe, i.e., no queens are attacking each other. \n1. Maintain an array `cols` storing the row indices of placed queens. The index in this array represents the column the queen is placed in. This ensures that no two queens are placed in the same column.\n2. Recursively place queens (column-wise).\n3. Check for a safe position for each queen in the current column:\n   a. Check for same row (`cols[i] == row`).\n   b. Check for diagonal attack (`abs(i - col) == abs(cols[i] - row)`).\n4. If the current position is safe, place the queen in the current column at the current row position, and continue to place the next queen.\n5. If all queens are placed, increment the solution count.\n6. If the recursive call finishes, backtrack by removing the queen from the current column and move on to the next row in the same column.\n7. The base case is when the `cols` size equals `n`, meaning all queens have been placed safely; increment the count.\n\nThis approach considers all possible configurations for placing the n queens while avoiding visiting invalid configurations. It uses backtracking to explore the state space efficiently. The algorithm finds the number of distinct solutions to the n-queens puzzle.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 4",
                    "output": " 2",
                    "explanation": " There are two distinct solutions to the 4-queens puzzle as shown."
                },
                {
                    "input": " n = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "4",
                    "output": "2"
                },
                {
                    "input": "1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-9",
        "prompt": "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_."
    },
    "leetcode-benchmark-10": {
        "id": "leetcode-benchmark-10",
        "title": "Permutation Sequence",
        "difficulty": "Hard",
        "content": {
            "problem": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1.  `\"123 \"`\n2.  `\"132 \"`\n3.  `\"213 \"`\n4.  `\"231 \"`\n5.  `\"312 \"`\n6.  `\"321 \"`\n\nGiven `n` and `k`, return the `kth` permutation sequence.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 3\n**Output:** \"213\"\n\n",
                "**Example 2:**\n\n**Input:** n = 4, k = 9\n**Output:** \"2314\"\n\n",
                "**Example 3:**\n\n**Input:** n = 3, k = 1\n**Output:** \"123\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 9`\n*   `1 <= k <= n!`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String getPermutation(int n, int k) {\n    List<Integer> nums = new ArrayList<>();\n    int[] factorials = new int[n];\n    StringBuilder sb = new StringBuilder();\n    int index;\n\n    factorials[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n        nums.add(i);\n        factorials[i - 1] = i * factorials[i - 1];\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        sb.append(nums.get(index));\n        nums.remove(index);\n    }\n\n    return sb.toString();\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string getPermutation(int n, int k) {\n    std::vector<int> factorials(n, 1);\n    std::vector<char> nums(n, '1');\n    std::string result;\n    int index;\n\n    for (int i = 1; i <= n; ++i) {\n        nums[i - 1] += i - 1;\n        factorials[i - 1] *= i;\n    }\n\n    k--;\n\n    for (int i = n; i >= 1; --i) {\n        index = k / factorials[i - 1];\n        k %= factorials[i - 1];\n        result.push_back(nums[index]);\n        nums.erase(nums.begin() + index);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "python": "\n    ```python\ndef getPermutation(n, k):\n    factorials = [1]\n    nums = list(range(1, n + 1))\n    result = []\n\n    for i in range(1, n):\n        factorials.append(factorials[-1] * i)\n\n    k -= 1\n\n    for i in range(n, 0, -1):\n        index = k // factorials[i - 1]\n        k %= factorials[i - 1]\n        result.append(str(nums.pop(index)))\n\n    return ''.join(result)\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "javascript": "\n    ```javascript\nfunction getPermutation(n, k) {\n    const factorials = [1];\n    const nums = [...Array(n)].map((_, i) => i + 1);\n    let result = '';\n\n    for (let i = 1; i < n; i++) {\n        factorials[i] = factorials[i - 1] * i;\n    }\n\n    k--;\n\n    for (let i = n; i >= 1; i--) {\n        const index = Math.floor(k / factorials[i - 1]);\n        k %= factorials[i - 1];\n        result += nums[index];\n        nums.splice(index, 1);\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses factorials and a list of available numbers to construct the kth permutation. \n\nFirst, we precompute the factorials up to n using a loop.\n\nNext, we initialize an array or list of available numbers, from 1 to n.\n\nThen, we iterate from n down to 1, calculating the index of the current number in the available list to be included in the resulting permutation. We can calculate it as follows: `index = (k - 1) // factorials[i - 1]`. \n\nAfter, we update the value of k to: `k %= factorials[i - 1]`.\n\nAt each step, we append or concatenate the chosen number to the result and remove it from the list of available numbers.\n\nFinally, we return the result as a string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3, k = 3",
                    "output": " \"213\"",
                    "explanation": null
                },
                {
                    "input": " n = 4, k = 9",
                    "output": " \"2314\"",
                    "explanation": null
                },
                {
                    "input": " n = 3, k = 1",
                    "output": " \"123\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3,3",
                    "output": "\"213\""
                },
                {
                    "input": "4,9",
                    "output": "\"2314\""
                },
                {
                    "input": "3,1",
                    "output": "\"123\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-10",
        "prompt": "The set `[1, 2, 3, ..., n]` contains a total of `n!` unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for `n = 3`:\n\n1.  `\"123 \"`\n2.  `\"132 \"`\n3.  `\"213 \"`\n4.  `\"231 \"`\n5.  `\"312 \"`\n6.  `\"321 \"`\n\nGiven `n` and `k`, return the `kth` permutation sequence."
    },
    "leetcode-benchmark-11": {
        "id": "leetcode-benchmark-11",
        "title": "Text Justification",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n**Note:**\n\n*   A word is defined as a character sequence consisting of non-space characters only.\n*   Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.\n*   The input array `words` contains at least one word.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"This \",  \"is \",  \"an \",  \"example \",  \"of \",  \"text \",  \"justification. \"\\], maxWidth = 16\n**Output:**\n\\[\n    \"This    is    an \",\n    \"example  of text \",\n    \"justification.   \"\n\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"What \", \"must \", \"be \", \"acknowledgment \", \"shall \", \"be \"\\], maxWidth = 16\n**Output:**\n\\[\n   \"What   must   be \",\n   \"acknowledgment   \",\n   \"shall be         \"\n\\]\n**Explanation:** Note that the last line is  \"shall be     \" instead of  \"shall     be \", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"Science \", \"is \", \"what \", \"we \", \"understand \", \"well \", \"enough \", \"to \", \"explain \", \"to \", \"a \", \"computer. \", \"Art \", \"is \", \"everything \", \"else \", \"we \", \"do \"\\], maxWidth = 20\n**Output:**\n\\[\n   \"Science  is  what we \",\n   \"understand      well \",\n   \"enough to explain to \",\n   \"a  computer.  Art is \",\n   \"everything  else  we \",\n   \"do                   \"\n\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 300`\n*   `1 <= words[i].length <= 20`\n*   `words[i]` consists of only English letters and symbols.\n*   `1 <= maxWidth <= 100`\n*   `words[i].length <= maxWidth`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> fullJustify(String[] words, int maxWidth) {\n    List<String> result = new ArrayList<>();\n    int idx = 0;\n    while (idx < words.length) {\n        int totalChars = words[idx].length();\n        int last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        StringBuilder line = new StringBuilder();\n        if (last == words.length || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) line.append(\" \");\n            }\n            while (line.length() < maxWidth) line.append(\" \");\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line.append(words[i]);\n                if (i < last - 1) {\n                    line.append(\" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0)));\n                }\n            }\n        }\n        idx = last;\n        result.add(line.toString());\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> fullJustify(vector<string>& words, int maxWidth) {\n    vector<string> result;\n    int idx = 0;\n    while (idx < words.size()) {\n        int totalChars = words[idx].size();\n        int last = idx + 1;\n        while (last < words.size()) {\n            if (totalChars + 1 + words[last].length() > maxWidth) break;\n            totalChars += 1 + words[last].length();\n            last++;\n        }\n        int gaps = last - idx - 1;\n        stringstream line;\n        if (last == words.size() || gaps == 0) {\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) line << \" \";\n            }\n            line << string(maxWidth - line.str().size(), ' ');\n        } else {\n            int evenSpaces = (maxWidth - totalChars) / gaps;\n            int extraSpaces = (maxWidth - totalChars) % gaps;\n            for (int i = idx; i < last; i++) {\n                line << words[i];\n                if (i < last - 1) {\n                    line << string(evenSpaces + (i - idx < extraSpaces ? 1 : 0), ' ');\n                }\n            }\n        }\n        idx = last;\n        result.push_back(line.str());\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "python": "\n    ```python\ndef fullJustify(words, maxWidth):\n    result = []\n    idx = 0\n    while idx < len(words):\n        total_chars = len(words[idx])\n        last = idx + 1\n        while last < len(words):\n            if total_chars + 1 + len(words[last]) > maxWidth:\n                break\n            total_chars += 1 + len(words[last])\n            last += 1\n        gaps = last - idx - 1\n        line = []\n        if last == len(words) or gaps == 0:\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \")\n            while sum(len(w) for w in line) < maxWidth:\n                line.append(\" \")\n        else:\n            even_spaces = (maxWidth - total_chars) // gaps\n            extra_spaces = (maxWidth - total_chars) % gaps\n            for i in range(idx, last):\n                line.append(words[i])\n                if i < last - 1:\n                    line.append(\" \" * (even_spaces + (1 if i - idx < extra_spaces else 0)))\n        idx = last\n        result.append(\"\".join(line))\n    return result\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "javascript": "\n    ```javascript\nfunction fullJustify(words, maxWidth) {\n    const result = [];\n    let idx = 0;\n    while (idx < words.length) {\n        let totalChars = words[idx].length;\n        let last = idx + 1;\n        while (last < words.length) {\n            if (totalChars + 1 + words[last].length > maxWidth) break;\n            totalChars += 1 + words[last].length;\n            last++;\n        }\n        const gaps = last - idx - 1;\n        let line = \"\";\n        if (last === words.length || gaps === 0) {\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) line += \" \";\n            }\n            while (line.length < maxWidth) line += \" \";\n        } else {\n            const evenSpaces = Math.floor((maxWidth - totalChars) / gaps);\n            const extraSpaces = (maxWidth - totalChars) % gaps;\n            for (let i = idx; i < last; i++) {\n                line += words[i];\n                if (i < last - 1) {\n                    line += \" \".repeat(evenSpaces + (i - idx < extraSpaces ? 1 : 0));\n                }\n            }\n        }\n        idx = last;\n        result.push(line);\n    }\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Initialize an empty result list.\n2. Use `idx` to keep track of the start of the line. `idx` initially starts at 0, i.e., the first word.\n3. Calculate the total number of characters from `idx` to the last word in a line by testing whether adding the next word, with an extra space before it, would exceed `maxWidth`.\n4. Find the number of gaps in the current line. If it is the last line or there is only one word, left-justify the words and pad the remaining space with spaces.\n5. If it's not the last line, distribute spaces as evenly as possible between words: calculate `evenSpaces` and `extraSpaces`, and add an extra space to the left gaps until there are no more `extraSpaces`.\n6. Append the constructed line to the result list and update the `idx` to the start of the next line.\n7. Repeat steps 3 to 6 until reaching the last word.\n8. Return the result list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"This \",  \"is \",  \"an \",  \"example \",  \"of \",  \"text \",  \"justification. \"], maxWidth = 16",
                    "output": "\n[\n    \"This    is    an \",\n    \"example  of text \",\n    \"justification.   \"\n]",
                    "explanation": null
                },
                {
                    "input": " words = [ \"What \", \"must \", \"be \", \"acknowledgment \", \"shall \", \"be \"], maxWidth = 16",
                    "output": "\n[\n   \"What   must   be \",\n   \"acknowledgment   \",\n   \"shall be         \"\n]",
                    "explanation": " Note that the last line is  \"shall be     \" instead of  \"shall     be \", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word."
                },
                {
                    "input": " words = [ \"Science \", \"is \", \"what \", \"we \", \"understand \", \"well \", \"enough \", \"to \", \"explain \", \"to \", \"a \", \"computer. \", \"Art \", \"is \", \"everything \", \"else \", \"we \", \"do \"], maxWidth = 20",
                    "output": "\n[\n   \"Science  is  what we \",\n   \"understand      well \",\n   \"enough to explain to \",\n   \"a  computer.  Art is \",\n   \"everything  else  we \",\n   \"do                   \"\n]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"This\",\"is\",\"an\",\"example\",\"of\",\"text\",\"justification.\"],16",
                    "output": "\n[\n\"Thisisan\",\n\"exampleoftext\",\n\"justification.\"\n]"
                },
                {
                    "input": "[\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"],16",
                    "output": "\n[\n\"Whatmustbe\",\n\"acknowledgment\",\n\"shallbe\"\n]"
                },
                {
                    "input": "[\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"],20",
                    "output": "\n[\n\"Scienceiswhatwe\",\n\"understandwell\",\n\"enoughtoexplainto\",\n\"acomputer.Artis\",\n\"everythingelsewe\",\n\"do\"\n]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-11",
        "prompt": "Given an array of strings `words` and a width `maxWidth`, format the text such that each line has exactly `maxWidth` characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces `' '` when necessary so that each line has exactly `maxWidth` characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\n**Note:**\n\n*   A word is defined as a character sequence consisting of non-space characters only.\n*   Each word's length is guaranteed to be greater than `0` and not exceed `maxWidth`.\n*   The input array `words` contains at least one word."
    },
    "leetcode-benchmark-12": {
        "id": "leetcode-benchmark-12",
        "title": "Edit Distance",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character",
            "examples": [
                "**Example 1:**\n\n**Input:** word1 =  \"horse \", word2 =  \"ros \"\n**Output:** 3\n**Explanation:** \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\n\n",
                "**Example 2:**\n\n**Input:** word1 =  \"intention \", word2 =  \"execution \"\n**Output:** 5\n**Explanation:** \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= word1.length, word2.length <= 500`\n*   `word1` and `word2` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minDistance(String word1, String word2) {\n    int m = word1.length();\n    int n = word2.length();\n    int[][] dp = new int[m + 1][n + 1];\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "c++": "\n    ```cpp\nint minDistance(string word1, string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "python": "\n    ```python\ndef minDistance(word1: str, word2: str) -> int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n    \n    return dp[m][n]\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "javascript": "\n    ```javascript\nfunction minDistance(word1, word2) {\n    const m = word1.length;\n    const n = word2.length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        for (let j = 0; j <= n; j++) {\n            if (i === 0) {\n                dp[i][j] = j;\n            } else if (j === 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] === word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n```\n    \n    The algorithm used is dynamic programming. We create a 2D table dp with dimensions (m+1) x (n+1), where m is the length of word1 and n is the length of word2. Each cell dp[i][j] represents the minimum number of operations required to convert word1[0...i-1] to word2[0...j-1].\n\nFor each cell, we have the following conditions:\n1. If either i or j is 0, it means one of the strings is empty, so the minimum number of operations needed is the length of the non-empty string (i or j).\n2. If the current characters of the two strings are equal (word1[i-1] == word2[j-1]), we don't have to do anything, so dp[i][j] = dp[i-1][j-1].\n3. If the current characters are different, we take the minimum of the following and add 1:\n    a. dp[i-1][j]: Delete operation\n    b. dp[i][j-1]: Insert operation\n    c. dp[i-1][j-1]: Replace operation\n\nAfter filling the table, the minimum number of operations will be at dp[m][n].\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " word1 =  \"horse \", word2 =  \"ros \"",
                    "output": " 3",
                    "explanation": " \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')"
                },
                {
                    "input": " word1 =  \"intention \", word2 =  \"execution \"",
                    "output": " 5",
                    "explanation": " \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
                }
            ],
            "function_input": [
                {
                    "input": "\"horse\",\"ros\"",
                    "output": "3"
                },
                {
                    "input": "\"intention\",\"execution\"",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-12",
        "prompt": "Given two strings `word1` and `word2`, return _the minimum number of operations required to convert `word1` to `word2`_.\n\nYou have the following three operations permitted on a word:\n\n*   Insert a character\n*   Delete a character\n*   Replace a character"
    },
    "leetcode-benchmark-13": {
        "id": "leetcode-benchmark-13",
        "title": "Largest Rectangle in Histogram",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[2,1,5,6,2,3\\]\n**Output:** 10\n**Explanation:** The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[2,4\\]\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `0 <= heights[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int largestRectangleArea(int[] heights) {\n    Stack<Integer> stack = new Stack<>();\n    int max_area = 0;\n    for (int i = 0; i <= heights.length; i++) {\n        int height = (i == heights.length) ? 0 : heights[i];\n        while (!stack.isEmpty() && heights[stack.peek()] > height) {\n            int h = heights[stack.pop()];\n            int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n            max_area = Math.max(max_area, h * w);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "c++": "\n    ```cpp\nint largestRectangleArea(vector<int>& heights) {\n    heights.push_back(0);\n    stack<int> s;\n    int max_area = 0;\n    for (int i = 0; i < heights.size(); i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int height = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            max_area = max(max_area, height * width);\n        }\n        s.push(i);\n    }\n    return max_area;\n}\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "python": "\n    ```python\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    for i, h in enumerate(heights + [0]):\n        while stack and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n    return max_area\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "javascript": "\n    ```javascript\nfunction largestRectangleArea(heights) {\n    let stack = [];\n    let max_area = 0;\n    heights.push(0);\n    for (let i = 0; i < heights.length; i++) {\n        while (stack.length > 0 && heights[stack[stack.length - 1]] > heights[i]) {\n            let height = heights[stack.pop()];\n            let width = stack.length === 0 ? i : i - stack[stack.length - 1] - 1;\n            max_area = Math.max(max_area, height * width);\n        }\n        stack.push(i);\n    }\n    return max_area;\n}\n```\n    \n    The algorithm utilizes a stack to keep track of the indices of the heights array. It starts iterating through the array, appending a zero at the end to ensure the last bar is considered. When a higher bar is found, it is pushed onto the stack, and if a lower bar is found, it calculates the area of the bar under the current top of the stack considering the width between the current bar and the next lowest bar in the stack, storing the highest area found.\n\nThis algorithm has a time complexity of O(n) as it iterates through the heights only once, resulting in optimal performance.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " heights = [2,1,5,6,2,3]",
                    "output": " 10",
                    "explanation": " The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units."
                },
                {
                    "input": " heights = [2,4]",
                    "output": " 4",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,1,5,6,2,3]",
                    "output": "10"
                },
                {
                    "input": "[2,4]",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-13",
        "prompt": "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_."
    },
    "leetcode-benchmark-14": {
        "id": "leetcode-benchmark-14",
        "title": "Maximal Rectangle",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 6\n**Explanation:** The maximal rectangle is shown in the above picture.\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[ \"1 \"\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `rows == matrix.length`\n*   `cols == matrix[i].length`\n*   `1 <= row, cols <= 200`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int maximalRectangle(char[][] matrix) {\n    if (matrix.length == 0) return 0;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[] height = new int[n + 1];\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        Stack<Integer> s = new Stack<>();\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.peek()]) {\n                int h = height[s.pop()];\n                int w = s.empty() ? j : j - s.peek() - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint maximalRectangle(vector<vector<char>>& matrix) {\n    if (matrix.empty()) return 0;\n\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<int> height(n + 1, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        stack<int> s;\n        for (int j = 0; j <= n; ++j) {\n            if (j < n) {\n                height[j] = matrix[i][j] == '1' ? height[j] + 1 : 0;\n            }\n            while (!s.empty() && height[j] < height[s.top()]) {\n                int h = height[s.top()];\n                s.pop();\n                int w = s.empty() ? j : j - s.top() - 1;\n                maxArea = max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "python": "\n    ```python\ndef maximalRectangle(matrix):\n    if not matrix:\n        return 0\n\n    m = len(matrix)\n    n = len(matrix[0])\n    height = [0] * (n + 1)\n    max_area = 0\n\n    for i in range(m):\n        s = []\n        for j in range(n + 1):\n            if j < n:\n                height[j] = height[j] + 1 if matrix[i][j] == '1' else 0\n            while s and height[j] < height[s[-1]]:\n                h = height[s.pop()]\n                w = j if not s else j - s[-1] - 1\n                max_area = max(max_area, h * w)\n            s.append(j)\n\n    return max_area\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction maximalRectangle(matrix) {\n    if (!matrix.length) return 0;\n\n    let m = matrix.length;\n    let n = matrix[0].length;\n    let height = Array(n + 1).fill(0);\n    let maxArea = 0;\n\n    for (let i = 0; i < m; i++) {\n        let s = [];\n        for (let j = 0; j <= n; j++) {\n            if (j < n) {\n                height[j] = matrix[i][j] === '1' ? height[j] + 1 : 0;\n            }\n            while (s.length && height[j] < height[s[s.length - 1]]) {\n                let h = height[s.pop()];\n                let w = !s.length ? j : j - s[s.length - 1] - 1;\n                maxArea = Math.max(maxArea, h * w);\n            }\n            s.push(j);\n        }\n    }\n\n    return maxArea;\n}\n```\n\n    \n    The algorithm uses a stack to keep track of indices of increasing heights. The height-array is updated every row to add the height of the previous row if the cell value is '1', else it is set to 0. Every time a smaller height is encountered than the top of the stack, we pop the top of the stack and calculate the area using that height (popped value) and the width (current index minus the index below the top of the stack minus 1), updating maxArea with the new maximum value. \n\nThis is done for all the rows of the matrix, and finally, the maxArea is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"],[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"],[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"],[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"]]",
                    "output": " 6",
                    "explanation": " The maximal rectangle is shown in the above picture."
                },
                {
                    "input": " matrix = [[ \"0 \"]]",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " matrix = [[ \"1 \"]]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                    "output": "6"
                },
                {
                    "input": "[[\"0\"]]",
                    "output": "0"
                },
                {
                    "input": "[[\"1\"]]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-14",
        "prompt": "Given a `rows x cols` binary `matrix` filled with `0`'s and `1`'s, find the largest rectangle containing only `1`'s and return _its area_."
    },
    "leetcode-benchmark-15": {
        "id": "leetcode-benchmark-15",
        "title": "Scramble String",
        "difficulty": "Hard",
        "content": {
            "problem": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"great \", s2 =  \"rgeat \"\n**Output:** true\n**Explanation:** One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"abcde \", s2 =  \"caebd \"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** s1 =  \"a \", s2 =  \"a \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `s1.length == s2.length`\n*   `1 <= s1.length <= 30`\n*   `s1` and `s2` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isScramble(String s1, String s2) {\n    if (s1.equals(s2)) return true;\n    if (sorted(s1).equals(sorted(s2)) == false) return false;\n\n    for (int i = 1; i < s1.length(); i++) {\n        if (isScramble(s1.substring(0, i), s2.substring(0, i)) && isScramble(s1.substring(i), s2.substring(i)))\n            return true;\n        if (isScramble(s1.substring(0, i), s2.substring(s2.length() - i)) && isScramble(s1.substring(i), s2.substring(0, s2.length() - i)))\n            return true;\n    }\n    return false;\n}\n\nprivate String sorted(String s) {\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    return new String(chars);\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "c++": "\n    ```cpp\nbool isScramble(string s1, string s2) {\n    if (s1 == s2) return true;\n    if (s1.size() != s2.size() || sort(s1.begin(), s1.end()) != sort(s2.begin(), s2.end())) return false;\n\n    for (int i = 1; i < s1.size(); i++) {\n        if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))\n            return true;\n        if (isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) && isScramble(s1.substr(i), s2.substr(0, s2.size() - i)))\n            return true;\n    }\n    return false;\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "python": "\n    ```python\ndef isScramble(s1: str, s2: str) -> bool:\n    if s1 == s2:\n        return True\n    if len(s1) != len(s2) or sorted(s1) != sorted(s2):\n        return False\n\n    for i in range(1, len(s1)):\n        if (isScramble(s1[:i], s2[:i]) and isScramble(s1[i:], s2[i:])) or \\\n           (isScramble(s1[:i], s2[-i:]) and isScramble(s1[i:], s2[:-i])):\n            return True\n    return False\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "javascript": "\n    ```javascript\nfunction isScramble(s1, s2) {\n    if (s1 === s2) return true;\n    if (s1.length !== s2.length || sorted(s1) !== sorted(s2)) return false;\n\n    for (let i = 1; i < s1.length; i++) {\n        if ((isScramble(s1.slice(0, i), s2.slice(0, i)) && isScramble(s1.slice(i), s2.slice(i))) || \n            (isScramble(s1.slice(0, i), s2.slice(s2.length - i)) && isScramble(s1.slice(i), s2.slice(0, s2.length - i))))\n            return true;\n    }\n    return false;\n}\n\nfunction sorted(s) {\n    return s.split('').sort().join('');\n}\n```\n    \n    The algorithm works by recursively dividing the strings into smaller substrings and checking if the substrings from s1 can be rearranged into the corresponding substrings of s2. The base case is when both strings (s1, and s2) are equal. If the lengths of the strings are different or the characters are different, then the function returns false. Then, we iterate through the length of strings, dividing the strings into smaller substrings and checking if these substrings can be rearranged to form the scrambled string. We check for both possible arrangements of the substrings, i.e., same order and reverse order, invoking the same function recursively for each combination.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s1 =  \"great \", s2 =  \"rgeat \"",
                    "output": " True",
                    "explanation": " One possible scenario applied on s1 is:\n \"great \" -->  \"gr/eat \" // divide at random index.\n \"gr/eat \" -->  \"gr/eat \" // random decision is not to swap the two substrings and keep them in order.\n \"gr/eat \" -->  \"g/r / e/at \" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n \"g/r / e/at \" -->  \"r/g / e/at \" // random decision was to swap the first substring and to keep the second substring in the same order.\n \"r/g / e/at \" -->  \"r/g / e/ a/t \" // again apply the algorithm recursively, divide  \"at \" to  \"a/t \".\n \"r/g / e/ a/t \" -->  \"r/g / e/ a/t \" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is  \"rgeat \" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true."
                },
                {
                    "input": " s1 =  \"abcde \", s2 =  \"caebd \"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " s1 =  \"a \", s2 =  \"a \"",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"great\",\"rgeat\"",
                    "output": "True"
                },
                {
                    "input": "\"abcde\",\"caebd\"",
                    "output": "False"
                },
                {
                    "input": "\"a\",\"a\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-15",
        "prompt": "We can scramble a string s to get a string t using the following algorithm:\n\n1.  If the length of the string is 1, stop.\n2.  If the length of the string is > 1, do the following:\n    *   Split the string into two non-empty substrings at a random index, i.e., if the string is `s`, divide it to `x` and `y` where `s = x + y`.\n    *   **Randomly** decide to swap the two substrings or to keep them in the same order. i.e., after this step, `s` may become `s = x + y` or `s = y + x`.\n    *   Apply step 1 recursively on each of the two substrings `x` and `y`.\n\nGiven two strings `s1` and `s2` of **the same length**, return `true` if `s2` is a scrambled string of `s1`, otherwise, return `false`."
    },
    "leetcode-benchmark-16": {
        "id": "leetcode-benchmark-16",
        "title": "Distinct Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"rabbbit \", t =  \"rabbit \"\n**Output:** 3\n**Explanation:**\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`\n\n",
                "**Example 2:**\n\n**Input:** s =  \"babgbag \", t =  \"bag \"\n**Output:** 5\n**Explanation:**\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, t.length <= 1000`\n*   `s` and `t` consist of English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "c++": "\n    ```cpp\nint numDistinct(string s, string t) {\n    int m = s.size(), n = t.size();\n    vector<vector<unsigned int>> dp(m + 1, vector<unsigned int>(n + 1, 0));\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "python": "\n    ```python\ndef numDistinct(s: str, t: str) -> int:\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "javascript": "\n    ```javascript\nfunction numDistinct(s, t) {\n    const m = s.length, n = t.length;\n    const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));\n\n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of distinct subsequences. The main idea is to create a 2D table `dp` where `dp[i][j]` represents the number of distinct subsequences of the first `i` characters in string `s` that equal the first `j` characters in string `t`. \n\nThe algorithm initializes the first row of the table since there are no subsequences of an empty string. Then, it iterates through each character in both strings, comparing for equality. If the characters are equal, the value of `dp[i][j]` is updated to `dp[i - 1][j - 1] + dp[i - 1][j]`. If the characters are not equal, the value of `dp[i][j]` is updated to `dp[i - 1][j]`. After filling the 2D table, the value at `dp[m][n]` represents the total number of distinct subsequences of `s` that equal `t`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"rabbbit \", t =  \"rabbit \"",
                    "output": " 3",
                    "explanation": "\nAs shown below, there are 3 ways you can generate  \"rabbit \" from s.\n`**rabb**b**it**`\n`**ra**b**bbit**`\n`**rab**b**bit**`"
                },
                {
                    "input": " s =  \"babgbag \", t =  \"bag \"",
                    "output": " 5",
                    "explanation": "\nAs shown below, there are 5 ways you can generate  \"bag \" from s.\n`**ba**b**g**bag`\n`**ba**bgba**g**`\n`**b**abgb**ag**`\n`ba**b**gb**ag**`\n`babg**bag**`"
                }
            ],
            "function_input": [
                {
                    "input": "\"rabbbit\",\"rabbit\"",
                    "output": "3"
                },
                {
                    "input": "\"babgbag\",\"bag\"",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-16",
        "prompt": "Given two strings `s` and `t`, return _the number of distinct_ **_subsequences_** _of_ `s` _which equals_ `t`.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer."
    },
    "leetcode-benchmark-17": {
        "id": "leetcode-benchmark-17",
        "title": "Best Time to Buy and Sell Stock III",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[3,3,5,0,0,3,1,4\\]\n**Output:** 6\n**Explanation:** Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n\n",
                "**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** In this case, no transaction is done, i.e. max profit = 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `0 <= prices[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int buy1 = INT_MAX, buy2 = INT_MAX;\n    int profit1 = 0, profit2 = 0;\n    \n    for (int price : prices) {\n        buy1 = min(buy1, price);\n        profit1 = max(profit1, price - buy1);\n        buy2 = min(buy2, price - profit1);\n        profit2 = max(profit2, price - buy2);\n    }\n    \n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    buy1, buy2 = float(\"inf\"), float(\"inf\")\n    profit1, profit2 = 0, 0\n\n    for price in prices:\n        buy1 = min(buy1, price)\n        profit1 = max(profit1, price - buy1)\n        buy2 = min(buy2, price - profit1)\n        profit2 = max(profit2, price - buy2)\n\n    return profit2\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let buy1 = Infinity, buy2 = Infinity;\n    let profit1 = 0, profit2 = 0;\n\n    for (let price of prices) {\n        buy1 = Math.min(buy1, price);\n        profit1 = Math.max(profit1, price - buy1);\n        buy2 = Math.min(buy2, price - profit1);\n        profit2 = Math.max(profit2, price - buy2);\n    }\n\n    return profit2;\n}\n```\n    \n    1. Initialize variables buy1 and buy2 to track the minimum prices, and profit1 and profit2 to track the maximum profits.\n2. Iterate through prices array.\n3. Update buy1 to the minimum of buy1 and the current price.\n4. Update profit1 to the maximum of profit1 and the current price - buy1.\n5. Update buy2 to the minimum of buy2 and the current price - profit1.\n6. Update profit2 to the maximum of profit2 and the current price - buy2.\n7. Return profit2. This is the profit from two transactions.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " prices = [3,3,5,0,0,3,1,4]",
                    "output": " 6",
                    "explanation": " Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3."
                },
                {
                    "input": " prices = [1,2,3,4,5]",
                    "output": " 4",
                    "explanation": " Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again."
                },
                {
                    "input": " prices = [7,6,4,3,1]",
                    "output": " 0",
                    "explanation": " In this case, no transaction is done, i.e. max profit = 0."
                }
            ],
            "function_input": [
                {
                    "input": "[3,3,5,0,0,3,1,4]",
                    "output": "6"
                },
                {
                    "input": "[1,2,3,4,5]",
                    "output": "4"
                },
                {
                    "input": "[7,6,4,3,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-17",
        "prompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete **at most two transactions**.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."
    },
    "leetcode-benchmark-18": {
        "id": "leetcode-benchmark-18",
        "title": "Palindrome Partitioning II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn _the **minimum** cuts needed for a palindrome partitioning of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aab \"\n**Output:** 1\n**Explanation:** The palindrome partitioning \\[ \"aa \", \"b \"\\] could be produced using 1 cut.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"a \"\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** s =  \"ab \"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 2000`\n*   `s` consists of lowercase English letters only.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minCut(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    boolean[][] isPalindrome = new boolean[n][n];\n    \n    for (int i=0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j=1; j < n; j++) {\n        for (int i=j; i >= 0; i--) {\n            if (s.charAt(i) == s.charAt(j) && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint minCut(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    std::vector<std::vector<bool>> isPalindrome(n, std::vector<bool>(n, false));\n    \n    for (int i = 0; i <= n; i++) {\n        dp[i] = i - 1;\n    }\n    \n    for (int j = 1; j < n; j++) {\n        for (int i = j; i >= 0; i--) {\n            if (s[i] == s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = std::min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "python": "\n    ```python\ndef minCut(s):\n    n = len(s)\n    dp = [i - 1 for i in range(n + 1)]\n    is_palindrome = [[False] * n for _ in range(n)]\n    \n    for j in range(1, n):\n        for i in range(j, -1, -1):\n            if s[i] == s[j] and (j - i < 2 or is_palindrome[i + 1][j - 1]):\n                is_palindrome[i][j] = True\n                dp[j + 1] = min(dp[j + 1], dp[i] + 1)\n                \n    return dp[n]\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "javascript": "\n    ```javascript\nfunction minCut(s) {\n    const n = s.length;\n    const dp = Array.from({ length: n + 1 }, (_, i) => i - 1);\n    const isPalindrome = Array.from({ length: n }, () => Array(n).fill(false));\n    \n    for (let j = 1; j < n; j++) {\n        for (let i = j; i >= 0; i--) {\n            if (s[i] === s[j] && (j - i < 2 || isPalindrome[i + 1][j - 1])) {\n                isPalindrome[i][j] = true;\n                dp[j + 1] = Math.min(dp[j + 1], dp[i] + 1);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    The solution uses dynamic programming with an array `dp` of length `n+1` representing  the minimum cuts. `is_palindrome` is a 2D matrix that stores whether the substring from `i` to `j` of string `s` is palindromic or not.\n\nWe first initialize the `dp` array with values (i-1) for each index 'i'. This represents the maximum possible cuts needed to satisfy the condition.\n\nThen, we iterate over the string in a nested loop. For each substring `s[i:j]`, we check if it is a palindrome. If it is a palindrome, we'll update the `dp` array with the minimum value between the current value of the `dp` array and the value of the `dp` array at `[i]` plus 1. By doing this, we are considering all possible cuts for a palindromic partition of string `s`.\n\nFinally, we return the last element in the `dp` array, representing the minimum cuts needed for a palindrome partitioning of string `s`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aab \"",
                    "output": " 1",
                    "explanation": " The palindrome partitioning \\[ \"aa \", \"b \"\\] could be produced using 1 cut."
                },
                {
                    "input": " s =  \"a \"",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " s =  \"ab \"",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aab\"",
                    "output": "1"
                },
                {
                    "input": "\"a\"",
                    "output": "0"
                },
                {
                    "input": "\"ab\"",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-18",
        "prompt": "Given a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn _the **minimum** cuts needed for a palindrome partitioning of_ `s`."
    },
    "leetcode-benchmark-19": {
        "id": "leetcode-benchmark-19",
        "title": "Candy",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_.",
            "examples": [
                "**Example 1:**\n\n**Input:** ratings = \\[1,0,2\\]\n**Output:** 5\n**Explanation:** You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\n\n",
                "**Example 2:**\n\n**Input:** ratings = \\[1,2,2\\]\n**Output:** 4\n**Explanation:** You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions."
            ],
            "constraints": "**Constraints:**\n\n*   `n == ratings.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= ratings[i] <= 2 * 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minCandies(int[] ratings) {\n    int n = ratings.length;\n    int[] candies = new int[n];\n    for (int i = 0; i < n; i++) candies[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (int i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    int sum = 0;\n    for (int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint minCandies(vector<int>& ratings) {\n    int n = ratings.size();\n    vector<int> candies(n, 1);\n\n    for(int i = 1; i < n; i++) {\n        if(ratings[i] > ratings[i-1]) candies[i] = candies[i-1] + 1;\n    }\n    for(int i = n - 2; i >= 0; i--) {\n        if(ratings[i] > ratings[i+1]) candies[i] = max(candies[i], candies[i+1] + 1);\n    }\n\n    int sum = 0;\n    for(int candy : candies) sum += candy;\n\n    return sum;\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "python": "\n    ```python\ndef min_candies(ratings):\n    n = len(ratings)\n    candies = [1] * n\n\n    for i in range(1, n):\n        if ratings[i] > ratings[i - 1]:\n            candies[i] = candies[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n        if ratings[i] > ratings[i + 1]:\n            candies[i] = max(candies[i], candies[i + 1] + 1)\n\n    return sum(candies)\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "javascript": "\n    ```javascript\nfunction minCandies(ratings) {\n    const n = ratings.length;\n    const candies = Array(n).fill(1);\n\n    for (let i = 1; i < n; i++) {\n        if (ratings[i] > ratings[i - 1]) candies[i] = candies[i - 1] + 1;\n    }\n    for (let i = n - 2; i >= 0; i--) {\n        if (ratings[i] > ratings[i + 1]) candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n    }\n\n    return candies.reduce((a, b) => a + b, 0);\n}\n```\n    \n    The algorithm takes the following steps to find the minimum number of candies needed to be distributed among the children:\n1. Initialize an array or vector 'candies' with the same length as ratings and set all its elements to 1 as every child will have at least 1 candy.\n2. Iterate through the ratings array from the second child to the last child. If the rating of the current child is more than the rating of the previous child, update the candies for the current child as candies of the previous child plus 1.\n3. Now iterate through the ratings array from the second last child to the first child. If the rating of the current child is more than the rating of the next child, update the candies for the current child as maximum between the candies the child already holds and candies of the next child plus 1.\n4. Compute the sum of candies in the candies array or vector.\n5. Return the total number of candies needed.\n\nThis algorithm ensures that we give the proper number of candies to the children based on both their neighbors while also minimizing the total candies used.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " ratings = [1,0,2]",
                    "output": " 5",
                    "explanation": " You can allocate to the first, second and third child with 2, 1, 2 candies respectively."
                },
                {
                    "input": " ratings = [1,2,2]",
                    "output": " 4",
                    "explanation": " You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions."
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,2]",
                    "output": "5"
                },
                {
                    "input": "[1,2,2]",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-19",
        "prompt": "There are `n` children standing in a line. Each child is assigned a rating value given in the integer array `ratings`.\n\nYou are giving candies to these children subjected to the following requirements:\n\n*   Each child must have at least one candy.\n*   Children with a higher rating get more candies than their neighbors.\n\nReturn _the minimum number of candies you need to have to distribute the candies to the children_."
    },
    "leetcode-benchmark-20": {
        "id": "leetcode-benchmark-20",
        "title": "Word Break II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"catsanddog \", wordDict = \\[ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"\\]\n**Output:** \\[ \"cats and dog \", \"cat sand dog \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"pineapplepenapple \", wordDict = \\[ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"\\]\n**Output:** \\[ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"\\]\n**Explanation:** Note that you are allowed to reuse a dictionary word.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 10`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.\n*   Input is generated in a way that the length of the answer doesn't exceed 105.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<String> wordBreak(String s, List<String> wordDict) {\n    HashSet<String> dict = new HashSet<>(wordDict);\n    HashMap<String, List<String>> memo = new HashMap<>();\n    return helper(s, dict, memo);\n}\n\nprivate List<String> helper(String s, HashSet<String> dict, HashMap<String, List<String>> memo) {\n    if (memo.containsKey(s)) {\n        return memo.get(s);\n    }\n    \n    List<String> res = new ArrayList<>();\n    if (dict.contains(s)) {\n        res.add(s);\n    }\n    \n    for (int i = 1; i < s.length(); ++i) {\n        String prefix = s.substring(0, i);\n        if (!dict.contains(prefix)) continue;\n        String suffix = s.substring(i);\n        List<String> temp = helper(suffix, dict, memo);\n        for (String t : temp) {\n            res.add(prefix + \" \" + t);\n        }\n    }\n\n    memo.put(s, res);\n    return res;\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nstd::vector<std::string> helper(const std::string& s, const std::unordered_set<std::string>& dict, std::unordered_map<std::string, std::vector<std::string>>& memo) {\n    if (memo.count(s)) return memo[s];\n\n    std::vector<std::string> res;\n    if (dict.count(s)) res.push_back(s);\n\n    for (int i = 1; i < s.size(); ++i) {\n        std::string prefix = s.substr(0, i);\n        if (!dict.count(prefix)) continue;\n        std::string suffix = s.substr(i);\n        auto temp = helper(suffix, dict, memo);\n        for (const auto& t : temp) {\n            res.push_back(prefix + \" \" + t);\n        }\n    }\n    memo[s] = res;\n    return res;\n}\n\nstd::vector<std::string> wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::unordered_map<std::string, std::vector<std::string>> memo;\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "python": "\n    ```python\ndef word_break(s, word_dict):\n    def helper(s, dict, memo):\n        if s in memo:\n            return memo[s]\n\n        res = []\n        if s in dict:\n            res.append(s)\n\n        for i in range(1, len(s)):\n            prefix = s[:i]\n            if prefix not in dict:\n                continue\n            suffix = s[i:]\n            temp = helper(suffix, dict, memo)\n            for t in temp:\n                res.append(prefix + \" \" + t)\n\n        memo[s] = res\n        return res\n\n    word_set = set(word_dict)\n    memo = {}\n    return helper(s, word_set, memo)\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "javascript": "\n    ```javascript\nfunction wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const memo = {};\n\n    function helper(s, dict, memo) {\n        if (s in memo) {\n            return memo[s];\n        }\n        \n        const res = [];\n        if (dict.has(s)) {\n            res.push(s);\n        }\n        \n        for (let i = 1; i < s.length; ++i) {\n            const prefix = s.slice(0, i);\n            if (!dict.has(prefix)) continue;\n            const suffix = s.slice(i);\n            const temp = helper(suffix, dict, memo);\n            for (const t of temp) {\n                res.push(prefix + \" \" + t);\n            }\n        }\n\n        memo[s] = res;\n        return res;\n    }\n\n    return helper(s, dict, memo);\n}\n```\n    \n    The algorithm used is a combination of depth-first search with memoization. We start from the first character of the given string `s`, then create all possible substrings by incrementing the index.\n\nFor each substring, we check if it exists in the dictionary. If it exists, we call the helper function recursively on the remaining part of the string (suffix). This will give us all the possible combinations for the suffix. Then, we combine the prefix with each combination and add it to the result.\n\nMemoization is used to store the results of the helper function for each substring encountered, so that we don't need to compute it multiple times. This speeds up the algorithm by reducing repeated computations.\n\nFinally, we return the list of combinations where all the words are found in the dictionary.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"catsanddog \", wordDict = [ \"cat \", \"cats \", \"and \", \"sand \", \"dog \"]",
                    "output": " [ \"cats and dog \", \"cat sand dog \"]",
                    "explanation": null
                },
                {
                    "input": " s =  \"pineapplepenapple \", wordDict = [ \"apple \", \"pen \", \"applepen \", \"pine \", \"pineapple \"]",
                    "output": " [ \"pine apple pen apple \", \"pineapple pen apple \", \"pine applepen apple \"]",
                    "explanation": " Note that you are allowed to reuse a dictionary word."
                },
                {
                    "input": " s =  \"catsandog \", wordDict = [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"catsanddog\",[\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
                    "output": "[\"catsanddog\",\"catsanddog\"]"
                },
                {
                    "input": "\"pineapplepenapple\",[\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
                    "output": "[\"pineapplepenapple\",\"pineapplepenapple\",\"pineapplepenapple\"]"
                },
                {
                    "input": "\"catsandog\",[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-20",
        "prompt": "Given a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation."
    },
    "leetcode-benchmark-21": {
        "id": "leetcode-benchmark-21",
        "title": "Find Minimum in Rotated Sorted Array II",
        "difficulty": "Hard",
        "content": {
            "problem": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,4]` if it was rotated `4` times.\n*   `[0,1,4,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` that may contain **duplicates**, return _the minimum element of this array_.\n\nYou must decrease the overall operation steps as much as possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,5\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,0,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   `nums` is sorted and rotated between `1` and `n` times.\n\n**",
            "follow_up": "Follow up:** This problem is similar to [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/), but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?"
        },
        "java": "\n    ```java\npublic int findMin(int[] nums) {\n    int low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "c++": "\n    ```cpp\nint findMin(vector<int>& nums) {\n    int low = 0, high = nums.size() - 1;\n    \n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "python": "\n    ```python\ndef findMin(nums):\n    low, high = 0, len(nums) - 1\n    \n    while low < high:\n        mid = low + (high - low) // 2\n        if nums[mid] > nums[high]:\n            low = mid + 1\n        elif nums[mid] < nums[high]:\n            high = mid\n        else:\n            high -= 1\n            \n    return nums[low]\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "javascript": "\n    ```javascript\nfunction findMin(nums) {\n    let low = 0, high = nums.length - 1;\n    \n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        if (nums[mid] > nums[high]) {\n            low = mid + 1;\n        } else if (nums[mid] < nums[high]) {\n            high = mid;\n        } else {\n            high--;\n        }\n    }\n    return nums[low];\n}\n```\n    \n    The overall algorithm is based on the binary search. We maintain two pointers low and high, initially set to the first and last indices of array nums. Then we perform the following steps until low is less than high:\n\n1. Calculate mid index.\n2. If nums[mid] is greater than nums[high], it means the minimum element lies in the right half of the array, so we set low to mid + 1.\n3. If nums[mid] is less than nums[high], it means the minimum element lies in the left half of the array, so we set high to mid.\n4. If nums[mid] is equal to nums[high], we cannot be certain in which half the minimum element lies, so we simply decrement high by 1.\n\nAt the end, the minimum element will be at index low. The solution takes O(log n) time in the average case and O(n) in the worst case.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,5]",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " nums = [2,2,2,0,1]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,5]",
                    "output": "1"
                },
                {
                    "input": "[2,2,2,0,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-21",
        "prompt": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,4,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,4]` if it was rotated `4` times.\n*   `[0,1,4,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` that may contain **duplicates**, return _the minimum element of this array_.\n\nYou must decrease the overall operation steps as much as possible."
    },
    "leetcode-benchmark-22": {
        "id": "leetcode-benchmark-22",
        "title": "Maximum Gap",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the maximum difference between two successive elements in its sorted form_. If the array contains less than two elements, return `0`.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,6,9,1\\]\n**Output:** 3\n**Explanation:** The sorted form of the array is \\[1,3,6,9\\], either (3,6) or (6,9) has the maximum difference 3.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[10\\]\n**Output:** 0\n**Explanation:** The array contains less than 2 elements, therefore return 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maximumGap(int[] nums) {\n    if (nums.length < 2) return 0;\n\n    int min_val = Arrays.stream(nums).min().getAsInt();\n    int max_val = Arrays.stream(nums).max().getAsInt();\n    int len = nums.length;\n    int bucket_size = Math.max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    int[][] buckets = new int[bucket_num][2];\n    for (int i = 0; i < bucket_num; i++) {\n        buckets[i] = new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE};\n    }\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (int[] bucket : buckets) {\n        if (bucket[0] == Integer.MAX_VALUE) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "c++": "\n    ```cpp\nint maximumGap(vector<int>& nums) {\n    if (nums.size() < 2) return 0;\n    \n    int min_val = *min_element(nums.begin(), nums.end());\n    int max_val = *max_element(nums.begin(), nums.end());\n    int len = nums.size();\n    int bucket_size = max(1, (max_val - min_val) / (len - 1));\n    int bucket_num = (max_val - min_val) / bucket_size + 1;\n    vector<pair<int, int>> buckets(bucket_num, {INT_MAX, INT_MIN});\n\n    for (int num : nums) {\n        int idx = (num - min_val) / bucket_size;\n        buckets[idx].first = min(buckets[idx].first, num);\n        buckets[idx].second = max(buckets[idx].second, num);\n    }\n\n    int max_gap = 0, prev_max = min_val;\n    for (auto& bucket : buckets) {\n        if (bucket.first == INT_MAX) continue;\n        max_gap = max(max_gap, bucket.first - prev_max);\n        prev_max = bucket.second;\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "python": "\n    ```python\ndef maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n\n    min_val = min(nums)\n    max_val = max(nums)\n    length = len(nums)\n    bucket_size = max(1, (max_val - min_val) // (length - 1))\n    bucket_num = (max_val - min_val) // bucket_size + 1\n    buckets = [[float(\"inf\"), float(\"-inf\")] for _ in range(bucket_num)]\n\n    for num in nums:\n        idx = (num - min_val) // bucket_size\n        buckets[idx][0] = min(buckets[idx][0], num)\n        buckets[idx][1] = max(buckets[idx][1], num)\n\n    max_gap = 0\n    prev_max = min_val\n    for bucket in buckets:\n        if bucket[0] == float(\"inf\"):\n            continue\n        max_gap = max(max_gap, bucket[0] - prev_max)\n        prev_max = bucket[1]\n    return max_gap\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "javascript": "\n    ```javascript\nfunction maximumGap(nums) {\n    if (nums.length < 2) return 0;\n\n    let min_val = Math.min(...nums);\n    let max_val = Math.max(...nums);\n    let len = nums.length;\n    let bucket_size = Math.max(1, Math.floor((max_val - min_val) / (len - 1)));\n    let bucket_num = Math.floor((max_val - min_val) / bucket_size) + 1;\n    let buckets = Array.from({ length: bucket_num }, () => [Infinity, -Infinity]);\n\n    for (let num of nums) {\n        let idx = Math.floor((num - min_val) / bucket_size);\n        buckets[idx][0] = Math.min(buckets[idx][0], num);\n        buckets[idx][1] = Math.max(buckets[idx][1], num);\n    }\n\n    let max_gap = 0, prev_max = min_val;\n    for (let bucket of buckets) {\n        if (bucket[0] === Infinity) continue;\n        max_gap = Math.max(max_gap, bucket[0] - prev_max);\n        prev_max = bucket[1];\n    }\n    return max_gap;\n}\n```\n    \n    The algorithm first finds the minimum and maximum values of the input array `nums`. Then it calculates the ideal bucket size by dividing the difference between the maximum and minimum values by the length of the array minus one. The algorithm then initializes an array of buckets, where each bucket contains the minimum and maximum values of its elements.\n\nNext, the algorithm updates the minimum and maximum values for each bucket appropriately by iterating through the input array. Finally, the algorithm calculates the maximum gap by finding the difference between the minimum value of the current bucket and the maximum value of the previous non-empty bucket, and updating the maximum gap value accordingly.\n\nThis algorithm runs in linear time, because it iterates through the input array once to fill the buckets, and then it iterates through the buckets once to compute the maximum gap. It also uses linear extra space, as the number of buckets is proportional to the length of the input array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,6,9,1]",
                    "output": " 3",
                    "explanation": " The sorted form of the array is \\[1,3,6,9\\], either (3,6) or (6,9) has the maximum difference 3."
                },
                {
                    "input": " nums = [10]",
                    "output": " 0",
                    "explanation": " The array contains less than 2 elements, therefore return 0."
                }
            ],
            "function_input": [
                {
                    "input": "[3,6,9,1]",
                    "output": "3"
                },
                {
                    "input": "[10]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-22",
        "prompt": "Given an integer array `nums`, return _the maximum difference between two successive elements in its sorted form_. If the array contains less than two elements, return `0`.\n\nYou must write an algorithm that runs in linear time and uses linear extra space."
    },
    "leetcode-benchmark-23": {
        "id": "leetcode-benchmark-23",
        "title": "Dungeon Game",
        "difficulty": "Hard",
        "content": {
            "problem": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned.",
            "examples": [
                "**Example 1:**\n\n**Input:** dungeon = \\[\\[-2,-3,3\\],\\[-5,-10,1\\],\\[10,30,-5\\]\\]\n**Output:** 7\n**Explanation:** The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN.\n\n",
                "**Example 2:**\n\n**Input:** dungeon = \\[\\[0\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == dungeon.length`\n*   `n == dungeon[i].length`\n*   `1 <= m, n <= 200`\n*   `-1000 <= dungeon[i][j] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int calculateMinimumHP(int[][] dungeon) {\n    int m = dungeon.length, n = dungeon[0].length;\n    int[][] dp = new int[m][n];\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i == m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j == n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nint calculateMinimumHP(vector<vector<int>>& dungeon) {\n    int m = dungeon.size(), n = dungeon[0].size();\n    vector<vector<int>> dp(m, vector<int>(n));\n\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            if(i == m-1 && j == n-1){\n                dp[i][j] = min(0, dungeon[i][j]);\n            }\n            else if (i == m - 1) {\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j]);\n            }\n            else if (j == n - 1) {\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j]);\n            }\n            else {\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n            }\n        }\n    }\n\n    return abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "python": "\n    ```python\ndef calculateMinimumHP(dungeon):\n    m, n = len(dungeon), len(dungeon[0])\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n - 1, -1, -1):\n            if i == m - 1 and j == n - 1:\n                dp[i][j] = min(0, dungeon[i][j])\n            elif i == m - 1:\n                dp[i][j] = min(0, dp[i][j + 1] + dungeon[i][j])\n            elif j == n - 1:\n                dp[i][j] = min(0, dp[i + 1][j] + dungeon[i][j])\n            else:\n                dp[i][j] = min(0, max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j])\n\n    return abs(dp[0][0]) + 1\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "javascript": "\n    ```javascript\nfunction calculateMinimumHP(dungeon) {\n    const m = dungeon.length, n = dungeon[0].length;\n    const dp = new Array(m).fill(0).map(() => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            if (i === m - 1 && j === n - 1)\n                dp[i][j] = Math.min(0, dungeon[i][j]);\n            else if (i === m - 1)\n                dp[i][j] = Math.min(0, dp[i][j + 1] + dungeon[i][j]);\n            else if (j === n - 1)\n                dp[i][j] = Math.min(0, dp[i + 1][j] + dungeon[i][j]);\n            else\n                dp[i][j] = Math.min(0, Math.max(dp[i + 1][j], dp[i][j + 1]) + dungeon[i][j]);\n        }\n    }\n\n    return Math.abs(dp[0][0]) + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum health needed in a bottom-up manner by starting from the bottom-right corner of the dungeon to the top-left corner. We create a \"dp\" table with the same size as the dungeon and fill it initially with zeros. Then we iterate over each cell in the dungeon from the bottom-right to the top-left. For each cell, we consider the right and down adjacent cells (if they exist) and calculate the minimum health required to move forward. We update the \"dp\" table with these values. The minimum of the health required to move right or down, plus the current cell dungeon value, is then stored in the current cell in the \"dp\" table. Finally, we return the absolute value of the top-left cell of \"dp\" table plus one (for the initial health point). This gives us the minimum initial health needed to get to the princess.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " dungeon = [[-2,-3,3],[-5,-10,1],[10,30,-5]]",
                    "output": " 7",
                    "explanation": " The initial health of the knight must be at least 7 if he follows the optimal path: RIGHT-> RIGHT -> DOWN -> DOWN."
                },
                {
                    "input": " dungeon = [[0]]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[-2,-3,3],[-5,-10,1],[10,30,-5]]",
                    "output": "7"
                },
                {
                    "input": "[[0]]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-23",
        "prompt": "The demons had captured the princess and imprisoned her in **the bottom-right corner** of a `dungeon`. The `dungeon` consists of `m x n` rooms laid out in a 2D grid. Our valiant knight was initially positioned in **the top-left room** and must fight his way through `dungeon` to rescue the princess.\n\nThe knight has an initial health point represented by a positive integer. If at any point his health point drops to `0` or below, he dies immediately.\n\nSome of the rooms are guarded by demons (represented by negative integers), so the knight loses health upon entering these rooms; other rooms are either empty (represented as 0) or contain magic orbs that increase the knight's health (represented by positive integers).\n\nTo reach the princess as quickly as possible, the knight decides to move only **rightward** or **downward** in each step.\n\nReturn _the knight's minimum initial health so that he can rescue the princess_.\n\n**Note** that any room can contain threats or power-ups, even the first room the knight enters and the bottom-right room where the princess is imprisoned."
    },
    "leetcode-benchmark-24": {
        "id": "leetcode-benchmark-24",
        "title": "Best Time to Buy and Sell Stock IV",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 2, prices = \\[2,4,1\\]\n**Output:** 2\n**Explanation:** Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\n\n",
                "**Example 2:**\n\n**Input:** k = 2, prices = \\[3,2,6,5,0,3\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= 100`\n*   `1 <= prices.length <= 1000`\n*   `0 <= prices[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxProfit(int k, int[] prices) {\n    int n = prices.length;\n    if (k > n / 2) {\n        int maxProfit = 0;\n        for (int i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    int[][] dp = new int[k + 1][n];\n    for (int i = 1; i <= k; ++i) {\n        int maxDiff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nint maxProfit(int k, std::vector<int>& prices) {\n    int n = prices.size();\n    if (k > n / 2) {\n        int max_profit = 0;\n        for (int i = 1; i < n; ++i)\n            max_profit += std::max(prices[i] - prices[i - 1], 0);\n        return max_profit;  \n    }\n\n    std::vector<std::vector<int>> dp(k + 1, std::vector<int>(n, 0));\n    for (int i = 1; i <= k; ++i) {\n        int max_diff = -prices[0];\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = std::max(dp[i][j - 1], prices[j] + max_diff);\n            max_diff = std::max(max_diff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "python": "\n    ```python\ndef maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(max(prices[i] - prices[i - 1], 0) for i in range(1, n))\n\n    dp = [[0] * n for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    return dp[k][n - 1]\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProfit(k, prices) {\n    let n = prices.length;\n    if (k > n / 2) {\n        let maxProfit = 0;\n        for (let i = 1; i < n; ++i)\n            maxProfit += Math.max(prices[i] - prices[i - 1], 0);\n        return maxProfit;  \n    }\n\n    let dp = new Array(k + 1).fill(null).map(() => new Array(n).fill(0));\n    for (let i = 1; i <= k; ++i) {\n        let maxDiff = -prices[0];\n        for (let j = 1; j < n; ++j) {\n            dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n            maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n        }\n    }\n    return dp[k][n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to build a table `dp` where `dp[i][j]` represents the maximum profit after completing `i` transactions up to day `j`. Initialize `dp` with all zeros, since no initial transactions will result in 0 profit.\n\nFirst, handle the case where `k > n / 2`. If allowed transactions (`k`) are more than half of the available days (`n`), you can simply trade daily by only considering positive profits.\n\nNow, use two nested loops to fill the `dp` table. The outer loop iterates over the allowed transactions (1 to k), and the inner loop iterates over the days (1 to n-1). Inside the inner loop, find the maximum difference between the current day's price and previous days' prices minus the maximum profit after completing one less transaction at previous days (i.e., `prices[j] + dp[i-1][j'] - prices[j']` for all j' < j). This will keep track of the most profitable second transaction after buying a stock at the highest possible profit for the first transaction.\n\nFinally, return the value in the bottom-right corner of the `dp` table (i.e., `dp[k][n-1]`), which provides the maximum profit after completing the allowed number of transactions.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " k = 2, prices = [2,4,1]",
                    "output": " 2",
                    "explanation": " Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2."
                },
                {
                    "input": " k = 2, prices = [3,2,6,5,0,3]",
                    "output": " 7",
                    "explanation": " Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
                }
            ],
            "function_input": [
                {
                    "input": "2,[2,4,1]",
                    "output": "2"
                },
                {
                    "input": "2,[3,2,6,5,0,3]",
                    "output": "7"
                }
            ]
        },
        "task_id": "leetcode-benchmark-24",
        "prompt": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `k`.\n\nFind the maximum profit you can achieve. You may complete at most `k` transactions: i.e. you may buy at most `k` times and sell at most `k` times.\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."
    },
    "leetcode-benchmark-25": {
        "id": "leetcode-benchmark-25",
        "title": "Word Search II",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.\n\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"o \", \"a \", \"a \", \"n \"\\],\\[ \"e \", \"t \", \"a \", \"e \"\\],\\[ \"i \", \"h \", \"k \", \"r \"\\],\\[ \"i \", \"f \", \"l \", \"v \"\\]\\], words = \\[ \"oath \", \"pea \", \"eat \", \"rain \"\\]\n**Output:** \\[ \"eat \", \"oath \"\\]\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \"a \", \"b \"\\],\\[ \"c \", \"d \"\\]\\], words = \\[ \"abcb \"\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 12`\n*   `board[i][j]` is a lowercase English letter.\n*   `1 <= words.length <= 3 * 104`\n*   `1 <= words[i].length <= 10`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are unique.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> findWords(char[][] board, String[] words) {\n    List<String> result = new ArrayList<>();\n    for (String word : words) {\n        if (exist(board, word)) {\n            result.add(word);\n        }\n    }\n    return result;\n}\n\nprivate boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n    boolean[][] visited = new boolean[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, word, 0, i, j, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, String word, int index, int i, int j, boolean[][] visited) {\n    if (index == word.length()) {\n        return true;\n    }\n    if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) {\n        return false;\n    }\n    visited[i][j] = true;\n    boolean found =\n            dfs(board, word, index + 1, i - 1, j, visited) ||\n            dfs(board, word, index + 1, i + 1, j, visited) ||\n            dfs(board, word, index + 1, i, j - 1, visited) ||\n            dfs(board, word, index + 1, i, j + 1, visited);\n    visited[i][j] = false;\n    return found;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid dfs(const std::vector<std::vector<char>>& board, const std::string& word, int index, int i, int j, std::vector<std::vector<bool>>& visited, bool& found){\n    if (index == word.length()) {\n        found = true;\n        return;\n    }\n    if (i < 0 || j < 0 || i >= board.size() || j >= board[0].size() || visited[i][j] || board[i][j] != word[index]){\n        return;\n    }\n    visited[i][j] = true;\n    dfs(board, word, index + 1, i - 1, j, visited, found);\n    dfs(board, word, index + 1, i + 1, j, visited, found);\n    dfs(board, word, index + 1, i, j - 1, visited, found);\n    dfs(board, word, index + 1, i, j + 1, visited, found);\n    visited[i][j] = false;\n}\n\nstd::vector<std::string> findWords(std::vector<std::vector<char>>& board, std::vector<std::string>& words) {\n    std::vector<std::string> result;\n    for (const auto& word : words) {\n        bool found = false;\n        std::vector<std::vector<bool>> visited(board.size(), std::vector<bool>(board[0].size(), false));\n        for (int i = 0; i < board.size() && !found; ++i) {\n            for (int j = 0; j < board[0].size() && !found; ++j) {\n                dfs(board, word, 0, i, j, visited, found);\n            }\n        }\n        if (found) {\n            result.push_back(word);\n        }\n    }\n    return result;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "python": "\n    ```python\ndef findWords(board, words):\n    def dfs(board, word, index, i, j, visited):\n        if index == len(word):\n            return True\n        if i < 0 or j < 0 or i >= len(board) or j >= len(board[0]) or visited[i][j] or board[i][j] != word[index]:\n            return False\n        visited[i][j] = True\n        found = dfs(board, word, index + 1, i - 1, j, visited) or \\\n                dfs(board, word, index + 1, i + 1, j, visited) or \\\n                dfs(board, word, index + 1, i, j - 1, visited) or \\\n                dfs(board, word, index + 1, i, j + 1, visited)\n        visited[i][j] = False\n        return found\n\n    res = []\n    for word in words:\n        if any(dfs(board, word, 0, i, j, [[False] * len(board[0]) for _ in range(len(board))])\n               for i in range(len(board)) for j in range(len(board[0]))):\n            res.append(word)\n    return res\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "javascript": "\n    ```javascript\nfunction findWords(board, words) {\n    function dfs(board, word, index, i, j, visited) {\n        if (index === word.length) {\n            return true;\n        }\n        if (i < 0 || j < 0 || i >= board.length || j >= board[0].length || visited[i][j] || board[i][j] !== word.charAt(index)) {\n            return false;\n        }\n        visited[i][j] = true;\n        const found = dfs(board, word, index + 1, i - 1, j, visited) ||\n                      dfs(board, word, index + 1, i + 1, j, visited) ||\n                      dfs(board, word, index + 1, i, j - 1, visited) ||\n                      dfs(board, word, index + 1, i, j + 1, visited);\n        visited[i][j] = false;\n        return found;\n    }\n\n    const res = [];\n    for (const word of words) {\n        let found = false;\n        for (let i = 0; i < board.length && !found; i++) {\n            for (let j = 0; j < board[0].length && !found; j++) {\n                if (dfs(board, word, 0, i, j, Array.from({ length: board.length }, () => Array(board[0].length).fill(false)))) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            res.push(word);\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm uses Depth First Search (DFS) to search for each word in the board. For each word, we iterate through all the cells in the board and start the DFS search if the current cell matches the word's first letter. During the DFS search, we mark the cell as visited and only continue the search if the next cell we are going to move to is not yet visited, in the allowed board bounds, and it matches the next character of the word. If we reached the end of the word, then we know that this word is found in the board.\n\nFor each programming language, we implemented the `findWords` function that takes the `board` and the `words` as an input and returns a list of found words. The core algorithm is the same, but the language-specific syntax and constructs are used accordingly.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[ \"o \", \"a \", \"a \", \"n \"],[ \"e \", \"t \", \"a \", \"e \"],[ \"i \", \"h \", \"k \", \"r \"],[ \"i \", \"f \", \"l \", \"v \"]], words = [ \"oath \", \"pea \", \"eat \", \"rain \"]",
                    "output": " [ \"eat \", \"oath \"]",
                    "explanation": null
                },
                {
                    "input": " board = [[ \"a \", \"b \"],[ \"c \", \"d \"]], words = [ \"abcb \"]",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]],[\"oath\",\"pea\",\"eat\",\"rain\"]",
                    "output": "[\"eat\",\"oath\"]"
                },
                {
                    "input": "[[\"a\",\"b\"],[\"c\",\"d\"]],[\"abcb\"]",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-25",
        "prompt": "Given an `m x n` `board` of characters and a list of strings `words`, return _all words on the board_.\n\nEach word must be constructed from letters of sequentially adjacent cells, where **adjacent cells** are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word."
    },
    "leetcode-benchmark-26": {
        "id": "leetcode-benchmark-26",
        "title": "Shortest Palindrome",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string `s`. You can convert `s` to a palindrome by adding characters in front of it.\n\nReturn _the shortest palindrome you can find by performing this transformation_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"aacecaaa\"\n**Output:** \"aaacecaaa\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"abcd\"\n**Output:** \"dcbabcd\""
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of lowercase English letters only.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String shortestPalindrome(String s) {\n    int n = s.length();\n    String rev_s = new StringBuilder(s).reverse().toString();\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substring(0, n - i).equals(rev_s.substring(i)))\n            return rev_s.substring(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string shortestPalindrome(std::string s) {\n    int n = s.size();\n    std::string rev_s = s;\n    std::reverse(rev_s.begin(), rev_s.end());\n    \n    for (int i = 0; i < n; ++i) {\n        if(s.substr(0, n - i) == rev_s.substr(i))\n            return rev_s.substr(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "python": "\n    ```python\ndef shortest_palindrome(s: str) -> str:\n    n = len(s)\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        if s[:n - i] == rev_s[i:]:\n            return rev_s[:i] + s\n    return \"\"\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "javascript": "\n    ```javascript\nfunction shortestPalindrome(s) {\n    let n = s.length;\n    let rev_s = s.split('').reverse().join('');\n    \n    for (let i = 0; i < n; ++i) {\n        if (s.slice(0, n - i) === rev_s.slice(i))\n            return rev_s.slice(0, i) + s;\n    }\n    return \"\";\n}\n```\n\n    \n    1. Take input string `s`.\n2. Get string `rev_s` by reversing the input string.\n3. Iterate through the characters in both strings.\n4. For each index `i`, compare the substring `[0, n - i)` of `s` and substring `[i, n)` of `rev_s`.\n5. If the substrings match, concatenate the non-matching substring of `rev_s` and the original input string `s`. This will result in the shortest palindromic string we can build.\n6. If not, continue with the next iteration.\n7. The function returns an empty string if an exception occurs.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"aacecaaa\"",
                    "output": " \"aaacecaaa\"",
                    "explanation": null
                },
                {
                    "input": " s = \"abcd\"",
                    "output": " \"dcbabcd\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aacecaaa\"",
                    "output": "\"aaacecaaa\""
                },
                {
                    "input": "\"abcd\"",
                    "output": "\"dcbabcd\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-26",
        "prompt": "You are given a string `s`. You can convert `s` to a palindrome by adding characters in front of it.\n\nReturn _the shortest palindrome you can find by performing this transformation_."
    },
    "leetcode-benchmark-27": {
        "id": "leetcode-benchmark-27",
        "title": "Basic Calculator",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return _the result of the evaluation_.\n\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"1 + 1 \"\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** s =  \" 2-1 + 2  \"\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** s =  \"(1+(4+5+2)-3)+(6+8) \"\n**Output:** 23"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of digits, `'+'`, `'-'`, `'('`, `')'`, and `' '`.\n*   `s` represents a valid expression.\n*   `'+'` is **not** used as a unary operation (i.e., `\"+1 \"` and `\"+(2 + 3) \"` is invalid).\n*   `'-'` could be used as a unary operation (i.e., `\"-1 \"` and `\"-(2 + 3) \"` is valid).\n*   There will be no two consecutive operators in the input.\n*   Every number and running calculation will fit in a signed 32-bit integer.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int calculate(String s) {\n    int result = 0, sign = 1, num = 0;\n    Stack<Integer> st = new Stack<>();\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.pop();\n                int prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "c++": "\n    ```cpp\nint calculate(string s) {\n    int result = 0, sign = 1, num = 0;\n    stack<int> st;\n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c == '+') {\n                sign = 1;\n            } else if (c == '-') {\n                sign = -1;\n            } else if (c == '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                int prev_sign = st.top();\n                st.pop();\n                int prev_result = st.top();\n                st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "python": "\n    ```python\ndef calculate(s: str) -> int:\n    result = 0\n    sign = 1\n    num = 0\n    st = []\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        else:\n            result += sign * num\n            num = 0\n            if c == '+':\n                sign = 1\n            elif c == '-':\n                sign = -1\n            elif c == '(':\n                st.append(result)\n                st.append(sign)\n                result = 0\n                sign = 1\n            elif c == ')':\n                prev_sign = st.pop()\n                prev_result = st.pop()\n                result = prev_result + prev_sign * result\n    result += sign * num\n    return result\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "javascript": "\n    ```javascript\nfunction calculate(s) {\n    let result = 0, sign = 1, num = 0;\n    let st = [];\n    for (let c of s) {\n        if (/\\d/.test(c)) {\n            num = num * 10 + (c - '0');\n        } else {\n            result += sign * num;\n            num = 0;\n            if (c === '+') {\n                sign = 1;\n            } else if (c === '-') {\n                sign = -1;\n            } else if (c === '(') {\n                st.push(result);\n                st.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c === ')') {\n                let prev_sign = st.pop();\n                let prev_result = st.pop();\n                result = prev_result + prev_sign * result;\n            }\n        }\n    }\n    result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm first initializes variables `result`, `sign`, and `num` along with a stack `st`. It iterates through each character of the given string, `s`. If a digit is encountered, we update `num`, otherwise, if an operator, `(` or `)` is found, we perform the appropriate operation and update the variables accordingly. For example, we store the current result and sign onto the stack when we encounter a `(` and calculate the result when we encounter a `)` and use the stack to track the values of previous results and signs. Finally, we return the final result after the iteration is complete.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"1 + 1 \"",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " s =  \" 2-1 + 2  \"",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " s =  \"(1+(4+5+2)-3)+(6+8) \"",
                    "output": " 23",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"1+1\"",
                    "output": "2"
                },
                {
                    "input": "\"2-1+2\"",
                    "output": "3"
                },
                {
                    "input": "\"(1+(4+5+2)-3)+(6+8)\"",
                    "output": "23"
                }
            ]
        },
        "task_id": "leetcode-benchmark-27",
        "prompt": "Given a string `s` representing a valid expression, implement a basic calculator to evaluate it, and return _the result of the evaluation_.\n\n**Note:** You are **not** allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`."
    },
    "leetcode-benchmark-28": {
        "id": "leetcode-benchmark-28",
        "title": "Number of Digit One",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countDigitOne(int n) {\n    int count = 0;\n    for(long i = 1; i <= n; i *= 10){\n        long divider = i * 10;\n        count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "c++": "\n    ```cpp\nint countDigitOne(int n) {\n    int count = 0;\n    for(long long i = 1; i <= n; i *= 10){\n        int divider = i * 10;\n        count += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "python": "\n    ```python\ndef countDigitOne(n):\n    count = 0\n    i = 1\n    while i <= n:\n        divider = i * 10\n        count += (n // divider) * i + min(max(n % divider - i + 1, 0), i)\n        i *= 10\n    return count\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "javascript": "\n    ```javascript\nfunction countDigitOne(n) {\n    let count = 0;\n    for(let i = 1; i <= n; i *= 10){\n        let divider = i * 10;\n        count += Math.floor(n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n    }\n    return count;\n}\n```\n    \n    1. The algorithm uses a loop that iterates from the digit 1 to the highest digit in the given number, starting with 1 and incrementing by multiplying by 10 each iteration (1, 10, 100...).\n2. On each iteration, the algorithm checks how many times 1's appear in the current digit:\n   a. Calculates the occurrences of digit 1 contributed by the higher digits (n / divider) * i.\n   b. Counts the remaining occurrences in the current digit using the formula min(max(n % divider - i + 1, 0), i).\n3. It sums up the occurrences for each digit in a variable called `count`.\n4. When the loop ends, all occurrences of digit 1 have been considered, and `count` has the final sum of all occurrences.\n\nThe algorithm runs in O(log10(n)) time complexity since the loop runs for however many digits there are in the input number.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 13",
                    "output": " 6",
                    "explanation": null
                },
                {
                    "input": " n = 0",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "13",
                    "output": "6"
                },
                {
                    "input": "0",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-28",
        "prompt": "Given an integer `n`, count _the total number of digit_ `1` _appearing in all non-negative integers less than or equal to_ `n`."
    },
    "leetcode-benchmark-29": {
        "id": "leetcode-benchmark-29",
        "title": "Strobogrammatic Number III",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two strings low and high that represent two integers `low` and `high` where `low <= high`, return _the number of **strobogrammatic numbers** in the range_ `[low, high]`.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** low = \"50\", high = \"100\"\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** low = \"0\", high = \"0\"\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= low.length, high.length <= 15`\n*   `low` and `high` consist of only digits.\n*   `low <= high`\n*   `low` and `high` do not contain any leading zeros except for zero itself.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int strobogrammaticInRange(String low, String high) {\n    int count = 0;\n    for(int len = low.length(); len <= high.length(); ++len)\n        count += withinRange(helper(len, len), low, high) ? 1 : 0;\n    return count;\n}\n\nprivate String helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    String res = \"\";\n    for(String a : helper(m - 2, n).split(\" \")) {\n        if(m != n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n\nprivate boolean withinRange(String num, String low, String high) {\n    if(num.length() > low.length()) return num.compareTo(high) <= 0;\n    if(num.length() < low.length()) return num.compareTo(low) >= 0;\n    return num.compareTo(low) >= 0 && num.compareTo(high) <= 0;\n}\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "c++": "\n    ```cpp\nint strobogrammaticInRange(string low, string high) {\n    int count = 0;\n    for(int len = low.size(); len <= high.size(); ++len)\n        count += helper(len, len) <= high ? helper(len, len) >= low ? 1 : 0 : 0;\n    return count;\n}\n\nstring helper(int m, int n) {\n    if(m == 0) return \"\";\n    if(m == 1) return \"0 1 8\";\n    if(n == 0) return \"11 69 88 96\";\n    string res = \"\";\n    for(auto a : helper(m - 2, n)) {\n        if(m != n) res += a + \"0\" + a;\n        res += a + \"1\" + a;\n        res += a + \"6\" + a;\n        res += a + \"8\" + a;\n        res += a + \"9\" + a;\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "python": "\n    ```python\ndef strobogrammaticInRange(low, high):\n    count = 0\n    for len in range(len(low), len(high)+1):\n        count += 1 if low <= helper(len, len) <= high else 0\n    return count\n\ndef helper(m, n):\n    if m == 0:\n        return \"\"\n    if m == 1:\n        return \"0 1 8\"\n    if n == 0:\n        return \"11 69 88 96\"\n    res = \"\"\n    for a in helper(m-2, n).split():\n        if m != n:\n            res += a + \"0\" + a + \" \"\n        res += a + \"1\" + a + \" \"\n        res += a + \"6\" + a + \" \"\n        res += a + \"8\" + a + \" \"\n        res += a + \"9\" + a + \" \"\n    return res\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "javascript": "\n    ```javascript\nfunction strobogrammaticInRange(low, high) {\n    let count = 0;\n    for (let len = low.length; len <= high.length; ++len) {\n        const num = helper(len, len);\n        count += (num >= low && num <= high) ? 1 : 0;\n    }\n    return count;\n}\n\nfunction helper(m, n) {\n    if (m === 0) return \"\";\n    if (m === 1) return \"0 1 8\";\n    if (n === 0) return \"11 69 88 96\";\n    let res = \"\";\n    for (const a of helper(m - 2, n).split(\" \")) {\n        if (m !== n) res += a + \"0\" + a + \" \";\n        res += a + \"1\" + a + \" \";\n        res += a + \"6\" + a + \" \";\n        res += a + \"8\" + a + \" \";\n        res += a + \"9\" + a + \" \";\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we will use a recursive approach. \nWe will create a helper function that takes two arguments m and n where m represents the remaining length of the number, and n represents the original length of the number. This helper function will return the strobogrammatic numbers of that length as a space-separated string.\n\nIn the helper function:\n\n1. If m is 0, we return an empty string.\n2. If m is 1, we return \"0 1 8\" representing the single-digit strobogrammatic numbers.\n3. If n is 0, we return \"11 69 88 96\" representing the two-digit strobogrammatic numbers.\n\nFor each character `a` in the strobogrammatic numbers of length `m-2`:\n\n1. If m is not equal to n, add a '0' in between the characters and concatenate to the result string.\n2. Add '1', '6', '8', and '9' in between the characters, and concatenate to the result string.\n\nThen, in the strobogrammaticInRange function, we iterate through the range of lengths from `low` to `high`. For each length, we check if the strobogrammatic number of that length is within the range `[low, high]`, and if it is, we increase the count by 1.\n\nFinally, we return the total count of strobogrammatic numbers within the specified range.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " low = \"50\", high = \"100\"",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " low = \"0\", high = \"0\"",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"50\",\"100\"",
                    "output": "3"
                },
                {
                    "input": "\"0\",\"0\"",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-29",
        "prompt": "Given two strings low and high that represent two integers `low` and `high` where `low <= high`, return _the number of **strobogrammatic numbers** in the range_ `[low, high]`.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down)."
    },
    "leetcode-benchmark-30": {
        "id": "leetcode-benchmark-30",
        "title": "Paint House II",
        "difficulty": "Hard",
        "content": {
            "problem": "There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...\n\nReturn _the minimum cost to paint all houses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** costs = \\[\\[1,5,3\\],\\[2,9,4\\]\\]\n**Output:** 5\n**Explanation:**\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5.\n\n",
                "**Example 2:**\n\n**Input:** costs = \\[\\[1,3\\],\\[2,4\\]\\]\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == k`\n*   `1 <= n <= 100`\n*   `2 <= k <= 20`\n*   `1 <= costs[i][j] <= 20`\n\n**",
            "follow_up": "Follow up:** Could you solve it in `O(nk)` runtime?"
        },
        "java": "\n    ```java\npublic int minCost(int[][] costs) {\n    if (costs == null || costs.length == 0) return 0;\n\n    int n = costs.length;\n    int k = costs[0].length;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < k; j++) {\n            int minCost = Integer.MAX_VALUE;\n            for (int l = 0; l < k; l++) {\n                if (l == j) continue;\n                minCost = Math.min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return Arrays.stream(costs[n - 1]).min().getAsInt();\n}\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n\n    int n = costs.size();\n    int k = costs[0].size();\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < k; ++j) {\n            int minCost = INT_MAX;\n            for (int l = 0; l < k; ++l) {\n                if (l == j) continue;\n                minCost = min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return *min_element(costs[n - 1].begin(), costs[n - 1].end());\n}\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "python": "\n    ```python\ndef min_cost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n\n    n, k = len(costs), len(costs[0])\n\n    for i in range(1, n):\n        for j in range(k):\n            min_cost = float(\"inf\")\n            for l in range(k):\n                if l == j:\n                    continue\n                min_cost = min(min_cost, costs[i - 1][l])\n            costs[i][j] += min_cost\n\n    return min(costs[n - 1])\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "javascript": "\n    ```javascript\nfunction minCost(costs) {\n    if (!costs || costs.length === 0) return 0;\n\n    const n = costs.length;\n    const k = costs[0].length;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < k; j++) {\n            let minCost = Number.MAX_VALUE;\n            for (let l = 0; l < k; l++) {\n                if (l === j) continue;\n                minCost = Math.min(minCost, costs[i - 1][l]);\n            }\n            costs[i][j] += minCost;\n        }\n    }\n    return Math.min(...costs[n - 1]);\n}\n```\n\n    \n    The algorithm stores the minimum cost to paint each house up to the current house with each color. Then for each house, it iterates through all the colors and calculates the minimum cost for painting that house with each color. It skips the same color as the previous house because no two adjacent houses can have the same color. After processing all the houses, the minimum of the last row in `costs` is the minimum cost to paint all the houses.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " costs = [[1,5,3],[2,9,4]]",
                    "output": " 5",
                    "explanation": "\nPaint house 0 into color 0, paint house 1 into color 2. Minimum cost: 1 + 4 = 5; \nOr paint house 0 into color 2, paint house 1 into color 0. Minimum cost: 3 + 2 = 5."
                },
                {
                    "input": " costs = [[1,3],[2,4]]",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,5,3],[2,9,4]]",
                    "output": "5"
                },
                {
                    "input": "[[1,3],[2,4]]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-30",
        "prompt": "There are a row of `n` houses, each house can be painted with one of the `k` colors. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x k` cost matrix costs.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with color `0`; `costs[1][2]` is the cost of painting house `1` with color `2`, and so on...\n\nReturn _the minimum cost to paint all houses_."
    },
    "leetcode-benchmark-31": {
        "id": "leetcode-benchmark-31",
        "title": "Best Meeting Point",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an `m x n` binary grid `grid` where each `1` marks the home of one friend, return _the minimal **total travel distance**_.\n\nThe **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.\n\nThe distance is calculated using [Manhattan Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0,1\\],\\[0,0,0,0,0\\],\\[0,0,1,0,0\\]\\]\n**Output:** 6\n**Explanation:** Given three friends living at (0,0), (0,4), and (2,2).\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.\nSo return 6.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `grid[i][j]` is either `0` or `1`.\n*   There will be **at least two** friends in the `grid`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minTotalDistance(int[][] grid) {\n    List<Integer> rows = new ArrayList<Integer>();\n    List<Integer> cols = new ArrayList<Integer>();\n    int m = grid.length, n = grid[0].length;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                rows.add(i);\n                cols.add(j);\n            }\n        }\n    }\n    Collections.sort(cols);\n    int row_median = rows.get(rows.size() / 2), col_median = cols.get(cols.size() / 2);\n    int distance = 0;\n    for (int i : rows) distance += Math.abs(i - row_median);\n    for (int j : cols) distance += Math.abs(j - col_median);\n    return distance;\n}\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "c++": "\n    ```cpp\nint minTotalDistance(vector<vector<int>>& grid) {\n    vector<int> rows, cols;\n    int m = grid.size(), n = grid[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j]) {\n                rows.push_back(i);\n                cols.push_back(j);\n            }\n        }\n    }\n    sort(cols.begin(), cols.end());\n    int row_median = rows[rows.size() / 2], col_median = cols[cols.size() / 2];\n    int distance = 0;\n    for (int i : rows) distance += abs(i - row_median);\n    for (int j : cols) distance += abs(j - col_median);\n    return distance;\n}\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "python": "\n    ```python\ndef minTotalDistance(grid):\n    m, n = len(grid), len(grid[0])\n    rows, cols = [], []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows.append(i)\n                cols.append(j)\n\n    cols.sort()\n    row_median, col_median = rows[len(rows) // 2], cols[len(cols) // 2]\n    distance = sum(abs(i - row_median) for i in rows) + sum(abs(j - col_median) for j in cols)\n    return distance\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "javascript": "\n    ```javascript\nvar minTotalDistance = function(grid) {\n    let m = grid.length, n = grid[0].length;\n    let rows = [], cols = [];\n    for (let i = 0; i < m; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (grid[i][j] === 1) {\n                rows.push(i);\n                cols.push(j);\n            }\n        }\n    }\n    cols.sort((a, b) => a - b);\n    let row_median = rows[Math.floor(rows.length / 2)], col_median = cols[Math.floor(cols.length / 2)];\n    let distance = rows.reduce((acc, i) => acc + Math.abs(i - row_median), 0) + cols.reduce((acc, j) => acc + Math.abs(j - col_median), 0);\n    return distance;\n};\n```\n    \n    1. Iterate through the given grid and store the row and column indices separately for each friend's home.\n2. Sort the columns list.\n3. Find the median of row and column separately (using middle element in sorted list) as it represents the optimal meeting point.\n4. Calculate the total distance by summing up Manhattan Distance for each friend to the meeting point.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
                    "output": " 6",
                    "explanation": " Given three friends living at (0,0), (0,4), and (2,2).\nThe point (0,2) is an ideal meeting point, as the total travel distance of 2 + 2 + 2 = 6 is minimal.\nSo return 6."
                },
                {
                    "input": " grid = [[1,1]]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]",
                    "output": "6"
                },
                {
                    "input": "[[1,1]]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-31",
        "prompt": "Given an `m x n` binary grid `grid` where each `1` marks the home of one friend, return _the minimal **total travel distance**_.\n\nThe **total travel distance** is the sum of the distances between the houses of the friends and the meeting point.\n\nThe distance is calculated using [Manhattan Distance](http://en.wikipedia.org/wiki/Taxicab_geometry), where `distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|`."
    },
    "leetcode-benchmark-32": {
        "id": "leetcode-benchmark-32",
        "title": "Smallest Rectangle Enclosing Black Pixels",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` binary matrix `image` where `0` represents a white pixel and `1` represents a black pixel.\n\nThe black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.\n\nGiven two integers `x` and `y` that represents the location of one of the black pixels, return _the area of the smallest (axis-aligned) rectangle that encloses all black pixels_.\n\nYou must write an algorithm with less than `O(mn)` runtime complexity",
            "examples": [
                "**Example 1:**\n\n**Input:** image = \\[\\[ \"0 \", \"0 \", \"1 \", \"0 \"\\],\\[ \"0 \", \"1 \", \"1 \", \"0 \"\\],\\[ \"0 \", \"1 \", \"0 \", \"0 \"\\]\\], x = 0, y = 2\n**Output:** 6\n\n",
                "**Example 2:**\n\n**Input:** image = \\[\\[ \"1 \"\\]\\], x = 0, y = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == image.length`\n*   `n == image[i].length`\n*   `1 <= m, n <= 100`\n*   `image[i][j]` is either `'0'` or `'1'`.\n*   `0 <= x < m`\n*   `0 <= y < n`\n*   `image[x][y] == '1'.`\n*   The black pixels in the `image` only form **one component**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minArea(char[][] image, int x, int y) {\n    int top = x, bottom = x, left = y, right = y;\n    for (int i = 0; i < image.length; ++i) {\n        for (int j = 0; j < image[i].length; ++j) {\n            if (image[i][j] == '1') {\n                top = Math.min(top, i);\n                bottom = Math.max(bottom, i);\n                left = Math.min(left, j);\n                right = Math.max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "c++": "\n    ```cpp\nint minArea(vector<vector<char>>& image, int x, int y) {\n    int top = x, bottom = x, left = y, right = y;\n    for (int i = 0; i < image.size(); ++i) {\n        for (int j = 0; j < image[i].size(); ++j) {\n            if (image[i][j] == '1') {\n                top = min(top, i);\n                bottom = max(bottom, i);\n                left = min(left, j);\n                right = max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "python": "\n    ```python\ndef minArea(image, x, y):\n    top, bottom, left, right = x, x, y, y\n    for i, row in enumerate(image):\n        for j, cell in enumerate(row):\n            if cell == '1':\n                top, bottom = min(top, i), max(bottom, i)\n                left, right = min(left, j), max(right, j)\n    return (bottom - top + 1) * (right - left + 1)\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "javascript": "\n    ```javascript\nfunction minArea(image, x, y) {\n    let top = x, bottom = x, left = y, right = y;\n    for (let i = 0; i < image.length; ++i) {\n        for (let j = 0; j < image[i].length; ++j) {\n            if (image[i][j] === '1') {\n                top = Math.min(top, i);\n                bottom = Math.max(bottom, i);\n                left = Math.min(left, j);\n                right = Math.max(right, j);\n            }\n        }\n    }\n    return (bottom - top + 1) * (right - left + 1);\n}\n```\n    \n    For each language, we first initialize the `top`, `bottom`, `left`, and `right` variables to the starting point `x` and `y`. Then, we iterate through the cells of the `image` matrix. If the cell value is `'1'` (a black pixel), we update the `top,` `bottom`, `left`, and `right` variables by taking the minimum and/or maximum value depending on the variables, respectively. Once the iteration is complete, we return the product of the difference of `bottom` and `top` (plus 1) and the difference of `right` and `left` (plus 1). This gives us the area of the smallest rectangle that encloses all the black pixels.\n\nThe complexity of the algorithm would be `O(mn)` if we were not given the starting point `(x, Y)`; however, since we have the starting point, the complexity will be smaller in practice.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " image = [[ \"0 \", \"0 \", \"1 \", \"0 \"],[ \"0 \", \"1 \", \"1 \", \"0 \"],[ \"0 \", \"1 \", \"0 \", \"0 \"]], x = 0, y = 2",
                    "output": " 6",
                    "explanation": null
                },
                {
                    "input": " image = [[ \"1 \"]], x = 0, y = 0",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"0\",\"0\",\"1\",\"0\"],[\"0\",\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"0\"]],0,2",
                    "output": "6"
                },
                {
                    "input": "[[\"1\"]],0,0",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-32",
        "prompt": "You are given an `m x n` binary matrix `image` where `0` represents a white pixel and `1` represents a black pixel.\n\nThe black pixels are connected (i.e., there is only one black region). Pixels are connected horizontally and vertically.\n\nGiven two integers `x` and `y` that represents the location of one of the black pixels, return _the area of the smallest (axis-aligned) rectangle that encloses all black pixels_.\n\nYou must write an algorithm with less than `O(mn)` runtime complexity"
    },
    "leetcode-benchmark-33": {
        "id": "leetcode-benchmark-33",
        "title": "Number of Islands II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).\n\nWe may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [ri, ci]` is the position `(ri, ci)` at which we should operate the `ith` operation.\n\nReturn _an array of integers_ `answer` _where_ `answer[i]` _is the number of islands after turning the cell_ `(ri, ci)` _into a land_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, positions = \\[\\[0,0\\],\\[0,1\\],\\[1,2\\],\\[2,1\\]\\]\n**Output:** \\[1,1,2,3\\]\n**Explanation:**\nInitially, the 2d grid is filled with water.\n- Operation #1: addLand(0, 0) turns the water at grid\\[0\\]\\[0\\] into a land. We have 1 island.\n- Operation #2: addLand(0, 1) turns the water at grid\\[0\\]\\[1\\] into a land. We still have 1 island.\n- Operation #3: addLand(1, 2) turns the water at grid\\[1\\]\\[2\\] into a land. We have 2 islands.\n- Operation #4: addLand(2, 1) turns the water at grid\\[2\\]\\[1\\] into a land. We have 3 islands.\n\n",
                "**Example 2:**\n\n**Input:** m = 1, n = 1, positions = \\[\\[0,0\\]\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n, positions.length <= 104`\n*   `1 <= m * n <= 104`\n*   `positions[i].length == 2`\n*   `0 <= ri < m`\n*   `0 <= ci < n`\n\n**",
            "follow_up": "Follow up:** Could you solve it in time complexity `O(k log(mn))`, where `k == positions.length`?"
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<Integer> numIslands2(int m, int n, int[][] positions) {\n    int[] roots = new int[m * n];\n    Arrays.fill(roots, -1);\n    int[][] dirs = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int islandCount = 0;\n    List<Integer> result = new ArrayList<>();\n\n    for (int[] position : positions) {\n        int i = position[0], j = position[1], index = i * n + j;\n        if (roots[index] != -1) {\n            result.add(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[index] = index;\n        for (int[] dir : dirs) {\n            int ni = i + dir[0], nj = j + dir[1], neighbor = ni * n + nj;\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {\n                int rootNb = find(roots, neighbor);\n                if (index != rootNb) {\n                    roots[rootNb] = index;\n                    islandCount--;\n                }\n            }\n        }\n        result.add(islandCount);\n    }\n    return result;\n}\n\nprivate int find(int[] roots, int x) {\n    if (roots[x] != x) roots[x] = find(roots, roots[x]);\n    return roots[x];\n}\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nusing namespace std;\n\nvector<int> numIslands2(int m, int n, vector<vector<int>>& positions) {\n    vector<int> roots(m * n, -1);\n    vector<vector<int>> dirs{{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n    int islandCount = 0;\n    vector<int> result;\n    \n    auto getIndex = [&](int i, int j){\n        return i * n + j;\n    };        \n    \n    function<int(int)> findRoot = [&](int x) {\n        if (roots[x] != x) {\n            roots[x] = findRoot(roots[x]);\n        }\n        return roots[x];\n    };\n    \n    for(const auto& position : positions) {\n        int i = position[0], j = position[1], index = getIndex(i, j);\n        if (roots[index] != -1) {\n            result.push_back(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[index] = index;\n        for (const auto& dir : dirs) {\n            int ni = i + dir[0], nj = j + dir[1], neighbor = getIndex(ni, nj);\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] != -1) {\n                int rootNb = findRoot(neighbor);\n                if (index != rootNb) {\n                    roots[rootNb] = index;\n                    islandCount--;\n                }\n            }\n        }\n        result.push_back(islandCount);\n    }\n    return result;\n}\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "python": "\n    ```python\ndef numIslands2(m: int, n: int, positions: List[List[int]]) -> List[int]:\n    def index(x: int, y: int) -> int:\n        return x * n + y\n    \n    def find(x: int) -> int:\n        if roots[x] != x:\n            roots[x] = find(roots[x])\n        return roots[x]\n\n    roots = [-1] * (m * n)\n    dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n    islandCount = 0\n    result = []\n\n    for i, j in positions:\n        idx = index(i, j)\n        if roots[idx] != -1:\n            result.append(islandCount)\n            continue\n        islandCount += 1\n        roots[idx] = idx\n        for dx, dy in dirs:\n            ni, nj = i + dx, j + dy\n            neighbor = index(ni, nj)\n            if 0 <= ni < m and 0 <= nj < n and roots[neighbor] != -1:\n                root_neighbor = find(neighbor)\n                if idx != root_neighbor:\n                    roots[root_neighbor] = idx\n                    islandCount -= 1\n        result.append(islandCount)\n    return result\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "javascript": "\n    ```javascript\nfunction numIslands2(m, n, positions) {\n    const roots = new Array(m * n).fill(-1);\n    const dirs = [[0, 1], [1, 0], [-1, 0], [0, -1]];\n    let islandCount = 0;\n    const result = [];\n\n    const index = (x, y) => x * n + y;\n    \n    function find(x) {\n        if (roots[x] !== x) roots[x] = find(roots[x]);\n        return roots[x];\n    }\n\n    for (const [i, j] of positions) {\n        const idx = index(i, j);\n        if (roots[idx] !== -1) {\n            result.push(islandCount);\n            continue;\n        }\n        islandCount++;\n        roots[idx] = idx;\n        for (const [dx, dy] of dirs) {\n            const ni = i + dx, nj = j + dy;\n            const neighbor = index(ni, nj);\n            if (ni >= 0 && ni < m && nj >= 0 && nj < n && roots[neighbor] !== -1) {\n                const root_neighbor = find(neighbor);\n                if (idx !== root_neighbor) {\n                    roots[root_neighbor] = idx;\n                    islandCount--;\n                }\n            }\n        }\n        result.push(islandCount);\n    }\n    return result;\n}\n```\n\n    \n    We will use a Union-Find data structure to keep track of the number of distinct islands. Initially, we set all the cells of the grid as water cells which are -1 in the `roots` array.\n\nFor each position in `positions`, let's consider it as a new land. We'll increment the island count at this point. If this cell was already processed as land, it is already in the same group or set of lands, so we just push the current island count as part of the result.\n\nNext, we will check and merge the neighboring cells if they are lands. We iterate through 4 possible neighbors (up, down, left, and right) and find their root. If the root of the neighbor is different than the root of the current cell, we merge the sets and decrement island count.\n\nFinally, we push the current island count after processing each position as part of the result.\n\nThe time complexity is O(k * log(mn)) as the Union-Find data structure has a log(n) time complexity for find and union operations.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " m = 3, n = 3, positions = [[0,0],[0,1],[1,2],[2,1]]",
                    "output": " [1,1,2,3]",
                    "explanation": "\nInitially, the 2d grid is filled with water.\n- Operation #1: addLand(0, 0) turns the water at grid\\[0\\]\\[0\\] into a land. We have 1 island.\n- Operation #2: addLand(0, 1) turns the water at grid\\[0\\]\\[1\\] into a land. We still have 1 island.\n- Operation #3: addLand(1, 2) turns the water at grid\\[1\\]\\[2\\] into a land. We have 2 islands.\n- Operation #4: addLand(2, 1) turns the water at grid\\[2\\]\\[1\\] into a land. We have 3 islands."
                },
                {
                    "input": " m = 1, n = 1, positions = [[0,0]]",
                    "output": " [1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3,3,[[0,0],[0,1],[1,2],[2,1]]",
                    "output": "[1,1,2,3]"
                },
                {
                    "input": "1,1,[[0,0]]",
                    "output": "[1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-33",
        "prompt": "You are given an empty 2D binary grid `grid` of size `m x n`. The grid represents a map where `0`'s represent water and `1`'s represent land. Initially, all the cells of `grid` are water cells (i.e., all the cells are `0`'s).\n\nWe may perform an add land operation which turns the water at position into a land. You are given an array `positions` where `positions[i] = [ri, ci]` is the position `(ri, ci)` at which we should operate the `ith` operation.\n\nReturn _an array of integers_ `answer` _where_ `answer[i]` _is the number of islands after turning the cell_ `(ri, ci)` _into a land_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water."
    },
    "leetcode-benchmark-34": {
        "id": "leetcode-benchmark-34",
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,1,5,8\\]\n**Output:** 167\n**Explanation:**\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5\\]\n**Output:** 10"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `0 <= nums[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxCoins(int[] nums) {\n    int n = nums.length;\n    int[] newNums = new int[n + 2];\n    newNums[0] = 1;\n    newNums[n + 1] = 1;\n    for (int i = 1; i <= n; i++) {\n        newNums[i] = nums[i - 1];\n    }\n\n    int[][] dp = new int[n + 2][n + 2];\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], newNums[left - 1] * newNums[i] * newNums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "c++": "\n    ```cpp\nint maxCoins(vector<int>& nums) {\n    int n = nums.size();\n    nums.insert(nums.begin(), 1);\n    nums.push_back(1);\n\n    vector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n    for (int len = 1; len <= n; len++) {\n        for (int left = 1; left <= n - len + 1; left++) {\n            int right = left + len - 1;\n            for (int i = left; i <= right; i++) {\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "python": "\n    ```python\ndef maxCoins(nums):\n    nums = [1] + nums + [1]\n    n = len(nums)\n    dp = [[0] * n for _ in range(n)]\n\n    for length in range(1, n - 1):\n        for left in range(1, n - length):\n            right = left + length - 1\n            for i in range(left, right + 1):\n                dp[left][right] = max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right])\n\n    return dp[1][n - 2]\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "javascript": "\n    ```javascript\nfunction maxCoins(nums) {\n    nums.unshift(1);\n    nums.push(1);\n    const n = nums.length;\n\n    const dp = [];\n    for (let i = 0; i < n; i++) {\n        dp.push(new Array(n).fill(0));\n    }\n\n    for (let len = 1; len <= n - 2; len++) {\n        for (let left = 1; left <= n - len - 1; left++) {\n            const right = left + len - 1;\n            for (let i = left; i <= right; i++) {\n                dp[left][right] = Math.max(dp[left][right], nums[left - 1] * nums[i] * nums[right + 1] + dp[left][i - 1] + dp[i + 1][right]);\n            }\n        }\n    }\n\n    return dp[1][n - 2];\n}\n```\n    \n    This problem can be solved using dynamic programming. We define a 2D array `dp` where `dp[left][right]` represents the maximum coins we can get by bursting the balloons from index `left` to `right`. To fill `dp`, we iterate over all possible subarrays (by varying length) and calculate the optimal solution for each subarray by choosing the bursting order. For each subarray, we iterate over all balloons, bursting the `i`th balloon and taking the maximum value between the current `dp[left][right]` and the obtained coins by bursting the `i`th balloon + the coins obtained by bursting the balloons on the left of `i`th balloon + the coins obtained by bursting the balloons on the right of `i`th balloon. Finally, we return `dp[1][n - 2]` since we added dummy balloons with value 1 at the beginning and end.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,1,5,8]",
                    "output": " 167",
                    "explanation": "\nnums = \\[3,1,5,8\\] --> \\[3,5,8\\] --> \\[3,8\\] --> \\[8\\] --> \\[\\]\ncoins =  3\\*1\\*5    +   3\\*5\\*8   +  1\\*3\\*8  + 1\\*8\\*1 = 167"
                },
                {
                    "input": " nums = [1,5]",
                    "output": " 10",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,1,5,8]",
                    "output": "167"
                },
                {
                    "input": "[1,5]",
                    "output": "10"
                }
            ]
        },
        "task_id": "leetcode-benchmark-34",
        "prompt": "You are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then treat it as if there is a balloon with a `1` painted on it.\n\nReturn _the maximum coins you can collect by bursting the balloons wisely_."
    },
    "leetcode-benchmark-35": {
        "id": "leetcode-benchmark-35",
        "title": "Count of Smaller Numbers After Self",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _an integer array_ `counts` _where_ `counts[i]` _is the number of smaller elements to the right of_ `nums[i]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,2,6,1\\]\n**Output:** \\[2,1,1,0\\]\n**Explanation:**\nTo the right of 5 there are **2** smaller elements (2 and 1).\nTo the right of 2 there is only **1** smaller element (1).\nTo the right of 6 there is **1** smaller element (1).\nTo the right of 1 there is **0** smaller element.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1\\]\n**Output:** \\[0\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[-1,-1\\]\n**Output:** \\[0,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> countSmaller(int[] nums) {\n    int n = nums.length;\n    int[] indices = new int[n];\n    int[] counts = new int[n];\n    \n    for (int i = 0; i < n; i++) {\n        indices[i] = i;\n    }\n    \n    mergeSort(nums, indices, counts, 0, n - 1);\n    List<Integer> result = new ArrayList<>();\n    for (int count : counts) {\n        result.add(count);\n    }\n    return result;\n}\n\nprivate void mergeSort(int[] nums, int[] indices, int[] counts, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n    \n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indices, counts, left, mid);\n    mergeSort(nums, indices, counts, mid + 1, right);\n    \n    int[] temp = new int[right - left + 1];\n    int i = left, j = mid + 1, k = 0;\n    while (i <= mid && j <= right) {\n        if (nums[indices[i]] <= nums[indices[j]]) {\n            counts[indices[i]] += j - mid - 1;\n            temp[k++] = indices[i++];\n        } else {\n            temp[k++] = indices[j++];\n        }\n    }\n    \n    while (i <= mid) {\n        counts[indices[i]] += j - mid - 1;\n        temp[k++] = indices[i++];\n    }\n    \n    while (j <= right) {\n        temp[k++] = indices[j++];\n    }\n    \n    System.arraycopy(temp, 0, indices, left, right - left + 1);\n}\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nvector<int> countSmaller(vector<int>& nums) {\n    vector<int> result(nums.size(), 0);\n    vector<int> indices(nums.size(), 0);\n\n    for (int i = 0; i < nums.size(); ++i) {\n        indices[i] = i;\n    }\n\n    mergeSort(nums, indices, result, 0, nums.size() - 1);\n    return result;\n}\n\nvoid mergeSort(vector<int>& nums, vector<int>& indices, vector<int>& result, int left, int right) {\n    if (left >= right) {\n        return;\n    }\n\n    int mid = left + (right - left) / 2;\n    mergeSort(nums, indices, result, left, mid);\n    mergeSort(nums, indices, result, mid + 1, right);\n\n\n    int I = left;\n    int J = mid + 1;\n    int K = 0;\n    vector<int> temp(right - left + 1);\n    while (I <= mid && J <= right) {\n        if (nums[indices[I]] <= nums[indices[J]]) {\n            result[indices[I]] += (J - mid - 1);\n            temp[K++] = indices[I++];\n        } else {\n            temp[K++] = indices[J++];\n        }\n    }\n\n    while (I <= mid) {\n        result[indices[I]] += (J - mid - 1);\n        temp[K++] = indices[I++];\n    }\n\n    while (J <= right) {\n        temp[K++] = indices[J++];\n    }\n\n    for (int i = left, k = 0; i <= right; ++i, ++k) {\n        indices[i] = temp[k];\n    }\n}\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "python": "\n    ```python\ndef countSmaller(nums):\n    def merge_sort(indices):\n        if len(indices) <= 1:\n            return indices\n        mid = len(indices) // 2\n        left = merge_sort(indices[:mid])\n        right = merge_sort(indices[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        merged, count = [], 0\n        while left and right:\n            if nums[left[0]] <= nums[right[0]]:\n                counts[left[0]] += count\n                merged.append(left.pop(0))\n            else:\n                count += len(left)\n                merged.append(right.pop(0))\n        for i in left:\n            counts[i] += count\n        return merged + left + right\n\n    counts = [0] * len(nums)\n    merge_sort(list(range(len(nums))))\n    return counts\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "javascript": "\n    ```javascript\nfunction countSmaller(nums) {\n    function mergeSort(indices, start, end) {\n        if (start >= end) {\n            return;\n        }\n\n        let mid = start + ((end - start) >> 1);\n        mergeSort(indices, start, mid);\n        mergeSort(indices, mid + 1, end);\n\n        let i = start, j = mid + 1, k = 0, cnt = 0;\n        let temp = [];\n        while (i <= mid || j <= end) {\n            if (j > end || (i <= mid && nums[indices[i]] <= nums[indices[j]])) {\n                cnt += j - mid - 1;\n                counts[indices[i]] = cnt;\n                temp[k++] = indices[i++];\n            } else {\n                temp[k++] = indices[j++];\n            }\n        }\n\n        for (let i = 0; i < k; i++) {\n            indices[start + i] = temp[i];\n        }\n    }\n    \n    let counts = Array(nums.length).fill(0);\n    let indices = Array.from({length: nums.length}, (_, i) => i);\n    mergeSort(indices, 0, nums.length - 1);\n    return counts;\n}\n```\n    \n    The algorithm uses a modified merge sort to track the count of smaller elements to the right of each element in the array. The modification is made to merge function. During the merge process, whenever an element from the right side of the array is merged into the sorted subarray (meaning it's smaller than some elements), the count for those elements from the left side of the array is updated by adding the number of elements in the left subarray processed so far. The time complexity of this algorithm is O(n log n) due to the merge sort, and space complexity is O(n) for the auxiliary arrays used. \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [5,2,6,1]",
                    "output": " [2,1,1,0]",
                    "explanation": "\nTo the right of 5 there are **2** smaller elements (2 and 1).\nTo the right of 2 there is only **1** smaller element (1).\nTo the right of 6 there is **1** smaller element (1).\nTo the right of 1 there is **0** smaller element."
                },
                {
                    "input": " nums = [-1]",
                    "output": " [0]",
                    "explanation": null
                },
                {
                    "input": " nums = [-1,-1]",
                    "output": " [0,0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[5,2,6,1]",
                    "output": "[2,1,1,0]"
                },
                {
                    "input": "[-1]",
                    "output": "[0]"
                },
                {
                    "input": "[-1,-1]",
                    "output": "[0,0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-35",
        "prompt": "Given an integer array `nums`, return _an integer array_ `counts` _where_ `counts[i]` _is the number of smaller elements to the right of_ `nums[i]`."
    },
    "leetcode-benchmark-36": {
        "id": "leetcode-benchmark-36",
        "title": "Count of Range Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and two integers `lower` and `upper`, return _the number of range sums that lie in_ `[lower, upper]` _inclusive_.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,5,-1\\], lower = -2, upper = 2\n**Output:** 3\n**Explanation:** The three ranges are: \\[0,0\\], \\[2,2\\], and \\[0,2\\] and their respective sums are: -2, -1, 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\], lower = 0, upper = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `-105 <= lower <= upper <= 105`\n*   The answer is **guaranteed** to fit in a **32-bit** integer.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countRangeSum(int[] nums, int lower, int upper) {\n    long[] sums = new long[nums.length + 1];\n    for (int i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    return countWhileMergeSort(sums, lower, upper, 0, nums.length);\n}\n\nprivate int countWhileMergeSort(long[] sums, int lower, int upper, int start, int end) {\n    if (start >= end)\n        return 0;\n\n    int mid = start + (end - start) / 2;\n    int count = countWhileMergeSort(sums, lower, upper, start, mid) + countWhileMergeSort(sums, lower, upper, mid + 1, end);\n\n    int j = mid + 1, k = mid + 1;\n    for (int i = start; i <= mid; ++i) {\n        while (j <= end && sums[j] - sums[i] < lower) ++j;\n        while (k <= end && sums[k] - sums[i] <= upper) ++k;\n        count += k - j;\n    }\n\n    Arrays.sort(sums, start, end + 1);\n    return count;\n}\n```\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "c++": "\n    ```cpp\nint countRangeSum(vector<int>& nums, int lower, int upper) {\n    int n = nums.size();\n    vector<long> sums(n + 1, 0);\n    for (int i = 0; i < n; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function<int(int, int)> mergeSort = [&](int start, int end) {\n        if (start == end)\n            return 0;\n        int mid = start + (end - start) / 2;\n        int count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        int j = mid + 1, k = mid + 1;\n        for (int i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        inplace_merge(sums.begin() + start, sums.begin() + mid + 1, sums.begin() + end + 1);\n        return count;\n    };\n\n    return mergeSort(0, n);\n}\n```\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "python": "\n    ```python\ndef countRangeSum(nums, lower, upper):\n    sums = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        sums[i + 1] = sums[i] + nums[i]\n\n    def mergeSort(start, end):\n        if start == end:\n            return 0\n        mid = start + (end - start) // 2\n        count = mergeSort(start, mid) + mergeSort(mid + 1, end)\n\n        j, k = mid + 1, mid + 1\n        for i in range(start, mid + 1):\n            while j <= end and sums[j] - sums[i] < lower: j += 1\n            while k <= end and sums[k] - sums[i] <= upper: k += 1\n            count += k - j\n\n        sums[start:end + 1] = sorted(sums[start:end + 1])\n        return count\n\n    return mergeSort(0, len(nums))\n```\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "javascript": "\n    ```javascript\nfunction countRangeSum(nums, lower, upper) {\n    let sums = new Array(nums.length + 1).fill(0);\n    for (let i = 0; i < nums.length; ++i)\n        sums[i + 1] = sums[i] + nums[i];\n\n    function mergeSort(start, end) {\n        if (start === end)\n            return 0;\n        let mid = start + Math.floor((end - start) / 2);\n        let count = mergeSort(start, mid) + mergeSort(mid + 1, end);\n\n        let j = mid + 1, k = mid + 1;\n        for (let i = start; i <= mid; ++i) {\n            while (j <= end && sums[j] - sums[i] < lower) ++j;\n            while (k <= end && sums[k] - sums[i] <= upper) ++k;\n            count += k - j;\n        }\n\n        let sortedPart = sums.slice(start, end + 1).sort((a, b) => a - b);\n        for (let i = start; i <= end; ++i) {\n            sums[i] = sortedPart[i - start];\n        }\n\n        return count;\n    };\n\n    return mergeSort(0, nums.length);\n}\n```\n\n    \n    The algorithm is based on the divide-and-conquer strategy. First, we calculate the cumulative sums of the input array. Then, we apply a modified merge-sort function to count the number of range sums that lie in the [lower, upper] interval.\n\nDuring the merge-sort, for each subarray from index i to mid, we find the first `j` and the first `k` that meet the following conditions:\n- `sums[j] - sums[i] >= lower`, and\n- `sums[k] - sums[i] > upper`.\n\nThe number of range sums in this subarray that lie in the [lower, upper] interval is `k - j`. We add this count to the result.\n\nFinally, we merge the sorted partitions of the subarray.\n\nThis process is repeated recursively for all subarrays until only one element remains. At the end, the function should return the total count of range sums that lie in the [lower, upper] interval.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-2,5,-1], lower = -2, upper = 2",
                    "output": " 3",
                    "explanation": " The three ranges are: \\[0,0\\], \\[2,2\\], and \\[0,2\\] and their respective sums are: -2, -1, 2."
                },
                {
                    "input": " nums = [0], lower = 0, upper = 0",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[-2,5,-1],-2,2",
                    "output": "3"
                },
                {
                    "input": "[0],0,0",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-36",
        "prompt": "Given an integer array `nums` and two integers `lower` and `upper`, return _the number of range sums that lie in_ `[lower, upper]` _inclusive_.\n\nRange sum `S(i, j)` is defined as the sum of the elements in `nums` between indices `i` and `j` inclusive, where `i <= j`."
    },
    "leetcode-benchmark-37": {
        "id": "leetcode-benchmark-37",
        "title": "Patching Array",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.\n\nReturn _the minimum number of patches required_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3\\], n = 6\n**Output:** 1\nExplanation:\nCombinations of nums are \\[1\\], \\[3\\], \\[1,3\\], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: \\[1\\], \\[2\\], \\[3\\], \\[1,3\\], \\[2,3\\], \\[1,2,3\\].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range \\[1, 6\\].\nSo we only need 1 patch.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,5,10\\], n = 20\n**Output:** 2\nExplanation: The two patches can be \\[2, 4\\].\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,2\\], n = 5\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 104`\n*   `nums` is sorted in **ascending order**.\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minPatches(int[] nums, int n) {\n    long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "c++": "\n    ```cpp\nint minPatches(vector<int>& nums, int n) {\n    long long maxSum = 0;\n    int patches = 0, i = 0;\n    \n    while (maxSum < n) {\n        if (i < nums.size() && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "python": "\n    ```python\ndef minPatches(nums, n):\n    max_sum = 0\n    patches = 0\n    i = 0\n\n    while max_sum < n:\n        if i < len(nums) and nums[i] <= max_sum + 1:\n            max_sum += nums[i]\n            i += 1\n        else:\n            max_sum += max_sum + 1\n            patches += 1\n\n    return patches\n```\n\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "javascript": "\n    ```javascript\nfunction minPatches(nums, n) {\n    let maxSum = 0;\n    let patches = 0;\n    let i = 0;\n\n    while (maxSum < n) {\n        if (i < nums.length && nums[i] <= maxSum + 1) {\n            maxSum += nums[i];\n            i++;\n        } else {\n            maxSum += maxSum + 1;\n            patches++;\n        }\n    }\n    return patches;\n}\n```\n\n    \n    The algorithm maintains a variable `maxSum` which stores the maximum sum that can be obtained using the current elements in the nums array. Initially, `maxSum` is set to 0, and we iterate through the array until `maxSum` is greater than or equal to the given `n`.\n\nDuring the iteration, if the current element (nums[i]) is less than or equal to `maxSum + 1`, we can extend our sum range by updating `maxSum += nums[i]`. This means that the current element can be used to form a sum in the target range.\n\nHowever, if the current nums[i] is greater than `maxSum + 1`, a patch would be needed. To minimize the number of patches, the best element to add would be `maxSum + 1`, as it extends the current maxSum twice as much without gaps. So, we update `maxSum += maxSum + 1`, and increment the patches count.\n\nWe repeat this process until `maxSum` reaches or exceeds the given `n`. Finally, we return the number of patches used.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3], n = 6",
                    "output": " 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.",
                    "explanation": null
                },
                {
                    "input": " nums = [1,5,10], n = 20",
                    "output": " 2\nExplanation: The two patches can be [2, 4].",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2,2], n = 5",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3],6",
                    "output": "1\nExplanation:\nCombinationsofnumsare[1],[3],[1,3],whichformpossiblesumsof:1,3,4.\nNowifweadd/patch2tonums,thecombinationsare:[1],[2],[3],[1,3],[2,3],[1,2,3].\nPossiblesumsare1,2,3,4,5,6,whichnowcoverstherange[1,6].\nSoweonlyneed1patch."
                },
                {
                    "input": "[1,5,10],20",
                    "output": "2\nExplanation:Thetwopatchescanbe[2,4]."
                },
                {
                    "input": "[1,2,2],5",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-37",
        "prompt": "Given a sorted integer array `nums` and an integer `n`, add/patch elements to the array such that any number in the range `[1, n]` inclusive can be formed by the sum of some elements in the array.\n\nReturn _the minimum number of patches required_."
    },
    "leetcode-benchmark-38": {
        "id": "leetcode-benchmark-38",
        "title": "Self Crossing",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an **X-Y plane,** and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\nReturn `true` _if your path crosses itself or_ `false` _if it does not_.",
            "examples": [
                "**Example 1:**\n\n**Input:** distance = \\[2,1,1,2\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 1).\n\n",
                "**Example 2:**\n\n**Input:** distance = \\[1,2,3,4\\]\n**Output:** false\n**Explanation:** The path does not cross itself at any point.\n\n",
                "**Example 3:**\n\n**Input:** distance = \\[1,1,1,2,1\\]\n**Output:** true\n**Explanation:** The path crosses itself at the point (0, 0)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= distance.length <= 105`\n*   `1 <= distance[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isPathCrossing(int[] distance) {\n    Set<Pair<Integer, Integer>> visited = new HashSet<>();\n    int x = 0, y = 0;\n    visited.add(new Pair<>(x, y));\n    int[] dx = {0, -1, 0, 1};\n    int[] dy = {1, 0, -1, 0};\n    \n    for (int i = 0; i < distance.length; i++) {\n        int direction = i % 4;\n        for (int j = 0; j < distance[i]; j++) {\n            x += dx[direction];\n            y += dy[direction];\n            Pair<Integer, Integer> point = new Pair<>(x, y);\n            if (!visited.add(point)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "c++": "\n    ```cpp\nbool isPathCrossing(const std::vector<int>& distance) {\n    std::unordered_set<std::pair<int, int>, pair_hash> visited;\n    int x = 0, y = 0;\n    visited.insert({x, y});\n    int dx[] = {0, -1, 0, 1};\n    int dy[] = {1, 0, -1, 0};\n    \n    for (int i = 0; i < distance.size(); ++i) {\n        int direction = i % 4;\n        for (int j = 0; j < distance[i]; ++j) {\n            x += dx[direction];\n            y += dy[direction];\n            if (!visited.insert({x, y}).second) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "python": "\n    ```python\ndef is_path_crossing(distance):\n    visited = set([(0, 0)])\n    x, y = 0, 0\n    directions = [(0, 1), (-1, 0), (0, -1), (1, 0)]\n    \n    for i, d in enumerate(distance):\n        dx, dy = directions[i % 4]\n        for _ in range(d):\n            x += dx\n            y += dy\n            if (x, y) in visited:\n                return True\n            visited.add((x, y))\n    return False\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "javascript": "\n    ```javascript\nfunction isPathCrossing(distance) {\n    let visited = new Set([\"0,0\"]);\n    let x = 0, y = 0;\n    const dx = [0, -1, 0, 1];\n    const dy = [1, 0, -1, 0];\n    \n    for (let i = 0; i < distance.length; i++) {\n        let direction = i % 4;\n        for (let j = 0; j < distance[i]; j++) {\n            x += dx[direction];\n            y += dy[direction];\n            let point = `${x},${y}`; \n            if (visited.has(point)) {\n                return true;\n            }\n            visited.add(point);\n        }\n    }\n    return false;\n}\n```\n\n    \n    - Create a visited set containing the initial starting point `(0, 0)`\n- Create variables x, y initialized as 0, which represent the current position\n- Create two arrays dx, and dy to represent the change in the x and y directions for each step depending on the current direction (north, west, south, east).\n- Use a nested loop to iterate over each step in given distances\n  - Calculate the current direction using modulo operation\n  - Move x and y based on the current direction using dx and dy\n  - Check if the resulting point is in the visited set. If so, return True\n  - Otherwise, add the point to the visited set\n- After iterating through all steps, return False if no crossing has been detected\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " distance = [2,1,1,2]",
                    "output": " True",
                    "explanation": " The path crosses itself at the point (0, 1)."
                },
                {
                    "input": " distance = [1,2,3,4]",
                    "output": " False",
                    "explanation": " The path does not cross itself at any point."
                },
                {
                    "input": " distance = [1,1,1,2,1]",
                    "output": " True",
                    "explanation": " The path crosses itself at the point (0, 0)."
                }
            ],
            "function_input": [
                {
                    "input": "[2,1,1,2]",
                    "output": "True"
                },
                {
                    "input": "[1,2,3,4]",
                    "output": "False"
                },
                {
                    "input": "[1,1,1,2,1]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-38",
        "prompt": "You are given an array of integers `distance`.\n\nYou start at the point `(0, 0)` on an **X-Y plane,** and you move `distance[0]` meters to the north, then `distance[1]` meters to the west, `distance[2]` meters to the south, `distance[3]` meters to the east, and so on. In other words, after each move, your direction changes counter-clockwise.\n\nReturn `true` _if your path crosses itself or_ `false` _if it does not_."
    },
    "leetcode-benchmark-39": {
        "id": "leetcode-benchmark-39",
        "title": "Palindrome Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a **0-indexed** array of **unique** strings `words`.\n\nA **palindrome pair** is a pair of integers `(i, j)` such that:\n\n*   `0 <= i, j < words.length`,\n*   `i != j`, and\n*   `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.\n\nReturn _an array of all the **palindrome pairs** of_ `words`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abcd \", \"dcba \", \"lls \", \"s \", \"sssll \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\],\\[3,2\\],\\[2,4\\]\\]\n**Explanation:** The palindromes are \\[ \"abcddcba \", \"dcbaabcd \", \"slls \", \"llssssll \"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"bat \", \"tab \", \"cat \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n**Explanation:** The palindromes are \\[ \"battab \", \"tabbat \"\\]\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"a \", \" \"\\]\n**Output:** \\[\\[0,1\\],\\[1,0\\]\\]\n**Explanation:** The palindromes are \\[ \"a \", \"a \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 5000`\n*   `0 <= words[i].length <= 300`\n*   `words[i]` consists of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> palindromePairs(String[] words) {\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < words.length; i++) {\n        for (int j = 0; j < words.length; j++) {\n            if (i == j) continue;\n            String concat = words[i] + words[j];\n\n            boolean isPalindrome = true;\n            for (int left = 0, right = concat.length() - 1; left < right; left++, right--) {\n                if (concat.charAt(left) != concat.charAt(right)) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n\n            if (isPalindrome) {\n                List<Integer> pair = new ArrayList<>();\n                pair.add(i);\n                pair.add(j);\n                result.add(pair);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::pair<int, int>> palindromePairs(const std::vector<std::string> &words) {\n    std::vector<std::pair<int, int>> result;\n\n    for (size_t i = 0; i < words.size(); i++) {\n        for (size_t j = 0; j < words.size(); j++) {\n            if (i == j) continue;\n            std::string concat = words[i] + words[j];\n\n            bool is_palindrome = true;\n            for (size_t left = 0, right = concat.size() - 1; left < right; left++, right--) {\n                if (concat[left] != concat[right]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n\n            if (is_palindrome) {\n                result.push_back(std::make_pair(i, j));\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "python": "\n    ```python\ndef palindrome_pairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    result = []\n    for i in range(len(words)):\n        for j in range(len(words)):\n            if i == j:\n                continue\n            concat = words[i] + words[j]\n            if is_palindrome(concat):\n                result.append([i, j])\n    return result\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "javascript": "\n    ```javascript\nfunction palindromePairs(words) {\n    function isPalindrome(s) {\n        return s === s.split('').reverse().join('');\n    }\n\n    const result = [];\n    for (let i = 0; i < words.length; i++) {\n        for (let j = 0; j < words.length; j++) {\n            if (i === j) continue;\n            const concat = words[i] + words[j];\n            if (isPalindrome(concat)) {\n                result.push([i, j]);\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm starts by defining a nested function `isPalindrome` to check if a given string is a palindrome. This function will be used later in the code. \n\nThen, a `result` list (vector in C++) is created to store the index pairs of the palindrome concatenations.\n\nTwo nested loops are used to iterate through all the pairs of words in the input list. If the two words are the same (i.e., the indices `i` and `j` are equal), the current iteration is ignored (with a `continue` statement). This ensures that we only process distinct pairs of words.\n\nNext, we concatenate the two words, and check if the resulting string is a palindrome using the `isPalindrome` function. If it is, we add the indices as a pair to the `result` list.\n\nOnce the two loops complete, the `result` list is returned, containing all the unique index pairs (i, j) where the concatenation of words[i] and words[j] is a palindrome.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"abcd \", \"dcba \", \"lls \", \"s \", \"sssll \"]",
                    "output": " [[0,1],[1,0],[3,2],[2,4]]",
                    "explanation": " The palindromes are \\[ \"abcddcba \", \"dcbaabcd \", \"slls \", \"llssssll \"\\]"
                },
                {
                    "input": " words = [ \"bat \", \"tab \", \"cat \"]",
                    "output": " [[0,1],[1,0]]",
                    "explanation": " The palindromes are \\[ \"battab \", \"tabbat \"\\]"
                },
                {
                    "input": " words = [ \"a \", \" \"]",
                    "output": " [[0,1],[1,0]]",
                    "explanation": " The palindromes are \\[ \"a \", \"a \"\\]"
                }
            ],
            "function_input": [
                {
                    "input": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
                    "output": "[[0,1],[1,0],[3,2],[2,4]]"
                },
                {
                    "input": "[\"bat\",\"tab\",\"cat\"]",
                    "output": "[[0,1],[1,0]]"
                },
                {
                    "input": "[\"a\",\"\"]",
                    "output": "[[0,1],[1,0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-39",
        "prompt": "You are given a **0-indexed** array of **unique** strings `words`.\n\nA **palindrome pair** is a pair of integers `(i, j)` such that:\n\n*   `0 <= i, j < words.length`,\n*   `i != j`, and\n*   `words[i] + words[j]` (the concatenation of the two strings) is a palindrome.\n\nReturn _an array of all the **palindrome pairs** of_ `words`."
    },
    "leetcode-benchmark-40": {
        "id": "leetcode-benchmark-40",
        "title": "Perfect Rectangle",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]` represents an axis-aligned rectangle. The bottom-left point of the rectangle is `(xi, yi)` and the top-right point of it is `(ai, bi)`.\n\nReturn `true` _if all the rectangles together form an exact cover of a rectangular region_.",
            "examples": [
                "**Example 1:**\n\n**Input:** rectangles = \\[\\[1,1,3,3\\],\\[3,1,4,2\\],\\[3,2,4,4\\],\\[1,3,2,4\\],\\[2,3,3,4\\]\\]\n**Output:** true\n**Explanation:** All 5 rectangles together form an exact cover of a rectangular region.\n\n",
                "**Example 2:**\n\n**Input:** rectangles = \\[\\[1,1,2,3\\],\\[1,3,2,4\\],\\[3,1,4,2\\],\\[3,2,4,4\\]\\]\n**Output:** false\n**Explanation:** Because there is a gap between the two rectangular regions.\n\n",
                "**Example 3:**\n\n**Input:** rectangles = \\[\\[1,1,3,3\\],\\[3,1,4,2\\],\\[1,3,2,4\\],\\[2,2,4,4\\]\\]\n**Output:** false\n**Explanation:** Because two of the rectangles overlap with each other."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rectangles.length <= 2 * 104`\n*   `rectangles[i].length == 4`\n*   `-105 <= xi, yi, ai, bi <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.awt.Point;\n\npublic class RectCover {\n    public boolean isRectangleCover(int[][] rectangles) {\n        int area = 0;\n        Set<Point> points = new HashSet<>();\n        int lx = Integer.MAX_VALUE, ly = Integer.MAX_VALUE, rx = Integer.MIN_VALUE, ry = Integer.MIN_VALUE;\n\n        for (int[] rect : rectangles) {\n            lx = Math.min(lx, rect[0]);\n            ly = Math.min(ly, rect[1]);\n            rx = Math.max(rx, rect[2]);\n            ry = Math.max(ry, rect[3]);\n\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n            Point p1 = new Point(rect[0], rect[1]);\n            Point p2 = new Point(rect[0], rect[3]);\n            Point p3 = new Point(rect[2], rect[1]);\n            Point p4 = new Point(rect[2], rect[3]);\n\n            if (!points.remove(p1)) points.add(p1);\n            if (!points.remove(p2)) points.add(p2);\n            if (!points.remove(p3)) points.add(p3);\n            if (!points.remove(p4)) points.add(p4);\n        }\n\n        if (points.contains(new Point(lx, ly)) && points.contains(new Point(lx, ry)) &&\n            points.contains(new Point(rx, ly)) && points.contains(new Point(rx, ry)) &&\n            points.size() == 4)\n            return area == (rx - lx) * (ry - ly);\n\n        return false;\n    }\n}\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\n\nbool isRectangleCover(std::vector<std::vector<int>>& rectangles) {\n    int area = 0;\n    std::set<std::pair<int, int>> points;\n    int lx = INT_MAX, ly = INT_MAX, rx = INT_MIN, ry = INT_MIN;\n\n    for (auto& rect : rectangles) {\n        lx = std::min(lx, rect[0]);\n        ly = std::min(ly, rect[1]);\n        rx = std::max(rx, rect[2]);\n        ry = std::max(ry, rect[3]);\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n        std::pair<int, int> p1(rect[0], rect[1]);\n        std::pair<int, int> p2(rect[0], rect[3]);\n        std::pair<int, int> p3(rect[2], rect[1]);\n        std::pair<int, int> p4(rect[2], rect[3]);\n\n        if (!points.erase(p1)) points.insert(p1);\n        if (!points.erase(p2)) points.insert(p2);\n        if (!points.erase(p3)) points.insert(p3);\n        if (!points.erase(p4)) points.insert(p4);\n    }\n\n    if (points.count({lx, ly}) && points.count({lx, ry}) &&\n        points.count({rx, ly}) && points.count({rx, ry}) &&\n        points.size() == 4)\n        return area == (rx - lx) * (ry - ly);\n\n    return false;\n}\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "python": "\n    ```python\ndef isRectangleCover(rectangles):\n    area = 0\n    points = set()\n    lx, ly, rx, ry = float('inf'), float('inf'), float('-inf'), float('-inf')\n\n    for rect in rectangles:\n        lx, ly = min(lx, rect[0]), min(ly, rect[1])\n        rx, ry = max(rx, rect[2]), max(ry, rect[3])\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1])\n\n        p1, p2, p3, p4 = (rect[0], rect[1]), (rect[0], rect[3]), (rect[2], rect[1]), (rect[2], rect[3])\n\n        points ^= {p1, p2, p3, p4}\n\n    return len(points) == 4 and area == (rx - lx) * (ry - ly) and (lx, ly) in points and \\\n           (lx, ry) in points and (rx, ly) in points and (rx, ry) in points\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "javascript": "\n    ```javascript\nfunction isRectangleCover(rectangles) {\n    let area = 0;\n    let points = new Set();\n    let lx = Infinity, ly = Infinity, rx = -Infinity, ry = -Infinity;\n\n    for (let rect of rectangles) {\n        lx = Math.min(lx, rect[0]);\n        ly = Math.min(ly, rect[1]);\n        rx = Math.max(rx, rect[2]);\n        ry = Math.max(ry, rect[3]);\n\n        area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n        let p1 = rect[0] + \",\" + rect[1];\n        let p2 = rect[0] + \",\" + rect[3];\n        let p3 = rect[2] + \",\" + rect[1];\n        let p4 = rect[2] + \",\" + rect[3];\n\n        if (points.has(p1)) points.delete(p1);\n        else points.add(p1);\n        if (points.has(p2)) points.delete(p2);\n        else points.add(p2);\n        if (points.has(p3)) points.delete(p3);\n        else points.add(p3);\n        if (points.has(p4)) points.delete(p4);\n        else points.add(p4);\n    }\n\n    return points.size === 4 &&\n           points.has(lx + \",\" + ly) && points.has(lx + \",\" + ry) &&\n           points.has(rx + \",\" + ly) && points.has(rx + \",\" + ry) &&\n           area === (rx - lx) * (ry - ly);\n}\n```\n    \n    1. Initialize the area to 0 and create a set to store the points.\n2. Initialize lx, ly, rx, and ry to min and max values.\n3. Iterate through the input rectangles.\n4. Update lx, ly, rx, and ry with the min and the max values found in the rectangles.\n5. Calculate the area of the current rectangle and add it to the total area.\n6. Compute 4 points for each rectangle and store them in the set using the following conditions:\n   - If a point exists in the set, remove it.\n   - If a point doesn't exist in the set, add it.\n7. Check if the set contains the four corner points of the large rectangle (lx, ly), (lx, ry), (rx, ly), (rx, ry) and if the size of the set is 4.\n8. Return true if the area of the large rectangle equals the total area calculated in step 5, and the conditions in step 7 are met; otherwise, return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]",
                    "output": " True",
                    "explanation": " All 5 rectangles together form an exact cover of a rectangular region."
                },
                {
                    "input": " rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]",
                    "output": " False",
                    "explanation": " Because there is a gap between the two rectangular regions."
                },
                {
                    "input": " rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]",
                    "output": " False",
                    "explanation": " Because two of the rectangles overlap with each other."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]",
                    "output": "True"
                },
                {
                    "input": "[[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]",
                    "output": "False"
                },
                {
                    "input": "[[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-40",
        "prompt": "Given an array `rectangles` where `rectangles[i] = [xi, yi, ai, bi]` represents an axis-aligned rectangle. The bottom-left point of the rectangle is `(xi, yi)` and the top-right point of it is `(ai, bi)`.\n\nReturn `true` _if all the rectangles together form an exact cover of a rectangular region_."
    },
    "leetcode-benchmark-41": {
        "id": "leetcode-benchmark-41",
        "title": "Frog Jump",
        "difficulty": "Hard",
        "content": {
            "problem": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction.",
            "examples": [
                "**Example 1:**\n\n**Input:** stones = \\[0,1,3,5,6,8,12,17\\]\n**Output:** true\n**Explanation:** The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n\n",
                "**Example 2:**\n\n**Input:** stones = \\[0,1,2,3,4,8,9,11\\]\n**Output:** false\n**Explanation:** There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= stones.length <= 2000`\n*   `0 <= stones[i] <= 231 - 1`\n*   `stones[0] == 0`\n*   `stones` is sorted in a strictly increasing order.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic boolean canCross(int[] stones) {\n    Map<Integer, Set<Integer>> dp = new HashMap<>();\n    for (int stone : stones)\n        dp.put(stone, new HashSet<>());\n    dp.get(0).add(0);\n\n    for (int stone : stones) {\n        for (int k : dp.get(stone)) {\n            for (int jump : new int[]{k - 1, k, k + 1}) {\n                if (jump > 0 && dp.containsKey(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return !dp.get(stones[stones.length - 1]).isEmpty();\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nbool canCross(vector<int>& stones) {\n    unordered_map<int, unordered_set<int>> dp;\n    int n = stones.size();\n    for (int stone : stones)\n        dp[stone] = unordered_set<int>();\n    dp[0].insert(0);\n\n    for (int stone : stones) {\n        for (int k : dp[stone]) {\n            for (int jump : {k - 1, k, k + 1}) {\n                if (jump > 0 && dp.count(stone + jump))\n                    dp[stone + jump].insert(jump);\n            }\n        }\n    }\n    return !dp[stones.back()].empty();\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "python": "\n    ```python\ndef can_cross(stones):\n    dp = {stone: set() for stone in stones}\n    dp[0].add(0)\n\n    for stone in stones:\n        for k in dp[stone]:\n            for jump in (k - 1, k, k + 1):\n                if jump > 0 and stone + jump in dp:\n                    dp[stone + jump].add(jump)\n\n    return bool(dp[stones[-1]])\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "javascript": "\n    ```javascript\nfunction canCross(stones) {\n    const dp = new Map();\n    stones.forEach(stone => dp.set(stone, new Set()));\n    dp.get(0).add(0);\n\n    for (const stone of stones) {\n        for (const k of dp.get(stone)) {\n            for (const jump of [k - 1, k, k + 1]) {\n                if (jump > 0 && dp.has(stone + jump))\n                    dp.get(stone + jump).add(jump);\n            }\n        }\n    }\n    return dp.get(stones[stones.length - 1]).size > 0;\n}\n```\n\n    \n    The algorithm initializes an empty hash map `dp` with a key for each stone position and the values set to be an empty set. We then add the initial jump (0) to the first stone in the `dp` hash map. The algorithm proceeds iteratively for each of the stones. For each stone, the algorithm checks all possible jump lengths (`k`) in the `dp` hash map for the stone. The next possible jumps are then calculated (k - 1, k, and k + 1) and added to their respective stone positions in the `dp` map. This process continues until all stones are traversed. At the end, if the last stone in `dp` map contains any elements, it means the frog can reach the last stone, and the function returns True/True or False. Otherwise, the function returns False/false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " stones = [0,1,3,5,6,8,12,17]",
                    "output": " True",
                    "explanation": " The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone."
                },
                {
                    "input": " stones = [0,1,2,3,4,8,9,11]",
                    "output": " False",
                    "explanation": " There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large."
                }
            ],
            "function_input": [
                {
                    "input": "[0,1,3,5,6,8,12,17]",
                    "output": "True"
                },
                {
                    "input": "[0,1,2,3,4,8,9,11]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-41",
        "prompt": "A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n\nGiven a list of `stones`' positions (in units) in sorted **ascending order**, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be `1` unit.\n\nIf the frog's last jump was `k` units, its next jump must be either `k - 1`, `k`, or `k + 1` units. The frog can only jump in the forward direction."
    },
    "leetcode-benchmark-42": {
        "id": "leetcode-benchmark-42",
        "title": "Split Array Largest Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[7,2,5,10,8\\], k = 2\n**Output:** 18\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,4,5\\], k = 2\n**Output:** 9\n**Explanation:** There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= min(50, nums.length)`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int splitArray(int[] nums, int m) {\n    long left = 0, right = 0;\n    for (int num : nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        long mid = (left + right) / 2;\n        int count = 1;\n        long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "c++": "\n    ```cpp\nint splitArray(vector<int>& nums, int m) {\n    long long left = 0, right = 0;\n    for (int num : nums) {\n        left = max(left, (long long)num);\n        right += num;\n    }\n\n    while (left < right) {\n        long long mid = (left + right) / 2;\n        int count = 1;\n        long long curSum = 0;\n        for (int num : nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return (int)left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "python": "\n    ```python\ndef splitArray(nums, m):\n    left, right = max(nums), sum(nums)\n\n    while left < right:\n        mid = (left + right) // 2\n        count, cur_sum = 1, 0\n        for num in nums:\n            cur_sum += num\n            if cur_sum > mid:\n                cur_sum = num\n                count += 1\n\n        if count > m:\n            left = mid + 1\n        else:\n            right = mid\n\n    return left\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "javascript": "\n    ```javascript\nfunction splitArray(nums, m) {\n    let left = 0, right = 0;\n    for (let num of nums) {\n        left = Math.max(left, num);\n        right += num;\n    }\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        let count = 1;\n        let curSum = 0;\n        for (let num of nums) {\n            curSum += num;\n            if (curSum > mid) {\n                curSum = num;\n                count++;\n            }\n        }\n\n        if (count > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}\n```\n    \n    The algorithm to solve this problem is to use a binary search approach. We first initialize the minimum and maximum possible values for the largest sum. The minimum value is initialized to the maximum integer value in the given array, and the maximum value is initialized to the sum of all the integer values in the array. These values are assigned to the variables `left` and `right` respectively.\n\nWe then perform a binary search to find the smallest largest sum. In each iteration, we calculate the mid value between left and right (`(left + right) / 2`). Then, we iterate through the array and sum the integers, counting how many subarrays are needed to fit the running sum without exceeding the mid value.\n\nAfter iterating through the array, if the count of subarrays needed is greater than `m`, it means the mid value is too small. In this case, we update the left value to `mid + 1`. Otherwise, if the count is less than or equal to `m`, we update the right value to `mid`. The process continues until left is equal to or greater than right.\n\nFinally, we return the left value as the minimized largest sum among the m subarrays.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [7,2,5,10,8], k = 2",
                    "output": " 18",
                    "explanation": " There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[7,2,5\\] and \\[10,8\\], where the largest sum among the two subarrays is only 18."
                },
                {
                    "input": " nums = [1,2,3,4,5], k = 2",
                    "output": " 9",
                    "explanation": " There are four ways to split nums into two subarrays.\nThe best way is to split it into \\[1,2,3\\] and \\[4,5\\], where the largest sum among the two subarrays is only 9."
                }
            ],
            "function_input": [
                {
                    "input": "[7,2,5,10,8],2",
                    "output": "18"
                },
                {
                    "input": "[1,2,3,4,5],2",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-42",
        "prompt": "Given an integer array `nums` and an integer `k`, split `nums` into `k` non-empty subarrays such that the largest sum of any subarray is **minimized**.\n\nReturn _the minimized largest sum of the split_.\n\nA **subarray** is a contiguous part of the array."
    },
    "leetcode-benchmark-43": {
        "id": "leetcode-benchmark-43",
        "title": "Minimum Unique Word Abbreviation",
        "difficulty": "Hard",
        "content": {
            "problem": "A string can be **abbreviated** by replacing any number of **non-adjacent** substrings with their lengths. For example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nNote that `\"s55n \"` ( `\"s ubsti tutio n \"`) is not a valid abbreviation of `\"substitution \"` because the replaced substrings are adjacent.\n\nThe **length** of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation `\"s10n \"` has a length of `3` (`2` letters + `1` substring) and `\"su3i1u2on \"` has a length of `9` (`6` letters + `3` substrings).\n\nGiven a target string `target` and an array of strings `dictionary`, return _an **abbreviation** of_ `target` _with the **shortest possible length** such that it is **not an abbreviation** of **any** string in_ `dictionary`_. If there are multiple shortest abbreviations, return any of them_.",
            "examples": [
                "**Example 1:**\n\n**Input:** target =  \"apple \", dictionary = \\[ \"blade \"\\]\n**Output:**  \"a4 \"\n**Explanation:** The shortest abbreviation of  \"apple \" is  \"5 \", but this is also an abbreviation of  \"blade \".\nThe next shortest abbreviations are  \"a4 \" and  \"4e \".  \"4e \" is an abbreviation of blade while  \"a4 \" is not.\nHence, return  \"a4 \".\n\n",
                "**Example 2:**\n\n**Input:** target =  \"apple \", dictionary = \\[ \"blade \", \"plain \", \"amber \"\\]\n**Output:**  \"1p3 \"\n**Explanation:**  \"5 \" is an abbreviation of both  \"apple \" but also every word in the dictionary.\n \"a4 \" is an abbreviation of  \"apple \" but also  \"amber \".\n \"4e \" is an abbreviation of  \"apple \" but also  \"blade \".\n \"1p3 \",  \"2p2 \", and  \"3l1 \" are the next shortest abbreviations of  \"apple \".\nSince none of them are abbreviations of words in the dictionary, returning any of them is correct."
            ],
            "constraints": "**Constraints:**\n\n*   `m == target.length`\n*   `n == dictionary.length`\n*   `1 <= m <= 21`\n*   `0 <= n <= 1000`\n*   `1 <= dictionary[i].length <= 100`\n*   `log2(n) + m <= 21` if `n > 0`\n*   `target` and `dictionary[i]` consist of lowercase English letters.\n*   `dictionary` does not contain `target`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.List;\n\npublic class Solution {\n    private static String abbreviate(String s, int k, int i) {\n        if (i == s.length()) {\n            return (k > 0) ? String.valueOf(k) : \"\";\n        }\n        if (k == 0) {\n            return s.substring(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n        }\n        return String.valueOf(k) + s.charAt(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n    }\n\n    private static boolean isAbbreviation(String target, String word) {\n        int i = 0, j = 0;\n        while (i < target.length() && j < word.length()) {\n            if (target.charAt(i) == word.charAt(j)) {\n                i++; j++;\n            } else if (Character.isDigit(target.charAt(i))) {\n                int k = 0;\n                while (i < target.length() && Character.isDigit(target.charAt(i))) {\n                    k = k * 10 + target.charAt(i++) - '0';\n                }\n                j += k;\n            } else {\n                return false;\n            }\n        }\n        return (i == target.length() && j == word.length());\n    }\n\n    public static String minAbbreviation(String target, List<String> dictionary) {\n        String ans = target;\n        for (int k = 0; k <= target.length(); k++) {\n            for (int i = 0; i <= target.length() - k; i++) {\n                String current = abbreviate(target, k, i);\n                if (current.length() < ans.length()) {\n                    boolean valid = true;\n                    for (String word : dictionary) {\n                        if (isAbbreviation(current, word)) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) {\n                        ans = current;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string abbreviate(const std::string& s, int k, int i) {\n    if (i == s.length()) {\n        return (k > 0) ? std::to_string(k) : \"\";\n    }\n    if (k == 0) {\n        return s.substr(i) + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n    }\n    return std::to_string(k) + s[i] + (i + 1 < s.length() ? abbreviate(s, 1, i + 1) : \"\");\n}\n\nbool isAbbreviation(const std::string& target, const std::string& word) {\n    int i = 0, j = 0;\n    while (i < target.length() && j < word.length()) {\n        if (target[i] == word[j]) {\n            i++; j++;\n        } else if (isdigit(target[i])) {\n            int k = 0;\n            while (i < target.length() && isdigit(target[i])) {\n                k = k * 10 + target[i++] - '0';\n            }\n            j += k;\n        } else {\n            return false;\n        }\n    }\n    return (i == target.length() && j == word.length());\n}\n\nstd::string minAbbreviation(std::string target, std::vector<std::string>& dictionary) {\n    std::string ans = target;\n    for (int k = 0; k <= target.length(); k++) {\n        for (int i = 0; i <= target.length() - k; i++) {\n            std::string current = abbreviate(target, k, i);\n            if (current.length() < ans.length()) {\n                bool valid = true;\n                for (const std::string& word : dictionary) {\n                    if (isAbbreviation(current, word)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    ans = current;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "python": "\n    ```python\ndef abbreviate(s, k, i):\n    if i == len(s):\n        return str(k) if k > 0 else \"\"\n    if k == 0:\n        return s[i:] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n    return str(k) + s[i] + (abbreviate(s, 1, i + 1) if i + 1 < len(s) else \"\")\n\ndef is_abbreviation(target, word):\n    i, j = 0, 0\n    while i < len(target) and j < len(word):\n        if target[i] == word[j]:\n            i, j = i + 1, j + 1\n        elif target[i].isdigit():\n            k = 0\n            while i < len(target) and target[i].isdigit():\n                k = k * 10 + int(target[i])\n                i += 1\n            j += k\n        else:\n            return False\n    return i == len(target) and j == len(word)\n\ndef min_abbreviation(target, dictionary):\n    ans = target\n    for k in range(0, len(target) + 1):\n        for i in range(0, len(target) - k + 1):\n            current = abbreviate(target, k, i)\n            if len(current) < len(ans):\n                valid = True\n                for word in dictionary:\n                    if is_abbreviation(current, word):\n                        valid = False\n                        break\n                if valid:\n                    ans = current\n    return ans\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "javascript": "\n    ```javascript\nfunction abbreviate(s, k, i) {\n    if (i === s.length) {\n        return (k > 0) ? String(k) : \"\";\n    }\n    if (k === 0) {\n        return s.slice(i) + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : \"\");\n    }\n    return String(k) + s[i] + (i + 1 < s.length ? abbreviate(s, 1, i + 1) : \"\");\n}\n\nfunction isAbbreviation(target, word) {\n    let i = 0, j = 0;\n    while (i < target.length && j < word.length) {\n        if (target[i] === word[j]) {\n            i++; j++;\n        } else if (target[i] >= '0' && target[i] <= '9') {\n            let k = 0;\n            while (i < target.length && target[i] >= '0' && target[i] <= '9') {\n                k = k * 10 + parseInt(target[i++]);\n            }\n            j += k;\n        } else {\n            return false;\n        }\n    }\n    return (i === target.length && j === word.length);\n}\n\nfunction minAbbreviation(target, dictionary) {\n    let ans = target;\n    for (let k = 0; k <= target.length; k++) {\n        for (let i = 0; i <= target.length - k; i++) {\n            let current = abbreviate(target, k, i);\n            if (current.length < ans.length) {\n                let valid = true;\n                for (const word of dictionary) {\n                    if (isAbbreviation(current, word)) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    ans = current;\n                }\n            }\n        }\n    }\n    return ans;\n}\n```\n\n    \n    The algorithm first defines a helper function `abbreviate` to generate the abbreviations of the input string. It takes in a string, an abbreviation position, and a counter. This function generates abbreviated strings by recursively replacing substrings at the abbreviation position with their lengths, and concatenating the output.\n\nThe main function then iterates through all possible abbreviation lengths, from 0 up to the length of the target string, and for each length, it calculates the abbreviation using the helper function `abbreviate`. For each abbreviation, it checks if this abbreviation is valid, i.e., it's not an abbreviation of any word in the dictionary. If it's not an abbreviation of any word in the dictionary and its length is less than the current answer, it updates the answer.\n\nThe validation of an abbreviation is done using another helper function `isAbbreviation`. It takes in a target abbreviation and a dictionary word and checks if the target abbreviation is an abbreviation of the dictionary word by iterating through both strings and comparing characters. If the characters at the current positions match, it moves to the next positions in both strings. If the character in the target string is a digit, it's considered as an abbreviation of part of the dictionary word, and the current position in the dictionary word is updated accordingly. If the characters don't match and the target character is not a digit, it means the target abbreviation is not an abbreviation of the dictionary word.\n\nThe time complexity is of the algorithm is O(n * m * 2^m), where n is the length of the dictionary and m is the length of the target string, because there are 2^m possible abbreviations for each string, and for each abbreviation, it checks n words in the dictionary. The space complexity is O(m) for the recursive `abbreviate` function.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " target =  \"apple \", dictionary = [ \"blade \"]",
                    "output": "  \"a4 \"",
                    "explanation": " The shortest abbreviation of  \"apple \" is  \"5 \", but this is also an abbreviation of  \"blade \".\nThe next shortest abbreviations are  \"a4 \" and  \"4e \".  \"4e \" is an abbreviation of blade while  \"a4 \" is not.\nHence, return  \"a4 \"."
                },
                {
                    "input": " target =  \"apple \", dictionary = [ \"blade \", \"plain \", \"amber \"]",
                    "output": "  \"1p3 \"",
                    "explanation": "  \"5 \" is an abbreviation of both  \"apple \" but also every word in the dictionary.\n \"a4 \" is an abbreviation of  \"apple \" but also  \"amber \".\n \"4e \" is an abbreviation of  \"apple \" but also  \"blade \".\n \"1p3 \",  \"2p2 \", and  \"3l1 \" are the next shortest abbreviations of  \"apple \".\nSince none of them are abbreviations of words in the dictionary, returning any of them is correct."
                }
            ],
            "function_input": [
                {
                    "input": "\"apple\",[\"blade\"]",
                    "output": "\"a4\""
                },
                {
                    "input": "\"apple\",[\"blade\",\"plain\",\"amber\"]",
                    "output": "\"1p3\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-43",
        "prompt": "A string can be **abbreviated** by replacing any number of **non-adjacent** substrings with their lengths. For example, a string such as `\"substitution \"` could be abbreviated as (but not limited to):\n\n*   `\"s10n \"` ( `\"s ubstitutio n \"`)\n*   `\"sub4u4 \"` ( `\"sub stit u tion \"`)\n*   `\"12 \"` ( `\"substitution \"`)\n*   `\"su3i1u2on \"` ( `\"su bst i t u ti on \"`)\n*   `\"substitution \"` (no substrings replaced)\n\nNote that `\"s55n \"` ( `\"s ubsti tutio n \"`) is not a valid abbreviation of `\"substitution \"` because the replaced substrings are adjacent.\n\nThe **length** of an abbreviation is the number of letters that were not replaced plus the number of substrings that were replaced. For example, the abbreviation `\"s10n \"` has a length of `3` (`2` letters + `1` substring) and `\"su3i1u2on \"` has a length of `9` (`6` letters + `3` substrings).\n\nGiven a target string `target` and an array of strings `dictionary`, return _an **abbreviation** of_ `target` _with the **shortest possible length** such that it is **not an abbreviation** of **any** string in_ `dictionary`_. If there are multiple shortest abbreviations, return any of them_."
    },
    "leetcode-benchmark-44": {
        "id": "leetcode-benchmark-44",
        "title": "Strong Password Checker",
        "difficulty": "Hard",
        "content": {
            "problem": "A password is considered strong if the below conditions are all met:\n\n*   It has at least `6` characters and at most `20` characters.\n*   It contains at least **one lowercase** letter, at least **one uppercase** letter, and at least **one digit**.\n*   It does not contain three repeating characters in a row (i.e., `\"B**aaa**bb0 \"` is weak, but `\"B**aa**b**a**0 \"` is strong).\n\nGiven a string `password`, return _the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`._\n\nIn one step, you can:\n\n*   Insert one character to `password`,\n*   Delete one character from `password`, or\n*   Replace one character of `password` with another character.",
            "examples": [
                "**Example 1:**\n\n**Input:** password = \"a\"\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** password = \"aA1\"\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** password = \"1337C0d3\"\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= password.length <= 50`\n*   `password` consists of letters, digits, dot `'.'` or exclamation mark `'!'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nint strongPassword(String password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = password.length();\n    for (char c : password.toCharArray()) {\n        if (Character.isLowerCase(c)) missingLower = 0;\n        if (Character.isUpperCase(c)) missingUpper = 0;\n        if (Character.isDigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "c++": "\n    ```cpp\n#include <cctype>\n#include <algorithm>\nint strongPassword(string password) {\n    int missingLower = 1, missingUpper = 1, missingDigit = 1;\n    int total = (int)password.size();\n    for (char c : password) {\n        if (islower(c)) missingLower = 0;\n        if (isupper(c)) missingUpper = 0;\n        if (isdigit(c)) missingDigit = 0;\n    }\n    int missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "python": "\n    ```python\ndef strong_password(password):\n    missing_lower = 1\n    missing_upper = 1\n    missing_digit = 1\n    total = len(password)\n    \n    for c in password:\n        if c.islower(): missing_lower = 0\n        if c.isupper(): missing_upper = 0\n        if c.isdigit(): missing_digit = 0\n    \n    missing = missing_lower + missing_upper + missing_digit\n    if total < 6: return max(missing, 6 - total)\n    if total > 20: return missing + total - 20\n\n    return missing\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "javascript": "\n    ```javascript\nfunction strongPassword(password) {\n    let missingLower = 1, missingUpper = 1, missingDigit = 1;\n    let total = password.length;\n    for (const c of password) {\n        if (c.match(/[a-z]/)) missingLower = 0;\n        if (c.match(/[A-Z]/)) missingUpper = 0;\n        if (c.match(/[0-9]/)) missingDigit = 0;\n    }\n    let missing = missingLower + missingUpper + missingDigit;\n    if (total < 6) return Math.max(missing, 6 - total);\n    if (total > 20) return missing + total - 20;\n    return missing;\n}\n```\n    \n    We first initiate three variables `missingLower`, `missingUpper`, and `missingDigit` indicating if we need a lowercase letter, an uppercase letter, or a digit, respectively. Then, we iterate through each character of the password, updating the missing variables if we find a character that satisfies the respective condition. After that, we calculate the total number of missing characters.\n\nThe final result depends on the total length of the password:\n- if it is less than 6, the result is equal to the maximum of missing characters and the difference between the desired length (6) and the current length.\n- if it is greater than 20, the result is equal to the sum of missing characters and the difference between the current length and the desired length (20).\n- otherwise, the result is equal to the number of missing characters.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " password = \"a\"",
                    "output": " 5",
                    "explanation": null
                },
                {
                    "input": " password = \"aA1\"",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " password = \"1337C0d3\"",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"a\"",
                    "output": "5"
                },
                {
                    "input": "\"aA1\"",
                    "output": "3"
                },
                {
                    "input": "\"1337C0d3\"",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-44",
        "prompt": "A password is considered strong if the below conditions are all met:\n\n*   It has at least `6` characters and at most `20` characters.\n*   It contains at least **one lowercase** letter, at least **one uppercase** letter, and at least **one digit**.\n*   It does not contain three repeating characters in a row (i.e., `\"B**aaa**bb0 \"` is weak, but `\"B**aa**b**a**0 \"` is strong).\n\nGiven a string `password`, return _the minimum number of steps required to make `password` strong. if `password` is already strong, return `0`._\n\nIn one step, you can:\n\n*   Insert one character to `password`,\n*   Delete one character from `password`, or\n*   Replace one character of `password` with another character."
    },
    "leetcode-benchmark-45": {
        "id": "leetcode-benchmark-45",
        "title": "K-th Smallest in Lexicographical Order",
        "difficulty": "Hard",
        "content": {
            "problem": "Given two integers `n` and `k`, return _the_ `kth` _lexicographically smallest integer in the range_ `[1, n]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13, k = 2\n**Output:** 10\n**Explanation:** The lexicographical order is \\[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9\\], so the second smallest number is 10.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= n <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\npublic class Solution {\n    public int findKthNumber(int n, int k) {\n        List<Integer> nums = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            nums.add(i);\n        }\n        nums.sort((a, b) -> String.valueOf(a).compareTo(String.valueOf(b)));\n        return nums.get(k - 1);\n    }\n}\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nint findKthNumber(int n, int k) {\n    vector<int> nums;\n    for (int i = 1; i <= n; ++i) {\n        nums.push_back(i);\n    }\n    sort(nums.begin(), nums.end(), [](int a, int b) {\n        return to_string(a) < to_string(b);\n    });\n    return nums[k - 1];\n}\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "python": "\n    ```python\ndef find_kth_number(n, k):\n    nums = [i for i in range(1, n + 1)]\n    nums.sort(key=lambda x: str(x))\n    return nums[k - 1]\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "javascript": "\n    ```javascript\nfunction findKthNumber(n, k) {\n    const nums = [];\n    for (let i = 1; i <= n; i++) {\n        nums.push(i);\n    }\n    nums.sort((a, b) => String(a).localeCompare(String(b)));\n    return nums[k - 1];\n}\n```\n\n    \n    First, we initialize a list or vector containing all the integers from 1 to n. \n\nThen, we sort this list lexicographically. For C++ and Java, we use a lambda function to compare the string representation of the numbers. In Python, we use a lambda function inside the sort function, and in JavaScript, we use the `localeCompare()` method to sort the integers lexicographically.\n\nFinally, we return the Kth element in the sorted list by accessing the element at index `k - 1`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 13, k = 2",
                    "output": " 10",
                    "explanation": " The lexicographical order is \\[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9\\], so the second smallest number is 10."
                },
                {
                    "input": " n = 1, k = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "13,2",
                    "output": "10"
                },
                {
                    "input": "1,1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-45",
        "prompt": "Given two integers `n` and `k`, return _the_ `kth` _lexicographically smallest integer in the range_ `[1, n]`."
    },
    "leetcode-benchmark-46": {
        "id": "leetcode-benchmark-46",
        "title": "Arithmetic Slices II - Subsequence",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of all the **arithmetic subsequences** of_ `nums`.\n\nA sequence of numbers is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1, 3, 5, 7, 9]`, `[7, 7, 7, 7]`, and `[3, -1, -5, -9]` are arithmetic sequences.\n*   For example, `[1, 1, 2, 5, 7]` is not an arithmetic sequence.\n\nA **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n*   For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`.\n\nThe test cases are generated so that the answer fits in **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,4,6,8,10\\]\n**Output:** 7\n**Explanation:** All arithmetic subsequence slices are:\n\\[2,4,6\\]\n\\[4,6,8\\]\n\\[6,8,10\\]\n\\[2,4,6,8\\]\n\\[4,6,8,10\\]\n\\[2,4,6,8,10\\]\n\\[2,6,10\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[7,7,7,7,7\\]\n**Output:** 16\n**Explanation:** Any subsequence of this array is arithmetic."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int numberOfArithmeticSlices(int[] nums) {\n    int res = 0;\n    int n = nums.length;\n    Map<Integer, Integer>[] dp = new HashMap[n];\n\n    for (int i = 0; i < n; ++i) {\n        dp[i] = new HashMap<>();\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= Integer.MIN_VALUE || diff > Integer.MAX_VALUE) continue;\n\n            int delta = (int)diff;\n            dp[i].put(delta, dp[i].getOrDefault(delta, 0) + 1);\n\n            if (dp[j].containsKey(delta)) {\n                res += dp[j].get(delta);\n                dp[i].put(delta, dp[i].get(delta) + dp[j].get(delta));\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) {\n    int res = 0;\n    int n = nums.size();\n    std::vector<std::unordered_map<int, int>> dp(n);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            long diff = (long)nums[i] - (long)nums[j];\n            if (diff <= INT_MIN || diff > INT_MAX) continue;\n\n            int delta = (int)diff;\n            dp[i][delta] += 1;\n\n            if (dp[j].count(delta)) {\n                res += dp[j][delta];\n                dp[i][delta] += dp[j][delta];\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "python": "\n    ```python\ndef numberOfArithmeticSlices(nums):\n    res = 0\n    n = len(nums)\n    dp = [dict() for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i):\n            diff = nums[i] - nums[j]\n            if diff <= -2**31 or diff > 2**31:\n                continue\n\n            dp[i][diff] = dp[i].get(diff, 0) + 1\n\n            if diff in dp[j]:\n                res += dp[j][diff]\n                dp[i][diff] += dp[j][diff]\n\n    return res\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "javascript": "\n    ```javascript\nfunction numberOfArithmeticSlices(nums) {\n    let res = 0;\n    const n = nums.length;\n    const dp = new Array(n).fill(0).map(() => new Map());\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            const diff = nums[i] - nums[j];\n            if (diff <= Number.MIN_SAFE_INTEGER || diff > Number.MAX_SAFE_INTEGER) continue;\n\n            if (!dp[i].has(diff)) {\n                dp[i].set(diff, 0);\n            }\n\n            dp[i].set(diff, dp[i].get(diff) + 1);\n\n            if (dp[j].has(diff)) {\n                res += dp[j].get(diff);\n                dp[i].set(diff, dp[i].get(diff) + dp[j].get(diff));\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    To solve this problem, we use dynamic programming. The `dp` data structure is an array of hashmaps or dictionaries. Each index `i` in the array represents an element in the given array `nums`, and the hashmap stored at `dp[i]` will store the count of arithmetic subsequences that end at the element `nums[i]`, with keys representing the differences between elements.\n\nStarting with index `i = 0`, we iterate through the `nums` array. For each element `nums[i]`, we iterate through all previous elements `nums[j]` with `j < i`.\n\nFor each pair of elements `(nums[i], nums[j])`, we calculate their difference and store the count of arithmetic subsequences formed by this difference at `dp[i]`.\n\nIf an existing subsequence with the same difference is found in `dp[j]`, we should be able to append `nums[i]` to all previously formed subsequences ending at `nums[j]`. Thus, we add the count of subsequences from `dp[j][delta]` to the result, and also update the count in `dp[i][delta]`.\n\nFinally, after iterating through all elements, the `res` variable will hold the count of all the arithmetic subsequences.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,4,6,8,10]",
                    "output": " 7",
                    "explanation": " All arithmetic subsequence slices are:\n\\[2,4,6\\]\n\\[4,6,8\\]\n\\[6,8,10\\]\n\\[2,4,6,8\\]\n\\[4,6,8,10\\]\n\\[2,4,6,8,10\\]\n\\[2,6,10\\]"
                },
                {
                    "input": " nums = [7,7,7,7,7]",
                    "output": " 16",
                    "explanation": " Any subsequence of this array is arithmetic."
                }
            ],
            "function_input": [
                {
                    "input": "[2,4,6,8,10]",
                    "output": "7"
                },
                {
                    "input": "[7,7,7,7,7]",
                    "output": "16"
                }
            ]
        },
        "task_id": "leetcode-benchmark-46",
        "prompt": "Given an integer array `nums`, return _the number of all the **arithmetic subsequences** of_ `nums`.\n\nA sequence of numbers is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1, 3, 5, 7, 9]`, `[7, 7, 7, 7]`, and `[3, -1, -5, -9]` are arithmetic sequences.\n*   For example, `[1, 1, 2, 5, 7]` is not an arithmetic sequence.\n\nA **subsequence** of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\n*   For example, `[2,5,10]` is a subsequence of `[1,2,1,**2**,4,1,**5**,**10**]`.\n\nThe test cases are generated so that the answer fits in **32-bit** integer."
    },
    "leetcode-benchmark-47": {
        "id": "leetcode-benchmark-47",
        "title": "Poor Pigs",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1.  Choose some live pigs to feed.\n2.  For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3.  Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4.  After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5.  Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return _the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time_.",
            "examples": [
                "**Example 1:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 15\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous.\n\n",
                "**Example 2:**\n\n**Input:** buckets = 4, minutesToDie = 15, minutesToTest = 30\n**Output:** 2\n**Explanation:** We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= buckets <= 1000`\n*   `1 <= minutesToDie <= minutesToTest <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (Math.pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "c++": "\n    ```cpp\nint poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    int pigs = 0;\n    while (pow((minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "python": "\n    ```python\ndef poor_pigs(buckets, minutes_to_die, minutes_to_test):\n    pigs = 0\n    while (minutes_to_test // minutes_to_die + 1) ** pigs < buckets:\n        pigs += 1\n    return pigs\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "javascript": "\n    ```javascript\nfunction poorPigs(buckets, minutesToDie, minutesToTest) {\n    let pigs = 0;\n    while (Math.pow(Math.floor(minutesToTest / minutesToDie) + 1, pigs) < buckets) {\n        pigs++;\n    }\n    return pigs;\n}\n```\n\n    \n    The algorithm calculates the minimum number of pigs required to test all the buckets within the given time constraint. It is based on the fact that each pig can be used to test multiple buckets (in a binary search manner) within the time constraint, as it is repeatedly fed different buckets.\n\n1. Initialize the number of pigs to 0.\n2. Calculate the maximum number of tests each pig can make within the given time constraint (`minutesToTest / minutesToDie + 1`).\n3. Iterate and increment the number of pigs until the total number of buckets is less than the power of the number of tests each pig can make to the number of pigs.\n4. Return the minimum number of pigs required.\n\nThe algorithm leverages the multi-level testing capacity of the pigs within the given time frame to minimize the number of pigs needed. Each pig represents an additional level of testing capacity, reducing the total number of tests needed.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " buckets = 4, minutesToDie = 15, minutesToTest = 15",
                    "output": " 2",
                    "explanation": " We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\nAt time 15, there are 4 possible outcomes:\n- If only the first pig dies, then bucket 1 must be poisonous.\n- If only the second pig dies, then bucket 3 must be poisonous.\n- If both pigs die, then bucket 2 must be poisonous.\n- If neither pig dies, then bucket 4 must be poisonous."
                },
                {
                    "input": " buckets = 4, minutesToDie = 15, minutesToTest = 30",
                    "output": " 2",
                    "explanation": " We can determine the poisonous bucket as follows:\nAt time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\nAt time 15, there are 2 possible outcomes:\n- If either pig dies, then the poisonous bucket is the one it was fed.\n- If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\nAt time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed."
                }
            ],
            "function_input": [
                {
                    "input": "4,15,15",
                    "output": "2"
                },
                {
                    "input": "4,15,30",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-47",
        "prompt": "There are `buckets` buckets of liquid, where **exactly one** of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have `minutesToTest` minutes to determine which bucket is poisonous.\n\nYou can feed the pigs according to these steps:\n\n1.  Choose some live pigs to feed.\n2.  For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n3.  Wait for `minutesToDie` minutes. You may **not** feed any other pigs during this time.\n4.  After `minutesToDie` minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n5.  Repeat this process until you run out of time.\n\nGiven `buckets`, `minutesToDie`, and `minutesToTest`, return _the **minimum** number of pigs needed to figure out which bucket is poisonous within the allotted time_."
    },
    "leetcode-benchmark-48": {
        "id": "leetcode-benchmark-48",
        "title": "Count The Repetitions",
        "difficulty": "Hard",
        "content": {
            "problem": "We define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times.\n\n*   For example, `str == [ \"abc \", 3] == \"abcabcabc \"`.\n\nWe define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`.\n\n*   For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded underlined characters.\n\nYou are given two strings `s1` and `s2` and two integers `n1` and `n2`. You have the two strings `str1 = [s1, n1]` and `str2 = [s2, n2]`.\n\nReturn _the maximum integer_ `m` _such that_ `str = [str2, m]` _can be obtained from_ `str1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length, s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.\n*   `1 <= n1, n2 <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) == s2.charAt(j)) {\n            j++;\n            if (j == s2.length()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.length()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "c++": "\n    ```cpp\nint getMaxRepetitions(string s1, int n1, string s2, int n2) {\n    int count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1[i] == s2[j]) {\n            j++;\n            if (j == s2.size()) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i == s1.size()) {\n            i = 0;\n            count1++;\n        }\n    }\n    return count2 / n2;\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "python": "\n    ```python\ndef getMaxRepetitions(s1: str, n1: int, s2: str, n2: int) -> int:\n    count1, count2, i, j = 0, 0, 0, 0\n    while count1 < n1:\n        if s1[i] == s2[j]:\n            j += 1\n            if j == len(s2):\n                j = 0\n                count2 += 1\n        i += 1\n        if i == len(s1):\n            i = 0\n            count1 += 1\n    return count2 // n2\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "javascript": "\n    ```javascript\nfunction getMaxRepetitions(s1, n1, s2, n2) {\n    let count1 = 0, count2 = 0, i = 0, j = 0;\n    while (count1 < n1) {\n        if (s1.charAt(i) === s2.charAt(j)) {\n            j++;\n            if (j === s2.length) {\n                j = 0;\n                count2++;\n            }\n        }\n        i++;\n        if (i === s1.length) {\n            i = 0;\n            count1++;\n        }\n    }\n    return Math.floor(count2 / n2);\n}\n```\n\n    \n    1. Initialize counter variables for both strings (count1 and count2) as well as indices for both strings (i and j).\n2. Iterate through str1 while count1 is less than n1.\n3. Compare the characters at the current indices of s1 and s2. If they match, increment index j of s2.\n4. If j reaches the length of s2, reset j to 0 and increment count2.\n5. Increment index i of s1. If i reaches the length of s1, reset i to 0 and increment count1.\n6. Return the integer division of count2 by n2 as the maximum integer m.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"acb\",4,\"ab\",2",
                    "output": "2"
                },
                {
                    "input": "\"acb\",1,\"acb\",1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-48",
        "prompt": "We define `str = [s, n]` as the string `str` which consists of the string `s` concatenated `n` times.\n\n*   For example, `str == [ \"abc \", 3] == \"abcabcabc \"`.\n\nWe define that string `s1` can be obtained from string `s2` if we can remove some characters from `s2` such that it becomes `s1`.\n\n*   For example, `s1 = \"abc \"` can be obtained from `s2 = \"ab**dbe**c \"` based on our definition by removing the bolded underlined characters.\n\nYou are given two strings `s1` and `s2` and two integers `n1` and `n2`. You have the two strings `str1 = [s1, n1]` and `str2 = [s2, n2]`.\n\nReturn _the maximum integer_ `m` _such that_ `str = [str2, m]` _can be obtained from_ `str1`."
    },
    "leetcode-benchmark-49": {
        "id": "leetcode-benchmark-49",
        "title": "Encode String with Shortest Length",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `s`, encode the string such that its encoded length is the shortest.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. `k` should be a positive integer.\n\nIf an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return **any of them**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaa \"\n**Output:**  \"aaa \"\n**Explanation:** There is no way to encode it such that it is shorter than the input string, so we do not encode it.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aaaaa \"\n**Output:**  \"5\\[a\\] \"\n**Explanation:**  \"5\\[a\\] \" is shorter than  \"aaaaa \" by 1 character.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"aaaaaaaaaa \"\n**Output:**  \"10\\[a\\] \"\n**Explanation:**  \"a9\\[a\\] \" or  \"9\\[a\\]a \" are also valid solutions, both of them have the same length = 5, which is the same as  \"10\\[a\\] \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 150`\n*   `s` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nString encode(String s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            String sub = s.substring(0, i);\n            StringBuilder composed = new StringBuilder();\n            for (int j = 0; j < reps; j++) {\n                composed.append(sub);\n            }\n            if (s.equals(composed.toString())) {\n                return reps + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "c++": "\n    ```cpp\nstd::string encode(std::string s) {\n    int n = s.length();\n    for (int i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            int reps = n / i;\n            std::string sub = s.substr(0, i);\n            std::string composed = \"\";\n            for (int j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s == composed) {\n                return std::to_string(reps) + \"[\" + sub + \"]\";\n            }\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "python": "\n    ```python\ndef encode(s: str) -> str:\n    n = len(s)\n    for i in range(n // 2, 0, -1):\n        if n % i == 0:\n            reps = n // i\n            sub = s[:i]\n            composed = sub * reps\n            if s == composed:\n                return f\"{reps}[{sub}]\"\n    return s\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "javascript": "\n    ```javascript\nfunction encode(s) {\n    const n = s.length;\n    for (let i = Math.floor(n / 2); i > 0; i--) {\n        if (n % i === 0) {\n            const reps = n / i;\n            const sub = s.slice(0, i);\n            let composed = \"\";\n            for (let j = 0; j < reps; j++) {\n                composed += sub;\n            }\n            if (s === composed) {\n                return `${reps}[${sub}]`;\n            }\n        }\n    }\n    return s;\n}\n```\n    \n    The algorithm works by iteratively checking substrings of the input string `s` from the largest possible ones (half of the input string's length) to the smallest (single characters). To find the shortest possible encoding, the algorithm calculates the number of repetitions of the current substring and checks if the input string can be entirely composed of that substring. If a suitable substring is found, it returns the encoded string in the format _k[encoded_string]_, where _k_ is the number of repetitions, otherwise it returns the original input string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aaa \"",
                    "output": "  \"aaa \"",
                    "explanation": " There is no way to encode it such that it is shorter than the input string, so we do not encode it."
                },
                {
                    "input": " s =  \"aaaaa \"",
                    "output": "  \"5[a] \"",
                    "explanation": "  \"5\\[a\\] \" is shorter than  \"aaaaa \" by 1 character."
                },
                {
                    "input": " s =  \"aaaaaaaaaa \"",
                    "output": "  \"10[a] \"",
                    "explanation": "  \"a9\\[a\\] \" or  \"9\\[a\\]a \" are also valid solutions, both of them have the same length = 5, which is the same as  \"10\\[a\\] \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"aaa\"",
                    "output": "\"aaa\""
                },
                {
                    "input": "\"aaaaa\"",
                    "output": "\"5[a]\""
                },
                {
                    "input": "\"aaaaaaaaaa\"",
                    "output": "\"10[a]\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-49",
        "prompt": "Given a string `s`, encode the string such that its encoded length is the shortest.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. `k` should be a positive integer.\n\nIf an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return **any of them**."
    },
    "leetcode-benchmark-50": {
        "id": "leetcode-benchmark-50",
        "title": "Concatenated Words",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.\n\nA **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"cat \", \"cats \", \"catsdogcats \", \"dog \", \"dogcatsdog \", \"hippopotamuses \", \"rat \", \"ratcatdogcat \"\\]\n**Output:** \\[ \"catsdogcats \", \"dogcatsdog \", \"ratcatdogcat \"\\]\n**Explanation:**  \"catsdogcats \" can be concatenated by  \"cats \",  \"dog \" and  \"cats \"; \n \"dogcatsdog \" can be concatenated by  \"dog \",  \"cats \" and  \"dog \"; \n \"ratcatdogcat \" can be concatenated by  \"rat \",  \"cat \",  \"dog \" and  \"cat \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"cat \", \"dog \", \"catdog \"\\]\n**Output:** \\[ \"catdog \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= words[i].length <= 30`\n*   `words[i]` consists of only lowercase English letters.\n*   All the strings of `words` are **unique**.\n*   `1 <= sum(words[i].length) <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class Solution {\n    public boolean isConcatenated(String word, Set<String> wordDict) {\n        int n = word.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (dp[j] && wordDict.contains(word.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n\n    public List<String> findAllConcatenatedWords(String[] words) {\n        Set<String> wordDict = new HashSet<>();\n        for (String word : words) {\n            wordDict.add(word);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (isConcatenated(word, wordDict)) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\nusing namespace std;\n\nbool isConcatenated(const string& word, unordered_set<string>& wordDict) {\n    int n = word.size();\n    vector<bool> dp(n + 1, false);\n    dp[0] = true;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.count(word.substr(j, i - j))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nvector<string> findAllConcatenatedWords(vector<string>& words) {\n    unordered_set<string> wordDict(words.begin(), words.end());\n    vector<string> result;\n\n    for (const string& word : words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push_back(word);\n        }\n    }\n    \n    return result;\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "python": "\n    ```python\ndef is_concatenated(word, word_dict):\n    n = len(word)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if dp[j] and word[j:i] in word_dict:\n                dp[i] = True\n                break\n\n    return dp[n]\n\n\ndef find_all_concatenated_words(words):\n    word_dict = set(words)\n    result = []\n\n    for word in words:\n        if is_concatenated(word, word_dict):\n            result.append(word)\n\n    return result\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "javascript": "\n    ```javascript\nfunction isConcatenated(word, wordDict) {\n    const n = word.length;\n    const dp = Array(n + 1).fill(false);\n    dp[0] = true;\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 0; j < i; ++j) {\n            if (dp[j] && wordDict.has(word.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[n];\n}\n\nfunction findAllConcatenatedWords(words) {\n    const wordDict = new Set(words);\n    const result = [];\n\n    for (const word of words) {\n        if (isConcatenated(word, wordDict)) {\n            result.push(word);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm uses dynamic programming to determine if a given word is a concatenated word. The function `isConcatenated` checks if a word can be formed by concatenating two or more words from the input array. It iterates through the characters of the word and uses a boolean array `dp` to keep track of whether or not the substring from the start of the word up to a certain index can be formed by concatenating the words from the input array.\n\nThen, the main function `findAllConcatenatedWords` iterates through each word in the array, and if the word is a concatenated word, adds it to the result list/array.\n\nThe four implementations in C++, Java, Python, and JavaScript use the same algorithm described above but are adapted to their respective language syntax and standard libraries.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"cat \", \"cats \", \"catsdogcats \", \"dog \", \"dogcatsdog \", \"hippopotamuses \", \"rat \", \"ratcatdogcat \"]",
                    "output": " [ \"catsdogcats \", \"dogcatsdog \", \"ratcatdogcat \"]",
                    "explanation": "  \"catsdogcats \" can be concatenated by  \"cats \",  \"dog \" and  \"cats \"; \n \"dogcatsdog \" can be concatenated by  \"dog \",  \"cats \" and  \"dog \"; \n \"ratcatdogcat \" can be concatenated by  \"rat \",  \"cat \",  \"dog \" and  \"cat \"."
                },
                {
                    "input": " words = [ \"cat \", \"dog \", \"catdog \"]",
                    "output": " [ \"catdog \"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]",
                    "output": "[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]"
                },
                {
                    "input": "[\"cat\",\"dog\",\"catdog\"]",
                    "output": "[\"catdog\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-50",
        "prompt": "Given an array of strings `words` (**without duplicates**), return _all the **concatenated words** in the given list of_ `words`.\n\nA **concatenated word** is defined as a string that is comprised entirely of at least two shorter words (not necesssarily distinct) in the given array."
    },
    "leetcode-benchmark-51": {
        "id": "leetcode-benchmark-51",
        "title": "Largest Palindrome Product",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer n, return _the **largest palindromic integer** that can be represented as the product of two `n`\\-digits integers_. Since the answer can be very large, return it **modulo** `1337`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 8`",
            "follow_up": ""
        },
        "java": "\n    ```java\nint largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = (int) Math.pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long temp = i;\n        long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long palindrome = i * (long) Math.pow(10, n) + reverse;\n        for (long j = upper_limit; j > lower_limit; --j) {\n            long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return (int) (palindrome % 1337);\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "c++": "\n    ```cpp\nint largestPalindrome(int n) {\n    if (n == 1) return 9;\n    int upper_limit = pow(10, n) - 1;\n    int lower_limit = upper_limit / 10;\n    for (int i = upper_limit; i > lower_limit; --i) {\n        long long temp = i;\n        long long reverse = 0;\n        while (temp != 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp /= 10;\n        }\n        long long palindrome = i * pow(10, n) + reverse;\n        for (long long j = upper_limit; j > lower_limit; --j) {\n            long long product = palindrome / j;\n            if (palindrome % j == 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "python": "\n    ```python\ndef largestPalindrome(n):\n    if n == 1: \n        return 9\n    upper_limit = 10**n - 1\n    lower_limit = upper_limit // 10\n    for i in range(upper_limit, lower_limit, -1):\n        temp = i\n        reverse = 0\n        while temp != 0:\n            reverse = reverse * 10 + temp % 10\n            temp //= 10\n        palindrome = i * (10**n) + reverse\n        for j in range(upper_limit, lower_limit, -1):\n            product = palindrome // j\n            if palindrome % j == 0 and product <= upper_limit:\n                return palindrome % 1337\n    return -1\n```\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "javascript": "\n    ```javascript\nfunction largestPalindrome(n) {\n    if (n === 1) return 9; // Handle 1-digit numbers\n    let upper_limit = Math.pow(10, n) - 1;\n    let lower_limit = Math.floor(upper_limit / 10);\n    for (let i = upper_limit; i > lower_limit; i--) {\n        let temp = i;\n        let reverse = 0;\n        while (temp !== 0) {\n            reverse = reverse * 10 + temp % 10;\n            temp = Math.floor(temp / 10);\n        }\n        let palindrome = i * Math.pow(10, n) + reverse;\n        for (let j = upper_limit; j > lower_limit; j--) {\n            let product = Math.floor(palindrome / j);\n            if (palindrome % j === 0 && product <= upper_limit) {\n                return palindrome % 1337;\n            }\n        }\n    }\n    return -1;\n}\n```\n\n    \n    1. If n is 1, return 9 (the largest palindromic product of two 1-digit numbers is 9).\n2. Calculate the upper and lower limits for the n-digit numbers.\n3. Loop through the numbers in reverse order, starting from the upper limit down to the lower limit.\n4. Within the loop, find the reverse of the current iteration number.\n5. Calculate the possible palindrome by concatenating the current number and its reverse.\n6. Loop through the numbers again to find the two factors of the palindrome.\n7. If a palindrome with valid factors is found, return the palindrome modulo 1337.\n8. If no such palindrome is found, return -1.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " 987\nExplanation: 99 x 91 = 9009, 9009 % 1337 = 987",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " 9",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "987\nExplanation:99x91=9009,9009%1337=987"
                },
                {
                    "input": "1",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-51",
        "prompt": "Given an integer n, return _the **largest palindromic integer** that can be represented as the product of two `n`\\-digits integers_. Since the answer can be very large, return it **modulo** `1337`."
    },
    "leetcode-benchmark-52": {
        "id": "leetcode-benchmark-52",
        "title": "Smallest Good Base",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer `n` represented as a string, return _the smallest **good base** of_ `n`.\n\nWe call `k >= 2` a **good base** of `n`, if all digits of `n` base `k` are `1`'s.",
            "examples": [
                "**Example 1:**\n\n**Input:** n =  \"13 \"\n**Output:**  \"3 \"\n**Explanation:** 13 base 3 is 111.\n\n",
                "**Example 2:**\n\n**Input:** n =  \"4681 \"\n**Output:**  \"8 \"\n**Explanation:** 4681 base 8 is 11111.\n\n",
                "**Example 3:**\n\n**Input:** n =  \"1000000000000000000 \"\n**Output:**  \"999999999999999999 \"\n**Explanation:** 1000000000000000000 base 999999999999999999 is 11."
            ],
            "constraints": "**Constraints:**\n\n*   `n` is an integer in the range `[3, 1018]`.\n*   `n` does not contain any leading zeros.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic class SmallestGoodBase {\n    public String smallestGoodBase(String n) {\n        long num_n = Long.parseLong(n);\n        \n        for(int m = (int)(Math.log(num_n)/Math.log(2)) + 1; m >= 1; m--) {\n            long k = (long)Math.pow((double)num_n, 1.0 / m);\n            long sum = 0;\n            for(int i=0; i <= m; i++) {\n                sum = sum * k + 1;\n            }\n            if(sum == num_n) {\n                return String.valueOf(k);\n            }\n        }\n        \n        return \"-1\";\n    }\n}\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "c++": "\n    ```cpp\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nll smallestGoodBase(string n) {\n    ll num_n = stoll(n);\n    \n    for(int m = log2(num_n) + 1; m >= 1; m--) {\n        ll k = pow(num_n, 1.0 / m);\n        ll sum = 0;\n        for(int i=0; i <= m; i++) {\n            sum = sum * k + 1;\n        }\n        if(sum == num_n) {\n            return k;\n        }\n    }\n    \n    return -1;\n}\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "python": "\n    ```python\ndef smallest_good_base(n: str) -> str:\n    num_n = int(n)\n\n    for m in range(int(num_n.bit_length()), 0, -1):\n        k = int(num_n ** (1.0 / m))\n        if sum(k**i for i in range(m+1)) == num_n:\n            return str(k)\n\n    return \"-1\"\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "javascript": "\n    ```javascript\nfunction smallestGoodBase(n) {\n    const num_n = BigInt(n);\n    \n    for(let m = BigInt(Math.floor(Math.log2(Number(n))) + 1); m >= 1; m--) {\n        const k = BigInt(Math.floor(num_n ** (1n / m)));\n        let sum = 0n;\n        for(let i=0n; i <= m; i++) {\n            sum = sum * k + 1n;\n        }\n        if(sum === num_n) {\n            return String(k);\n        }\n    }\n    \n    return \"-1\";\n}\n```\n    \n    1. First we convert the given string `n` into an integer (in respective format for each language)\n2. We loop through possible values of `m` (the number of digits in base `k`) in reverse order\n3. We calculate the value of `k` using `k = n^(1/m)` (using the power operator `**` in python and JS and `pow` function in C++ and Java)\n4. We calculate the sum of the series `k^0 + k^1 + ... + k^m` which will give us the value when all the digits of `n` are 1 in base `k`\n5. If the sum of the series is equal to `n`, we found the smallest good base and return it\n6. If we haven't found a good base at the end of the loop, return -1 (which shouldn't happen given the problem statement)\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n =  \"13 \"",
                    "output": "  \"3 \"",
                    "explanation": " 13 base 3 is 111."
                },
                {
                    "input": " n =  \"4681 \"",
                    "output": "  \"8 \"",
                    "explanation": " 4681 base 8 is 11111."
                },
                {
                    "input": " n =  \"1000000000000000000 \"",
                    "output": "  \"999999999999999999 \"",
                    "explanation": " 1000000000000000000 base 999999999999999999 is 11."
                }
            ],
            "function_input": [
                {
                    "input": "\"13\"",
                    "output": "\"3\""
                },
                {
                    "input": "\"4681\"",
                    "output": "\"8\""
                },
                {
                    "input": "\"1000000000000000000\"",
                    "output": "\"999999999999999999\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-52",
        "prompt": "Given an integer `n` represented as a string, return _the smallest **good base** of_ `n`.\n\nWe call `k >= 2` a **good base** of `n`, if all digits of `n` base `k` are `1`'s."
    },
    "leetcode-benchmark-53": {
        "id": "leetcode-benchmark-53",
        "title": "Reverse Pairs",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums`, return _the number of **reverse pairs** in the array_.\n\nA **reverse pair** is a pair `(i, j)` where:\n\n*   `0 <= i < j < nums.length` and\n*   `nums[i] > 2 * nums[j]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,2,3,1\\]\n**Output:** 2\n**Explanation:** The reverse pairs are:\n(1, 4) --> nums\\[1\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n(3, 4) --> nums\\[3\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,4,3,5,1\\]\n**Output:** 3\n**Explanation:** The reverse pairs are:\n(1, 4) --> nums\\[1\\] = 4, nums\\[4\\] = 1, 4 > 2 \\* 1\n(2, 4) --> nums\\[2\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n(3, 4) --> nums\\[3\\] = 5, nums\\[4\\] = 1, 5 > 2 \\* 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `-231 <= nums[i] <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int reversePairs(int[] nums) {\n    return mergeSort(nums, 0, nums.length - 1, new int[nums.length]);\n}\n\nprivate int mergeSort(int[] nums, int left, int right, int[] temp) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = mergeSort(nums, left, mid, temp) + mergeSort(nums, mid + 1, right, temp);\n    count += merge(nums, left, mid, right, temp);\n    \n    return count;\n}\n\nprivate int merge(int[] nums, int left, int mid, int right, int[] temp) {\n    int count = 0;\n    System.arraycopy(nums, left, temp, left, right - left + 1);\n    int j = mid + 1;\n    for (int i = left; i <= mid; i++) {\n        while (j <= right && (long) nums[i] > 2L * nums[j]) {\n            j++;\n        }\n        count += j - (mid + 1);\n    }\n    int i = left;\n    j = mid + 1;\n    int k = left;\n    while (i <= mid && j <= right) {\n        if (temp[i] <= temp[j]) {\n            nums[k++] = temp[i++];\n        } else {\n            nums[k++] = temp[j++];\n        }\n    }\n    while (i <= mid) {\n        nums[k++] = temp[i++];\n    }\n    while (j <= right) {\n        nums[k++] = temp[j++];\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint merge(std::vector<int>& nums, std::vector<int>& temp, int left, int mid, int right) {\n    int count = 0;\n    int j = mid;\n    for (int i = left; i < mid; i++) {\n        while (j <= right && (long long)nums[i] > 2LL * nums[j]) {\n            j++;\n        }\n        count += j - mid;\n    }\n    std::merge(nums.begin() + left, nums.begin() + mid, nums.begin() + mid, nums.begin() + right + 1, temp.begin() + left);\n    \n    return count;\n}\n\nint countReversePairs(std::vector<int>& nums, std::vector<int>& temp, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n    int mid = left + (right - left) / 2;\n    int count = countReversePairs(nums, temp, left, mid) + countReversePairs(nums, temp, mid + 1, right);\n    count += merge(nums, temp, left, mid + 1, right);\n    std::copy(temp.begin() + left, temp.begin() + right + 1, nums.begin() + left);\n    \n    return count;\n}\n\nint reversePairs(std::vector<int>& nums) {\n    std::vector<int> temp(nums.size());\n    return countReversePairs(nums, temp, 0, nums.size() - 1);\n}\n```\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "python": "\n    ```python\ndef reversePairs(nums):\n    def mergeSort(l, r):\n        if l >= r:\n            return 0\n        \n        mid = (l + r) // 2\n        count = mergeSort(l, mid) + mergeSort(mid + 1, r)\n        j = mid + 1\n        for i in range(l, mid + 1):\n            while j <= r and nums[i] > 2 * nums[j]:\n                j += 1\n            count += j - (mid + 1)\n        \n        nums[l:r + 1] = sorted(nums[l:r + 1])\n        \n        return count\n    \n    return mergeSort(0, len(nums) - 1)\n```\n\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "javascript": "\n    ```javascript\nfunction reversePairs(nums) {\n    function mergeSort(l, r) {\n        if (l >= r) {\n            return 0;\n        }\n\n        const mid = Math.floor((l + r) / 2);\n        let count = mergeSort(l, mid) + mergeSort(mid + 1, r);\n        let j = mid + 1;\n        for (let i = l; i <= mid; i++) {\n            while (j <= r && nums[i] > 2 * nums[j]) {\n                j++;\n            }\n            count += j - (mid + 1);\n        }\n\n        const merged = nums.slice(l, r + 1).sort((a, b) => a - b);\n        nums.splice(l, merged.length, ...merged);\n\n        return count;\n    }\n\n    return mergeSort(0, nums.length - 1);\n}\n```\n\n\n    \n    The algorithm uses a modified merge sort to solve the problem efficiently. It counts the number of reverse pairs during the merge process, compares the elements in the left subarray with those in the right subarray, and increments the count based on the condition `nums[i] > 2 * nums[j]`. The merge sort divides the array into smaller subarrays, which are recursively sorted and merged.\n\nFor each subarray, we use two pointers `i` and `j` to find out the number of reverse pairs that satisfy the condition `nums[i] > 2 * nums[j]`. When iterating through the left subarray with `i`, we move `j` from the right subarray until we find the first index that doesn't satisfy the condition or we reach the end of the right subarray. The difference between the current position of `j` and the starting position is the count of valid reverse pairs. To get the overall count, we sum up the count value from both the left and right subarrays and also add the count found during merging the subarrays.\n\nFinally, we merge the sorted subarrays using built-in sort functions. The process is similar in all four languages: C++ uses `std::merge` and `std::copy`, Java uses `System.arraycopy`, Python uses list slicing with `sorted()`, and JavaScript uses `Array.prototype.sort()` and `Array.prototype.splice()`.\n\nThe time complexity of the algorithm is O(n log n), as it takes advantage of the merge sort structure.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,2,3,1]",
                    "output": " 2",
                    "explanation": " The reverse pairs are:\n(1, 4) --> nums\\[1\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n(3, 4) --> nums\\[3\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1"
                },
                {
                    "input": " nums = [2,4,3,5,1]",
                    "output": " 3",
                    "explanation": " The reverse pairs are:\n(1, 4) --> nums\\[1\\] = 4, nums\\[4\\] = 1, 4 > 2 \\* 1\n(2, 4) --> nums\\[2\\] = 3, nums\\[4\\] = 1, 3 > 2 \\* 1\n(3, 4) --> nums\\[3\\] = 5, nums\\[4\\] = 1, 5 > 2 \\* 1"
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,2,3,1]",
                    "output": "2"
                },
                {
                    "input": "[2,4,3,5,1]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-53",
        "prompt": "Given an integer array `nums`, return _the number of **reverse pairs** in the array_.\n\nA **reverse pair** is a pair `(i, j)` where:\n\n*   `0 <= i < j < nums.length` and\n*   `nums[i] > 2 * nums[j]`."
    },
    "leetcode-benchmark-54": {
        "id": "leetcode-benchmark-54",
        "title": "Freedom Trail",
        "difficulty": "Hard",
        "content": {
            "problem": "In the video game Fallout 4, the quest **\"Road to Freedom \"** requires players to reach a metal dial called the **\"Freedom Trail Ring \"** and use the dial to spell a specific keyword to open the door.\n\nGiven a string `ring` that represents the code engraved on the outer ring and another string `key` that represents the keyword that needs to be spelled, return _the minimum number of steps to spell all the characters in the keyword_.\n\nInitially, the first character of the ring is aligned at the `\"12:00 \"` direction. You should spell all the characters in `key` one by one by rotating `ring` clockwise or anticlockwise to make each character of the string key aligned at the `\"12:00 \"` direction and then by pressing the center button.\n\nAt the stage of rotating the ring to spell the key character `key[i]`:\n\n1.  You can rotate the ring clockwise or anticlockwise by one place, which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `\"12:00 \"` direction, where this character must equal `key[i]`.\n2.  If the character `key[i]` has been aligned at the `\"12:00 \"` direction, press the center button to spell, which also counts as **one step**. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling.",
            "examples": [
                "**Example 1:**\n\n**Input:** ring =  \"godding \", key =  \"gd \"\n**Output:** 4\n**Explanation:**\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring  \"godding \" anticlockwise by two steps to make it become  \"ddinggo \".\nAlso, we need 1 more step for spelling.\nSo the final output is 4.\n\n",
                "**Example 2:**\n\n**Input:** ring =  \"godding \", key =  \"godding \"\n**Output:** 13"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= ring.length, key.length <= 100`\n*   `ring` and `key` consist of only lower case English letters.\n*   It is guaranteed that `key` could always be spelled by rotating `ring`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findRotateSteps(String ring, String key) {\n    int n = ring.length(), m = key.length();\n    int[][] dp = new int[m + 1][n];\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = Integer.MAX_VALUE;\n            for (int k = 0; k < n; ++k) {\n                if (ring.charAt(k) == key.charAt(i)) {\n                    int diff = Math.abs(j - k);\n                    int step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nint findRotateSteps(std::string ring, std::string key) {\n    int n = ring.size(), m = key.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n, 0));\n\n    for (int i = m - 1; i >= 0; --i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j] = INT_MAX;\n            for (int k = 0; k < n; ++k) {\n                if (ring[k] == key[i]) {\n                    int diff = abs(j - k);\n                    int step = std::min(diff, n - diff);\n                    dp[i][j] = std::min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "python": "\n    ```python\ndef find_rotate_steps(ring: str, key: str) -> int:\n    n, m = len(ring), len(key)\n    dp = [[0] * n for _ in range(m + 1)]\n\n    for i in range(m - 1, -1, -1):\n        for j in range(n):\n            dp[i][j] = float('inf')\n            for k in range(n):\n                if ring[k] == key[i]:\n                    diff = abs(j - k)\n                    step = min(diff, n - diff)\n                    dp[i][j] = min(dp[i][j], step + dp[i + 1][k])\n\n    return dp[0][0] + m\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "javascript": "\n    ```javascript\nfunction findRotateSteps(ring, key) {\n    const n = ring.length, m = key.length;\n    const dp = Array.from({ length: m + 1 }, () => new Array(n).fill(0));\n\n    for (let i = m - 1; i >= 0; --i) {\n        for (let j = 0; j < n; ++j) {\n            dp[i][j] = Infinity;\n            for (let k = 0; k < n; ++k) {\n                if (ring[k] === key[i]) {\n                    const diff = Math.abs(j - k);\n                    const step = Math.min(diff, n - diff);\n                    dp[i][j] = Math.min(dp[i][j], step + dp[i + 1][k]);\n                }\n            }\n        }\n    }\n\n    return dp[0][0] + m;\n}\n```\n\n    \n    The algorithm uses dynamic programming. Create a 2D table (\"dp\") with the dimensions of the length of the key + 1 as rows and the length of the ring as columns. The table represents the minimum number of steps required to reach each character in the key by aligning it to the 12:00 direction.\n\nThe main logic runs in reverse of the key string. For each character in the key, the outer ring positions are iterated and checked if the character in the ring matches the character in the key. The minimum steps to reach the matching character are calculated and updated in the \"dp\" table.\n\nFinally, the first element in the \"dp\" table would represent the minimum number of steps required to complete the whole key. The result is the sum of that value and the length of the key.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " ring =  \"godding \", key =  \"gd \"",
                    "output": " 4",
                    "explanation": "\nFor the first key character 'g', since it is already in place, we just need 1 step to spell this character. \nFor the second key character 'd', we need to rotate the ring  \"godding \" anticlockwise by two steps to make it become  \"ddinggo \".\nAlso, we need 1 more step for spelling.\nSo the final output is 4."
                },
                {
                    "input": " ring =  \"godding \", key =  \"godding \"",
                    "output": " 13",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"godding\",\"gd\"",
                    "output": "4"
                },
                {
                    "input": "\"godding\",\"godding\"",
                    "output": "13"
                }
            ]
        },
        "task_id": "leetcode-benchmark-54",
        "prompt": "In the video game Fallout 4, the quest **\"Road to Freedom \"** requires players to reach a metal dial called the **\"Freedom Trail Ring \"** and use the dial to spell a specific keyword to open the door.\n\nGiven a string `ring` that represents the code engraved on the outer ring and another string `key` that represents the keyword that needs to be spelled, return _the minimum number of steps to spell all the characters in the keyword_.\n\nInitially, the first character of the ring is aligned at the `\"12:00 \"` direction. You should spell all the characters in `key` one by one by rotating `ring` clockwise or anticlockwise to make each character of the string key aligned at the `\"12:00 \"` direction and then by pressing the center button.\n\nAt the stage of rotating the ring to spell the key character `key[i]`:\n\n1.  You can rotate the ring clockwise or anticlockwise by one place, which counts as **one step**. The final purpose of the rotation is to align one of `ring`'s characters at the `\"12:00 \"` direction, where this character must equal `key[i]`.\n2.  If the character `key[i]` has been aligned at the `\"12:00 \"` direction, press the center button to spell, which also counts as **one step**. After the pressing, you could begin to spell the next character in the key (next stage). Otherwise, you have finished all the spelling."
    },
    "leetcode-benchmark-55": {
        "id": "leetcode-benchmark-55",
        "title": "Super Washing Machines",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** machines = \\[1,0,5\\]\n**Output:** 3\n**Explanation:**\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2\n\n",
                "**Example 2:**\n\n**Input:** machines = \\[0,3,0\\]\n**Output:** 2\n**Explanation:**\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1\n\n",
                "**Example 3:**\n\n**Input:** machines = \\[0,2,0\\]\n**Output:** -1\n**Explanation:**\nIt's impossible to make all three washing machines have the same number of dresses."
            ],
            "constraints": "**Constraints:**\n\n*   `n == machines.length`\n*   `1 <= n <= 104`\n*   `0 <= machines[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findMinMoves(int[] machines) {\n    int n = machines.length;\n    int totalDresses = 0;\n    for (int m : machines) totalDresses += m;\n    if (totalDresses % n != 0) return -1;\n    int average = totalDresses / n;\n    int moves = 0, imbalance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <numeric>\n#include <cmath>\n\nint findMinMoves(std::vector<int>& machines) {\n    int n = machines.size();\n    int totalDresses = std::accumulate(machines.begin(), machines.end(), 0);\n    if (totalDresses % n != 0) return -1;\n    int average = totalDresses / n;\n    int moves = 0, imbalance = 0;\n    \n    for (int i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = std::max(moves, std::max(abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "python": "\n    ```python\ndef find_min_moves(machines):\n    n = len(machines)\n    total_dresses = sum(machines)\n    if total_dresses % n != 0:\n        return -1\n    average = total_dresses // n\n    moves = 0\n    imbalance = 0\n    \n    for i in range(n):\n        imbalance += machines[i] - average\n        moves = max(moves, abs(imbalance), machines[i] - average)\n        \n    return moves\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "javascript": "\n    ```javascript\nfunction findMinMoves(machines) {\n    let n = machines.length;\n    let totalDresses = machines.reduce((a, b) => a + b, 0);\n    if (totalDresses % n !== 0) return -1;\n    let average = totalDresses / n;\n    let moves = 0, imbalance = 0;\n    \n    for (let i = 0; i < n; i++) {\n        imbalance += machines[i] - average;\n        moves = Math.max(moves, Math.max(Math.abs(imbalance), machines[i] - average));\n    }\n    \n    return moves;\n}\n```\n    \n    1. Calculate the total number of dresses and check if it can be evenly distributed among the machines. If it cannot, return -1.\n2. Calculate the average number of dresses each machine should have.\n3. Initialize the moves and imbalance count to 0.\n4. Iterate through the machines and calculate the current imbalance for each machine.\n5. Update the moves count by taking the maximum of the current moves, the absolute value of the current imbalance, and the difference between the current machine's dresses and the average value.\n6. Return the moves count.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " machines = [1,0,5]",
                    "output": " 3",
                    "explanation": "\n1st move:    1     0 <-- 5    =>    1     1     4\n2nd move:    1 <-- 1 <-- 4    =>    2     1     3\n3rd move:    2     1 <-- 3    =>    2     2     2"
                },
                {
                    "input": " machines = [0,3,0]",
                    "output": " 2",
                    "explanation": "\n1st move:    0 <-- 3     0    =>    1     2     0\n2nd move:    1     2 --> 0    =>    1     1     1"
                },
                {
                    "input": " machines = [0,2,0]",
                    "output": " -1",
                    "explanation": "\nIt's impossible to make all three washing machines have the same number of dresses."
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,5]",
                    "output": "3"
                },
                {
                    "input": "[0,3,0]",
                    "output": "2"
                },
                {
                    "input": "[0,2,0]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-55",
        "prompt": "You have `n` super washing machines on a line. Initially, each washing machine has some dresses or is empty.\n\nFor each move, you could choose any `m` (`1 <= m <= n`) washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time.\n\nGiven an integer array `machines` representing the number of dresses in each washing machine from left to right on the line, return _the minimum number of moves to make all the washing machines have the same number of dresses_. If it is not possible to do it, return `-1`."
    },
    "leetcode-benchmark-56": {
        "id": "leetcode-benchmark-56",
        "title": "Word Abbreviation",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an array of **distinct** strings `words`, return _the minimal possible **abbreviations** for every word_.\n\nThe following are the rules for a string abbreviation:\n\n1.  The **initial** abbreviation for each word is: the first character, then the number of characters in between, followed by the last character.\n2.  If more than one word shares the **same** abbreviation, then perform the following operation:\n    *   **Increase** the prefix (characters in the first part) of each of their abbreviations by `1`.\n        *   For example, say you start with the words `[ \"abcdef \", \"abndef \"]` both initially abbreviated as `\"a4f \"`. Then, a sequence of operations would be `[ \"a4f \", \"a4f \"]` -> `[ \"ab3f \", \"ab3f \"]` -> `[ \"abc2f \", \"abn2f \"]`.\n    *   This operation is repeated until every abbreviation is **unique**.\n3.  At the end, if an abbreviation did not make a word shorter, then keep it as the original word.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"\\]\n**Output:** \\[\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"\\]\n\n",
                "**Example 2:**\n\n**Input:** words = \\[\"aa\",\"aaa\"\\]\n**Output:** \\[\"aa\",\"aaa\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 400`\n*   `2 <= words[i].length <= 400`\n*   `words[i]` consists of lowercase English letters.\n*   All the strings of `words` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Arrays;\n\npublic String[] wordsAbbreviation(String[] words) {\n    int n = words.length;\n    String[] abbr = new String[n];\n    int[] prefixLen = new int[n];\n\n    for (int i = 0; i < n; i++) {\n        abbr[i] = abbrev(words[i], 1);\n        prefixLen[i] = 1;\n    }\n\n    for (int i = 0; i < n; i++) {\n        while (true) {\n            Map<String, int[]> groups = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (abbr[i].equals(abbr[j])) {\n                    if (!groups.containsKey(abbr[j])) {\n                        groups.put(abbr[j], new int[]{0, 0});\n                    }\n                    groups.get(abbr[j])[0]++;\n                    groups.get(abbr[j])[1] = j;\n                }\n            }\n            if (groups.get(abbr[i])[0] == 1) {\n                break;\n            }\n            abbr[groups.get(abbr[i])[1]] = abbrev(words[groups.get(abbr[i])[1]], ++prefixLen[groups.get(abbr[i])[1]]);\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n\nprivate String abbrev(String s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substring(0, k + 1) + Integer.toString(n - k - 2) + s.charAt(n - 1);\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::string abbrev(const std::string& s, int k) {\n    int n = s.length();\n    if (k >= n - 2) {\n        return s;\n    }\n    return s.substr(0, k + 1) + std::to_string(n - k - 2) + s.back();\n}\n\nstd::vector<std::string> wordsAbbreviation(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<std::string> abbr;\n    std::vector<int> prefixLen(n, 1);\n\n    for (int i = 0; i < n; ++i) {\n        abbr.push_back(abbrev(words[i], 1));\n    }\n\n    for (int i = 0; i < n; ++i) {\n        while (true) {\n            std::unordered_map<std::string, std::vector<int>> groups;\n            for (int j = i + 1; j < n; ++j) {\n                if (abbr[i] == abbr[j]) {\n                    groups[abbr[j]].push_back(j);\n                }\n            }\n            if (groups.empty()) {\n                break;\n            }\n            for (const auto &group : groups) {\n                for (int id : group.second) {\n                    abbr[id] = abbrev(words[id], ++prefixLen[id]);\n                }\n            }\n            abbr[i] = abbrev(words[i], ++prefixLen[i]);\n        }\n    }\n\n    return abbr;\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "python": "\n    ```python\ndef wordsAbbreviation(words):\n    def abbrev(word, k):\n        return word[:k+1] + str(len(word) - k - 2) + word[-1] if k < len(word) - 2 else word\n\n    n = len(words)\n    abbr = [abbrev(word, 1) for word in words]\n    prefix_len = [1] * n\n\n    for i in range(n):\n        while abbr.count(abbr[i]) > 1:\n            groups = {}\n            for j in range(i + 1, n):\n                if abbr[i] == abbr[j]:\n                    if abbr[j] not in groups:\n                        groups[abbr[j]] = []\n                    groups[abbr[j]].append(j)\n            for group_members in groups.values():\n                for j in group_members:\n                    abbr[j] = abbrev(words[j], prefix_len[j] + 1)\n                    prefix_len[j] += 1\n            abbr[i] = abbrev(words[i], prefix_len[i] + 1)\n            prefix_len[i] += 1\n\n    return abbr\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "javascript": "\n    ```javascript\nfunction wordsAbbreviation(words) {\n    function abbrev(word, k) {\n        return k < word.length - 2 ? word.slice(0, k + 1) + (word.length - k - 2) + word.slice(-1) : word;\n    }\n\n    const n = words.length;\n    const abbr = words.map(word => abbrev(word, 1));\n    const prefixLen = new Array(n).fill(1);\n\n    for (let i = 0; i < n; i++) {\n        while (abbr.filter(a => a === abbr[i]).length > 1) {\n            const groups = {};\n            for (let j = i + 1; j < n; j++) {\n                if (abbr[i] === abbr[j]) {\n                    if (!groups[abbr[j]]) {\n                        groups[abbr[j]] = [];\n                    }\n                    groups[abbr[j]].push(j);\n                }\n            }\n            for (const groupMembers of Object.values(groups)) {\n                for (const j of groupMembers) {\n                    abbr[j] = abbrev(words[j], prefixLen[j] + 1);\n                    prefixLen[j]++;\n                }\n            }\n            abbr[i] = abbrev(words[i], prefixLen[i] + 1);\n            prefixLen[i]++;\n        }\n    }\n\n    return abbr;\n}\n```\n    \n    1. Initialize abbreviation lists and prefix lengths for each word.\n2. For each word, calculate its initial abbreviation based on the rule 1.\n3. Check if there are any words that share the same abbreviation.\n4. If there are, increase the prefix of those words as stated in rule 2 and update the abbreviation.\n5. Repeat steps 3 and 4 until every abbreviation is unique.\n6. Once all abbreviations are unique, return the list of abbreviations.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"]",
                    "output": " [\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"]",
                    "explanation": null
                },
                {
                    "input": " words = [\"aa\",\"aaa\"]",
                    "output": " [\"aa\",\"aaa\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"like\",\"god\",\"internal\",\"me\",\"internet\",\"interval\",\"intension\",\"face\",\"intrusion\"]",
                    "output": "[\"l2e\",\"god\",\"internal\",\"me\",\"i6t\",\"interval\",\"inte4n\",\"f2e\",\"intr4n\"]"
                },
                {
                    "input": "[\"aa\",\"aaa\"]",
                    "output": "[\"aa\",\"aaa\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-56",
        "prompt": "Given an array of **distinct** strings `words`, return _the minimal possible **abbreviations** for every word_.\n\nThe following are the rules for a string abbreviation:\n\n1.  The **initial** abbreviation for each word is: the first character, then the number of characters in between, followed by the last character.\n2.  If more than one word shares the **same** abbreviation, then perform the following operation:\n    *   **Increase** the prefix (characters in the first part) of each of their abbreviations by `1`.\n        *   For example, say you start with the words `[ \"abcdef \", \"abndef \"]` both initially abbreviated as `\"a4f \"`. Then, a sequence of operations would be `[ \"a4f \", \"a4f \"]` -> `[ \"ab3f \", \"ab3f \"]` -> `[ \"abc2f \", \"abn2f \"]`.\n    *   This operation is repeated until every abbreviation is **unique**.\n3.  At the end, if an abbreviation did not make a word shorter, then keep it as the original word."
    },
    "leetcode-benchmark-57": {
        "id": "leetcode-benchmark-57",
        "title": "Remove Boxes",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given several `boxes` with different colors represented by different positive numbers.\n\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.\n\nReturn _the maximum points you can get_.",
            "examples": [
                "**Example 1:**\n\n**Input:** boxes = \\[1,3,2,2,2,3,4,3,1\\]\n**Output:** 23\n**Explanation:**\n\\[1, 3, 2, 2, 2, 3, 4, 3, 1\\] \n----> \\[1, 3, 3, 4, 3, 1\\] (3\\*3=9 points) \n----> \\[1, 3, 3, 3, 1\\] (1\\*1=1 points) \n----> \\[1, 1\\] (3\\*3=9 points) \n----> \\[\\] (2\\*2=4 points)\n\n",
                "**Example 2:**\n\n**Input:** boxes = \\[1,1,1\\]\n**Output:** 9\n\n",
                "**Example 3:**\n\n**Input:** boxes = \\[1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= boxes.length <= 100`\n*   `1 <= boxes[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int removeBoxes(int[] boxes) {\n    int[][][] dp = new int[100][100][100];\n    return dfs(boxes, dp, 0, boxes.length - 1, 0);\n}\n\nprivate int dfs(int[] boxes, int[][][] dp, int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "c++": "\n    ```cpp\nint removeBoxes(vector<int>& boxes) {\n    int dp[100][100][100] = {0};\n    return dfs(boxes, dp, 0, boxes.size() - 1, 0);\n}\n\nint dfs(vector<int>& boxes, int dp[100][100][100], int l, int r, int k) {\n    if (l > r) return 0;\n    if (dp[l][r][k] != 0) return dp[l][r][k];\n\n    while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n    dp[l][r][k] = (k + 1) * (k + 1) + dfs(boxes, dp, l, r - 1, 0);\n\n    for (int i = l; i < r; i++) {\n        if (boxes[i] == boxes[r]) {\n            dp[l][r][k] = max(dp[l][r][k], dfs(boxes, dp, l, i, k + 1) + dfs(boxes, dp, i + 1, r - 1, 0));\n        }\n    }\n\n    return dp[l][r][k];\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "python": "\n    ```python\ndef removeBoxes(boxes):\n    def dfs(l, r, k):\n        if l > r: return 0\n        if dp[l][r][k] != 0: return dp[l][r][k]\n\n        while r > l and boxes[r] == boxes[r - 1]:\n            r -= 1\n            k += 1\n            \n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0)\n\n        for i in range(l, r):\n            if boxes[i] == boxes[r]:\n                dp[l][r][k] = max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0))\n                \n        return dp[l][r][k]\n\n    dp = [[[0] * 100 for _ in xrange(100)] for _ in xrange(100)]\n    return dfs(0, len(boxes) - 1, 0)\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "javascript": "\n    ```javascript\nfunction removeBoxes(boxes) {\n    const dfs = (l, r, k) => {\n        if (l > r) return 0;\n        if (dp[l][r][k] !== 0) return dp[l][r][k];\n\n        while (r > l && boxes[r] == boxes[r - 1]) {r--; k++;}\n\n        dp[l][r][k] = (k + 1) * (k + 1) + dfs(l, r - 1, 0);\n\n        for (let i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k], dfs(l, i, k + 1) + dfs(i + 1, r - 1, 0));\n            }\n        }\n\n        return dp[l][r][k];\n    };\n\n    let dp = Array.from({ length: 100 }, () => Array.from({ length: 100 }, () => Array(100).fill(0)));\n    return dfs(0, boxes.length - 1, 0);\n}\n```\n    \n    The problem can be solved using dynamic programming. We can define a 3D DP table where `dp[l][r][k]` will be the maximum points we can get for the boxes in the range `[l, r]`, where there are `k` boxes with the same color as `boxes[r]` to the right of `boxes[r]`. \n\nWe'll use a DFS approach to fill our DP table. \n1. First, we check whether our current range `l > r`, in which case we return 0.\n2. If `dp[l][r][k]` already has a non-zero value, we return `dp[l][r][k]`.\n3. Then, we remove all continuous boxes with the same color as `boxes[r]` on the right side of `boxes[r]` to calculate the initial value of `dp[l][r][k]`.\n4. We iterate from `l` to `r` and whenever we find a box with the same color as `boxes[r]`, we update `dp[l][r][k]` with the maximum of the current value and the sum of the result we get in the current split and the result that we have found for the next continuous split.\n\nFinally, we return the value in `dp[0][boxes.length - 1][0]`, which gives us the maximum points that can be obtained for the given input.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " boxes = [1,3,2,2,2,3,4,3,1]",
                    "output": " 23",
                    "explanation": "\n\\[1, 3, 2, 2, 2, 3, 4, 3, 1\\] \n----> \\[1, 3, 3, 4, 3, 1\\] (3\\*3=9 points) \n----> \\[1, 3, 3, 3, 1\\] (1\\*1=1 points) \n----> \\[1, 1\\] (3\\*3=9 points) \n----> \\[\\] (2\\*2=4 points)"
                },
                {
                    "input": " boxes = [1,1,1]",
                    "output": " 9",
                    "explanation": null
                },
                {
                    "input": " boxes = [1]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,2,2,2,3,4,3,1]",
                    "output": "23"
                },
                {
                    "input": "[1,1,1]",
                    "output": "9"
                },
                {
                    "input": "[1]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-57",
        "prompt": "You are given several `boxes` with different colors represented by different positive numbers.\n\nYou may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (i.e., composed of `k` boxes, `k >= 1`), remove them and get `k * k` points.\n\nReturn _the maximum points you can get_."
    },
    "leetcode-benchmark-58": {
        "id": "leetcode-benchmark-58",
        "title": "Split Array with Equal Sum",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` of length `n`, return `true` if there is a triplet `(i, j, k)` which satisfies the following conditions:\n\n*   `0 < i, i + 1 < j, j + 1 < k < n - 1`\n*   The sum of subarrays `(0, i - 1)`, `(i + 1, j - 1)`, `(j + 1, k - 1)` and `(k + 1, n - 1)` is equal.\n\nA subarray `(l, r)` represents a slice of the original array starting from the element indexed `l` to the element indexed `r`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1\\]\n**Output:** true\n**Explanation:**\ni = 1, j = 3, k = 5. \nsum(0, i - 1) = sum(0, 0) = 1\nsum(i + 1, j - 1) = sum(2, 2) = 1\nsum(j + 1, k - 1) = sum(4, 4) = 1\nsum(k + 1, n - 1) = sum(6, 6) = 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1,2\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 2000`\n*   `-106 <= nums[i] <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\nboolean find_triplet_equal_sum(int[] nums) {\n    int n = nums.length;\n    int[] prefix_sum = new int[n + 1];\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "c++": "\n    ```cpp\nbool find_triplet_equal_sum(const std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefix_sum(n + 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (int i = 1; i + 2 < n; ++i) {\n        for (int j = i + 2; j + 1 < n; ++j) {\n            for (int k = j + 2; k < n; ++k) {\n                int s1 = prefix_sum[i];\n                int s2 = prefix_sum[j] - prefix_sum[i + 1];\n                int s3 = prefix_sum[k] - prefix_sum[j + 1];\n                int s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 == s2 && s2 == s3 && s3 == s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "python": "\n    ```python\ndef find_triplet_equal_sum(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n\n    for i in range(1, n - 2):\n        for j in range(i + 2, n - 1):\n            for k in range(j + 2, n):\n                s1 = prefix_sum[i]\n                s2 = prefix_sum[j] - prefix_sum[i + 1]\n                s3 = prefix_sum[k] - prefix_sum[j + 1]\n                s4 = prefix_sum[n] - prefix_sum[k + 1]\n                if s1 == s2 == s3 == s4:\n                    return True\n    return False\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction find_triplet_equal_sum(nums) {\n    const n = nums.length;\n    const prefix_sum = new Array(n + 1).fill(0);\n\n    for (let i = 0; i < n; ++i) {\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i];\n    }\n\n    for (let i = 1; i + 2 < n; ++i) {\n        for (let j = i + 2; j + 1 < n; ++j) {\n            for (let k = j + 2; k < n; ++k) {\n                const s1 = prefix_sum[i];\n                const s2 = prefix_sum[j] - prefix_sum[i + 1];\n                const s3 = prefix_sum[k] - prefix_sum[j + 1];\n                const s4 = prefix_sum[n] - prefix_sum[k + 1];\n                if (s1 === s2 && s2 === s3 && s3 === s4) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The problem can be solved by calculating the prefix sum of the given `nums` array to optimize the sum calculation of subarrays. We use three nested loops to iterate through all possible values of `i`, `j`, and `k`. To check if the sum of the subarrays specified in the problem statement are equal, compare `s1`, `s2`, `s3` and `s4` which represent the sum of these subarrays, and return `true` if they are equal. If no triplet is found after iterating through all possible combinations, return `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,1,2,1,2,1]",
                    "output": " True",
                    "explanation": "\ni = 1, j = 3, k = 5. \nsum(0, i - 1) = sum(0, 0) = 1\nsum(i + 1, j - 1) = sum(2, 2) = 1\nsum(j + 1, k - 1) = sum(4, 4) = 1\nsum(k + 1, n - 1) = sum(6, 6) = 1"
                },
                {
                    "input": " nums = [1,2,1,2,1,2,1,2]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,1,2,1,2,1]",
                    "output": "True"
                },
                {
                    "input": "[1,2,1,2,1,2,1,2]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-58",
        "prompt": "Given an integer array `nums` of length `n`, return `true` if there is a triplet `(i, j, k)` which satisfies the following conditions:\n\n*   `0 < i, i + 1 < j, j + 1 < k < n - 1`\n*   The sum of subarrays `(0, i - 1)`, `(i + 1, j - 1)`, `(j + 1, k - 1)` and `(k + 1, n - 1)` is equal.\n\nA subarray `(l, r)` represents a slice of the original array starting from the element indexed `l` to the element indexed `r`."
    },
    "leetcode-benchmark-59": {
        "id": "leetcode-benchmark-59",
        "title": "Student Attendance Record II",
        "difficulty": "Hard",
        "content": {
            "problem": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n`, return _the **number** of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it **modulo**_ `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 8\n**Explanation:** There are 8 records with length 2 that are eligible for an award:\n \"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2).\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 3\n\n",
                "**Example 3:**\n\n**Input:** n = 10101\n**Output:** 183236316"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int checkRecord(int n) {\n    int M = 1000000007;\n    long[] dp = new long[6];  // {latent state 0, latent state 1, ..., latent state 5}\n    Arrays.fill(dp, 1);\n    while (n-- > 0) {\n        long[] next_dp = new long[6];\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (int) ((dp[0] + dp[1] + dp[2] +\n                   dp[3] + dp[4] + dp[5]) % M);\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "c++": "\n    ```cpp\nint checkRecord(int n) {\n    int M = 1000000007;\n    vector<long long> dp(6, 1);  // {latent state 0, latent state 1, ..., latent state 5}\n    while (n--) {\n        vector<long long> next_dp(6, 0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return (dp[0] + dp[1] + dp[2] + dp[3] + dp[4] + dp[5]) % M;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "python": "\n    ```python\ndef checkRecord(n: int) -> int:\n    M = 1000000007\n    dp = [1] * 6  # [latent state 0, latent state 1, ..., latent state 5]\n    while n:\n        next_dp = [0] * 6\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M\n        next_dp[1] = dp[0]\n        next_dp[2] = dp[1]\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M\n        next_dp[4] = dp[3]\n        next_dp[5] = dp[4]\n        dp = next_dp\n        n -= 1\n    return sum(dp) % M\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "javascript": "\n    ```javascript\nfunction checkRecord(n) {\n    let M = 1000000007;\n    let dp = Array(6).fill(1);  // [latent state 0, latent state 1, ..., latent state 5]\n    while (n--) {\n        let next_dp = Array(6).fill(0);\n        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M;\n        next_dp[1] = dp[0];\n        next_dp[2] = dp[1];\n        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M;\n        next_dp[4] = dp[3];\n        next_dp[5] = dp[4];\n        dp = next_dp;\n    }\n    return dp.reduce((sum, val) => (sum + val) % M, 0);\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of eligible attendance records. We use a latent state representation consisting of 6 states to account for previous attendance occurrences:\n\n- latent state 0: no A or L\n- latent state 1: no A, 1 consecutive L\n- latent state 2: no A, 2 consecutive L\n- latent state 3: 1 A, no L\n- latent state 4: 1 A, 1 consecutive L\n- latent state 5: 1 A, 2 consecutive L\n\nIn each iteration, we update these latent states according to the previous states. After n iterations, the sum of all latent states represents the number of eligible attendance records.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " 8",
                    "explanation": " There are 8 records with length 2 that are eligible for an award:\n \"PP \",  \"AP \",  \"PA \",  \"LP \",  \"PL \",  \"AL \",  \"LA \",  \"LL \"\nOnly  \"AA \" is not eligible because there are 2 absences (there need to be fewer than 2)."
                },
                {
                    "input": " n = 1",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " n = 10101",
                    "output": " 183236316",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "8"
                },
                {
                    "input": "1",
                    "output": "3"
                },
                {
                    "input": "10101",
                    "output": "183236316"
                }
            ]
        },
        "task_id": "leetcode-benchmark-59",
        "prompt": "An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:\n\n*   `'A'`: Absent.\n*   `'L'`: Late.\n*   `'P'`: Present.\n\nAny student is eligible for an attendance award if they meet **both** of the following criteria:\n\n*   The student was absent (`'A'`) for **strictly** fewer than 2 days **total**.\n*   The student was **never** late (`'L'`) for 3 or more **consecutive** days.\n\nGiven an integer `n`, return _the **number** of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it **modulo**_ `109 + 7`."
    },
    "leetcode-benchmark-60": {
        "id": "leetcode-benchmark-60",
        "title": "Find the Closest Palindrome",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string `n` representing an integer, return _the closest integer (not including itself), which is a palindrome_. If there is a tie, return _**the smaller one**_.\n\nThe closest is defined as the absolute difference minimized between two integers.",
            "examples": [
                "**Example 1:**\n\n**Input:** n =  \"123 \"\n**Output:**  \"121 \"\n\n",
                "**Example 2:**\n\n**Input:** n =  \"1 \"\n**Output:**  \"0 \"\n**Explanation:** 0 and 2 are the closest palindromes but we return the smallest which is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n.length <= 18`\n*   `n` consists of only digits.\n*   `n` does not have leading zeros.\n*   `n` is representing an integer in the range `[1, 1018 - 1]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic class ClosestPalindrome {\n    public static boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static int closestPalindrome(String n) {\n        int num = Integer.parseInt(n);\n        int left = num - 1;\n        int right = num + 1;\n\n        while (true) {\n            if (isPalindrome(Integer.toString(left))) {\n                return left;\n            }\n            if (isPalindrome(Integer.toString(right))) {\n                return right;\n            }\n            left--;\n            right++;\n        }\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <cmath>\n#include <limits>\n\nbool isPalindrome(std::string str) {\n    int left = 0;\n    int right = str.length() - 1;\n    while (left < right) {\n        if (str[left] != str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nint closestPalindrome(std::string n) {\n    int num = std::stoi(n);\n    int left = num - 1;\n    int right = num + 1;\n\n    while (true) {\n        if (isPalindrome(std::to_string(left))) {\n            return left;\n        } \n        if (isPalindrome(std::to_string(right))) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "python": "\n    ```python\ndef is_palindrome(s: str) -> bool:\n    return s == s[::-1]\n\ndef closest_palindrome(n: str) -> int:\n    num = int(n)\n    left = num - 1\n    right = num + 1\n\n    while True:\n        if is_palindrome(str(left)):\n            return left\n        if is_palindrome(str(right)):\n            return right\n        left -= 1\n        right += 1\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "javascript": "\n    ```javascript\nfunction isPalindrome(str) {\n    let left = 0;\n    let right = str.length - 1;\n\n    while (left < right) {\n        if (str[left] !== str[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nfunction closestPalindrome(n) {\n    const num = parseInt(n);\n    let left = num - 1;\n    let right = num + 1;\n\n    while (true) {\n        if (isPalindrome(left.toString())) {\n            return left;\n        }\n        if (isPalindrome(right.toString())) {\n            return right;\n        }\n        left--;\n        right++;\n    }\n}\n```\n    \n    The algorithm works as follows:\n\n1. Define a function `isPalindrome` that checks if a given string is a palindrome. This function uses two pointers, one at the left end and one at the right-end of the string, and compares the characters at these positions. If the characters are different, the string is not a palindrome. If the pointers cross or meet, the entire string has been checked, and it is a palindrome.\n2. Define the `closestPalindrome` function that takes a string representing an integer as input. Convert the input string to an integer.\n3. Initialize two variables, `left` and `right`, to represent the numbers to the left and right of the input integer.\n4. In a loop, check if the string representations of `left` and `right` are palindromes using the `isPalindrome` function. If either is a palindrome, return that number. Otherwise, decrement `left` and increment `right` in each iteration.\n\nThis process continues until a palindrome is found on either side of the input integer. If both are found at the same time, the smaller one is favored due to the decrement of `left` and increment of `right`, resulting in `left` being returned first.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n =  \"123 \"",
                    "output": "  \"121 \"",
                    "explanation": null
                },
                {
                    "input": " n =  \"1 \"",
                    "output": "  \"0 \"",
                    "explanation": " 0 and 2 are the closest palindromes but we return the smallest which is 0."
                }
            ],
            "function_input": [
                {
                    "input": "\"123\"",
                    "output": "\"121\""
                },
                {
                    "input": "\"1\"",
                    "output": "\"0\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-60",
        "prompt": "Given a string `n` representing an integer, return _the closest integer (not including itself), which is a palindrome_. If there is a tie, return _**the smaller one**_.\n\nThe closest is defined as the absolute difference minimized between two integers."
    },
    "leetcode-benchmark-61": {
        "id": "leetcode-benchmark-61",
        "title": "Maximum Vacation Days",
        "difficulty": "Hard",
        "content": {
            "problem": "LeetCode wants to give one of its best employees the option to travel among `n` cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\n\nRules and restrictions:\n\n1.  You can only travel among `n` cities, represented by indexes from `0` to `n - 1`. Initially, you are in the city indexed `0` on **Monday**.\n2.  The cities are connected by flights. The flights are represented as an `n x n` matrix (not necessarily symmetrical), called `flights` representing the airline status from the city `i` to the city `j`. If there is no flight from the city `i` to the city `j`, `flights[i][j] == 0`; Otherwise, `flights[i][j] == 1`. Also, `flights[i][i] == 0` for all `i`.\n3.  You totally have `k` weeks (each week has **seven days**) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we do not consider the impact of flight time.\n4.  For each city, you can only have restricted vacation days in different weeks, given an `n x k` matrix called `days` representing this relationship. For the value of `days[i][j]`, it represents the maximum days you could take a vacation in the city `i` in the week `j`.\n5.  You could stay in a city beyond the number of vacation days, but you should work on the extra days, which will not be counted as vacation days.\n6.  If you fly from city `A` to city `B` and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city `B` in that week.\n7.  We do not consider the impact of flight hours on the calculation of vacation days.\n\nGiven the two matrices `flights` and `days`, return _the maximum vacation days you could take during_ `k` _weeks_.",
            "examples": [
                "**Example 1:**\n\n**Input:** flights = \\[\\[0,1,1\\],\\[1,0,1\\],\\[1,1,0\\]\\], days = \\[\\[1,3,1\\],\\[6,0,3\\],\\[3,3,3\\]\\]\n**Output:** 12\n**Explanation:**\nOne of the best strategies is:\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.\n(Although you start at city 0, we could also fly to and start at other cities since it is Monday.)\n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\n3rd week : stay at city 2, and play 3 days and work 4 days.\nAns = 6 + 3 + 3 = 12.\n\n",
                "**Example 2:**\n\n**Input:** flights = \\[\\[0,0,0\\],\\[0,0,0\\],\\[0,0,0\\]\\], days = \\[\\[1,1,1\\],\\[7,7,7\\],\\[7,7,7\\]\\]\n**Output:** 3\n**Explanation:**\nSince there are no flights that enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. \nFor each week, you only have one day to play and six days to work.\nSo the maximum number of vacation days is 3.\nAns = 1 + 1 + 1 = 3.\n\n",
                "**Example 3:**\n\n**Input:** flights = \\[\\[0,1,1\\],\\[1,0,1\\],\\[1,1,0\\]\\], days = \\[\\[7,0,0\\],\\[0,7,0\\],\\[0,0,7\\]\\]\n**Output:** 21\n**Explanation:**\nOne of the best strategies is:\n1st week : stay at city 0, and play 7 days.\n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\nAns = 7 + 7 + 7 = 21"
            ],
            "constraints": "**Constraints:**\n\n*   `n == flights.length`\n*   `n == flights[i].length`\n*   `n == days.length`\n*   `k == days[i].length`\n*   `1 <= n, k <= 100`\n*   `flights[i][j]` is either `0` or `1`.\n*   `0 <= days[i][j] <= 7`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxVacationDays(int[][] flights, int[][] days) {\n    int n = flights.length;\n    int k = days[0].length;\n    int[][] memo = new int[n][k];\n    for (int i = 0; i < n; i++) {\n        Arrays.fill(memo[i], -1);\n    }\n    return dfs(flights, days, 0, 0, memo);\n}\n\nprivate int dfs(int[][] flights, int[][] days, int week, int city, int[][] memo) {\n    int numCities = flights.length;\n    int numWeeks = days[0].length;\n\n    if (week == numWeeks) {\n        return 0;\n    }\n\n    if (memo[city][week] != -1) {\n        return memo[city][week];\n    }\n\n    int maxVacation = days[city][week] + dfs(flights, days, week + 1, city, memo);\n\n    for (int i = 0; i < numCities; i++) {\n        if (flights[city][i] == 1) {\n            maxVacation = Math.max(maxVacation, days[i][week] + dfs(flights, days, week + 1, i, memo));\n        }\n    }\n\n    memo[city][week] = maxVacation;\n    return maxVacation;\n}\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "c++": "\n    ```cpp\nint dfs(const vector<vector<int>>& flights, const vector<vector<int>>& days, int currentWeek, int currentCity, vector<vector<int>>& memo) {\n    if (currentWeek == days[currentCity].size()) {\n        return 0;\n    }\n    if (memo[currentCity][currentWeek] != -1) {\n        return memo[currentCity][currentWeek];\n    }\n\n    int maxVacation = days[currentCity][currentWeek] + dfs(flights, days, currentWeek + 1, currentCity, memo);\n\n    for (int i = 0; i < flights.size(); i++) {\n        if (flights[currentCity][i] == 1) {\n            maxVacation = max(maxVacation, days[i][currentWeek] + dfs(flights, days, currentWeek + 1, i, memo));\n        }\n    }\n\n    memo[currentCity][currentWeek] = maxVacation;\n    return maxVacation;\n}\n\nint maxVacationDays(vector<vector<int>>& flights, vector<vector<int>>& days) {\n    vector<vector<int>> memo(flights.size(), vector<int>(days[0].size(), -1));\n    return dfs(flights, days, 0, 0, memo);\n}\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "python": "\n    ```python\ndef maxVacationDays(flights, days):\n    n = len(flights)\n    k = len(days[0])\n    memo = [[-1] * k for _ in range(n)]\n\n    def dfs(currentWeek, currentCity):\n        if currentWeek == k:\n            return 0\n        if memo[currentCity][currentWeek] != -1:\n            return memo[currentCity][currentWeek]\n\n        maxVacation = days[currentCity][currentWeek] + dfs(currentWeek + 1, currentCity)\n\n        for i in range(n):\n            if flights[currentCity][i] == 1:\n                maxVacation = max(maxVacation, days[i][currentWeek] + dfs(currentWeek + 1, i))\n\n        memo[currentCity][currentWeek] = maxVacation\n        return maxVacation\n\n    return dfs(0, 0)\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "javascript": "\n    ```javascript\nfunction maxVacationDays(flights, days) {\n    let n = flights.length;\n    let k = days[0].length;\n    let memo = new Array(n).fill(null).map(() => new Array(k).fill(-1));\n\n    function dfs(week, city) {\n        if (week === k) {\n            return 0;\n        }\n        if (memo[city][week] !== -1) {\n            return memo[city][week];\n        }\n\n        let maxVacation = days[city][week] + dfs(week + 1, city);\n\n        for (let i = 0; i < n; i++) {\n            if (flights[city][i] === 1) {\n                maxVacation = Math.max(maxVacation, days[i][week] + dfs(week + 1, i));\n            }\n        }\n\n        memo[city][week] = maxVacation;\n        return maxVacation;\n    }\n\n    return dfs(0, 0);\n}\n```\n\n    \n    We will use Depth First Search to explore all the possible valid city change and weeks, and keep track of the current week and current city. \n\nWe use memoization to store the calculated maximum vacation for each city and week, to avoid redundant calculations.\n\nThe base case is when the current week is equal to the total number of weeks, in this case, we can't take any more vacations, so we return 0.\n\nWe initialize the maximum vacation to be the vacation days in the current city and week, calling the dfs function recursively with the next week and the same city, as we don't change the city in this case.\n\nThen, for each possible city change using the flights matrix, we calculate the maximum vacation days with the new city and update the maximum vacation accordingly.\n\nWe store the maximum vacation for the current city and week in the memoization table and return the maximum vacation.\n\nThe final result is the maximum vacation days starting from city 0 and week 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[1,3,1],[6,0,3],[3,3,3]]",
                    "output": " 12",
                    "explanation": "\nOne of the best strategies is:\n1st week : fly from city 0 to city 1 on Monday, and play 6 days and work 1 day.\n(Although you start at city 0, we could also fly to and start at other cities since it is Monday.)\n2nd week : fly from city 1 to city 2 on Monday, and play 3 days and work 4 days.\n3rd week : stay at city 2, and play 3 days and work 4 days.\nAns = 6 + 3 + 3 = 12."
                },
                {
                    "input": " flights = [[0,0,0],[0,0,0],[0,0,0]], days = [[1,1,1],[7,7,7],[7,7,7]]",
                    "output": " 3",
                    "explanation": "\nSince there are no flights that enable you to move to another city, you have to stay at city 0 for the whole 3 weeks. \nFor each week, you only have one day to play and six days to work.\nSo the maximum number of vacation days is 3.\nAns = 1 + 1 + 1 = 3."
                },
                {
                    "input": " flights = [[0,1,1],[1,0,1],[1,1,0]], days = [[7,0,0],[0,7,0],[0,0,7]]",
                    "output": " 21",
                    "explanation": "\nOne of the best strategies is:\n1st week : stay at city 0, and play 7 days.\n2nd week : fly from city 0 to city 1 on Monday, and play 7 days.\n3rd week : fly from city 1 to city 2 on Monday, and play 7 days.\nAns = 7 + 7 + 7 = 21"
                }
            ],
            "function_input": [
                {
                    "input": "[[0,1,1],[1,0,1],[1,1,0]],[[1,3,1],[6,0,3],[3,3,3]]",
                    "output": "12"
                },
                {
                    "input": "[[0,0,0],[0,0,0],[0,0,0]],[[1,1,1],[7,7,7],[7,7,7]]",
                    "output": "3"
                },
                {
                    "input": "[[0,1,1],[1,0,1],[1,1,0]],[[7,0,0],[0,7,0],[0,0,7]]",
                    "output": "21"
                }
            ]
        },
        "task_id": "leetcode-benchmark-61",
        "prompt": "LeetCode wants to give one of its best employees the option to travel among `n` cities to collect algorithm problems. But all work and no play makes Jack a dull boy, you could take vacations in some particular cities and weeks. Your job is to schedule the traveling to maximize the number of vacation days you could take, but there are certain rules and restrictions you need to follow.\n\nRules and restrictions:\n\n1.  You can only travel among `n` cities, represented by indexes from `0` to `n - 1`. Initially, you are in the city indexed `0` on **Monday**.\n2.  The cities are connected by flights. The flights are represented as an `n x n` matrix (not necessarily symmetrical), called `flights` representing the airline status from the city `i` to the city `j`. If there is no flight from the city `i` to the city `j`, `flights[i][j] == 0`; Otherwise, `flights[i][j] == 1`. Also, `flights[i][i] == 0` for all `i`.\n3.  You totally have `k` weeks (each week has **seven days**) to travel. You can only take flights at most once per day and can only take flights on each week's Monday morning. Since flight time is so short, we do not consider the impact of flight time.\n4.  For each city, you can only have restricted vacation days in different weeks, given an `n x k` matrix called `days` representing this relationship. For the value of `days[i][j]`, it represents the maximum days you could take a vacation in the city `i` in the week `j`.\n5.  You could stay in a city beyond the number of vacation days, but you should work on the extra days, which will not be counted as vacation days.\n6.  If you fly from city `A` to city `B` and take the vacation on that day, the deduction towards vacation days will count towards the vacation days of city `B` in that week.\n7.  We do not consider the impact of flight hours on the calculation of vacation days.\n\nGiven the two matrices `flights` and `days`, return _the maximum vacation days you could take during_ `k` _weeks_."
    },
    "leetcode-benchmark-62": {
        "id": "leetcode-benchmark-62",
        "title": "Erect the Fence",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `trees` where `trees[i] = [xi, yi]` represents the location of a tree in the garden.\n\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if **all the trees are enclosed**.\n\nReturn _the coordinates of trees that are exactly located on the fence perimeter_. You may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** trees = \\[\\[1,1\\],\\[2,2\\],\\[2,0\\],\\[2,4\\],\\[3,3\\],\\[4,2\\]\\]\n**Output:** \\[\\[1,1\\],\\[2,0\\],\\[4,2\\],\\[3,3\\],\\[2,4\\]\\]\n**Explanation:** All the trees will be on the perimeter of the fence except the tree at \\[2, 2\\], which will be inside the fence.\n\n",
                "**Example 2:**\n\n**Input:** trees = \\[\\[1,2\\],\\[2,2\\],\\[4,2\\]\\]\n**Output:** \\[\\[4,2\\],\\[2,2\\],\\[1,2\\]\\]\n**Explanation:** The fence forms a line that passes through all the trees."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= trees.length <= 3000`\n*   `trees[i].length == 2`\n*   `0 <= xi, yi <= 100`\n*   All the given positions are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n    private static int[][] fence(int[][] trees) {\n        Arrays.sort(trees, (p, q) -> p[0] == q[0] ? p[1] - q[1] : p[0] - q[0]);\n        List<int[]> hull = new ArrayList<>();\n        for (int[] p : trees) {\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        for (int i = trees.length - 1; i >= 0; i--) {\n            int[] p = trees[i];\n            while (hull.size() >= 2 && crossProduct(hull.get(hull.size() - 2), hull.get(hull.size() - 1), p) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        return hull.toArray(new int[hull.size()][]);\n    }\n\n    private static int crossProduct(int[] p, int[] q, int[] r) {\n        return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    }\n}\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nbool compare(const vector<int>& p, const vector<int>& q) {\n    return p[0] < q[0] || (p[0] == q[0] && p[1] < q[1]);\n}\n\nint cross_product(const vector<int>& p, const vector<int>& q, const vector<int>& r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nvector<vector<int>> fence(vector<vector<int>>& trees) {\n    sort(trees.begin(), trees.end(), compare);\n    vector<vector<int>> hull;\n    for (const auto& p : trees) {\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    for (int i = trees.size() - 1; i >= 0; --i) {\n        const auto& p = trees[i];\n        while (hull.size() >= 2 && cross_product(hull[hull.size() - 2], hull[hull.size() - 1], p) > 0) {\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    return hull;\n}\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "python": "\n    ```python\ndef cross_product(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef fence(trees):\n    trees.sort(key=lambda p: (p[0], p[1]))\n    hull = []\n    for p in trees:\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n\n    for p in reversed(trees):\n        while len(hull) >= 2 and cross_product(hull[-2], hull[-1], p) > 0:\n            hull.pop()\n        hull.append(p)\n    \n    return hull\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "javascript": "\n    ```javascript\nfunction crossProduct(p, q, r) {\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n}\n\nfunction fence(trees) {\n    trees.sort((p, q) => p[0] === q[0] ? p[1] - q[1] : p[0] - q[0]);\n    const hull = [];\n    for (const p of trees) {\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    for (let i = trees.length - 1; i >= 0; i--) {\n        const p = trees[i];\n        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], p) > 0) {\n            hull.pop();\n        }\n        hull.push(p);\n    }\n    return hull;\n}\n```\n    \n    We use the **Graham's Scan Algorithm** to find the convex hull or the trees that form the fence perimeter. This algorithm works in O(n log n) time complexity.\n\n1. First, we sort the trees based on their x coordinates. If two trees have the same x coordinate, they are sorted by their y coordinates.\n2. We create an empty list called `hull` to store the trees that belong to the convex hull.\n3. Iterate through the sorted `trees` and:\n   a. For each tree `p`, we check if `hull` has at least two trees and the cross product of the last two trees and `p` is greater than 0.\n   b. If the cross product is greater than 0, then the last tree in the `hull` doesn't belong to the convex hull, so we remove it.\n   c. Add tree `p` to the `hull`.\n4. Now we iterate through the sorted `trees` in reverse order and repeat steps 3a-3c.\n5. At the end, the `hull` contains the coordinates of the trees that form the fence perimeter.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " trees = [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]",
                    "output": " [[1,1],[2,0],[4,2],[3,3],[2,4]]",
                    "explanation": " All the trees will be on the perimeter of the fence except the tree at \\[2, 2\\], which will be inside the fence."
                },
                {
                    "input": " trees = [[1,2],[2,2],[4,2]]",
                    "output": " [[4,2],[2,2],[1,2]]",
                    "explanation": " The fence forms a line that passes through all the trees."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]",
                    "output": "[[1,1],[2,0],[4,2],[3,3],[2,4]]"
                },
                {
                    "input": "[[1,2],[2,2],[4,2]]",
                    "output": "[[4,2],[2,2],[1,2]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-62",
        "prompt": "You are given an array `trees` where `trees[i] = [xi, yi]` represents the location of a tree in the garden.\n\nFence the entire garden using the minimum length of rope, as it is expensive. The garden is well-fenced only if **all the trees are enclosed**.\n\nReturn _the coordinates of trees that are exactly located on the fence perimeter_. You may return the answer in **any order**."
    },
    "leetcode-benchmark-63": {
        "id": "leetcode-benchmark-63",
        "title": "Tag Validator",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\n\nA code snippet is valid if all the following rules hold:\n\n1.  The code must be wrapped in a **valid closed tag**. Otherwise, the code is invalid.\n2.  A **closed tag** (not necessarily valid) has exactly the following format : `TAG_CONTENT`. Among them, is the start tag, and is the end tag. The TAG\\_NAME in start and end tags should be the same. A closed tag is **valid** if and only if the TAG\\_NAME and TAG\\_CONTENT are valid.\n3.  A **valid** `TAG_NAME` only contain **upper-case letters**, and has length in range \\[1,9\\]. Otherwise, the `TAG_NAME` is **invalid**.\n4.  A **valid** `TAG_CONTENT` may contain other **valid closed tags**, **cdata** and any characters (see note1) **EXCEPT** unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG\\_NAME. Otherwise, the `TAG_CONTENT` is **invalid**.\n5.  A start tag is unmatched if no end tag exists with the same TAG\\_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n6.  A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or ``, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).``\n``` *   The cdata has the following format : . The range of `CDATA_CONTENT` is defined as the characters between ``and the **first subsequent** `]]>`.`` ``*   `CDATA_CONTENT` may contain **any characters**. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as **regular characters**.`` ```\n\n``` ``",
            "examples": [
                "**Example 1:**  **Input:** code =  \"  This is the first line ]]>   \" **Output:** true **Explanation:**  The code is wrapped in a closed tag :    and   .  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true.  ",
                "**Example 2:**  **Input:** code =  \"  >>  ![cdata[]] ]>]]>]]>>]   \" **Output:** true **Explanation:** We first separate the code into : start_tag|tag_content|end_tag. start_tag -> ** \"**   **\"** end_tag -> ** \"**   **\"** tag_content could also be separated into : text1|cdata|text2. text1 -> ** \">>  ![cdata[]]  \"** cdata -> ** \"]>]]> \"**, where the CDATA_CONTENT is ** \"**  **]> \"** text2 -> ** \"]]>>] \"** The reason why start_tag is NOT ** \"**  **>> \"** is because of the rule 6. The reason why cdata is NOT ** \"]>]]>]]> \"** is because of the rule 7.  ",
                "**Example 3:**  **Input:** code =  \"    \" **Output:** false **Explanation:** Unbalanced. If  \" \" is closed, then  \" **\" must be unmatched, and vice versa.**  **"
            ],
            "constraints": "**Constraints:**  *   `1 <= code.length <= 500` *   `code` consists of English letters, digits, `'<'`, `'>'`, `'/'`, `'!'`, `'['`, `']'`, `'.'`, and `' '`.  **`` ```",
            "follow_up": ""
        },
        "java": "\n    ```java\nprivate static boolean isValid(String code, int[] i) {\n    if (i[0] >= code.length()) return false;\n    if (code.charAt(i[0]) != '<') return false;\n    int nameLength = 0;\n    for (++i[0]; i[0] < code.length() && nameLength < 9 && Character.isUpperCase(code.charAt(i[0])); ++i[0]) ++nameLength;\n    if (nameLength < 1 || nameLength > 9 || code.charAt(i[0]++) != '>') return false;\n\n    while (i[0] < code.length() && code.charAt(i[0]) != '<') ++i[0];\n    if (i[0] >= code.length()) return false;\n\n    if (!code.substring(i[0], i[0] + nameLength + 3).equals(\"</\" + code.substring(i[0] - nameLength - 1, i[0] - 1) + \">\"))\n        return false;\n    i[0] += nameLength + 3;\n    return true;\n}\n\npublic static boolean validateCodeSnippet(String code) {\n    int[] i = {0};\n    return isValid(code, i) && i[0] == code.length();\n}\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "c++": "\n    ```cpp\nbool is_valid(const std::string& code, size_t &i) {\n    if (i >= code.size()) return false;\n    if (code[i] != '<') return false;\n    int name_len = 0;\n    for (++i; i < code.size() && name_len < 9 && isupper(code[i]); ++i) ++name_len;\n    if (name_len < 1 || name_len > 9 || code[i++] != '>') return false;\n\n    while (i < code.size() && code[i] != '<') ++i;\n    if (i >= code.size()) return false;\n\n    if (code.substr(i, name_len + 3) != \"</\" + code.substr(i - name_len - 1, name_len) + \">\") \n        return false;\n    i += name_len + 3;\n    return true;\n}\n\nbool validateCodeSnippet(const std::string &code) {\n    size_t i = 0;\n    return is_valid(code, i) && i == code.size();\n}\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "python": "\n    ```python\ndef is_valid(code, i):\n    if i >= len(code) or code[i] != '<':\n        return False, i\n    i += 1\n    name_start = i\n    while i < len(code) and code[i].isupper():\n        i += 1\n    name_len = i - name_start\n    if name_len < 1 or name_len > 9 or code[i] != '>':\n        return False, i\n    i += 1\n\n    while i < len(code) and code[i] != '<':\n        i += 1\n    if i + 2 + name_len >= len(code) or code[i:i + 2 + name_len] != '</' + code[name_start:i] + '>':\n        return False, i\n    return True, i + 2 + name_len\n\ndef validate_code_snippet(code):\n    is_valid_code, i = is_valid(code, 0)\n    return is_valid_code and i == len(code)\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "javascript": "\n    ```javascript\nfunction isValid(code, i) {\n    if (!code || i.value >= code.length) return false;\n    if (code[i.value] != '<') return false;\n    let nameLength = 0;\n    for (++i.value; i.value < code.length && nameLength < 9 && /^[A-Z]$/.test(code[i.value]); ++i.value) ++nameLength;\n    if (nameLength < 1 || nameLength > 9 || code[i.value++] != '>') return false;\n\n    while (i.value < code.length && code[i.value] != '<') ++i.value;\n    if (i.value >= code.length) return false;\n\n    if (code.substring(i.value, i.value + nameLength + 3) != \"</\" + code.substring(i.value - nameLength - 1, i.value-1) + \">\")\n        return false;\n    i.value += nameLength + 3;\n    return true;\n}\n\nfunction validateCodeSnippet(code) {\n    let i = {value: 0};\n    return isValid(code, i) && i.value == code.length;\n}\n```\n    \n    The algorithm iterates through the code snippet and checks for valid start tags and end tags. It checks for the following conditions:\n1. The code snippet begins with a start tag and ends with a matching end tag.\n2. A start tag starts with `<` followed by uppercase alphabet letters and ends with `>`.\n3. An end tag is a string like `</TAG_NAME>` with no extra characters after the tag name, and TAG_NAME in the end tag is the same as the start tag.\n4. Valid tags don't have any other tags inside them but can have single or double quotes as a regular text element.\n\nWe use helper functions `is_valid` or `isValid` in each language to traverse the code string and match start tags with their corresponding end tags. It returns a boolean value indicating if the code is valid or not, and also updates the current index of the string traversal, which is passed as a reference or a mutable object.\n\nThe main function `validate_code_snippet` or `validateCodeSnippet` calls the helper function and checks if the returned boolean value is True and the updated index is equal to the length of the code string, which means the entire code snippet was traversed and validated successfully. If both conditions are met, the code snippet is valid, otherwise it is invalid.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " code =  \"  This is the first line ]]>   \"",
                    "output": " True",
                    "explanation": "  The code is wrapped in a closed tag :    and   .  The TAG_NAME is valid, the TAG_CONTENT consists of some characters and cdata.  Although CDATA_CONTENT has an unmatched start tag with invalid TAG_NAME, it should be considered as plain text, not parsed as a tag. So TAG_CONTENT is valid, and then the code is valid. Thus return true."
                },
                {
                    "input": " code =  \"  >>  ![cdata[]] ]>]]>]]>>]   \"",
                    "output": " True",
                    "explanation": " We first separate the code into : start_tag|tag_content|end_tag. start_tag -> ** \"**   **\"** end_tag -> ** \"**   **\"** tag_content could also be separated into : text1|cdata|text2. text1 -> ** \">>  ![cdata[]]  \"** cdata -> ** \"]>]]> \"**, where the CDATA_CONTENT is ** \"**  **]> \"** text2 -> ** \"]]>>] \"** The reason why start_tag is NOT ** \"**  **>> \"** is because of the rule 6. The reason why cdata is NOT ** \"]>]]>]]> \"** is because of the rule 7."
                },
                {
                    "input": " code =  \"    \"",
                    "output": " False",
                    "explanation": " Unbalanced. If  \" \" is closed, then  \" **\" must be unmatched, and vice versa.**  **"
                }
            ],
            "function_input": [
                {
                    "input": "\"Thisisthefirstline]>\"",
                    "output": "True"
                },
                {
                    "input": "\">>![cdata[]]]]>]]>>]\"",
                    "output": "True"
                },
                {
                    "input": "\"\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-63",
        "prompt": "Given a string representing a code snippet, implement a tag validator to parse the code and return whether it is valid.\n\nA code snippet is valid if all the following rules hold:\n\n1.  The code must be wrapped in a **valid closed tag**. Otherwise, the code is invalid.\n2.  A **closed tag** (not necessarily valid) has exactly the following format : `TAG_CONTENT`. Among them, is the start tag, and is the end tag. The TAG\\_NAME in start and end tags should be the same. A closed tag is **valid** if and only if the TAG\\_NAME and TAG\\_CONTENT are valid.\n3.  A **valid** `TAG_NAME` only contain **upper-case letters**, and has length in range \\[1,9\\]. Otherwise, the `TAG_NAME` is **invalid**.\n4.  A **valid** `TAG_CONTENT` may contain other **valid closed tags**, **cdata** and any characters (see note1) **EXCEPT** unmatched `<`, unmatched start and end tag, and unmatched or closed tags with invalid TAG\\_NAME. Otherwise, the `TAG_CONTENT` is **invalid**.\n5.  A start tag is unmatched if no end tag exists with the same TAG\\_NAME, and vice versa. However, you also need to consider the issue of unbalanced when tags are nested.\n6.  A `<` is unmatched if you cannot find a subsequent `>`. And when you find a `<` or ``, all the subsequent characters until the next `>` should be parsed as TAG_NAME (not necessarily valid).``\n``` *   The cdata has the following format : . The range of `CDATA_CONTENT` is defined as the characters between ``and the **first subsequent** `]]>`.`` ``*   `CDATA_CONTENT` may contain **any characters**. The function of cdata is to forbid the validator to parse `CDATA_CONTENT`, so even it has some characters that can be parsed as tag (no matter valid or invalid), you should treat it as **regular characters**.`` ```\n\n``` ``"
    },
    "leetcode-benchmark-64": {
        "id": "leetcode-benchmark-64",
        "title": "Non-negative Integers without Consecutive Ones",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5\n**Output:** 5\n**Explanation:**\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule. \n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findIntegers(int n) {\n    int[][] dp = new int[32][2];\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if ((n & (1 << i)) != 0) {\n            ans += dp[i][0];\n            if (prev_bit == 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "c++": "\n    ```cpp\nint findIntegers(int n) {\n    int dp[32][2] = {0};\n    dp[0][0] = dp[0][1] = 1;\n\n    for (int i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    int ans = 0, prev_bit = 0;\n    for (int i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "python": "\n    ```python\ndef findIntegers(n: int) -> int:\n    dp = [[0, 0] for _ in range(32)]\n    dp[0][0], dp[0][1] = 1, 1\n\n    for i in range(1, 32):\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1]\n        dp[i][1] = dp[i - 1][0]\n\n    ans = 0\n    prev_bit = 0\n    for i in range(30, -1, -1):\n        if n & (1 << i):\n            ans += dp[i][0]\n            if prev_bit:\n                break\n            prev_bit = 1\n        else:\n            prev_bit = 0\n\n    return ans + 1\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "javascript": "\n    ```javascript\nfunction findIntegers(n) {\n    let dp = new Array(32).fill(0).map(() => Array(2).fill(0));\n    dp[0][0] = 1;\n    dp[0][1] = 1;\n\n    for (let i = 1; i < 32; i++) {\n        dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n        dp[i][1] = dp[i - 1][0];\n    }\n\n    let ans = 0, prev_bit = 0;\n    for (let i = 30; i >= 0; i--) {\n        if (n & (1 << i)) {\n            ans += dp[i][0];\n            if (prev_bit === 1) break;\n            prev_bit = 1;\n        } else {\n            prev_bit = 0;\n        }\n    }\n\n    return ans + 1;\n}\n```\n\n    \n    The algorithm uses dynamic programming to count the number of valid integers with no consecutive 1s in their binary representation. It initializes an array `dp` with the dimensions [32][2], where the first dimension represents the length of the binary representation and the second dimension represents whether the last bit is a 1 (consecutive 1s) or a 0.\n\nFor every index i from `1` to `32`, dp[i][0] represents the count of valid integers without leading 1s, while dp[i][1] represents the count of valid integers without consecutive 1s ending with a 1. Starting from the highest bit and moving to the lowest bit, the algorithm checks if bit `i` is set in the given number `n`. If the bit is set, the algorithm increments the counter `ans` by the number of valid integers with that bit position.\n\nIf the previous bit was set, the algorithm breaks the loop because consecutive 1s were found. Finally, the algorithm returns the count of valid integers incremented by 1 to account for the integer 0, which always satisfies the condition.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5",
                    "output": " 5",
                    "explanation": "\nHere are the non-negative integers <= 5 with their corresponding binary representations:\n0 : 0\n1 : 1\n2 : 10\n3 : 11\n4 : 100\n5 : 101\nAmong them, only integer 3 disobeys the rule (two consecutive ones) and the other 5 satisfy the rule."
                },
                {
                    "input": " n = 1",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " n = 2",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5",
                    "output": "5"
                },
                {
                    "input": "1",
                    "output": "2"
                },
                {
                    "input": "2",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-64",
        "prompt": "Given a positive integer `n`, return the number of the integers in the range `[0, n]` whose binary representations **do not** contain consecutive ones."
    },
    "leetcode-benchmark-65": {
        "id": "leetcode-benchmark-65",
        "title": "K Inverse Pairs Array",
        "difficulty": "Hard",
        "content": {
            "problem": "For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 0\n**Output:** 1\n**Explanation:** Only the array \\[1,2,3\\] which consists of numbers from 1 to 3 has exactly 0 inverse pairs.\n\n",
                "**Example 2:**\n\n**Input:** n = 3, k = 1\n**Output:** 2\n**Explanation:** The array \\[1,3,2\\] and \\[2,1,3\\] have exactly 1 inverse pair."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= k <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int kInversePairs(int n, int k) {\n    int mod = 1000000007;\n    int[][] dp = new int[n + 1][k + 1];\n    for (int i = 1; i <= n; i++) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "c++": "\n    ```cpp\nint kInversePairs(int n, int k) {\n    int mod = 1e9 + 7;\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1, 0));\n    for (int i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (int j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "python": "\n    ```python\ndef kInversePairs(n: int, k: int) -> int:\n    mod = 10**9 + 7\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][0] = 1\n        for j in range(1, k + 1):\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod\n            if j - i >= 0:\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod\n    return dp[n][k]\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "javascript": "\n    ```javascript\nfunction kInversePairs(n, k) {\n    const mod = 1e9 + 7;\n    const dp = Array.from({ length: n + 1 }, () => Array(k + 1).fill(0));\n    for (let i = 1; i <= n; ++i) {\n        dp[i][0] = 1;\n        for (let j = 1; j <= k; ++j) {\n            dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % mod;\n            if (j - i >= 0) {\n                dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + mod) % mod;\n            }\n        }\n    }\n    return dp[n][k];\n}\n```\n    \n    We use dynamic programming to solve this problem. We create a 2D array dp where `dp[i][j]` represents the number of arrays with `i` elements having `j` inverse pairs. We initialize `dp[i][0]` to 1 for all `i`.\n\nFor each `i` and `j`, we update the value of `dp[i][j]` using the following relation:\n\n`dp[i][j] = dp[i][j - 1] + dp[i - 1][j]`\n\nIf there are enough elements (i.e., `j - i >= 0`) to form an inverse pair, we subtract the number of inverse pairs using `dp[i - 1][j - i]`. After updating the value, we ensure that the result stays within the given range by taking the modulo with 10^9 + 7.\n\nFinally, we return the value at `dp[n][k]`, which represents the number of arrays with `n` (1 to n) elements having exactly `k` inverse pairs. \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3, k = 0",
                    "output": " 1",
                    "explanation": " Only the array \\[1,2,3\\] which consists of numbers from 1 to 3 has exactly 0 inverse pairs."
                },
                {
                    "input": " n = 3, k = 1",
                    "output": " 2",
                    "explanation": " The array \\[1,3,2\\] and \\[2,1,3\\] have exactly 1 inverse pair."
                }
            ],
            "function_input": [
                {
                    "input": "3,0",
                    "output": "1"
                },
                {
                    "input": "3,1",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-65",
        "prompt": "For an integer array `nums`, an **inverse pair** is a pair of integers `[i, j]` where `0 <= i < j < nums.length` and `nums[i] > nums[j]`.\n\nGiven two integers n and k, return the number of different arrays consist of numbers from `1` to `n` such that there are exactly `k` **inverse pairs**. Since the answer can be huge, return it **modulo** `109 + 7`."
    },
    "leetcode-benchmark-66": {
        "id": "leetcode-benchmark-66",
        "title": "Decode Ways II",
        "difficulty": "Hard",
        "content": {
            "problem": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\n**In addition** to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1* \"` may represent any of the encoded messages `\"11 \"`, `\"12 \"`, `\"13 \"`, `\"14 \"`, `\"15 \"`, `\"16 \"`, `\"17 \"`, `\"18 \"`, or `\"19 \"`. Decoding `\"1* \"` is equivalent to decoding **any** of the encoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters, return _the **number** of ways to **decode** it_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"\\* \"\n**Output:** 9\n**Explanation:** The encoded message can represent any of the encoded messages  \"1 \",  \"2 \",  \"3 \",  \"4 \",  \"5 \",  \"6 \",  \"7 \",  \"8 \", or  \"9 \".\nEach of these can be decoded to the strings  \"A \",  \"B \",  \"C \",  \"D \",  \"E \",  \"F \",  \"G \",  \"H \", and  \"I \" respectively.\nHence, there are a total of 9 ways to decode  \"\\* \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"1\\* \"\n**Output:** 18\n**Explanation:** The encoded message can represent any of the encoded messages  \"11 \",  \"12 \",  \"13 \",  \"14 \",  \"15 \",  \"16 \",  \"17 \",  \"18 \", or  \"19 \".\nEach of these encoded messages have 2 ways to be decoded (e.g.  \"11 \" can be decoded to  \"AA \" or  \"K \").\nHence, there are a total of 9 \\* 2 = 18 ways to decode  \"1\\* \".\n\n",
                "**Example 3:**\n\n**Input:** s =  \"2\\* \"\n**Output:** 15\n**Explanation:** The encoded message can represent any of the encoded messages  \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \",  \"26 \",  \"27 \",  \"28 \", or  \"29 \".\n \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \", and  \"26 \" have 2 ways of being decoded, but  \"27 \",  \"28 \", and  \"29 \" only have 1 way.\nHence, there are a total of (6 \\* 2) + (3 \\* 1) = 12 + 3 = 15 ways to decode  \"2\\* \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is a digit or `'*'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numDecodings(String s) {\n    final int MOD = 1_000_000_007;\n    int n = s.length();\n    long[] dp = new long[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) == '*' ? 9 : (s.charAt(0) == '0' ? 0 : 1);\n\n    for (int i = 2; i <= n; ++i) {\n        char c = s.charAt(i - 1);\n        char prevC = s.charAt(i - 2);\n\n        if (c == '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (prevC == '1') dp[i] += 9 * dp[i - 2];\n            else if (prevC == '2') dp[i] += 6 * dp[i - 2];\n            else if (prevC == '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (c != '0') ? dp[i - 1] : 0;\n            int num = Integer.parseInt(s.substring(i - 2, i));\n            if (prevC == '1' || (prevC == '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (prevC == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return (int) dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "c++": "\n    ```cpp\nint numDecodings(const std::string& s) {\n    const int MOD = 1e9 + 7;\n    int n = s.size();\n    std::vector<long long> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] == '*' ? 9 : (s[0] == '0' ? 0 : 1);\n\n    for (int i = 2; i <= n; ++i) {\n        if (s[i - 1] == '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (s[i - 2] == '1') dp[i] += 9 * dp[i - 2];\n            else if (s[i - 2] == '2') dp[i] += 6 * dp[i - 2];\n            else if (s[i - 2] == '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (s[i - 1] != '0') ? dp[i - 1] : 0;\n            int num = std::stoi(s.substr(i - 2, 2));\n            if (s[i - 2] == '1' || (s[i - 2] == '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (s[i - 2] == '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "python": "\n    ```python\ndef num_decodings(s: str) -> int:\n    MOD = 10**9 + 7\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 9 if s[0] == '*' else (0 if s[0] == '0' else 1)\n\n    for i in range(2, n + 1):\n        c, prev_c = s[i - 1], s[i - 2]\n        \n        if c == '*':\n            dp[i] = 9 * dp[i - 1]\n            if prev_c == '1': dp[i] += 9 * dp[i - 2]\n            elif prev_c == '2': dp[i] += 6 * dp[i - 2]\n            elif prev_c == '*': dp[i] += 15 * dp[i - 2]\n        else:\n            dp[i] = dp[i - 1] if c != '0' else 0\n            num = int(s[i - 2 : i])\n            if prev_c == '1' or (prev_c == '2' and num <= 26): dp[i] += dp[i - 2]\n            elif prev_c == '*': dp[i] += 2 * dp[i - 2] if 10 <= num <= 26 else dp[i - 2]\n\n        dp[i] %= MOD\n    return dp[n]\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "javascript": "\n    ```javascript\nfunction numDecodings(s) {\n    const MOD = 1_000_000_007;\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] === '*' ? 9 : (s[0] === '0' ? 0 : 1);\n\n    for (let i = 2; i <= n; ++i) {\n        let c = s[i - 1];\n        let prevC = s[i - 2];\n\n        if (c === '*') {\n            dp[i] = 9 * dp[i - 1];\n            if (prevC === '1') dp[i] += 9 * dp[i - 2];\n            else if (prevC === '2') dp[i] += 6 * dp[i - 2];\n            else if (prevC === '*') dp[i] += 15 * dp[i - 2];\n        } else {\n            dp[i] = (c !== '0') ? dp[i - 1] : 0;\n            let num = parseInt(s.slice(i - 2, i));\n            if (prevC === '1' || (prevC === '2' && num <= 26)) dp[i] += dp[i - 2];\n            else if (prevC === '*') dp[i] += (num <= 26 && num >= 10) ? 2 * dp[i - 2] : dp[i - 2];\n        }\n        dp[i] %= MOD;\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm uses dynamic programming to calculate the number of ways to decode the string. The idea is to iterate over the characters of the string and, for each character `'c'`, calculate how many ways to decode the string up to the position of `'c'`.\n\nWe will use an array `dp`, where `dp[i]` holds the number of ways to decode the string up to position `i`. The base cases are `dp[0] = 1` and `dp[1]` is assigned depending on whether the first character is a star or not.\n\nIn each step, we will consider pairs of characters: the current character `'c'` and the previous character `'prevC'`. If `'c'` is a star, it can be replaced with any digit from '1' to '9', so we need to calculate how many ways we can decode each possibility. Similarly, we need to handle the case when `'c'` is not a star but `'prevC'` is.\n\nFinally, we update the number of ways to decode the string at each position, taking care of the modulo operation to avoid integer overflow issues.\n\nThe final answer will be the number of ways to decode the entire string, which is stored in `dp[n]`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"* \"",
                    "output": " 9",
                    "explanation": " The encoded message can represent any of the encoded messages  \"1 \",  \"2 \",  \"3 \",  \"4 \",  \"5 \",  \"6 \",  \"7 \",  \"8 \", or  \"9 \".\nEach of these can be decoded to the strings  \"A \",  \"B \",  \"C \",  \"D \",  \"E \",  \"F \",  \"G \",  \"H \", and  \"I \" respectively.\nHence, there are a total of 9 ways to decode  \"\\* \"."
                },
                {
                    "input": " s =  \"1* \"",
                    "output": " 18",
                    "explanation": " The encoded message can represent any of the encoded messages  \"11 \",  \"12 \",  \"13 \",  \"14 \",  \"15 \",  \"16 \",  \"17 \",  \"18 \", or  \"19 \".\nEach of these encoded messages have 2 ways to be decoded (e.g.  \"11 \" can be decoded to  \"AA \" or  \"K \").\nHence, there are a total of 9 \\* 2 = 18 ways to decode  \"1\\* \"."
                },
                {
                    "input": " s =  \"2* \"",
                    "output": " 15",
                    "explanation": " The encoded message can represent any of the encoded messages  \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \",  \"26 \",  \"27 \",  \"28 \", or  \"29 \".\n \"21 \",  \"22 \",  \"23 \",  \"24 \",  \"25 \", and  \"26 \" have 2 ways of being decoded, but  \"27 \",  \"28 \", and  \"29 \" only have 1 way.\nHence, there are a total of (6 \\* 2) + (3 \\* 1) = 12 + 3 = 15 ways to decode  \"2\\* \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"*\"",
                    "output": "9"
                },
                {
                    "input": "\"1*\"",
                    "output": "18"
                },
                {
                    "input": "\"2*\"",
                    "output": "15"
                }
            ]
        },
        "task_id": "leetcode-benchmark-66",
        "prompt": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\n**In addition** to the mapping above, an encoded message may contain the `'*'` character, which can represent any digit from `'1'` to `'9'` (`'0'` is excluded). For example, the encoded message `\"1* \"` may represent any of the encoded messages `\"11 \"`, `\"12 \"`, `\"13 \"`, `\"14 \"`, `\"15 \"`, `\"16 \"`, `\"17 \"`, `\"18 \"`, or `\"19 \"`. Decoding `\"1* \"` is equivalent to decoding **any** of the encoded messages it can represent.\n\nGiven a string `s` consisting of digits and `'*'` characters, return _the **number** of ways to **decode** it_.\n\nSince the answer may be very large, return it **modulo** `109 + 7`."
    },
    "leetcode-benchmark-67": {
        "id": "leetcode-benchmark-67",
        "title": "Maximum Average Subarray II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is greater than or equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,12,-5,-6,50,3\\], k = 4\n**Output:** 12.75000\n**Explanation:**\n\\- When the length is 4, averages are \\[0.5, 12.75, 10.5\\] and the maximum average is 12.75\n- When the length is 5, averages are \\[10.4, 10.8\\] and the maximum average is 10.8\n- When the length is 6, averages are \\[9.16667\\] and the maximum average is 9.16667\nThe maximum average is when we choose a subarray of length 4 (i.e., the sub array \\[12, -5, -6, 50\\]) which has the max average 12.75, so we return 12.75\nNote that we do not consider the subarrays of length < 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5\\], k = 1\n**Output:** 5.00000"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= k <= n <= 104`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic double findMaxAverage(int[] nums, int k) {\n    long sum = 0;\n    for(int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    double max_avg = (double) sum / k;\n    \n    for(int i = k; i < nums.length; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = Math.max(max_avg, (double) sum / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "c++": "\n    ```cpp\ndouble findMaxAverage(vector<int>& nums, int k) {\n    long sum = 0;\n    int n = nums.size();\n    for(int i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    double max_avg = static_cast<double>(sum) / k;\n    \n    for(int i = k; i < n; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = max(max_avg, static_cast<double>(sum) / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "python": "\n    ```python\ndef findMaxAverage(nums, k):\n    total = sum(nums[:k])\n    max_avg = total / k\n    for i in range(k, len(nums)):\n        total += nums[i] - nums[i - k]\n        max_avg = max(max_avg, total / k)\n    return max_avg\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "javascript": "\n    ```javascript\nfunction findMaxAverage(nums, k) {\n    let sum = 0;\n    for(let i = 0; i < k; i++) {\n        sum += nums[i];\n    }\n\n    let max_avg = sum / k;\n    \n    for(let i = k; i < nums.length; i++) {\n        sum += nums[i] - nums[i - k];\n        max_avg = Math.max(max_avg, sum / k);\n    }\n    \n    return max_avg;\n}\n```\n    \n    The algorithm calculates the initial total of the first `k` elements, and the initial average is the total divided by `k`. Then, it iterates through the rest of the array (from the `k`-th index to the end), updating the total by removing the (i-k)-th element and adding the i-th element. At each step, it compares the new average (total/k) with the previous maximum average and updates accordingly. Finally, it returns the maximum average found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,12,-5,-6,50,3], k = 4",
                    "output": " 12.75000",
                    "explanation": "\n\\- When the length is 4, averages are \\[0.5, 12.75, 10.5\\] and the maximum average is 12.75\n- When the length is 5, averages are \\[10.4, 10.8\\] and the maximum average is 10.8\n- When the length is 6, averages are \\[9.16667\\] and the maximum average is 9.16667\nThe maximum average is when we choose a subarray of length 4 (i.e., the sub array \\[12, -5, -6, 50\\]) which has the max average 12.75, so we return 12.75\nNote that we do not consider the subarrays of length < 4."
                },
                {
                    "input": " nums = [5], k = 1",
                    "output": " 5.00000",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,12,-5,-6,50,3],4",
                    "output": "12.75000"
                },
                {
                    "input": "[5],1",
                    "output": "5.00000"
                }
            ]
        },
        "task_id": "leetcode-benchmark-67",
        "prompt": "You are given an integer array `nums` consisting of `n` elements, and an integer `k`.\n\nFind a contiguous subarray whose **length is greater than or equal to** `k` that has the maximum average value and return _this value_. Any answer with a calculation error less than `10-5` will be accepted."
    },
    "leetcode-benchmark-68": {
        "id": "leetcode-benchmark-68",
        "title": "Coin Path",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `coins` (**1-indexed**) of length `n` and an integer `maxJump`. You can jump to any index `i` of the array `coins` if `coins[i] != -1` and you have to pay `coins[i]` when you visit index `i`. In addition to that, if you are currently at index `i`, you can only jump to any index `i + k` where `i + k <= n` and `k` is a value in the range `[1, maxJump]`.\n\nYou are initially positioned at index `1` (`coins[1]` is not `-1`). You want to find the path that reaches index n with the minimum cost.\n\nReturn an integer array of the indices that you will visit in order so that you can reach index n with the minimum cost. If there are multiple paths with the same cost, return the **lexicographically smallest** such path. If it is not possible to reach index n, return an empty array.\n\nA path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j` exists, then `x < y`.",
            "examples": [
                "**Example 1:**\n\n**Input:** coins = \\[1,2,4,-1,2\\], maxJump = 2\n**Output:** \\[1,3,5\\]\n\n",
                "**Example 2:**\n\n**Input:** coins = \\[1,2,4,-1,2\\], maxJump = 1\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= coins.length <= 1000`\n*   `-1 <= coins[i] <= 100`\n*   `coins[1] != -1`\n*   `1 <= maxJump <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\nclass Solution {\n    public int[] cheapestJump(int[] coins, int maxJump) {\n        int n = coins.length;\n        int[] dp = new int[n];\n        int[] parent = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        Arrays.fill(parent, -1);\n        dp[0] = coins[0];\n        for (int i = 0; i < n; ++i) {\n            if (coins[i] == -1) continue;\n            for (int j = 1; j <= maxJump && i + j < n; ++j) {\n                int next = i + j;\n                int cost = coins[next] + dp[i];\n                if (cost < dp[next]) {\n                    dp[next] = cost;\n                    parent[next] = i;\n                }\n            }\n        }\n        List<Integer> ansList = new ArrayList<>();\n        if (dp[n - 1] == Integer.MAX_VALUE) return new int[0];\n        int cur = n - 1;\n        while (cur != -1) {\n            ansList.add(cur + 1);\n            cur = parent[cur];\n        }\n        Collections.reverse(ansList);\n        int[] ans = new int[ansList.size()];\n        for (int i = 0; i < ansLIST.size(); i++) {\n            ans[i] = ansList.get(i);\n        }\n        return ans;\n    }\n}\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nvector<int> cheapestJump(vector<int>& coins, int maxJump) {\n    int n = coins.size();\n    vector<int> dp(n, 1e9), parent(n, -1);\n    dp[0] = coins[0];\n    for (int i = 0; i < n; ++i) {\n        if (coins[i] == -1) continue;\n        for (int j = 1; j <= maxJump && i + j < n; ++j) {\n            int next = i + j;\n            int cost = coins[next] + dp[i];\n            if (cost < dp[next]) {\n                dp[next] = cost;\n                parent[next] = i;\n            }\n        }\n    }\n    vector<int> ans;\n    if (dp[n - 1] == 1e9) return ans;\n    int cur = n - 1;\n    while (cur != -1) {\n        ans.push_back(cur + 1);\n        cur = parent[cur];\n    }\n    reverse(ans.begin(), ans.end());\n    return ans;\n}\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "python": "\n    ```python\ndef cheapestJump(coins, maxJump):\n    n = len(coins)\n    dp = [float('inf')] * n\n    parent = [-1] * n\n    dp[0] = coins[0]\n    for i in range(n):\n        if coins[i] == -1:\n            continue\n        for j in range(1, maxJump + 1):\n            if i + j >= n:\n                break\n            next = i + j\n            cost = coins[next] + dp[i]\n            if cost < dp[next]:\n                dp[next] = cost\n                parent[next] = i\n    ans = []\n    if dp[n - 1] == float('inf'):\n        return ans\n    cur = n - 1\n    while cur != -1:\n        ans.append(cur + 1)\n        cur = parent[cur]\n    ans.reverse()\n    return ans\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "javascript": "\n    ```javascript\nfunction cheapestJump(coins, maxJump) {\n    const n = coins.length;\n    const dp = new Array(n).fill(Infinity);\n    const parent = new Array(n).fill(-1);\n    dp[0] = coins[0];\n    for (let i = 0; i < n; ++i) {\n        if (coins[i] === -1) continue;\n        for (let j = 1; j <= maxJump && i + j < n; ++j) {\n            const next = i + j;\n            const cost = coins[next] + dp[i];\n            if (cost < dp[next]) {\n                dp[next] = cost;\n                parent[next] = i;\n            }\n        }\n    }\n    const ans = [];\n    if (dp[n - 1] === Infinity) return ans;\n    let cur = n - 1;\n    while (cur !== -1) {\n        ans.push(cur + 1);\n        cur = parent[cur];\n    }\n    ans.reverse();\n    return ans;\n}\n```\n    \n    The algorithm is a dynamic programming-based solution. The key is to define the state `dp[i]`, which represents the minimum cost to reach the `i`-th index. We initialize `dp` with infinity for all indexes except `dp[0]` which is initialized with `coins[0]`, and `parent` with -1 for all indexes.\n\nWe then traverse the input array `coins`. If `coins[i]` is -1, we skip the current index, as it is not visitable. Otherwise, we check all possible jumps from the current index `i`. For each jump, calculate the next index and cost to reach that index. If the current cost at the next index is greater than the newly calculated cost, we update the `dp[next]` and `parent[next]` with new values.\n\nOnce the traversal is complete, we construct our answer by backtracking through the parent array from the `n-1`-th index to the first index, and build the list of indices required to reach the end of the `coins` list with minimum cost. If a valid path exists, return this list of indices, otherwise, return an empty list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " coins = [1,2,4,-1,2], maxJump = 2",
                    "output": " [1,3,5]",
                    "explanation": null
                },
                {
                    "input": " coins = [1,2,4,-1,2], maxJump = 1",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,4,-1,2],2",
                    "output": "[1,3,5]"
                },
                {
                    "input": "[1,2,4,-1,2],1",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-68",
        "prompt": "You are given an integer array `coins` (**1-indexed**) of length `n` and an integer `maxJump`. You can jump to any index `i` of the array `coins` if `coins[i] != -1` and you have to pay `coins[i]` when you visit index `i`. In addition to that, if you are currently at index `i`, you can only jump to any index `i + k` where `i + k <= n` and `k` is a value in the range `[1, maxJump]`.\n\nYou are initially positioned at index `1` (`coins[1]` is not `-1`). You want to find the path that reaches index n with the minimum cost.\n\nReturn an integer array of the indices that you will visit in order so that you can reach index n with the minimum cost. If there are multiple paths with the same cost, return the **lexicographically smallest** such path. If it is not possible to reach index n, return an empty array.\n\nA path `p1 = [Pa1, Pa2, ..., Pax]` of length `x` is **lexicographically smaller** than `p2 = [Pb1, Pb2, ..., Pbx]` of length `y`, if and only if at the first `j` where `Paj` and `Pbj` differ, `Paj < Pbj`; when no such `j` exists, then `x < y`."
    },
    "leetcode-benchmark-69": {
        "id": "leetcode-benchmark-69",
        "title": "Remove 9",
        "difficulty": "Hard",
        "content": {
            "problem": "Start from integer `1`, remove any integer that contains `9` such as `9`, `19`, `29`...\n\nNow, you will have a new integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...]`.\n\nGiven an integer `n`, return _the_ `nth` (**1-indexed**) integer in the new sequence.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 9\n**Output:** 10\n\n",
                "**Example 2:**\n\n**Input:** n = 10\n**Output:** 11"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 8 * 108`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int newInteger(int n) {\n    int result = 0, base = 1;\n    while (n>0) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "c++": "\n    ```cpp\nint newInteger(int n) {\n    int result = 0, base = 1;\n    while (n) {\n        result += n % 9 * base;\n        n /= 9;\n        base *= 10;\n    }\n    return result;\n}\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "python": "\n    ```python\ndef newInteger(n):\n    result = 0\n    base = 1\n    while n:\n        result += n % 9 * base\n        n //= 9\n        base *= 10\n    return result\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "javascript": "\n    ```javascript\nfunction newInteger(n) {\n    let result = 0, base = 1;\n    while (n > 0) {\n        result += (n % 9) * base;\n        n = Math.floor(n / 9);\n        base *= 10;\n    }\n    return result;\n}\n```\n    \n    The general idea is to use a radix-9 representation for the resulting numbers, ignoring the number 9. The input number `n` is first considered to be in base 9, so we divide it by 9 and calculate the remainder. The remainder corresponds to a digit position in the resulting number. The algorithm continually adds the product of the remainder and the current base (starting at 1), and updates the input number by dividing it by 9. This process continues until the input number is reduced to 0. At this point, the result contains the final number, which is then returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 9",
                    "output": " 10",
                    "explanation": null
                },
                {
                    "input": " n = 10",
                    "output": " 11",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "9",
                    "output": "10"
                },
                {
                    "input": "10",
                    "output": "11"
                }
            ]
        },
        "task_id": "leetcode-benchmark-69",
        "prompt": "Start from integer `1`, remove any integer that contains `9` such as `9`, `19`, `29`...\n\nNow, you will have a new integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 10, 11, ...]`.\n\nGiven an integer `n`, return _the_ `nth` (**1-indexed**) integer in the new sequence."
    },
    "leetcode-benchmark-70": {
        "id": "leetcode-benchmark-70",
        "title": "Strange Printer",
        "difficulty": "Hard",
        "content": {
            "problem": "There is a strange printer with the following two special properties:\n\n*   The printer can only print a sequence of **the same character** each time.\n*   At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return _the minimum number of turns the printer needed to print it_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaabbb \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"bbb \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aba \"\n**Output:** 2\n**Explanation:** Print  \"aaa \" first and then print  \"b \" from the second place of the string, which will cover the existing character 'a'."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` consists of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nint strangePrinter(String s) {\n    int n = s.length();\n    if(n == 0) return 0;\n    int[][] dp = new int[n][n];\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s.charAt(i) == s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "c++": "\n    ```cpp\nint strangePrinter(string s) {\n    int n = s.size();\n    if(n == 0) return 0;\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    for(int i = 0; i < n; i++) dp[i][i] = 1;\n    for(int len = 1; len < n; len++) {\n        for(int i = 0; i < n - len; i++) {\n            int j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(int k = i + 1; k <= j; k++) {\n                if(s[i] == s[k]) {\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "python": "\n    ```python\ndef strange_printer(s: str) -> int:\n    n = len(s)\n    if n == 0: return 0\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for len in range(1, n):\n        for i in range(n - len):\n            j = i + len\n            dp[i][j] = dp[i+1][j] + 1\n            for k in range(i + 1, j + 1):\n                if s[i] == s[k]:\n                    dp[i][j] = min(dp[i][j], dp[i+1][k-1] + dp[k][j])\n    return dp[0][n-1]\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "javascript": "\n    ```javascript\nfunction strangePrinter(s) {\n    let n = s.length;\n    if(n === 0) return 0;\n    const dp = Array.from({ length: n }, () => Array(n).fill(0));\n    for(let i = 0; i < n; i++) dp[i][i] = 1;\n    for(let len = 1; len < n; len++) {\n        for(let i = 0; i < n - len; i++) {\n            let j = i + len;\n            dp[i][j] = dp[i+1][j] + 1;\n            for(let k = i + 1; k <= j; k++) {\n                if(s.charAt(i) === s.charAt(k)) {\n                    dp[i][j] = Math.min(dp[i][j], dp[i+1][k-1] + dp[k][j]);\n                }\n            }\n        }\n    }\n    return dp[0][n-1];\n}\n```\n    \n    1. Initialize a DP table `dp` of size `n x n` where `n` is the length of the input string `s`.\n2. Fill the diagonal of the DP table with 1 since it takes one turn to print a single character.\n3. Iterate through subproblems of increasing length using a nested loop.\n4. For each subproblem, initialize `dp[i][j]` as `dp[i+1][j] + 1` assuming it takes one more turn to print the character at the current `i`.\n5. Loop through `k` from `i + 1` to `j`. If the character at `i` matches the character at `k`, update `dp[i][j]` by taking the minimum of its current value and the sum of turns for two non-overlapping subproblems `dp[i+1][k-1]` and `dp[k][j]`.\n6. The answer is stored at `dp[0][n-1]`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aaabbb \"",
                    "output": " 2",
                    "explanation": " Print  \"aaa \" first and then print  \"bbb \"."
                },
                {
                    "input": " s =  \"aba \"",
                    "output": " 2",
                    "explanation": " Print  \"aaa \" first and then print  \"b \" from the second place of the string, which will cover the existing character 'a'."
                }
            ],
            "function_input": [
                {
                    "input": "\"aaabbb\"",
                    "output": "2"
                },
                {
                    "input": "\"aba\"",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-70",
        "prompt": "There is a strange printer with the following two special properties:\n\n*   The printer can only print a sequence of **the same character** each time.\n*   At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string `s`, return _the minimum number of turns the printer needed to print it_."
    },
    "leetcode-benchmark-71": {
        "id": "leetcode-benchmark-71",
        "title": "Kth Smallest Number in Multiplication Table",
        "difficulty": "Hard",
        "content": {
            "problem": "Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).\n\nGiven three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 3, k = 5\n**Output:** 3\n**Explanation:** The 5th smallest number is 3.\n\n",
                "**Example 2:**\n\n**Input:** m = 2, n = 3, k = 6\n**Output:** 6\n**Explanation:** The 6th smallest number is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= k <= m * n`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "c++": "\n    ```cpp\nint findKthNumber(int m, int n, int k) {\n    int low = 1, high = m * n;\n    while (low < high) {\n        int mid = low + (high - low) / 2;\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += std::min(mid / i, n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "python": "\n    ```python\ndef findKthNumber(m, n, k):\n    low, high = 1, m * n\n    while low < high:\n        mid = low + (high - low) // 2\n        count = 0\n        for i in range(1, m+1):\n            count += min(mid // i, n)\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    return low\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "javascript": "\n    ```javascript\nfunction findKthNumber(m, n, k) {\n    let low = 1, high = m * n;\n    while (low < high) {\n        let mid = low + Math.floor((high - low) / 2);\n        let count = 0;\n        for (let i = 1; i <= m; i++) {\n            count += Math.min(Math.floor(mid / i), n);\n        }\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n```\n    \n    We need to find the kth smallest element in an m x n multiplication table. The table is naturally sorted, so we can use binary search to find the desired element. We start with `low` as 1 and `high` as m * n. Our search space is between these values.\n\nIn each iteration, we look for the middle value `mid`. For each row `i`, we count the number of elements that are less than or equal to `mid`. The count is the sum of either `mid // i` or `n`, whichever is smaller. Then we check if the count is less than or equal to `k`. If it is, we move `low` to `mid + 1`; otherwise, we move `high` to `mid`. Once the search space narrowed down to a single value, we return that value as the kth smallest element in the m x n multiplication table.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " m = 3, n = 3, k = 5",
                    "output": " 3",
                    "explanation": " The 5th smallest number is 3."
                },
                {
                    "input": " m = 2, n = 3, k = 6",
                    "output": " 6",
                    "explanation": " The 6th smallest number is 6."
                }
            ],
            "function_input": [
                {
                    "input": "3,3,5",
                    "output": "3"
                },
                {
                    "input": "2,3,6",
                    "output": "6"
                }
            ]
        },
        "task_id": "leetcode-benchmark-71",
        "prompt": "Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).\n\nGiven three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_."
    },
    "leetcode-benchmark-72": {
        "id": "leetcode-benchmark-72",
        "title": "K Empty Slots",
        "difficulty": "Hard",
        "content": {
            "problem": "You have `n` bulbs in a row numbered from `1` to `n`. Initially, all the bulbs are turned off. We turn on **exactly one** bulb every day until all bulbs are on after `n` days.\n\nYou are given an array `bulbs` of length `n` where `bulbs[i] = x` means that on the `(i+1)th` day, we will turn on the bulb at position `x` where `i` is **0-indexed** and `x` is **1-indexed.**\n\nGiven an integer `k`, return _the **minimum day number** such that there exists two **turned on** bulbs that have **exactly** `k` bulbs between them that are **all turned off**. If there isn't such day, return `-1`._",
            "examples": [
                "**Example 1:**\n\n**Input:** bulbs = \\[1,3,2\\], k = 1\n**Output:** 2\n**Explanation:**\nOn the first day: bulbs\\[0\\] = 1, first bulb is turned on: \\[1,0,0\\]\nOn the second day: bulbs\\[1\\] = 3, third bulb is turned on: \\[1,0,1\\]\nOn the third day: bulbs\\[2\\] = 2, second bulb is turned on: \\[1,1,1\\]\nWe return 2 because on the second day, there were two on bulbs with one off bulb between them.\n\n",
                "**Example 2:**\n\n**Input:** bulbs = \\[1,2,3\\], k = 1\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == bulbs.length`\n*   `1 <= n <= 2 * 104`\n*   `1 <= bulbs[i] <= n`\n*   `bulbs` is a permutation of numbers from `1` to `n`.\n*   `0 <= k <= 2 * 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int kEmptySlots(int[] bulbs, int k) {\n    int[] days = new int[bulbs.length];\n    for(int i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n    \n    int ans = Integer.MAX_VALUE;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.length) {\n        int i = left + 1;\n        for (; i < right; i++) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n    \n    return ans == Integer.MAX_VALUE ? -1 : ans + 1;\n}\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "c++": "\n    ```cpp\nint kEmptySlots(vector<int>& bulbs, int k) {\n    vector<int> days(bulbs.size());\n    for(int i = 0; i < bulbs.size(); ++i) {\n        days[bulbs[i] - 1] = i;\n    }\n    \n    int ans = INT_MAX;\n    int left = 0;\n    int right = k + 1;\n    while (right < days.size()) {\n        int i = left + 1;\n        for (; i < right; ++i) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n        }\n        if (i == right) {\n            ans = min(ans, max(days[left], days[right]));\n            left ++;\n            right ++;\n        }\n    }\n    \n    return ans == INT_MAX ? -1 : ans + 1;\n}\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "python": "\n    ```python\ndef kEmptySlots(bulbs, k):\n    days = [0] * len(bulbs)\n    for i, bulb in enumerate(bulbs):\n        days[bulb - 1] = i\n\n    ans = float('inf')\n    left = 0\n    right = k + 1\n    while right < len(days):\n        i = left + 1\n        for i in range(left + 1, right):\n            if days[i] < days[left] or days[i] < days[right]:\n                left = i\n                break\n        else:\n            ans = min(ans, max(days[left], days[right]))\n            left += 1\n            right += 1\n\n    return -1 if ans == float('inf') else ans + 1\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "javascript": "\n    ```javascript\nfunction kEmptySlots(bulbs, k) {\n    const days = new Array(bulbs.length);\n    for (let i = 0; i < bulbs.length; i++) {\n        days[bulbs[i] - 1] = i;\n    }\n\n    let ans = Number.MAX_SAFE_INTEGER;\n    let left = 0;\n    let right = k + 1;\n    while (right < days.length) {\n        let i = left + 1;\n        while (i < right) {\n            if (days[i] < days[left] || days[i] < days[right]) {\n                left = i;\n                break;\n            }\n            i++;\n        }\n        if (i === right) {\n            ans = Math.min(ans, Math.max(days[left], days[right]));\n            left++;\n            right++;\n        }\n    }\n\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans + 1;\n}\n```\n\n    \n    The algorithm begins by creating a `days` array mirroring the bulbs with the values indicating the day on which the bulb at that index was turned on. Then, we set up a sliding window approach with a `left` and `right` pointer initialized at 0 and `k + 1` respectively. We iterate through the `days` array with a nested loop, comparing the values at the left/right pointers with the current value of the nested loop iteration. We verify that the current value is either greater than the left or right pointer value. If not, we update the pointer and break out of the inner loop. If the inner loop reaches its end without breaking, we compare the maximum value of the `left` and `right` pointers in the `days` array with the current smallest interval found (initialized as infinity). This updates the smallest interval, and we increment the left and right pointers to continue the sliding window approach. The final answer is then either the minimum day number (incremented by 1) or -1 if there was no valid interval found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " bulbs = [1,3,2], k = 1",
                    "output": " 2",
                    "explanation": "\nOn the first day: bulbs\\[0\\] = 1, first bulb is turned on: \\[1,0,0\\]\nOn the second day: bulbs\\[1\\] = 3, third bulb is turned on: \\[1,0,1\\]\nOn the third day: bulbs\\[2\\] = 2, second bulb is turned on: \\[1,1,1\\]\nWe return 2 because on the second day, there were two on bulbs with one off bulb between them."
                },
                {
                    "input": " bulbs = [1,2,3], k = 1",
                    "output": " -1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,2],1",
                    "output": "2"
                },
                {
                    "input": "[1,2,3],1",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-72",
        "prompt": "You have `n` bulbs in a row numbered from `1` to `n`. Initially, all the bulbs are turned off. We turn on **exactly one** bulb every day until all bulbs are on after `n` days.\n\nYou are given an array `bulbs` of length `n` where `bulbs[i] = x` means that on the `(i+1)th` day, we will turn on the bulb at position `x` where `i` is **0-indexed** and `x` is **1-indexed.**\n\nGiven an integer `k`, return _the **minimum day number** such that there exists two **turned on** bulbs that have **exactly** `k` bulbs between them that are **all turned off**. If there isn't such day, return `-1`._"
    },
    "leetcode-benchmark-73": {
        "id": "leetcode-benchmark-73",
        "title": "Redundant Connection II",
        "difficulty": "Hard",
        "content": {
            "problem": "In this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.\n\nReturn _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.",
            "examples": [
                "**Example 1:**\n\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,1\\],\\[1,5\\]\\]\n**Output:** \\[4,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`",
            "follow_up": ""
        },
        "java": "\n    ```java\nclass Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        int[] parent = new int[edges.length + 1];\n        int[] candidateA = null, candidateB = null;\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (parent[v] > 0) {\n                candidateA = new int[] {parent[v], v};\n                candidateB = edge;\n            } else {\n                parent[v] = u;\n            }\n        }\n        \n        for (int i = 1; i <= edges.length; ++i) {\n            int cycle = i, steps = edges.length;\n            while (parent[cycle] != 0 && steps-- > 0) {\n                cycle = parent[cycle];\n            }\n            if (steps == -1) {\n                if (candidateA == null) return new int[] {parent[i], i};\n                else return candidateA;\n            }\n        }\n        \n        return candidateB;\n    }\n}\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> findRedundantDirectedConnection(vector<vector<int>>& edges) {\n    vector<int> parent(edges.size() + 1, 0);\n    vector<int> candidateA, candidateB;\n    \n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1];\n        if (parent[v] > 0) {\n            candidateA = {parent[v], v};\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n    \n    for (int i = 1; i <= edges.size(); ++i) {\n        int cycle = i, steps = edges.size();\n        while (parent[cycle] != 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps == -1) {\n            if (candidateA.empty()) return {parent[i], i};\n            else return candidateA;\n        }\n    }\n    \n    return candidateB;\n}\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "python": "\n    ```python\ndef findRedundantDirectedConnection(edges):\n    parent = [0] * (len(edges) + 1)\n    candidateA = candidateB = None\n\n    for u, v in edges:\n        if parent[v] > 0:\n            candidateA = [parent[v], v]\n            candidateB = [u, v]\n        else:\n            parent[v] = u\n\n    for i in range(1, len(edges) + 1):\n        cycle = i\n        steps = len(edges)\n        while parent[cycle] != 0 and steps > 0:\n            cycle = parent[cycle]\n            steps -= 1\n        if steps == 0:\n            if not candidateA:\n                return [parent[i], i]\n            else:\n                return candidateA\n\n    return candidateB\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "javascript": "\n    ```javascript\nfunction findRedundantDirectedConnection(edges) {\n    const parent = Array(edges.length + 1).fill(0);\n    let candidateA = null, candidateB = null;\n\n    for (const edge of edges) {\n        const [u, v] = edge;\n        if (parent[v] > 0) {\n            candidateA = [parent[v], v];\n            candidateB = edge;\n        } else {\n            parent[v] = u;\n        }\n    }\n\n    for (let i = 1; i <= edges.length; ++i) {\n        let cycle = i, steps = edges.length;\n        while (parent[cycle] !== 0 && steps-- > 0) {\n            cycle = parent[cycle];\n        }\n        if (steps === -1) {\n            if (candidateA === null) return [parent[i], i];\n            else return candidateA;\n        }\n    }\n\n    return candidateB;\n}\n```\n\n    \n    1. Initialize an array `parent` to keep track of the parent of each node.\n2. Loop through the edges to build the `parent` array. If there is already a parent for node `v`, store this edge as `candidateA` and the current edge as `candidateB`.\n3. Loop through the nodes in the graph to find a cycle. If a cycle is found, it means the edge causing a cycle should be removed. If `candidateA` exists, return `candidateA`, otherwise return the edge causing the cycle.\n4. If no cycle is found, return `candidateB`. The presence of `candidateB` means that there is a node with two parents, which is the additional edge that needs to be removed to obtain the original tree.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " edges = [[1,2],[1,3],[2,3]]",
                    "output": " [2,3]",
                    "explanation": null
                },
                {
                    "input": " edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]",
                    "output": " [4,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[1,3],[2,3]]",
                    "output": "[2,3]"
                },
                {
                    "input": "[[1,2],[2,3],[3,4],[4,1],[1,5]]",
                    "output": "[4,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-73",
        "prompt": "In this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.\n\nReturn _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array."
    },
    "leetcode-benchmark-74": {
        "id": "leetcode-benchmark-74",
        "title": "Maximum Sum of 3 Non-Overlapping Subarrays",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (**0-indexed**). If there are multiple answers, return the lexicographically smallest one.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,2,6,7,5,1\\], k = 2\n**Output:** \\[0,3,5\\]\n**Explanation:** Subarrays \\[1, 2\\], \\[2, 6\\], \\[7, 5\\] correspond to the starting indices \\[0, 3, 5\\].\nWe could have also taken \\[2, 1\\], but an answer of \\[1, 3, 5\\] would be lexicographically larger.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,2,1,2,1,2,1\\], k = 2\n**Output:** \\[0,2,4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] < 216`\n*   `1 <= k <= floor(nums.length / 3)`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int[] max_sum_of_three_subarrays(int[] nums, int k) {\n    int n = nums.length;\n    int[] sums = new int[n - k + 1];\n    int[] left = new int[n], right = new int[n], ans = new int[3];\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = new int[] {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> max_sum_of_three_subarrays(std::vector<int> &nums, int k) {\n    int n = nums.size();\n    std::vector<int> sums(n - k + 1);\n    std::vector<int> left(n), right(n), ans(3);\n    int acc_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (int i = 1; i < n - k + 1; ++i) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (int i = n - k - 1; i >= 0; --i) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    int max_sum = 0;\n\n    for (int i = k; i < n - 2 * k + 1; ++i) {\n        int left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans = {left_idx, i, right_idx};\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "python": "\n    ```python\ndef max_sum_of_three_subarrays(nums, k):\n    n = len(nums)\n    sums = [0] * (n - k + 1)\n    left, right = [0] * n, [0] * n\n\n    acc_sum = 0\n    for i in range(n):\n        acc_sum += nums[i]\n        if i >= k:\n            acc_sum -= nums[i - k]\n        if i >= k - 1:\n            sums[i - k + 1] = acc_sum\n\n    left[0] = 0\n    right[n - k] = n - k\n    for i in range(1, n - k + 1):\n        left[i] = i if sums[i] > sums[left[i - 1]] else left[i - 1]\n\n    for i in range(n - k - 1, -1, -1):\n        right[i] = i if sums[i] >= sums[right[i + 1]] else right[i + 1]\n\n    max_sum, ans = 0, [0] * 3\n    for i in range(k, n - 2 * k + 1):\n        left_idx, right_idx = left[i - k], right[i + k]\n        total_sum = sums[left_idx] + sums[i] + sums[right_idx]\n        if total_sum > max_sum:\n            max_sum = total_sum\n            ans = [left_idx, i, right_idx]\n\n    return ans\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "javascript": "\n    ```javascript\nfunction max_sum_of_three_subarrays(nums, k) {\n    const n = nums.length;\n    const sums = new Array(n - k + 1);\n    const left = new Array(n), right = new Array(n);\n    let acc_sum = 0;\n\n    for (let i = 0; i < n; i++) {\n        acc_sum += nums[i];\n        if (i >= k) {\n            acc_sum -= nums[i - k];\n        }\n        if (i >= k - 1) {\n            sums[i - k + 1] = acc_sum;\n        }\n    }\n\n    left[0] = 0;\n    right[n - k] = n - k;\n\n    for (let i = 1; i < n - k + 1; i++) {\n        left[i] = sums[i] > sums[left[i - 1]] ? i : left[i - 1];\n    }\n\n    for (let i = n - k - 1; i >= 0; i--) {\n        right[i] = sums[i] >= sums[right[i + 1]] ? i : right[i + 1];\n    }\n\n    let max_sum = 0;\n    const ans = [0, 0, 0];\n\n    for (let i = k; i < n - 2 * k + 1; i++) {\n        const left_idx = left[i - k], right_idx = right[i + k], total_sum = sums[left_idx] + sums[i] + sums[right_idx];\n        if (total_sum > max_sum) {\n            max_sum = total_sum;\n            ans[0] = left_idx;\n            ans[1] = i;\n            ans[2] = right_idx;\n        }\n    }\n\n    return ans;\n}\n```\n    \n    First, we compute the k-length subarrays' sums into the array `sums`. We use cumulative sum to optimize the calculation of the sums.\n\nWe then initialize two arrays, `left` and `right`, both of size `n`.\n\nWe start populating `left` and `right` as follows:\n- For `left`, we iterate from 1 to (n - k), and store the starting index of the max subarray sum among subarrays ending at the currentIndex or earlier.\n- For `right`, we iterate from (n - k - 1) to 0, in reverse, and store the starting index of the max subarray sum among subarrays starting at the currentIndex or later.\n\nNext, we loop through `sums` from index `k` to `n - 2 * k`, and calculate the total sum of the subarrays indicated by the `left`, `current index`, and `right` arrays for each position.\n\nFinally, we compare the calculated sum to the current maximum sum, and if it's greater, we update the maximum sum and the `answer` array with the starting indices of the subarrays. At the end of the loop, we return the `answer` array containing the indices of the three non-overlapping subarrays with the maximum sum.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,1,2,6,7,5,1], k = 2",
                    "output": " [0,3,5]",
                    "explanation": " Subarrays \\[1, 2\\], \\[2, 6\\], \\[7, 5\\] correspond to the starting indices \\[0, 3, 5\\].\nWe could have also taken \\[2, 1\\], but an answer of \\[1, 3, 5\\] would be lexicographically larger."
                },
                {
                    "input": " nums = [1,2,1,2,1,2,1,2,1], k = 2",
                    "output": " [0,2,4]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,1,2,6,7,5,1],2",
                    "output": "[0,3,5]"
                },
                {
                    "input": "[1,2,1,2,1,2,1,2,1],2",
                    "output": "[0,2,4]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-74",
        "prompt": "Given an integer array `nums` and an integer `k`, find three non-overlapping subarrays of length `k` with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (**0-indexed**). If there are multiple answers, return the lexicographically smallest one."
    },
    "leetcode-benchmark-75": {
        "id": "leetcode-benchmark-75",
        "title": "Falling Squares",
        "difficulty": "Hard",
        "content": {
            "problem": "There are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the X-axis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\nAfter each square is dropped, you must record the **height of the current tallest stack of squares**.\n\nReturn _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.",
            "examples": [
                "**Example 1:**\n\n**Input:** positions = \\[\\[1,2\\],\\[2,3\\],\\[6,1\\]\\]\n**Output:** \\[2,5,5\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of \\[2, 5, 5\\].\n\n",
                "**Example 2:**\n\n**Input:** positions = \\[\\[100,100\\],\\[200,100\\]\\]\n**Output:** \\[100,100\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of \\[100, 100\\].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= positions.length <= 1000`\n*   `1 <= lefti <= 108`\n*   `1 <= sideLengthi <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int[] fallingSquares(int[][] positions) {\n    int[] ans = new int[positions.length];\n    List<int[]> intervals = new ArrayList<>();\n\n    for (int i = 0; i < positions.length; i++) {\n        int L = positions[i][0];\n        int R = positions[i][0] + positions[i][1];\n        int h = positions[i][1];\n        for (int[] interval : intervals) {\n            if (interval[1] > L && R > interval[1]) {\n                h = Math.max(h, positions[i][1] + interval[0]);\n            }\n        }\n\n        int maxHeight = h;\n        for (int[] interval : intervals) {\n            maxHeight = Math.max(maxHeight, interval[0]);\n        }\n\n        ans[i] = maxHeight;\n        intervals.add(new int[]{h, R});\n    }\n    \n    return ans;\n}\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\nusing namespace std;\n\nvector<int> fallingSquares(vector<vector<int>>& positions) {\n    vector<int> ans;\n    vector<pair<int, int>> intervals;\n\n    for (auto p : positions) {\n        int L = p[0];\n        int R = p[0] + p[1];\n        int h = p[1];\n        for (auto it : intervals) {\n            if (it.first < R && L < it.second) {\n                h = max(h, p[1] + it.first);\n            }\n        }\n\n        int maxHeight = h;\n        for (auto it : intervals) {\n            maxHeight = max(maxHeight, it.first);\n        }\n\n        ans.push_back(maxHeight);\n        intervals.push_back(make_pair(h, R));\n    }\n    \n    return ans;\n}\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "python": "\n    ```python\ndef fallingSquares(positions):\n    ans = []\n    intervals = []\n\n    for p in positions:\n        L, size = p\n        R = L + size\n        h = size\n        for h2, R2 in intervals:\n            if R2 > L and R > R2:\n                h = max(h, size + h2)\n\n        maxHeight = max((h2 for h2, R2 in intervals), default=0)\n        ans.append(max(maxHeight, h))\n        intervals.append((h, R))\n\n    return ans\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "javascript": "\n    ```javascript\nfunction fallingSquares(positions) {\n    let ans = [];\n    let intervals = [];\n\n    for (let p of positions) {\n        let L = p[0];\n        let R = p[0] + p[1];\n        let h = p[1];\n        for (let it of intervals) {\n            if (it[1] > L && R > it[1]) {\n                h = Math.max(h, p[1] + it[0]);\n            }\n        }\n\n        let maxHeight = h;\n        for (let it of intervals) {\n            maxHeight = Math.max(maxHeight, it[0]);\n        }\n\n        ans.push(maxHeight);\n        intervals.push([h, R]);\n    }\n    \n    return ans;\n}\n```\n    \n    The function follows this algorithm:\n1. Initialize an empty list `intervals` to store the height and right edge of each landed square, and an empty list `ans` to store the maximum height after each square has been dropped.\n2. Loop through each square in `positions`.\n3. For each square, find its left `L` and right `R` edge, and initialize its height `h` to its side length.\n4. Loop through all intervals in `intervals`. Check if the current square intersects any existing square, and update the height `h` to its previous height plus the height of the intersected square.\n5. Calculate the current maximum height by looping through all intervals and updating the maxHeight variable.\n6. Append the new maxHeight to the answer array `ans`.\n7. After dropping the current square, append its height and right edge to the `intervals` list.\n8. Return the list `ans` as the final answer.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " positions = [[1,2],[2,3],[6,1]]",
                    "output": " [2,5,5]",
                    "explanation": "\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of \\[2, 5, 5\\]."
                },
                {
                    "input": " positions = [[100,100],[200,100]]",
                    "output": " [100,100]",
                    "explanation": "\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of \\[100, 100\\].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[2,3],[6,1]]",
                    "output": "[2,5,5]"
                },
                {
                    "input": "[[100,100],[200,100]]",
                    "output": "[100,100]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-75",
        "prompt": "There are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the X-axis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\nAfter each square is dropped, you must record the **height of the current tallest stack of squares**.\n\nReturn _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_."
    },
    "leetcode-benchmark-76": {
        "id": "leetcode-benchmark-76",
        "title": "Find K-th Smallest Pair Distance",
        "difficulty": "Hard",
        "content": {
            "problem": "The **distance of a pair** of integers `a` and `b` is defined as the absolute difference between `a` and `b`.\n\nGiven an integer array `nums` and an integer `k`, return _the_ `kth` _smallest **distance among all the pairs**_ `nums[i]` _and_ `nums[j]` _where_ `0 <= i < j < nums.length`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,1\\], k = 1\n**Output:** 0\n**Explanation:** Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,1\\], k = 2\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,6,1\\], k = 3\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `2 <= n <= 104`\n*   `0 <= nums[i] <= 106`\n*   `1 <= k <= n * (n - 1) / 2`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int smallestDistancePair(int[] nums, int k) {\n    Arrays.sort(nums);\n    int low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint smallestDistancePair(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    int low = 0, high = nums.back() - nums.front();\n    \n    while (low < high) {\n        int mid = (low + high) / 2;\n        int count = 0, left = 0;\n\n        for (int right = 0; right < nums.size(); ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "python": "\n    ```python\ndef smallestDistancePair(nums, k):\n    nums.sort()\n    low, high = 0, nums[-1] - nums[0]\n    \n    while low < high:\n        mid = (low + high) // 2\n        count, left = 0, 0\n\n        for right in range(len(nums)):\n            while nums[right] - nums[left] > mid:\n                left += 1\n            count += (right - left)\n\n        if count < k:\n            low = mid + 1\n        else:\n            high = mid\n    \n    return low\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "javascript": "\n    ```javascript\nfunction smallestDistancePair(nums, k) {\n    nums.sort((a, b) => a - b);\n    let low = 0, high = nums[nums.length - 1] - nums[0];\n    \n    while (low < high) {\n        let mid = Math.floor((low + high) / 2);\n        let count = 0, left = 0;\n\n        for (let right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > mid) {\n                ++left;\n            }\n            count += (right - left);\n        }\n\n        if (count < k) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    \n    return low;\n}\n```\n\n    \n    The algorithm works as follows:\n1. Sort the input array `nums`.\n2. Initialize the search range for the kth smallest distance with `low` as 0 and `high` as the maximum possible distance in the array (i.e., the difference between the last element and the first element).\n3. While `low` is smaller than `high`, perform a binary-search-like technique:\n   a. Calculate the middle distance `mid` between `low` and `high`.\n   b. Initialize `count` and `left` pointers to 0.\n   c. Traverse the array using a `right` pointer.\n   d. Move the `left` pointer to the right as long as the distance between `nums[right]` and `nums[left]` is greater than `mid`.\n   e. Increment the `count` by the difference between `right` and `left`.\n   f. If the `count` is smaller than `k`, update `low` to `mid + 1`. Otherwise, update `high` to `mid`.\n4. When the loop ends, `low` will hold the kth smallest distance.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,1], k = 1",
                    "output": " 0",
                    "explanation": " Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0."
                },
                {
                    "input": " nums = [1,1,1], k = 2",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " nums = [1,6,1], k = 3",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,1],1",
                    "output": "0"
                },
                {
                    "input": "[1,1,1],2",
                    "output": "0"
                },
                {
                    "input": "[1,6,1],3",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-76",
        "prompt": "The **distance of a pair** of integers `a` and `b` is defined as the absolute difference between `a` and `b`.\n\nGiven an integer array `nums` and an integer `k`, return _the_ `kth` _smallest **distance among all the pairs**_ `nums[i]` _and_ `nums[j]` _where_ `0 <= i < j < nums.length`."
    },
    "leetcode-benchmark-77": {
        "id": "leetcode-benchmark-77",
        "title": "Minimum Window Subsequence",
        "difficulty": "Hard",
        "content": {
            "problem": "Given strings `s1` and `s2`, return _the minimum contiguous substring part of_ `s1`_, so that_ `s2` _is a subsequence of the part_.\n\nIf there is no such window in `s1` that covers all characters in `s2`, return the empty string `\" \"`. If there are multiple such minimum-length windows, return the one with the **left-most starting index**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"abcdebdde \", s2 =  \"bde \"\n**Output:**  \"bcde \"\n**Explanation:** \n \"bcde \" is the answer because it occurs before  \"bdde \" which has the same length.\n \"deb \" is not a smaller window because the elements of s2 in the window must occur in order.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl \", s2 =  \"u \"\n**Output:**  \" \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length <= 2 * 104`\n*   `1 <= s2.length <= 100`\n*   `s1` and `s2` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String minWindowSubSequence(String s1, String s2) {\n    int m = s1.length(), n = s2.length();\n    int[][] dp = new int[n + 1][m + 1];\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1.charAt(j - 1) == s2.charAt(i - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substring(start, start + length);\n}\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string min_window_sub_sequence(std::string s1, std::string s2) {\n    int m = s1.length(), n = s2.length();\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(m + 1, -1));\n\n    for (int j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (s1[j - 1] == s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    int start = 0, length = m + 1;\n    for (int j = 1; j <= m; ++j) {\n        if (dp[n][j] != -1 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length == m + 1 ? \"\" : s1.substr(start, length);\n}\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "python": "\n    ```python\ndef min_window_sub_sequence(s1: str, s2: str) -> str:\n    m, n = len(s1), len(s2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for j in range(0, m + 1):\n        dp[0][j] = j\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if s1[j - 1] == s2[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = dp[i][j - 1]\n\n    start, length = 0, m + 1\n    for j in range(1, m + 1):\n        if dp[n][j] != 0 and j - dp[n][j] < length:\n            start = dp[n][j]\n            length = j - start\n\n    return \"\" if length == m + 1 else s1[start:start + length]\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "javascript": "\n    ```javascript\nfunction minWindowSubSequence(s1, s2) {\n    const m = s1.length, n = s2.length;\n    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));\n\n    for (let j = 0; j <= m; ++j) {\n        dp[0][j] = j;\n    }\n\n    for (let i = 1; i <= n; ++i) {\n        for (let j = 1; j <= m; ++j) {\n            if (s1[j - 1] === s2[i - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = dp[i][j - 1];\n            }\n        }\n    }\n    \n    let start = 0, length = m + 1;\n    for (let j = 1; j <= m; ++j) {\n        if (dp[n][j] !== 0 && j - dp[n][j] < length) {\n            start = dp[n][j];\n            length = j - start;\n        }\n    }\n\n    return length === m + 1 ? \"\" : s1.slice(start, start + length);\n}\n```\n    \n    We will use Dynamic Programming to build a matrix `dp` where `dp[i][j]` represents the index in string `s1` where the length `i` of the subsequence `s2` has been reached up to index `j` in string `s1`. We fill the `dp` matrix by iterating through `s1` and `s2`, and if `s1[j-1] == s2[i-1]`, then we set `dp[i][j]` equal to the previous subsequence match index (which is `dp[i-1][j-1]`), otherwise, set `dp[i][j]` to the value in the left adjacent cell `dp[i][j-1]`.\n\nThen, we iterate through the last row of the `dp` matrix to find the minimum contiguous substring part of `s1`, such that `s2` is a subsequence of the part. For each cell in the last row (i.e., `dp[n][j]`), we evaluate if there is a better minimum length, and if so, update the `start` and `length` accordingly.\n\nFinally, we return the minimum contiguous substring part of `s1`, or an empty string if `length` is still equal to `m + 1`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s1 =  \"abcdebdde \", s2 =  \"bde \"",
                    "output": "  \"bcde \"",
                    "explanation": " \n \"bcde \" is the answer because it occurs before  \"bdde \" which has the same length.\n \"deb \" is not a smaller window because the elements of s2 in the window must occur in order."
                },
                {
                    "input": " s1 =  \"jmeqksfrsdcmsiwvaovztaqenprpvnbstl \", s2 =  \"u \"",
                    "output": "  \" \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abcdebdde\",\"bde\"",
                    "output": "\"bcde\""
                },
                {
                    "input": "\"jmeqksfrsdcmsiwvaovztaqenprpvnbstl\",\"u\"",
                    "output": "\"\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-77",
        "prompt": "Given strings `s1` and `s2`, return _the minimum contiguous substring part of_ `s1`_, so that_ `s2` _is a subsequence of the part_.\n\nIf there is no such window in `s1` that covers all characters in `s2`, return the empty string `\" \"`. If there are multiple such minimum-length windows, return the one with the **left-most starting index**."
    },
    "leetcode-benchmark-78": {
        "id": "leetcode-benchmark-78",
        "title": "Count Different Palindromic Subsequences",
        "difficulty": "Hard",
        "content": {
            "problem": "Given a string s, return _the number of different non-empty palindromic subsequences in_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from the string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some `i` for which `ai != bi`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"bccb \"\n**Output:** 6\n**Explanation:** The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba \"\n**Output:** 104860361\n**Explanation:** There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s[i]` is either `'a'`, `'b'`, `'c'`, or `'d'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countPalindromicSubsequences(String S) {\n    int n = S.length();\n    int mod = 1000000007;\n    int[][] dp = new int[4][n + 1];\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = S.charAt(i) - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            if (dp[c][j] < 0) dp[c][j] += mod;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % mod;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nint countPalindromicSubsequences(string s) {\n    int n = s.length();\n    int MOD = 1000000007;\n    vector<vector<int>> dp(4, vector<int>(n + 1, 0));\n\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int c = s[i] - 'a';\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "python": "\n    ```python\ndef countPalindromicSubsequences(s: str) -> int:\n    n = len(s)\n    MOD = 1000000007\n    dp = [[0] * (n + 1) for _ in range(4)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            c = ord(s[i]) - ord('a')\n            dp[c][j] = sum(dp[k][j - 1] for k in range(4)) - dp[c][i] + 2\n            dp[c][j] = (dp[c][j] + MOD) % MOD\n\n    return sum(dp[c][n] for c in range(4)) % MOD\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "javascript": "\n    ```javascript\nfunction countPalindromicSubsequences(s) {\n    const n = s.length;\n    const MOD = 1000000007;\n    const dp = Array.from({ length: 4 }, () => Array(n + 1).fill(0));\n\n    for (let i = n - 1; i >= 0; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            const c = s.charCodeAt(i) - 97;\n            dp[c][j] = dp[0][j - 1] + dp[1][j - 1] + dp[2][j - 1] + dp[3][j - 1] - dp[c][i] + 2;\n            dp[c][j] = (dp[c][j] + MOD) % MOD;\n        }\n    }\n\n    return (dp[0][n] + dp[1][n] + dp[2][n] + dp[3][n]) % MOD;\n}\n```\n\n    \n    The algorithm uses dynamic programming. The state of `dp[i][j]` stores the number of different non-empty palindromic subsequences of `s` with characters from index `i` to `j - 1`, and only considering the character `s[i]`. Iterating over the string from the back, the algorithm checks the current character into its corresponding bucket, and updates the current bucket's values based on the previous state.\n\nThis algorithm has a time complexity of O(N^2), where N is the length of the string. The space complexity is O(N), as the algorithm only stores palindromic subsequences for each character from 'a' to 'd'.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"bccb \"",
                    "output": " 6",
                    "explanation": " The 6 different non-empty palindromic subsequences are 'b', 'c', 'bb', 'cc', 'bcb', 'bccb'.\nNote that 'bcb' is counted only once, even though it occurs twice."
                },
                {
                    "input": " s =  \"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba \"",
                    "output": " 104860361",
                    "explanation": " There are 3104860382 different non-empty palindromic subsequences, which is 104860361 modulo 109 + 7."
                }
            ],
            "function_input": [
                {
                    "input": "\"bccb\"",
                    "output": "6"
                },
                {
                    "input": "\"abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba\"",
                    "output": "104860361"
                }
            ]
        },
        "task_id": "leetcode-benchmark-78",
        "prompt": "Given a string s, return _the number of different non-empty palindromic subsequences in_ `s`. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nA subsequence of a string is obtained by deleting zero or more characters from the string.\n\nA sequence is palindromic if it is equal to the sequence reversed.\n\nTwo sequences `a1, a2, ...` and `b1, b2, ...` are different if there is some `i` for which `ai != bi`."
    },
    "leetcode-benchmark-79": {
        "id": "leetcode-benchmark-79",
        "title": "Parse Lisp Expression",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a string expression representing a Lisp-like expression to return the integer value of.\n\nThe syntax for these expressions is given as follows.\n\n*   An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.\n*   (An integer could be positive or negative.)\n*   A let expression takes the form `\"(let v1 e1 v2 e2 ... vn en expr) \"`, where let is always the string `\"let \"`, then there are one or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let expression is the value of the expression `expr`.\n*   An add expression takes the form `\"(add e1 e2) \"` where add is always the string `\"add \"`, there are always two expressions `e1`, `e2` and the result is the addition of the evaluation of `e1` and the evaluation of `e2`.\n*   A mult expression takes the form `\"(mult e1 e2) \"` where mult is always the string `\"mult \"`, there are always two expressions `e1`, `e2` and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\n*   For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names `\"add \"`, `\"let \"`, and `\"mult \"` are protected and will never be used as variable names.\n*   Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"(let x 2 (mult x (let x 3 y 4 (add x y)))) \"\n**Output:** 14\n**Explanation:** In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"(let x 3 x 2 x) \"\n**Output:** 2\n**Explanation:** Assignment in let statements is processed sequentially.\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"(let x 1 y 2 x (add x y) (add x y)) \"\n**Output:** 5\n**Explanation:** The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 2000`\n*   There are no leading or trailing spaces in `expression`.\n*   All tokens are separated by a single space in `expression`.\n*   The answer and all intermediate calculations of that answer are guaranteed to fit in a **32-bit** integer.\n*   The expression is guaranteed to be legal and evaluate to an integer.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic class Solution {\n    public int evaluate(String expression) {\n        return calculate(expression, 0, expression.length(), new HashMap<>());\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables) {\n        if (expression.charAt(start) == '(') {\n            if (expression.startsWith(\"add\", start + 1)) {\n                int first = start + 5;\n                int[] second = new int[]{first};\n                int value1 = calculate(expression, first, end, variables, second);\n                int value2 = calculate(expression, second[0] + 1, end, variables, null);\n                return value1 + value2;\n            } else if (expression.startsWith(\"mult\", start + 1)) {\n                int first = start + 6;\n                int[] second = new int[]{first};\n                int value1 = calculate(expression, first, end, variables, second);\n                int value2 = calculate(expression, second[0] + 1, end, variables, null);\n                return value1 * value2;\n            } else {\n                HashMap<String, Integer> inner = variables;\n                for (int idx = start + 5; idx < end - 1 && expression.charAt(idx) != '('; ) {\n                    int temp = idx;\n                    idx = expression.indexOf(' ', idx + 1);\n                    String var = expression.substring(temp, idx);\n                    temp = idx + 1;\n                    if (expression.charAt(temp) == '(') {\n                        idx++;\n                    } else {\n                        idx = expression.indexOf(' ', idx + 1);\n                    }\n                    int result = calculate(expression, temp, idx, variables, null);\n                    inner = new HashMap<>(variables);\n                    inner.put(var, result);\n                }\n                return calculate(expression, end - 1, end, inner, null);\n            }\n        } else {\n            if (Character.isDigit(expression.charAt(start)) || expression.charAt(start) == '-') {\n                end = expression.indexOf(' ', start);\n                if (end == -1) {\n                    end = expression.length();\n                }\n                return Integer.parseInt(expression.substring(start, end));\n            } else {\n                end = expression.indexOf(' ', start);\n                if (end == -1) {\n                    end = expression.length();\n                }\n                return variables.get(expression.substring(start, end));\n            }\n        }\n    }\n\n    private int calculate(String expression, int start, int end, HashMap<String, Integer> variables, int[] nextStart) {\n        int temp = end;\n        int result = calculate(expression, start, end, variables);\n        if (nextStart != null) {\n            nextStart[0] = temp;\n        }\n        return result;\n    }\n}\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\nusing namespace std;\n\nint calculate(string &expression, const int &start, int &end, unordered_map<string, int> &variables) {\n    if (expression[start] == '(') {\n        if (expression.substr(start + 1, 3) == \"add\") {\n            int first = start + 5;\n            int second = first;\n            calculate(expression, first, second, variables);\n            int value1 = variables[\" \"];\n            calculate(expression, second + 1, end, variables);\n            int value2 = variables[\" \"];\n            end++;\n            return value1 + value2;\n        } else if (expression.substr(start + 1, 4) == \"mult\") {\n            int first = start + 6;\n            int second = first;\n            calculate(expression, first, second, variables);\n            int value1 = variables[\" \"];\n            calculate(expression, second + 1, end, variables);\n            int value2 = variables[\" \"];\n            end++;\n            return value1 * value2;\n        } else {\n            unordered_map<string, int> inner = unordered_map<string, int>(variables);\n            int idx = start + 5;\n            while (idx < end - 1 && expression[idx] != '(') {\n                int temp = idx;\n                idx = expression.find(' ', idx + 1);\n                string var = expression.substr(temp, idx - temp);\n                temp = idx + 1;\n                if (expression[temp] == '(') {\n                    idx++;\n                } else {\n                    idx = expression.find(' ', idx + 1);\n                }\n                int result = calculate(expression, temp, idx, variables);\n                inner[var] = result;\n                variables = inner;\n            }\n            return calculate(expression, idx, end, variables);\n        }\n    } else {\n        if (isdigit(expression[start]) || expression[start] == '-') {\n            end = expression.find(' ', start);\n            return stoi(expression.substr(start, end - start));\n        } else {\n            int idx = expression.find(' ', start);\n            end = (idx == -1) ? end : idx;\n            return variables[expression.substr(start, end - start)];\n        }\n    }\n}\n\nint evaluate(string expression) {\n    int end = expression.size();\n    unordered_map<string, int> variables;\n    int result = calculate(expression, 0, end, variables);\n    return result;\n}\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "python": "\n    ```python\ndef evaluate(expression: str) -> int:\n    def calculate(s, start, end, variables):\n        if s[start] == '(':\n            if s[start + 1:start + 4] == \"add\":\n                first = start + 5\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 + value2\n            elif s[start + 1:start + 5] == \"mult\":\n                first = start + 6\n                second = first\n                value1 = calculate(s, first, end, variables)\n                second = s.index(' ', second) + 1\n                value2 = calculate(s, second, end, variables)\n                return value1 * value2\n            else:\n                inner = variables.copy()\n                idx = start + 5\n                while idx < end - 1 and s[idx] != '(':\n                    temp = idx\n                    idx = s.index(' ', idx + 1)\n                    var = s[temp:idx]\n                    temp = idx + 1\n                    if s[temp] == '(':\n                        idx += 1\n                    else:\n                        idx = s.index(' ', idx + 1)\n                    result = calculate(s, temp, idx, variables)\n                    inner[var] = result\n                    variables = inner\n                return calculate(s, end - 1, end, variables)\n        else:\n            if s[start].isdigit() or s[start] == '-':\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return int(s[start:end])\n            else:\n                end = s.find(' ', start) if ' ' in s[start:end] else end\n                return variables[s[start:end]]\n\n    return calculate(expression, 0, len(expression), {})\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "javascript": "\n    ```javascript\nfunction evaluate(expression) {\n    function calculate(s, start, end, variables) {\n        if (s[start] === '(') {\n            if (s.substr(start + 1, 3) === \"add\") {\n                let first = start + 5;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 + value2;\n            } else if (s.substr(start + 1, 4) === \"mult\") {\n                let first = start + 6;\n                let second = first;\n                let value1 = calculate(s, first, end, variables);\n                second = s.indexOf(' ', second) + 1;\n                let value2 = calculate(s, second, end, variables);\n                return value1 * value2;\n            } else {\n                let inner = new Map(variables);\n                let idx = start + 5;\n                while (idx < end - 1 && s[idx] !== '(') {\n                    let temp = idx;\n                    idx = s.indexOf(' ', idx + 1);\n                    let varName = s.substring(temp, idx);\n                    temp = idx + 1;\n                    if (s[temp] === '(') {\n                        idx++;\n                    } else {\n                        idx = s.indexOf(' ', idx + 1);\n                    }\n                    let result = calculate(s, temp, idx, variables);\n                    inner.set(varName, result);\n                    variables = inner;\n                }\n                return calculate(s, end - 1, end, variables);\n            }\n        } else {\n            if (s[start] === '-' || !isNaN(s[start])) {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return parseInt(s.substring(start, end));\n            } else {\n                let idx = s.indexOf(' ', start);\n                end = idx === -1 ? end : idx;\n                return variables.get(s.substring(start, end));\n            }\n        }\n    }\n\n    return calculate(expression, 0, expression.length, new Map());\n}\n```\n    \n    First, we have the helper function `calculate`. It starts by checking if the expression starts with an opening parenthesis `(`. If so, it checks if it is an \"add\" or \"mult\" expression. If it's an \"add\" expression, it calculates the values of the two expressions inside it and returns their sum. If it's a \"mult\" expression, it calculates the values of the two expressions inside it and returns their multiplication.\n\nIf the expression starts with a \"let\" command, it creates a new `variables` Map (or dict/hashmap depending on the language) for the inner scope, which is a copy of the outer scope. It iterates through the string processing variable assignments sequentially, adding the variable and its value to the inner scope's `variables` Map. Once it reaches the final expression, it calls the `calculate` function again with this expression.\n\nIf the expression doesn't start with a parenthesis, it checks if it is a number or a variable. If it's a number, it returns the number parsed as an integer. If it's a variable, it returns the value of the variable from the `variables` Map.\n\nThe `evaluate` function is the entry point, which calls the `calculate` function with the entire expression string and an empty `variables` Map initially.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " expression =  \"(let x 2 (mult x (let x 3 y 4 (add x y)))) \"",
                    "output": " 14",
                    "explanation": " In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3."
                },
                {
                    "input": " expression =  \"(let x 3 x 2 x) \"",
                    "output": " 2",
                    "explanation": " Assignment in let statements is processed sequentially."
                },
                {
                    "input": " expression =  \"(let x 1 y 2 x (add x y) (add x y)) \"",
                    "output": " 5",
                    "explanation": " The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5."
                }
            ],
            "function_input": [
                {
                    "input": "\"(letx2(multx(letx3y4(addxy))))\"",
                    "output": "14"
                },
                {
                    "input": "\"(letx3x2x)\"",
                    "output": "2"
                },
                {
                    "input": "\"(letx1y2x(addxy)(addxy))\"",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-79",
        "prompt": "You are given a string expression representing a Lisp-like expression to return the integer value of.\n\nThe syntax for these expressions is given as follows.\n\n*   An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.\n*   (An integer could be positive or negative.)\n*   A let expression takes the form `\"(let v1 e1 v2 e2 ... vn en expr) \"`, where let is always the string `\"let \"`, then there are one or more pairs of alternating variables and expressions, meaning that the first variable `v1` is assigned the value of the expression `e1`, the second variable `v2` is assigned the value of the expression `e2`, and so on sequentially; and then the value of this let expression is the value of the expression `expr`.\n*   An add expression takes the form `\"(add e1 e2) \"` where add is always the string `\"add \"`, there are always two expressions `e1`, `e2` and the result is the addition of the evaluation of `e1` and the evaluation of `e2`.\n*   A mult expression takes the form `\"(mult e1 e2) \"` where mult is always the string `\"mult \"`, there are always two expressions `e1`, `e2` and the result is the multiplication of the evaluation of e1 and the evaluation of e2.\n*   For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names `\"add \"`, `\"let \"`, and `\"mult \"` are protected and will never be used as variable names.\n*   Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope."
    },
    "leetcode-benchmark-80": {
        "id": "leetcode-benchmark-80",
        "title": "Cherry Pickup",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[0,1,-1\\],\\[1,0,-1\\],\\[1,1,1\\]\\]\n**Output:** 5\n**Explanation:** The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1,-1\\],\\[1,-1,1\\],\\[-1,1,1\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `grid[i][j]` is `-1`, `0`, or `1`.\n*   `grid[0][0] != -1`\n*   `grid[n - 1][n - 1] != -1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int cherryPickup(int[][] grid) {\n    int N = grid.length;\n    int[][][] dp = new int[N][N][N];\n    for (int[][] layer: dp)\n        for (int[] row: layer)\n            Arrays.fill(row, Integer.MIN_VALUE);\n\n    return Math.max(0, dp(0, 0, 0, grid, dp));\n}\n\npublic int dp(int r1, int c1, int c2, int[][] grid, int[][][] memo) {\n    int r2 = r1 + c1 - c2;\n    if (r1 == grid.length || r2 == grid.length || c1 == grid.length || c2 == grid.length ||\n            grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n        return Integer.MIN_VALUE;\n    } else if (r1 == grid.length - 1 && c1 == grid.length - 1) {\n        return grid[r1][c1];\n    } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {\n        return memo[r1][c1][c2];\n    } else {\n        memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);\n        int tempMax = Math.max(Math.max(dp(r1+1, c1, c2+1, grid, memo), dp(r1, c1+1, c2+1, grid, memo)),\n                        Math.max(dp(r1+1, c1, c2, grid, memo), dp(r1, c1+1, c2, grid, memo)));\n        memo[r1][c1][c2] += tempMax;\n    }\n    return memo[r1][c1][c2];\n}\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "c++": "\n    ```cpp\nint helper(vector<vector<int>>& grid, vector<vector<vector<int>>>& memo, int r1, int c1, int r2) {\n    int c2 = r1 + c1 - r2;\n    if (r1 == grid.size() || r2 == grid.size() || c1 == grid.size() || c2 == grid.size() ||\n        grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n        return INT_MIN;\n    } else if (r1 == grid.size() - 1 && c1 == grid.size() - 1) {\n        return grid[r1][c1];\n    } else if (memo[r1][c1][r2] != INT_MIN) {\n        return memo[r1][c1][r2];\n    } else {\n        memo[r1][c1][r2] = grid[r1][c1] + (r1 != r2 ? grid[r2][c2] : 0);\n        int max_cherries = max(max(helper(grid, memo, r1 + 1, c1, r2 + 1), helper(grid, memo, r1, c1 + 1, r2 + 1)),\n                               max(helper(grid, memo, r1 + 1, c1, r2), helper(grid, memo, r1, c1 + 1, r2)));\n        memo[r1][c1][r2] += max_cherries;\n    }\n    return memo[r1][c1][r2];\n}\n\nint cherryPickup(vector<vector<int>>& grid) {\n    int n = grid.size();\n    vector<vector<vector<int>>> memo(n, vector<vector<int>>(n, vector<int>(n, INT_MIN)));\n    return max(0, helper(grid, memo, 0, 0, 0));\n}\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "python": "\n    ```python\ndef cherryPickup(self, grid: List[List[int]]) -> int:\n    def dp(r1, c1, c2):\n        r2 = r1 + c1 - c2\n        if (r1 == len(grid) or r2 == len(grid) or c1 == len(grid) or c2 == len(grid) or\n            grid[r1][c1] == -1 or grid[r2][c2] == -1):\n            return float('-inf')\n        elif r1 == len(grid) - 1 and c1 == len(grid) - 1:\n            return grid[r1][c1]\n        elif memo[r1][c1][c2] != float('-inf'):\n            return memo[r1][c1][c2]\n        else:\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 != r2) * grid[r2][c2]\n            max_cherries = max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1),\n                               dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2))\n            memo[r1][c1][c2] += max_cherries\n        \n        return memo[r1][c1][c2]\n    \n    N = len(grid)\n    memo = [[[float('-inf')] * N for _1 in range(N)] for _2 in range(N)]\n    return max(0, dp(0, 0, 0))\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "javascript": "\n    ```javascript\nvar cherryPickup = function(grid) {\n    const N = grid.length;\n    const memo = new Array(N).fill(0).map(() => new Array(N).fill(0).map(() => new Array(N).fill(Number.MIN_SAFE_INTEGER)));\n\n    function dp(r1, c1, c2) {\n        const r2 = r1 + c1 - c2;\n        if (r1 === N || r2 === N || c1 === N || c2 === N || grid[r1][c1] === -1 || grid[r2][c2] === -1) {\n            return Number.MIN_SAFE_INTEGER;\n        } else if (r1 === N - 1 && c1 === N - 1) {\n            return grid[r1][c1];\n        } else if (memo[r1][c1][c2] !== Number.MIN_SAFE_INTEGER) {\n            return memo[r1][c1][c2];\n        } else {\n            memo[r1][c1][c2] = grid[r1][c1] + (r1 !== r2 ? grid[r2][c2] : 0);\n            const tempMax = Math.max(Math.max(dp(r1 + 1, c1, c2 + 1), dp(r1, c1 + 1, c2 + 1)),\n                            Math.max(dp(r1 + 1, c1, c2), dp(r1, c1 + 1, c2)));\n            memo[r1][c1][c2] += tempMax;\n        }\n        return memo[r1][c1][c2];\n    }\n\n    return Math.max(0, dp(0, 0, 0));\n};\n```\n\n    \n    The algorithm is based on Dynamic Programming. The main idea is to traverse the grid twice - first from (0, 0) to (n-1, n-1) and then back to (0, 0) - using two different paths.\n\nWe use memoization to store values of the cherries collected at each step to avoid recomputations. The dp function takes three variables (r1, c1, and c2) as inputs, where r1 and c1 represent the row and column of the first path, and c2 represents the column of the second path. We then calculate the row of the second path (r2) using the formula r2 = r1 + c1 - c2.\n\nThe function checks the base cases for invalid inputs or if cherries collected are already calculated (memoized), then it returns the memoized value.\n\nThe main algorithm calculates the cherries for the current step by adding the cherries in the current cell r1 and c1, and if the paths are different, it adds cherries of r2 and c2 too. After that, it computes the maximum cherries from four possible ways to move (right, down) for both paths and adds it to the memoized table.\n\nFinally, the algorithm returns memo[r1][c1][c2] as the maximum cherries collected.\n\nAt the end, the function returns the maximum cherries collected between (0, 0) and (n-1, n-1) using two different paths, making sure it's not negative.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[0,1,-1],[1,0,-1],[1,1,1]]",
                    "output": " 5",
                    "explanation": " The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes \\[\\[0,1,-1\\],\\[0,0,-1\\],\\[0,0,0\\]\\].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible."
                },
                {
                    "input": " grid = [[1,1,-1],[1,-1,1],[-1,1,1]]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,1,-1],[1,0,-1],[1,1,1]]",
                    "output": "5"
                },
                {
                    "input": "[[1,1,-1],[1,-1,1],[-1,1,1]]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-80",
        "prompt": "You are given an `n x n` `grid` representing a field of cherries, each cell is one of three possible integers.\n\n*   `0` means the cell is empty, so you can pass through,\n*   `1` means the cell contains a cherry that you can pick up and pass through, or\n*   `-1` means the cell contains a thorn that blocks your way.\n\nReturn _the maximum number of cherries you can collect by following the rules below_:\n\n*   Starting at the position `(0, 0)` and reaching `(n - 1, n - 1)` by moving right or down through valid path cells (cells with value `0` or `1`).\n*   After reaching `(n - 1, n - 1)`, returning to `(0, 0)` by moving left or up through valid path cells.\n*   When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell `0`.\n*   If there is no valid path between `(0, 0)` and `(n - 1, n - 1)`, then no cherries can be collected."
    },
    "leetcode-benchmark-81": {
        "id": "leetcode-benchmark-81",
        "title": "Prefix and Suffix Search",
        "difficulty": "Hard",
        "content": {
            "problem": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the `WordFilter` class:\n\n*   `WordFilter(string[] words)` Initializes the object with the `words` in the dictionary.\n*   `f(string pref, string suff)` Returns _the index of the word in the dictionary,_ which has the prefix `pref` and the suffix `suff`. If there is more than one valid index, return **the largest** of them. If there is no such word in the dictionary, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input**\n\\[ \"WordFilter \",  \"f \"\\]\n\\[\\[\\[ \"apple \"\\]\\], \\[ \"a \",  \"e \"\\]\\]\n**Output**\n\\[null, 0\\]\n**Explanation**\nWordFilter wordFilter = new WordFilter(\\[ \"apple \"\\]);\nwordFilter.f( \"a \",  \"e \"); // return 0, because the word at index 0 has prefix =  \"a \" and suffix =  \"e \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 104`\n*   `1 <= words[i].length <= 7`\n*   `1 <= pref.length, suff.length <= 7`\n*   `words[i]`, `pref` and `suff` consist of lowercase English letters only.\n*   At most `104` calls will be made to the function `f`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic char nextGreatestLetter(char[] letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "c++": "\n    ```cpp\nchar nextGreatestLetter(vector<char>& letters, char target) {\n    for (char letter : letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "python": "\n    ```python\ndef next_greatest_letter(letters, target):\n    for letter in letters:\n        if letter > target:\n            return letter\n    return letters[0]\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "javascript": "\n    ```javascript\nfunction nextGreatestLetter(letters, target) {\n    for (let letter of letters) {\n        if (letter > target) {\n            return letter;\n        }\n    }\n    return letters[0];\n}\n```\n    \n    The algorithm simply iterates through the `letters` array, which is already sorted in non-decreasing order. For each letter in the array, it checks if the letter is larger than the target. If it is, then it returns that letter as the smallest letter larger than the target. If the loop completes without finding a letter larger than the target, the array wraps around, and the first element of the array is returned as the smallest letter larger than the target.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": "\n[ \"WordFilter \",  \"f \"]\n[[[ \"apple \"]], [ \"a \",  \"e \"]]",
                    "output": "\n[null, 0]",
                    "explanation": "\nWordFilter wordFilter = new WordFilter(\\[ \"apple \"\\]);\nwordFilter.f( \"a \",  \"e \"); // return 0, because the word at index 0 has prefix =  \"a \" and suffix =  \"e \"."
                }
            ],
            "function_input": [
                {
                    "input": "]\n]],[\"a\",\"e\"]]",
                    "output": "**Output**\n[null,0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-81",
        "prompt": "Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the `WordFilter` class:\n\n*   `WordFilter(string[] words)` Initializes the object with the `words` in the dictionary.\n*   `f(string pref, string suff)` Returns _the index of the word in the dictionary,_ which has the prefix `pref` and the suffix `suff`. If there is more than one valid index, return **the largest** of them. If there is no such word in the dictionary, return `-1`."
    },
    "leetcode-benchmark-82": {
        "id": "leetcode-benchmark-82",
        "title": "Contain Virus",
        "difficulty": "Hard",
        "content": {
            "problem": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used.",
            "examples": [
                "**Example 1:**\n\n**Input:** isInfected = \\[\\[0,1,0,0,0,0,0,1\\],\\[0,1,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,1\\],\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 10\n**Explanation:** There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n \n\n",
                "**Example 2:**\n\n**Input:** isInfected = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** 4\n**Explanation:** Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n",
                "**Example 3:**\n\n**Input:** isInfected = \\[\\[1,1,1,0,0,0,0,0,0\\],\\[1,0,1,0,1,1,1,1,1\\],\\[1,1,1,0,0,0,0,0,0\\]\\]\n**Output:** 13\n**Explanation:** The region on the left only builds two new walls."
            ],
            "constraints": "**Constraints:**\n\n*   `m == isInfected.length`\n*   `n == isInfected[i].length`\n*   `1 <= m, n <= 50`\n*   `isInfected[i][j]` is either `0` or `1`.\n*   There is always a contiguous viral region throughout the described process that will **infect strictly more uncontaminated squares** in the next round.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String shortestCompletingWord(String licensePlate, String[] words) {\n    HashMap<Character, Integer> target = new HashMap<>();\n    for (char c : licensePlate.toCharArray()) {\n        if (Character.isLetter(c)) {\n            char lower_c = Character.toLowerCase(c);\n            target.put(lower_c, target.getOrDefault(lower_c, 0) + 1);\n        }\n    }\n\n    String result = null;\n    for (String word : words) {\n        HashMap<Character, Integer> current = new HashMap<>();\n        for (char c : word.toCharArray())\n            if (Character.isLetter(c)) {\n                char lower_c = Character.toLowerCase(c);\n                current.put(lower_c, current.getOrDefault(lower_c, 0) + 1);\n            }\n\n        boolean valid = true;\n        for (char c : target.keySet()) {\n            if (current.getOrDefault(c, 0) < target.get(c)) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid && (result == null || word.length() < result.length())) result = word;\n    }\n\n    return result;\n}\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n\nstd::string shortestCompletingWord(std::string licensePlate, std::vector<std::string> words) {\n    std::vector<int> target(26, 0);\n    for (char c : licensePlate)\n        if (isalpha(c)) target[tolower(c) - 'a']++;\n\n    std::string result;\n    for (const std::string& word : words) {\n        std::vector<int> current(26, 0);\n        for (char c : word)\n            if (isalpha(c)) current[tolower(c) - 'a']++;\n\n        if (std::equal(target.begin(), target.end(), current.begin(), [](int a, int b){ return a <= b; }))\n            if (result.empty() || word.size() < result.size()) result = word;\n    }\n\n    return result;\n}\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "python": "\n    ```python\ndef shortest_completing_word(license_plate, words):\n    target = [0] * 26\n    for c in license_plate:\n        if c.isalpha():\n            target[ord(c.lower()) - ord('a')] += 1\n\n    result = \"\"\n    for word in words:\n        current = [0] * 26\n        for c in word:\n            if c.isalpha():\n                current[ord(c.lower()) - ord('a')] += 1\n\n        if all(a <= b for a, b in zip(target, current)) and (not result or len(word) < len(result)):\n            result = word\n\n    return result\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "javascript": "\n    ```javascript\nfunction shortestCompletingWord(licensePlate, words) {\n    let target = Array(26).fill(0);\n    for (let c of licensePlate)\n        if (c.toLowerCase() != c.toUpperCase()) target[c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    let result = \"\";\n    for (let word of words) {\n        let current = Array(26).fill(0);\n        for (let c of word)\n            if (c.toLowerCase() != c.toUpperCase()) current[c.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n        if (target.every((a, i) => a <= current[i]) && (result === \"\" || word.length < result.length)) result = word;\n    }\n\n    return result;\n}\n```\n    \n    1. We create an array `target` of length 26, representing the count of each letter in `licensePlate` (ignoring case, spaces, and numbers).\n2. Then, for each `word` in `words`, we create a new array `current`, representing the count of each letter in `word` (ignoring case).\n3. We check if every count in `target` is less than or equal to the corresponding count in `current`.\n4. If it is true, and the `result` is empty or the `word` has shorter length than the current result, we update `result` with the current `word`.\n5. We continue this process for all given `words`.\n6. Finally, we return the `result` which is the shortest completing word.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]",
                    "output": " 10",
                    "explanation": " There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n \nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained."
                },
                {
                    "input": " isInfected = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": " 4",
                    "explanation": " Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells."
                },
                {
                    "input": " isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]",
                    "output": " 13",
                    "explanation": " The region on the left only builds two new walls."
                }
            ],
            "function_input": [
                {
                    "input": "[[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]",
                    "output": "10"
                },
                {
                    "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "4"
                },
                {
                    "input": "[[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]",
                    "output": "13"
                }
            ]
        },
        "task_id": "leetcode-benchmark-82",
        "prompt": "A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an `m x n` binary grid `isInfected`, where `isInfected[i][j] == 0` represents uninfected cells, and `isInfected[i][j] == 1` represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two **4-directionally** adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There **will never be a tie**.\n\nReturn _the number of walls used to quarantine all the infected regions_. If the world will become fully infected, return the number of walls used."
    },
    "leetcode-benchmark-83": {
        "id": "leetcode-benchmark-83",
        "title": "Employee Free Time",
        "difficulty": "Hard",
        "content": {
            "problem": "We are given a list `schedule` of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing **common, positive-length free time** for _all_ employees, also in sorted order.\n\n(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined). Also, we wouldn't include intervals like \\[5, 5\\] in our answer, as they have zero length.",
            "examples": [
                "**Example 1:**\n\n**Input:** schedule = \\[\\[\\[1,2\\],\\[5,6\\]\\],\\[\\[1,3\\]\\],\\[\\[4,10\\]\\]\\]\n**Output:** \\[\\[3,4\\]\\]\n**Explanation:** There are a total of three employees, and all common\nfree time intervals would be \\[-inf, 1\\], \\[3, 4\\], \\[10, inf\\].\nWe discard any intervals that contain inf as they aren't finite.\n\n",
                "**Example 2:**\n\n**Input:** schedule = \\[\\[\\[1,3\\],\\[6,7\\]\\],\\[\\[2,4\\]\\],\\[\\[2,5\\],\\[9,12\\]\\]\\]\n**Output:** \\[\\[5,6\\],\\[7,9\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= schedule.length , schedule[i].length <= 50`\n*   `0 <= schedule[i].start < schedule[i].end <= 10^8`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic int minSetSize(int[][] intervals) {\n    Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n    int n = intervals.length;\n    int end = intervals[0][1];\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint minSetSize(std::vector<std::pair<int, int>> intervals) {\n    std::sort(intervals.begin(), intervals.end());\n    int n = intervals.size();\n    int end = intervals[0].second;\n    int count = 1;\n\n    for (int i = 1; i < n; i++) {\n        if (end < intervals[i].first) {\n            end = intervals[i].second;\n            count++;\n        } else {\n            end = std::min(end, intervals[i].second);\n        }\n    }\n    return count * 2;\n}\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "python": "\n    ```python\ndef min_set_size(intervals):\n    intervals.sort()\n    n = len(intervals)\n    end = intervals[0][1]\n    count = 1\n\n    for i in range(1, n):\n        if end < intervals[i][0]:\n            end = intervals[i][1]\n            count += 1\n        else:\n            end = min(end, intervals[i][1])\n    return count * 2\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "javascript": "\n    ```javascript\nfunction minSetSize(intervals) {\n    intervals.sort((a, b) => a[0] - b[0]);\n    const n = intervals.length;\n    let end = intervals[0][1];\n    let count = 1;\n\n    for (let i = 1; i < n; i++) {\n        if (end < intervals[i][0]) {\n            end = intervals[i][1];\n            count++;\n        } else {\n            end = Math.min(end, intervals[i][1]);\n        }\n    }\n    return count * 2;\n}\n```\n    \n    1. Sort the intervals by their starting point.\n2. Initialize `end` to the end of the first interval and set `count` to 1.\n3. Loop through the intervals from the second interval onwards.\n   - If the current `end` is less than the starting point of the current interval, set `end` to the end of the current interval and increment `count`.\n   - Otherwise, set `end` to the minimum of the current `end` and the end of the current interval.\n4. Return `count * 2` to ensure that the intersection of S with A has a size of at least two.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " schedule = [[[1,2],[5,6]],[[1,3]],[[4,10]]]",
                    "output": " [[3,4]]",
                    "explanation": " There are a total of three employees, and all common\nfree time intervals would be \\[-inf, 1\\], \\[3, 4\\], \\[10, inf\\].\nWe discard any intervals that contain inf as they aren't finite."
                },
                {
                    "input": " schedule = [[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]",
                    "output": " [[5,6],[7,9]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[[1,2],[5,6]],[[1,3]],[[4,10]]]",
                    "output": "[[3,4]]"
                },
                {
                    "input": "[[[1,3],[6,7]],[[2,4]],[[2,5],[9,12]]]",
                    "output": "[[5,6],[7,9]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-83",
        "prompt": "We are given a list `schedule` of employees, which represents the working time for each employee.\n\nEach employee has a list of non-overlapping `Intervals`, and these intervals are in sorted order.\n\nReturn the list of finite intervals representing **common, positive-length free time** for _all_ employees, also in sorted order.\n\n(Even though we are representing `Intervals` in the form `[x, y]`, the objects inside are `Intervals`, not lists or arrays. For example, `schedule[0][0].start = 1`, `schedule[0][0].end = 2`, and `schedule[0][0][0]` is not defined). Also, we wouldn't include intervals like \\[5, 5\\] in our answer, as they have zero length."
    },
    "leetcode-benchmark-84": {
        "id": "leetcode-benchmark-84",
        "title": "Special Binary String",
        "difficulty": "Hard",
        "content": {
            "problem": "**Special binary strings** are binary strings with the following two properties:\n\n*   The number of `0`'s is equal to the number of `1`'s.\n*   Every prefix of the binary string has at least as many `1`'s as `0`'s.\n\nYou are given a **special binary** string `s`.\n\nA move consists of choosing two consecutive, non-empty, special substrings of `s`, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\n\nReturn _the lexicographically largest resulting string possible after applying the mentioned operations on the string_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"11011000 \"\n**Output:**  \"11100100 \"\n**Explanation:** The strings  \"10 \" \\[occuring at s\\[1\\]\\] and  \"1100 \" \\[at s\\[3\\]\\] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"10 \"\n**Output:**  \"10 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 50`\n*   `s[i]` is either `'0'` or `'1'`.\n*   `s` is a special binary string.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String makeLargestSpecial(String s) {\n    int count = 0;\n    int i = 0;\n    List<String> subs = new ArrayList<>();\n\n    for (int j = 0; j < s.length(); j++) {\n        if (s.charAt(j) == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.add(\"1\" + makeLargestSpecial(s.substring(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    Collections.sort(subs, Collections.reverseOrder());\n    StringBuilder res = new StringBuilder();\n    for (String sub : subs) {\n        res.append(sub);\n    }\n    return res.toString();\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string makeLargestSpecial(std::string s) {\n    int count = 0, i = 0;\n    std::vector<std::string> subs;\n\n    for (int j = 0; j < s.size(); j++) {\n        if (s[j] == '1') count++;\n        else count--;\n\n        if (count == 0) {\n            subs.push_back('1' + makeLargestSpecial(s.substr(i+1, j-i-1)) + '0');\n            i = j + 1;\n        }\n    }\n\n    std::sort(subs.rbegin(), subs.rend());\n    std::string res;\n    for (const auto& sub : subs) {\n        res += sub;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "python": "\n    ```python\ndef makeLargestSpecial(s: str) -> str:\n    count, i = 0, 0\n    subs = []\n\n    for j in range(len(s)):\n        if s[j] == '1':\n            count += 1\n        else:\n            count -= 1\n\n        if count == 0:\n            subs.append(\"1\" + makeLargestSpecial(s[i+1:j]) + \"0\")\n            i = j + 1\n\n    subs.sort(reverse=True)\n    return \"\".join(subs)\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "javascript": "\n    ```javascript\nfunction makeLargestSpecial(s) {\n    let count = 0, i = 0;\n    let subs = [];\n\n    for (let j = 0; j < s.length; j++) {\n        if (s[j] === '1') count++;\n        else count--;\n\n        if (count === 0) {\n            subs.push(\"1\" + makeLargestSpecial(s.slice(i+1, j)) + \"0\");\n            i = j + 1;\n        }\n    }\n\n    subs.sort((a, b) => b.localeCompare(a));\n    return subs.join('');\n}\n```\n\n    \n    The algorithm starts by initializing some variables. `count` tracks the balance of 1's and 0's in the special binary string, and `i` tracks the starting index for extracting subproblems.\n\nIterating through the input string `s`, the algorithm updates `count`, incrementing it if the current character is '1' and decrementing if it's '0'. Whenever `count` becomes zero, it means that the current substring from index `i + 1` to index `j` is a valid special binary string. We proceed with the following steps:\n\n1. Extract the substring from index `i + 1` to index `j`.\n2. Recursively apply the function `makeLargestSpecial()` on the extracted substring.\n3. Concatenate the string \"1\" before and the string \"0\" after the result and add the resulting string into a list of substrings called `subs`.\n4. Update the `i` variable to the next index after `j`.\n\nAfter processing the entire input string in this way, we have several special binary substrings in `subs`. We sort the substrings in decreasing (non-ascending) order and concatenate them together to form the largest lexicographically possible string as the final result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"11011000 \"",
                    "output": "  \"11100100 \"",
                    "explanation": " The strings  \"10 \" \\[occuring at s\\[1\\]\\] and  \"1100 \" \\[at s\\[3\\]\\] are swapped.\nThis is the lexicographically largest string possible after some number of swaps."
                },
                {
                    "input": " s =  \"10 \"",
                    "output": "  \"10 \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"11011000\"",
                    "output": "\"11100100\""
                },
                {
                    "input": "\"10\"",
                    "output": "\"10\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-84",
        "prompt": "**Special binary strings** are binary strings with the following two properties:\n\n*   The number of `0`'s is equal to the number of `1`'s.\n*   Every prefix of the binary string has at least as many `1`'s as `0`'s.\n\nYou are given a **special binary** string `s`.\n\nA move consists of choosing two consecutive, non-empty, special substrings of `s`, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\n\nReturn _the lexicographically largest resulting string possible after applying the mentioned operations on the string_."
    },
    "leetcode-benchmark-85": {
        "id": "leetcode-benchmark-85",
        "title": "Couples Holding Hands",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.",
            "examples": [
                "**Example 1:**\n\n**Input:** row = \\[0,2,1,3\\]\n**Output:** 1\n**Explanation:** We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person.\n\n",
                "**Example 2:**\n\n**Input:** row = \\[3,2,0,1\\]\n**Output:** 0\n**Explanation:** All couples are already seated side by side."
            ],
            "constraints": "**Constraints:**\n\n*   `2n == row.length`\n*   `2 <= n <= 30`\n*   `n` is even.\n*   `0 <= row[i] < 2n`\n*   All the elements of `row` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minSwapsCouples(int[] row) {\n    int n = row.length;\n    int[] position = new int[n];\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            int temp = row[position[partner]];\n            row[position[partner]] = row[i + 1];\n            row[i + 1] = temp;\n            \n            temp = position[row[i + 1]];\n            position[row[i + 1]] = position[partner];\n            position[partner] = temp;\n            \n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "c++": "\n    ```cpp\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size();\n    vector<int> position(n);\n    for (int i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    int swaps = 0;\n    for (int i = 0; i < n; i += 2) {\n        int partner = row[i] % 2 == 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != partner) {\n            swap(row[position[partner]], row[i + 1]);\n            swap(position[row[i + 1]], position[partner]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "python": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row)\n    position = [0] * n\n    for i in range(n):\n        position[row[i]] = i\n\n    swaps = 0\n    for i in range(0, n, 2):\n        partner = row[i] + 1 if row[i] % 2 == 0 else row[i] - 1\n        if row[i + 1] != partner:\n            row[position[partner]], row[i + 1] = row[i + 1], row[position[partner]]\n            position[row[i + 1]], position[partner] = position[partner], position[row[i + 1]]\n            swaps += 1\n    return swaps\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "javascript": "\n    ```javascript\nfunction minSwapsCouples(row) {\n    const n = row.length;\n    const position = new Array(n);\n    for (let i = 0; i < n; ++i)\n        position[row[i]] = i;\n\n    let swaps = 0;\n    for (let i = 0; i < n; i += 2) {\n        const partner = row[i] % 2 === 0 ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== partner) {\n            [row[position[partner]], row[i + 1]] = [row[i + 1], row[position[partner]]];\n            [position[row[i + 1]], position[partner]] = [position[partner], position[row[i + 1]]];\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n\n    \n    The algorithm works by iterating through the array `row` in increments of 2, representing the couple's seats side by side. During the iteration, it checks if the couple's partner is sitting next to the current person, based on the fact that the partner would have an ID that is either one more or one less than the current person's ID.\n\nIf the partner is not sitting in the expected position, it then swaps the person sitting next to the current person with the partner. The positions of the people in the array are stored in a separate `position` array. The swap is done both in the `row` and `position` arrays, and the swap count is incremented.\n\nAfter the entire iteration, the swap count represents the minimum number of swaps needed to arrange the couples side by side.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " row = [0,2,1,3]",
                    "output": " 1",
                    "explanation": " We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person."
                },
                {
                    "input": " row = [3,2,0,1]",
                    "output": " 0",
                    "explanation": " All couples are already seated side by side."
                }
            ],
            "function_input": [
                {
                    "input": "[0,2,1,3]",
                    "output": "1"
                },
                {
                    "input": "[3,2,0,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-85",
        "prompt": "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats."
    },
    "leetcode-benchmark-86": {
        "id": "leetcode-benchmark-86",
        "title": "Max Chunks To Make Sorted II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an integer array `arr`.\n\nWe split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_.",
            "examples": [
                "**Example 1:**\n\n**Input:** arr = \\[5,4,3,2,1\\]\n**Output:** 1\n**Explanation:**\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into \\[5, 4\\], \\[3, 2, 1\\] will result in \\[4, 5, 1, 2, 3\\], which isn't sorted.\n\n",
                "**Example 2:**\n\n**Input:** arr = \\[2,1,3,4,4\\]\n**Output:** 4\n**Explanation:**\nWe can split into two chunks, such as \\[2, 1\\], \\[3, 4, 4\\].\nHowever, splitting into \\[2, 1\\], \\[3\\], \\[4\\], \\[4\\] is the highest number of chunks possible."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= arr.length <= 2000`\n*   `0 <= arr[i] <= 108`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> partitionLabels(String s) {\n    HashMap<Character, Integer> lastPos = new HashMap<>();\n    for (int i = 0; i < s.length(); i++) {\n        lastPos.put(s.charAt(i), i);\n    }\n\n    List<Integer> partitions = new ArrayList<>();\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        end = Math.max(end, lastPos.get(s.charAt(i)));\n        if (i == end) {\n            partitions.add(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nstd::vector<int> partitionLabels(const std::string& s) {\n    std::unordered_map<char, int> lastPos;\n    for (int i = 0; i < s.size(); i++) {\n        lastPos[s[i]] = i;\n    }\n\n    std::vector<int> partitions;\n    int start = 0, end = 0;\n    for (int i = 0; i < s.size(); i++) {\n        end = std::max(end, lastPos[s[i]]);\n        if (i == end) {\n            partitions.push_back(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "python": "\n    ```python\ndef partition_labels(s: str) -> list[int]:\n    last_pos = {}\n    for i, c in enumerate(s):\n        last_pos[c] = i\n\n    partitions = []\n    start, end = 0, 0\n    for i, c in enumerate(s):\n        end = max(end, last_pos[c])\n        if i == end:\n            partitions.append(end - start + 1)\n            start = i + 1\n    return partitions\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "javascript": "\n    ```javascript\nfunction partitionLabels(s) {\n    const lastPos = {};\n    for (let i = 0; i < s.length; i++) {\n        lastPos[s[i]] = i;\n    }\n\n    const partitions = [];\n    let start = 0, end = 0;\n    for (let i = 0; i < s.length; i++) {\n        end = Math.max(end, lastPos[s[i]]);\n        if (i === end) {\n            partitions.push(end - start + 1);\n            start = i + 1;\n        }\n    }\n    return partitions;\n}\n```\n\n    \n    1. Create a dictionary `lastPos` to store the last position for each character in the string.\n2. Iterate over the string, and for each character, store its last position in the `lastPos` dictionary.\n3. Create a list `partitions` to store the partition sizes.\n4. Initialize two variables `start` and `end` with value 0.\n5. Iterate over the string again:\n   a. For each character, update `end` with the maximum value between `end` and its last position from the `lastPos` dictionary.\n   b. If the current index is equal to `end`, calculate the length of the current partition, append it to `partitions`, and update `start` to the next index.\n6. Return the `partitions` list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " arr = [5,4,3,2,1]",
                    "output": " 1",
                    "explanation": "\nSplitting into two or more chunks will not return the required result.\nFor example, splitting into \\[5, 4\\], \\[3, 2, 1\\] will result in \\[4, 5, 1, 2, 3\\], which isn't sorted."
                },
                {
                    "input": " arr = [2,1,3,4,4]",
                    "output": " 4",
                    "explanation": "\nWe can split into two chunks, such as \\[2, 1\\], \\[3, 4, 4\\].\nHowever, splitting into \\[2, 1\\], \\[3\\], \\[4\\], \\[4\\] is the highest number of chunks possible."
                }
            ],
            "function_input": [
                {
                    "input": "[5,4,3,2,1]",
                    "output": "1"
                },
                {
                    "input": "[2,1,3,4,4]",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-86",
        "prompt": "You are given an integer array `arr`.\n\nWe split `arr` into some number of **chunks** (i.e., partitions), and individually sort each chunk. After concatenating them, the result should equal the sorted array.\n\nReturn _the largest number of chunks we can make to sort the array_."
    },
    "leetcode-benchmark-87": {
        "id": "leetcode-benchmark-87",
        "title": "Basic Calculator IV",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an expression such as `expression = \"e + 8 - a + 5 \"` and an evaluation map such as `{ \"e \": 1}` (given in terms of `evalvars = [ \"e \"]` and `evalints = [1]`), return a list of tokens representing the simplified expression, such as `[ \"-1*a \", \"14 \"]`\n\n*   An expression alternates chunks and symbols, with a space separating each chunk and symbol.\n*   A chunk is either an expression in parentheses, a variable, or a non-negative integer.\n*   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `\"2x \"` or `\"-x \"`.\n\nExpressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.\n\n*   For example, `expression = \"1 + 2 * 3 \"` has an answer of `[ \"7 \"]`.\n\nThe format of the output is as follows:\n\n*   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.\n    *   For example, we would never write a term like `\"b*a*c \"`, only `\"a*b*c \"`.\n*   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\n    *   For example, `\"a*a*b*c \"` has degree `4`.\n*   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n*   An example of a well-formatted answer is `[ \"-2*a*a*a \", \"3*a*a*b \", \"3*b*b \", \"4*a \", \"5*c \", \"-6 \"]`.\n*   Terms (including constant terms) with coefficient `0` are not included.\n    *   For example, an expression of `\"0 \"` has an output of `[]`.\n\n**Note:** You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"e + 8 - a + 5 \", evalvars = \\[ \"e \"\\], evalints = \\[1\\]\n**Output:** \\[ \"-1\\*a \", \"14 \"\\]\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"e - 8 + temperature - pressure \", evalvars = \\[ \"e \",  \"temperature \"\\], evalints = \\[1, 12\\]\n**Output:** \\[ \"-1\\*pressure \", \"5 \"\\]\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"(e + 8) \\* (e - 8) \", evalvars = \\[\\], evalints = \\[\\]\n**Output:** \\[ \"1\\*e\\*e \", \"-64 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 250`\n*   `expression` consists of lowercase English letters, digits, `'+'`, `'-'`, `'*'`, `'('`, `')'`, `' '`.\n*   `expression` does not contain any leading or trailing spaces.\n*   All the tokens in `expression` are separated by a single space.\n*   `0 <= evalvars.length <= 100`\n*   `1 <= evalvars[i].length <= 20`\n*   `evalvars[i]` consists of lowercase English letters.\n*   `evalints.length == evalvars.length`\n*   `-100 <= evalints[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic int minSwapsCouples(int[] row) {\n    int n = row.length / 2;\n    int swaps = 0;\n    Map<Integer, Integer> position = new HashMap<>();\n\n    for (int i = 0; i < row.length; i++) {\n        position.put(row[i], i);\n    }\n\n    for (int i = 0; i < row.length; i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            int temp = row[i + 1];\n            row[i + 1] = row[position.get(couple)];\n            row[position.get(couple)] = temp;\n            position.put(temp, position.get(couple));\n            position.put(couple, i + 1);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint minSwapsCouples(vector<int>& row) {\n    int n = row.size() / 2;\n    int swaps = 0;\n    unordered_map<int, int> position;\n\n    for (int i = 0; i < row.size(); i++) {\n        position[row[i]] = i;\n    }\n\n    for (int i = 0; i < row.size(); i += 2) {\n        int couple = (row[i] % 2 == 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] != couple) {\n            swap(row[i + 1], row[position[couple]]);\n            swap(position[row[i + 1]], position[couple]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "python": "\n    ```python\ndef minSwapsCouples(row):\n    n = len(row) // 2\n    swaps = 0\n    position = {num: i for i, num in enumerate(row)}\n\n    for i in range(0, len(row), 2):\n        couple = row[i] - 1 if row[i] % 2 else row[i] + 1\n        if row[i + 1] != couple:\n            row[i + 1], row[position[couple]] = row[position[couple]], row[i + 1]\n            position[row[i + 1]], position[couple] = position[couple], i + 1\n            swaps += 1\n\n    return swaps\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "javascript": "\n    ```javascript\nfunction minSwapsCouples(row) {\n    const n = row.length / 2;\n    let swaps = 0;\n    const position = {};\n\n    for (let i = 0; i < row.length; i++) {\n        position[row[i]] = i;\n    }\n\n    for (let i = 0; i < row.length; i += 2) {\n        const couple = (row[i] % 2 === 0) ? row[i] + 1 : row[i] - 1;\n        if (row[i + 1] !== couple) {\n            [row[i + 1], row[position[couple]]] = [row[position[couple]], row[i + 1]];\n            [position[row[i + 1]], position[couple]] = [position[couple], i + 1];\n            swaps++;\n        }\n    }\n\n    return swaps;\n}\n```\n    \n    1. Initialize variables: n (the number of couples), swaps (the number of swaps), and a dictionary 'position' where the keys are the person IDs and the values are their positions in the row.\n2. For each even-indexed element (i) in 'row', check if the current couple is sitting side by side.\n3. If not, find the position of the couple of the person sitting at index i, and swap the positions of the person sitting at i+1 and the couple. Update the position of them in the 'position' dictionary accordingly.\n4. Increment the swap counter.\n5. Repeat for all even-indexed elements in 'row', then return the total number of swaps.\n\nThis algorithm runs in O(n) time complexity due to iterating through the row once and performing swaps accordingly.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " expression =  \"e + 8 - a + 5 \", evalvars = [ \"e \"], evalints = [1]",
                    "output": " [ \"-1*a \", \"14 \"]",
                    "explanation": null
                },
                {
                    "input": " expression =  \"e - 8 + temperature - pressure \", evalvars = [ \"e \",  \"temperature \"], evalints = [1, 12]",
                    "output": " [ \"-1*pressure \", \"5 \"]",
                    "explanation": null
                },
                {
                    "input": " expression =  \"(e + 8) * (e - 8) \", evalvars = [], evalints = []",
                    "output": " [ \"1*e*e \", \"-64 \"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"e+8-a+5\",[\"e\"],[1]",
                    "output": "[\"-1*a\",\"14\"]"
                },
                {
                    "input": "\"e-8+temperature-pressure\",[\"e\",\"temperature\"],[1,12]",
                    "output": "[\"-1*pressure\",\"5\"]"
                },
                {
                    "input": "\"(e+8)*(e-8)\",[],[]",
                    "output": "[\"1*e*e\",\"-64\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-87",
        "prompt": "Given an expression such as `expression = \"e + 8 - a + 5 \"` and an evaluation map such as `{ \"e \": 1}` (given in terms of `evalvars = [ \"e \"]` and `evalints = [1]`), return a list of tokens representing the simplified expression, such as `[ \"-1*a \", \"14 \"]`\n\n*   An expression alternates chunks and symbols, with a space separating each chunk and symbol.\n*   A chunk is either an expression in parentheses, a variable, or a non-negative integer.\n*   A variable is a string of lowercase letters (not including digits.) Note that variables can be multiple letters, and note that variables never have a leading coefficient or unary operator like `\"2x \"` or `\"-x \"`.\n\nExpressions are evaluated in the usual order: brackets first, then multiplication, then addition and subtraction.\n\n*   For example, `expression = \"1 + 2 * 3 \"` has an answer of `[ \"7 \"]`.\n\nThe format of the output is as follows:\n\n*   For each term of free variables with a non-zero coefficient, we write the free variables within a term in sorted order lexicographically.\n    *   For example, we would never write a term like `\"b*a*c \"`, only `\"a*b*c \"`.\n*   Terms have degrees equal to the number of free variables being multiplied, counting multiplicity. We write the largest degree terms of our answer first, breaking ties by lexicographic order ignoring the leading coefficient of the term.\n    *   For example, `\"a*a*b*c \"` has degree `4`.\n*   The leading coefficient of the term is placed directly to the left with an asterisk separating it from the variables (if they exist.) A leading coefficient of 1 is still printed.\n*   An example of a well-formatted answer is `[ \"-2*a*a*a \", \"3*a*a*b \", \"3*b*b \", \"4*a \", \"5*c \", \"-6 \"]`.\n*   Terms (including constant terms) with coefficient `0` are not included.\n    *   For example, an expression of `\"0 \"` has an output of `[]`.\n\n**Note:** You may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`."
    },
    "leetcode-benchmark-88": {
        "id": "leetcode-benchmark-88",
        "title": "Reaching Points",
        "difficulty": "Hard",
        "content": {
            "problem": "Given four integers `sx`, `sy`, `tx`, and `ty`, return `true` _if it is possible to convert the point_ `(sx, sy)` _to the point_ `(tx, ty)` _through some operations__, or_ `false` _otherwise_.\n\nThe allowed operation on some point `(x, y)` is to convert it to either `(x, x + y)` or `(x + y, y)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** sx = 1, sy = 1, tx = 3, ty = 5\n**Output:** true\n**Explanation:**\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)\n\n",
                "**Example 2:**\n\n**Input:** sx = 1, sy = 1, tx = 2, ty = 2\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** sx = 1, sy = 1, tx = 1, ty = 1\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sx, sy, tx, ty <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxChunksToSorted(int[] arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "c++": "\n    ```cpp\nint maxChunksToSorted(vector<int>& arr) {\n    int max_so_far = 0, count = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        max_so_far = max(max_so_far, arr[i]);\n        if (max_so_far == i) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "python": "\n    ```python\ndef max_chunks_to_sorted(arr):\n    max_so_far, count = 0, 0\n    for i, val in enumerate(arr):\n        max_so_far = max(max_so_far, val)\n        if max_so_far == i:\n            count += 1\n    return count\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "javascript": "\n    ```javascript\nfunction maxChunksToSorted(arr) {\n    let max_so_far = 0, count = 0;\n    for (let i = 0; i < arr.length; i++) {\n        max_so_far = Math.max(max_so_far, arr[i]);\n        if (max_so_far === i) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n    \n    Iterate through the array and track the maximum value found so far (max_so_far), as well as the number of chunks (count). For each element in the array, update the max_so_far to the maximum of its current value and the current element. If the max_so_far is equal to the current index, it means that it is possible to create a sorted chunk from the starting index to the current index. Increase the count and continue iterating through the array until the end. Finally, return the count.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " sx = 1, sy = 1, tx = 3, ty = 5",
                    "output": " True",
                    "explanation": "\nOne series of moves that transforms the starting point to the target is:\n(1, 1) -> (1, 2)\n(1, 2) -> (3, 2)\n(3, 2) -> (3, 5)"
                },
                {
                    "input": " sx = 1, sy = 1, tx = 2, ty = 2",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " sx = 1, sy = 1, tx = 1, ty = 1",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,1,3,5",
                    "output": "True"
                },
                {
                    "input": "1,1,2,2",
                    "output": "False"
                },
                {
                    "input": "1,1,1,1",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-88",
        "prompt": "Given four integers `sx`, `sy`, `tx`, and `ty`, return `true` _if it is possible to convert the point_ `(sx, sy)` _to the point_ `(tx, ty)` _through some operations__, or_ `false` _otherwise_.\n\nThe allowed operation on some point `(x, y)` is to convert it to either `(x, x + y)` or `(x + y, y)`."
    },
    "leetcode-benchmark-89": {
        "id": "leetcode-benchmark-89",
        "title": "Transform to Chessboard",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other.\n\nReturn _the minimum number of moves to transform the board into a **chessboard board**_. If the task is impossible, return `-1`.\n\nA **chessboard board** is a board where no `0`'s and no `1`'s are 4-directionally adjacent.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[1,0,0,1\\],\\[1,0,0,1\\]\\]\n**Output:** 2\n**Explanation:** One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row.\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[0,1\\],\\[1,0\\]\\]\n**Output:** 0\n**Explanation:** Also note that the board with 0 in the top left corner, is also a valid chessboard.\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\\[1,0\\],\\[1,0\\]\\]\n**Output:** -1\n**Explanation:** No matter what sequence of moves you make, you cannot end with a valid chessboard."
            ],
            "constraints": "**Constraints:**\n\n*   `n == board.length`\n*   `n == board[i].length`\n*   `2 <= n <= 30`\n*   `board[i][j]` is either `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numJewelsInStones(String jewels, String stones) {\n    int count = 0;\n    for (char s : stones.toCharArray()) {\n        if (jewels.indexOf(s) != -1) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "c++": "\n    ```cpp\nint numJewelsInStones(string jewels, string stones) {\n    int count = 0;\n    for (char s : stones) {\n        if (jewels.find(s) != string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "python": "\n    ```python\ndef numJewelsInStones(jewels, stones):\n    count = 0\n    for s in stones:\n        if s in jewels:\n            count += 1\n    return count\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "javascript": "\n    ```javascript\nfunction numJewelsInStones(jewels, stones) {\n    let count = 0;\n    for (let s of stones) {\n        if (jewels.includes(s)) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm takes two strings as input, `jewels` and `stones`. For each character `s` in the `stones` string, check whether the character `s` exists in the `jewels` string. If it exists, that means the stone is a jewel, so we increment the count. After iterating through all characters in the `stones` string, we return the count, which represents the total number of jewels in the stones.\n\nEach respective implementation in C++, Java, Python, and JavaScript showcases the same algorithm adjusted for language-specific syntax differences. In all cases, the key aspect is to loop through the `stones` and check for membership within the string `jewels`, incrementing the count for each found jewel.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]",
                    "output": " 2",
                    "explanation": " One potential sequence of moves is shown.\nThe first move swaps the first and second column.\nThe second move swaps the second and third row."
                },
                {
                    "input": " board = [[0,1],[1,0]]",
                    "output": " 0",
                    "explanation": " Also note that the board with 0 in the top left corner, is also a valid chessboard."
                },
                {
                    "input": " board = [[1,0],[1,0]]",
                    "output": " -1",
                    "explanation": " No matter what sequence of moves you make, you cannot end with a valid chessboard."
                }
            ],
            "function_input": [
                {
                    "input": "[[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]]",
                    "output": "2"
                },
                {
                    "input": "[[0,1],[1,0]]",
                    "output": "0"
                },
                {
                    "input": "[[1,0],[1,0]]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-89",
        "prompt": "You are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other.\n\nReturn _the minimum number of moves to transform the board into a **chessboard board**_. If the task is impossible, return `-1`.\n\nA **chessboard board** is a board where no `0`'s and no `1`'s are 4-directionally adjacent."
    },
    "leetcode-benchmark-90": {
        "id": "leetcode-benchmark-90",
        "title": "Preimage Size of Factorial Zeroes Function",
        "difficulty": "Hard",
        "content": {
            "problem": "Let `f(x)` be the number of zeroes at the end of `x!`. Recall that `x! = 1 * 2 * 3 * ... * x` and by convention, `0! = 1`.\n\n*   For example, `f(3) = 0` because `3! = 6` has no zeroes at the end, while `f(11) = 2` because `11! = 39916800` has two zeroes at the end.\n\nGiven an integer `k`, return the number of non-negative integers `x` have the property that `f(x) = k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 0\n**Output:** 5\n**Explanation:** 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes.\n\n",
                "**Example 2:**\n\n**Input:** k = 5\n**Output:** 0\n**Explanation:** There is no x such that x! ends in k = 5 zeroes.\n\n",
                "**Example 3:**\n\n**Input:** k = 3\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= k <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canTransform(String start, String end) {\n    if (start.length() != end.length()) return false;\n\n    int i = 0, j = 0;\n    int n = start.length();\n    while (i < n && j < n) {\n        while (i < n && start.charAt(i) == 'X') i++;\n        while (j < n && end.charAt(j) == 'X') j++;\n\n        if (start.charAt(i) != end.charAt(j)) return false;\n\n        if ((start.charAt(i) == 'R' && i > j) || (start.charAt(i) == 'L' && i < j)) return false;\n\n        i++; j++;\n    }\n    return true;\n}\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "c++": "\n    ```cpp\nbool canTransform(string start, string end) {\n    if (start.size() != end.size()) return false;\n\n    int i = 0, j = 0;\n    int n = start.size();\n    while (i < n && j < n) {\n        while (i < n && start[i] == 'X') i++;\n        while (j < n && end[j] == 'X') j++;\n\n        if (start[i] != end[j]) return false;\n\n        if ((start[i] == 'R' && i > j) || (start[i] == 'L' && i < j)) return false;\n\n        i++; j++;\n    }\n    return true;\n}\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "python": "\n    ```python\ndef canTransform(start: str, end: str) -> bool:\n    if len(start) != len(end): return False\n\n    i, j = 0, 0\n    n = len(start)\n    while i < n and j < n:\n        while i < n and start[i] == 'X': i += 1\n        while j < n and end[j] == 'X': j += 1\n\n        if start[i] != end[j]: return False\n\n        if (start[i] == 'R' and i > j) or (start[i] == 'L' and i < j): return False\n\n        i += 1; j += 1\n    return True\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "javascript": "\n    ```javascript\nfunction canTransform(start, end) {\n    if (start.length !== end.length) return false;\n\n    let i = 0, j = 0;\n    const n = start.length;\n    while (i < n && j < n) {\n        while (i < n && start[i] === 'X') i++;\n        while (j < n && end[j] === 'X') j++;\n\n        if (start[i] !== end[j]) return false;\n\n        if ((start[i] === 'R' && i > j) || (start[i] === 'L' && i < j)) return false;\n\n        i++; j++;\n    }\n    return true;\n}\n```\n    \n    The algorithm follows the following steps:\n\n1. Check if the lengths of the `start` and `end` strings are the same, if they are not, return `false`.\n2. Initialize two pointers `i` and `j`, representing the current position within the start and end strings, respectively.\n3. Use a while loop to iterate through the characters in the strings:\n   a. If the current character in `start` or `end` is `'X'`, increment the respective index.\n   b. If the current characters in `start` and `end` are different, return `false`. This means the strings cannot be transformed into each other.\n   c. If the current character in `start` is `'R'` and `i > j`, return `false`. This means we cannot move `'R'` to the left, as it violates the given moves.\n   d. Similarly, if the current character in `start` is `'L'` and `i < j`, return `false`. This means we cannot move `'L'` to the right, as it violates the given moves.\n   e. Increment `i` and `j`.\n4. After the loop, return `true`, indicating that a sequence of moves exists to transform the `start` string into the `end` string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " k = 0",
                    "output": " 5",
                    "explanation": " 0!, 1!, 2!, 3!, and 4! end with k = 0 zeroes."
                },
                {
                    "input": " k = 5",
                    "output": " 0",
                    "explanation": " There is no x such that x! ends in k = 5 zeroes."
                },
                {
                    "input": " k = 3",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "0",
                    "output": "5"
                },
                {
                    "input": "5",
                    "output": "0"
                },
                {
                    "input": "3",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-90",
        "prompt": "Let `f(x)` be the number of zeroes at the end of `x!`. Recall that `x! = 1 * 2 * 3 * ... * x` and by convention, `0! = 1`.\n\n*   For example, `f(3) = 0` because `3! = 6` has no zeroes at the end, while `f(11) = 2` because `11! = 39916800` has two zeroes at the end.\n\nGiven an integer `k`, return the number of non-negative integers `x` have the property that `f(x) = k`."
    },
    "leetcode-benchmark-91": {
        "id": "leetcode-benchmark-91",
        "title": "Smallest Rotation with Highest Score",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array `nums`. You can rotate it by a non-negative integer `k` so that the array becomes `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]`. Afterward, any entries that are less than or equal to their index are worth one point.\n\n*   For example, if we have `nums = [2,4,1,3,0]`, and we rotate by `k = 2`, it becomes `[1,3,0,2,4]`. This is worth `3` points because `1 > 0` \\[no points\\], `3 > 1` \\[no points\\], `0 <= 2` \\[one point\\], `2 <= 3` \\[one point\\], `4 <= 4` \\[one point\\].\n\nReturn _the rotation index_ `k` _that corresponds to the highest score we can achieve if we rotated_ `nums` _by it_. If there are multiple answers, return the smallest such index `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,1,4,0\\]\n**Output:** 3\n**Explanation:** Scores for each k are listed below: \nk = 0,  nums = \\[2,3,1,4,0\\],    score 2\nk = 1,  nums = \\[3,1,4,0,2\\],    score 3\nk = 2,  nums = \\[1,4,0,2,3\\],    score 3\nk = 3,  nums = \\[4,0,2,3,1\\],    score 4\nk = 4,  nums = \\[0,2,3,1,4\\],    score 3\nSo we should choose k = 3, which has the highest score.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,0,2,4\\]\n**Output:** 0\n**Explanation:** nums will always have 3 points no matter how it shifts.\nSo we will choose the smallest k, which is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `0 <= nums[i] < nums.length`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int movesToChessboard(int[][] board) {\n    int N = board.length;\n    int row = 0, col = 0, rowCount = 0, colCount = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (((board[0][0] ^ board[i][0] ^ board[0][j]) ^ board[i][j]) != 0) return -1;\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        row ^= board[0][i];\n        col ^= board[i][0];\n        rowCount += board[0][i] == 1 ? 1 : 0;\n        colCount += board[i][0] == 1 ? 1 : 0;\n    }\n\n    if (row != 0 && rowCount * 2 != N) return -1;\n    if (col != 0 && colCount * 2 != N) return -1;\n\n    if (N % 2 == 1) {\n        if (rowCount % 2 == 1) rowCount = N - rowCount;\n        if (colCount % 2 == 1) colCount = N - colCount;\n    } else {\n        rowCount = Math.min(rowCount, N - rowCount);\n        colCount = Math.min(colCount, N - colCount);\n    }\n\n    return (rowCount + colCount) / 2;\n}\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "c++": "\n    ```cpp\n#include <bitset>\n#include <vector>\n\nint movesToChessboard(std::vector<std::vector<int>>& board) {\n  int N = board.size();\n  std::bitset<30> row, col;\n\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < N; ++j)\n      if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j])\n        return -1;\n\n  for (int i = 0; i < N; ++i) {\n    row.flip(i);\n    col.flip(i);\n  }\n\n  int c = board[0] & col;\n  int d = row.count() - row.count() & col;\n  int max_count = max(c, d);\n\n  if (max_count == N) return 0;\n\n  if (N & 1) return max_count & 1 ? max_count / 2 : max_count / 2 + 1;\n  else return max_count / 2;\n}\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "python": "\n    ```python\ndef moves_to_chessboard(board):\n    N = len(board)\n    row, col = 0, 0\n    row_count, col_count = 0, 0\n\n    for i in range(N):\n        for j in range(N):\n            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0:\n                return -1\n\n    for i in range(N):\n        row ^= board[0][i]\n        col ^= board[i][0]\n        row_count += 1 if board[0][i] == 1 else 0\n        col_count += 1 if board[i][0] == 1 else 0\n\n    if row != 0 and row_count * 2 != N:\n        return -1\n    if col != 0 and col_count * 2 != N:\n        return -1\n\n    if N % 2 == 1:\n        if row_count % 2 == 1:\n            row_count = N - row_count\n        if col_count % 2 == 1:\n            col_count = N - col_count\n    else:\n        row_count = min(row_count, N - row_count)\n        col_count = min(col_count, N - col_count)\n\n    return (row_count + col_count) // 2\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "javascript": "\n    ```javascript\nfunction movesToChessboard(board) {\n  const N = board.length;\n  let row = 0, col = 0, rowCount = 0, colCount = 0;\n\n  for (let i = 0; i < N; i++) {\n    for (let j = 0; j < N; j++) {\n      if (((board[0][0] ^ board[i][0] ^ board[0][j]) ^ board[i][j]) !== 0) return -1;\n    }\n  }\n\n  for (let i = 0; i < N; i++) {\n    row ^= board[0][i];\n    col ^= board[i][0];\n    rowCount += board[0][i] === 1 ? 1 : 0;\n    colCount += board[i][0] === 1 ? 1 : 0;\n  }\n\n  if (row !== 0 && rowCount * 2 !== N) return -1;\n  if (col !== 0 && colCount * 2 !== N) return -1;\n\n  if (N % 2 === 1) {\n    if (rowCount % 2 === 1) rowCount = N - rowCount;\n    if (colCount % 2 === 1) colCount = N - colCount;\n  } else {\n    rowCount = Math.min(rowCount, N - rowCount);\n    colCount = Math.min(colCount, N - colCount);\n  }\n\n  return (rowCount + colCount) / 2;\n}\n```\n    \n    1. Iterate through the board and check if swapping rows or columns can transform it into a chessboard by checking if the XOR of the first cell in each row and column, as well as the XOR with the current cell, is zero. If any of these XOR checks return a non-zero result, return -1 as it is impossible to transform the board into a chessboard.\n2. Iterate through the board again and calculate the number of ones in the first row and column, and store this in `rowCount` and `colCount` respectively, as well as the XOR of the entire row and column.\n3. Check if swapping is required based on the number of ones in the first row and column, and update `rowCount` and `colCount` accordingly.\n4. Calculate the minimum number of moves required to transform the board into a chessboard by adding `rowCount` and `colCount` and dividing the result by 2.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,3,1,4,0]",
                    "output": " 3",
                    "explanation": " Scores for each k are listed below: \nk = 0,  nums = \\[2,3,1,4,0\\],    score 2\nk = 1,  nums = \\[3,1,4,0,2\\],    score 3\nk = 2,  nums = \\[1,4,0,2,3\\],    score 3\nk = 3,  nums = \\[4,0,2,3,1\\],    score 4\nk = 4,  nums = \\[0,2,3,1,4\\],    score 3\nSo we should choose k = 3, which has the highest score."
                },
                {
                    "input": " nums = [1,3,0,2,4]",
                    "output": " 0",
                    "explanation": " nums will always have 3 points no matter how it shifts.\nSo we will choose the smallest k, which is 0."
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,1,4,0]",
                    "output": "3"
                },
                {
                    "input": "[1,3,0,2,4]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-91",
        "prompt": "You are given an array `nums`. You can rotate it by a non-negative integer `k` so that the array becomes `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]`. Afterward, any entries that are less than or equal to their index are worth one point.\n\n*   For example, if we have `nums = [2,4,1,3,0]`, and we rotate by `k = 2`, it becomes `[1,3,0,2,4]`. This is worth `3` points because `1 > 0` \\[no points\\], `3 > 1` \\[no points\\], `0 <= 2` \\[one point\\], `2 <= 3` \\[one point\\], `4 <= 4` \\[one point\\].\n\nReturn _the rotation index_ `k` _that corresponds to the highest score we can achieve if we rotated_ `nums` _by it_. If there are multiple answers, return the smallest such index `k`."
    },
    "leetcode-benchmark-92": {
        "id": "leetcode-benchmark-92",
        "title": "Chalkboard XOR Game",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of integers `nums` represents the numbers written on a chalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become `0`, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is `0`.\n\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to `0`, then that player wins.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** false\n**Explanation:** \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes \\[1, 2\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums become \\[1, 1\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] < 216`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean validTicTacToe(String[] board) {\n    int xCount = 0, oCount = 0;\n    for (String row : board) {\n        for (char c : row.toCharArray()) {\n            if (c == 'X') xCount++;\n            else if (c == 'O') oCount++;\n        }\n    }\n    if (xCount != oCount && xCount != oCount + 1) return false;\n\n    boolean xWin = false, oWin = false;\n    for (int i = 0; i < 3; ++i) {\n        if (board[i].charAt(0) == board[i].charAt(1) && board[i].charAt(1) == board[i].charAt(2))\n            xWin = board[i].charAt(0) == 'X' ? true : (board[i].charAt(0) == 'O' ? oWin = true : oWin);\n        if (board[0].charAt(i) == board[1].charAt(i) && board[1].charAt(i) == board[2].charAt(i))\n            xWin = board[0].charAt(i) == 'X' ? true : (board[0].charAt(i) == 'O' ? oWin = true : oWin);\n    }\n    if (board[0].charAt(0) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(2))\n        xWin = board[0].charAt(0) == 'X' ? true : (board[0].charAt(0) == 'O' ? oWin = true : oWin);\n    if (board[0].charAt(2) == board[1].charAt(1) && board[1].charAt(1) == board[2].charAt(0))\n        xWin = board[0].charAt(2) == 'X' ? true : (board[0].charAt(2) == 'O' ? oWin = true : oWin);\n\n    if (xWin && oWin) return false;\n    if (xWin && xCount == oCount) return false;\n    if (oWin && xCount > oCount) return false;\n\n    return true;\n}\n```\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "c++": "\n    ```cpp\nbool validTicTacToe(std::vector<std::string> &board) {\n    int xCount = 0, oCount = 0;\n    for (const std::string& row : board) {\n        for (char c : row) {\n            if (c == 'X') xCount++;\n            else if (c == 'O') oCount++;\n        }\n    }\n    if (xCount != oCount && xCount != oCount + 1) return false;\n\n    bool xWin = false, oWin = false;\n    for (int i = 0; i < 3; ++i) {\n        if (board[i][0] == board[i][1] && board[i][1] == board[i][2])\n            board[i][0] == 'X' ? xWin = true : (board[i][0] == 'O' ? oWin = true : 0);\n        if (board[0][i] == board[1][i] && board[1][i] == board[2][i])\n            board[0][i] == 'X' ? xWin = true : (board[0][i] == 'O' ? oWin = true : 0);\n    }\n    if (board[0][0] == board[1][1] && board[1][1] == board[2][2])\n        board[0][0] == 'X' ? xWin = true : (board[0][0] == 'O' ? oWin = true : 0);\n    if (board[0][2] == board[1][1] && board[1][1] == board[2][0])\n        board[0][2] == 'X' ? xWin = true : (board[0][2] == 'O' ? oWin = true : 0);\n    \n    if (xWin && oWin) return false;\n    if (xWin && xCount == oCount) return false;\n    if (oWin && xCount > oCount) return false;\n\n    return true;\n}\n```\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "python": "\n    ```python\ndef valid_tic_tac_toe(board: List[str]) -> bool:\n    x_count = sum(row.count('X') for row in board)\n    o_count = sum(row.count('O') for row in board)\n    if x_count != o_count and x_count != o_count + 1: return False\n\n    x_win, o_win = False, False\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2] != ' ':\n            x_win, o_win = (True, o_win) if board[i][0] == 'X' else (x_win, True)\n        if board[0][i] == board[1][i] == board[2][i] != ' ':\n            x_win, o_win = (True, o_win) if board[0][i] == 'X' else (x_win, True)\n    if board[0][0] == board[1][1] == board[2][2] != ' ':\n        x_win, o_win = (True, o_win) if board[0][0] == 'X' else (x_win, True)\n    if board[0][2] == board[1][1] == board[2][0] != ' ':\n        x_win, o_win = (True, o_win) if board[0][2] == 'X' else (x_win, True)\n\n    if x_win and o_win: return False\n    if x_win and x_count == o_count: return False\n    if o_win and x_count > o_count: return False\n\n    return True\n```\n\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "javascript": "\n    ```javascript\nfunction validTicTacToe(board) {\n    let xCount = 0, oCount = 0;\n    for (const row of board) {\n        for (const c of row) {\n            if (c === 'X') xCount++;\n            else if (c === 'O') oCount++;\n        }\n    }\n    if (xCount !== oCount && xCount !== oCount + 1) return false;\n\n    let xWin = false, oWin = false;\n    for (let i = 0; i < 3; ++i) {\n        if (board[i][0] === board[i][1] && board[i][1] === board[i][2])\n            board[i][0] === 'X' ? xWin = true : (board[i][0] === 'O' ? oWin = true : 0);\n        if (board[0][i] === board[1][i] && board[1][i] === board[2][i])\n            board[0][i] === 'X' ? xWin = true : (board[0][i] === 'O' ? oWin = true : 0);\n    }\n    if (board[0][0] === board[1][1] && board[1][1] === board[2][2])\n        board[0][0] === 'X' ? xWin = true : (board[0][0] === 'O' ? oWin = true : 0);\n    if (board[0][2] === board[1][1] && board[1][1] === board[2][0])\n        board[0][2] === 'X' ? xWin = true : (board[0][2] === 'O' ? oWin = true : 0);\n\n    if (xWin && oWin) return false;\n    if (xWin && xCount === oCount) return false;\n    if (oWin && xCount > oCount) return false;\n\n    return true;\n}\n```\n\n    \n    First, count the number of X's and O's. If the difference between the counts is not 0 or 1, return false.\n\nThen, check if X or O has won (formed a 3-length line in a row, column, or diagonal).\n1. Iterate through each row and column checking for three in a row (a win).\n2. Check the two diagonals for a win.\n\nAfter checking for wins, there are three invalid cases:\n1. Both X and O have won (not possible in a valid game).\n2. X has won, but there are an equal number of X's and O's on the board.\n3. O has won, but there are more X's than O's on the board.\n\nIf none of these cases apply, return true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,1,2]",
                    "output": " False",
                    "explanation": " \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes \\[1, 2\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums become \\[1, 1\\]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose."
                },
                {
                    "input": " nums = [0,1]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2,3]",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,2]",
                    "output": "False"
                },
                {
                    "input": "[0,1]",
                    "output": "True"
                },
                {
                    "input": "[1,2,3]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-92",
        "prompt": "You are given an array of integers `nums` represents the numbers written on a chalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become `0`, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is `0`.\n\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to `0`, then that player wins.\n\nReturn `true` _if and only if Alice wins the game, assuming both players play optimally_."
    },
    "leetcode-benchmark-93": {
        "id": "leetcode-benchmark-93",
        "title": "Race Car",
        "difficulty": "Hard",
        "content": {
            "problem": "Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'` (reverse):\n\n*   When you get an instruction `'A'`, your car does the following:\n    *   `position += speed`\n    *   `speed *= 2`\n*   When you get an instruction `'R'`, your car does the following:\n    *   If your speed is positive then `speed = -1`\n    *   otherwise `speed = 1`Your position stays the same.\n\nFor example, after commands `\"AAR \"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target`, return _the length of the shortest sequence of instructions to get there_.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:** \nThe shortest instruction sequence is  \"AA \".\nYour position goes from 0 --> 1 --> 3.\n\n",
                "**Example 2:**\n\n**Input:** target = 6\n**Output:** 5\n**Explanation:** \nThe shortest instruction sequence is  \"AAARA \".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int racecar(int target) {\n    return dp(0, 1, target, new HashMap<>());\n}\n\nprivate int dp(int position, int speed, int target, Map<String, Integer> memo) {\n    if (Math.abs(position) > 2 * target) {\n        return target + 1;\n    }\n    if (position == target) {\n        return speed == 1 ? 0 : 1;\n    }\n    String key = position + \",\" + speed;\n    if (memo.containsKey(key)) {\n        return memo.get(key);\n    }\n    int result = (speed > 0 ? dp(position + speed / 2, -speed / 2, target, memo) : dp(position - speed / 2, -speed / 2, target, memo)) + 1;\n    result = Math.min(result, dp(position + speed, speed * 2, target, memo) + 1);\n    memo.put(key, result);\n    return result;\n}\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "c++": "\n    ```cpp\nint racecar(int target) {\n    unordered_map<int, unordered_map<int, int>> memo;\n    function<int(int, int)> dp = [&](int pos, int speed) {\n        if (abs(pos) > 2 * target) return target + 1;\n        if (pos == target) return speed == 1 ? 0 : 1;\n        if (memo[pos][speed]) return memo[pos][speed];\n        int ans = (speed > 0 ? dp(pos + speed / 2, -speed / 2) : dp(pos - speed / 2, -speed / 2)) + 1;\n        ans = min(ans, dp(pos + speed, speed * 2) + 1);\n        return memo[pos][speed] = ans;\n    };\n    return dp(0, 1);\n}\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "python": "\n    ```python\ndef racecar(target: int) -> int:\n    memo = {}\n    def dp(position, speed):\n        if abs(position) > 2 * target:\n            return target + 1\n        if position == target:\n            return 0 if speed == 1 else 1\n        if (position, speed) in memo:\n            return memo[(position, speed)]\n        \n        ans = dp(position + speed // 2, -speed // 2) + 1 if speed > 0 else dp(position - speed // 2, -speed // 2) + 1\n        ans = min(ans, dp(position + speed, speed * 2) + 1)\n        memo[(position, speed)] = ans\n        return ans\n    \n    return dp(0, 1)\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "javascript": "\n    ```javascript\nfunction racecar(target) {\n    const memo = new Map();\n    \n    function dp(pos, speed) {\n        if (Math.abs(pos) > 2 * target) {\n            return target + 1;\n        }\n        if (pos === target) {\n            return speed === 1 ? 0 : 1;\n        }\n        const key = pos + \",\" + speed;\n        if (memo.has(key)) {\n            return memo.get(key);\n        }\n        \n        let result = ((speed > 0)\n            ? dp(pos + Math.floor(speed / 2), -Math.floor(speed / 2))\n            : dp(pos - Math.floor(speed / 2), -Math.floor(speed / 2))) + 1;\n        \n        result = Math.min(result, dp(pos + speed, speed * 2) + 1);\n        memo.set(key, result);\n        return result;\n    }\n    \n    return dp(0, 1);\n}\n```\n    \n    The algorithm uses a recursive depth-first search with memoization to find the shortest sequence of instructions to reach the target position from the initial position (0) with a speed of 1. At each step, the algorithm considers both reversing the direction and accelerating, making the minimal choice of the two options.\n\nMemoization is used to store the results of previous calculations for each position and speed combination, thus avoiding repeated time-consuming calculations and ensuring that the overall complexity is minimal.\n\nThe base case of the recursion is reached when the position is equal to the target, and the algorithm returns either 0 if the speed=1 or 1 if the speed is not equal to 1 (meaning that the algorithm needs to reverse the direction). This base case helps to calculate the results for upper levels of the recursion.\n\nOverall, this depth-first search with memoization efficiently calculates the shortest sequence of moves to reach the target position.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " target = 3",
                    "output": " 2",
                    "explanation": " \nThe shortest instruction sequence is  \"AA \".\nYour position goes from 0 --> 1 --> 3."
                },
                {
                    "input": " target = 6",
                    "output": " 5",
                    "explanation": " \nThe shortest instruction sequence is  \"AAARA \".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6."
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "2"
                },
                {
                    "input": "6",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-93",
        "prompt": "Your car starts at position `0` and speed `+1` on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions `'A'` (accelerate) and `'R'` (reverse):\n\n*   When you get an instruction `'A'`, your car does the following:\n    *   `position += speed`\n    *   `speed *= 2`\n*   When you get an instruction `'R'`, your car does the following:\n    *   If your speed is positive then `speed = -1`\n    *   otherwise `speed = 1`Your position stays the same.\n\nFor example, after commands `\"AAR \"`, your car goes to positions `0 --> 1 --> 3 --> 3`, and your speed goes to `1 --> 2 --> 4 --> -1`.\n\nGiven a target position `target`, return _the length of the shortest sequence of instructions to get there_."
    },
    "leetcode-benchmark-94": {
        "id": "leetcode-benchmark-94",
        "title": "Making A Large Island",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.\n\nReturn _the size of the largest **island** in_ `grid` _after applying this operation_.\n\nAn **island** is a 4-directionally connected group of `1`s.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** 3\n**Explanation:** Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** 4\n**Explanation:** Change the 0 to 1 and make the island bigger, only one island with area = 4.\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[\\[1,1\\],\\[1,1\\]\\]\n**Output:** 4\n**Explanation:** Can't change any 0 to 1, only one island with area = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 500`\n*   `grid[i][j]` is either `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxAreaOfIsland(int[][] grid) {\n    int ans = 0;\n    for (int i = 0; i < grid.length; ++i)\n        for (int j = 0; j < grid[i].length; ++j)\n            if (grid[i][j] == 0) {\n                grid[i][j] = 1;\n                ans = Math.max(ans, dfs(grid, i, j));\n                grid[i][j] = 0;\n            }\n    return ans;\n}\n\nprivate int dfs(int[][] grid, int x, int y) {\n    if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0) {\n        return 0;\n    }\n    grid[x][y] = 0;\n    return dfs(grid, x - 1, y) + dfs(grid, x + 1, y) + dfs(grid, x, y - 1) + dfs(grid, x, y + 1) + 1;\n}\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "c++": "\n    ```cpp\nint maxAreaOfIsland(vector<vector<int>>& grid)\n{\n    function<int(int, int)> dfs = [&](int x, int y) {\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] == 0) {\n            return 0;\n        }\n        grid[x][y] = 0;\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;\n    };\n\n    int ans = 0;\n    for (int i = 0; i < grid.size(); ++i)\n        for (int j = 0; j < grid[i].size(); ++j)\n            if (grid[i][j] == 0) {\n                grid[i][j] = 1;\n                ans = max(ans, dfs(i, j));\n                grid[i][j] = 0;\n            }\n    return ans;\n}\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "python": "\n    ```python\ndef maxAreaOfIsland(grid):\n    def dfs(x, y):\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == 0:\n            return 0\n        grid[x][y] = 0\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1\n\n    ans = 0\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 0:\n                grid[i][j] = 1\n                ans = max(ans, dfs(i, j))\n                grid[i][j] = 0\n    return ans\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "javascript": "\n    ```javascript\nfunction maxAreaOfIsland(grid) {\n    function dfs(x, y) {\n        if (x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] === 0) {\n            return 0;\n        }\n        grid[x][y] = 0;\n        return dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1) + 1;\n    }\n    \n    let ans = 0;\n    for (let i = 0; i < grid.length; ++i)\n        for (let j = 0; j < grid[i].length; ++j)\n            if (grid[i][j] === 0) {\n                grid[i][j] = 1;\n                ans = Math.max(ans, dfs(i, j));\n                grid[i][j] = 0;\n            }\n    return ans;\n}\n```\n    \n    The algorithm follows a Depth-First Search (DFS) approach. We iterate through each cell in the grid. If the current cell has a value of 0, we change it to 1 and call the DFS function starting from that cell. After the DFS call, we change the value back to 0.\n\nThe DFS function checks if the current position (x, y) is a valid position in the grid and if the value of the cell is 1. If not, the function returns 0. If the current cell has a value of 1, we change it to 0 to mark it as visited and make the recursive DFS calls for adjacent cells. We add 1 to the sum of return values from the recursive calls and return the result.\n\nAfter performing DFS for all 0-cells, we return the maximum island size found during the process. The time complexity of this algorithm is O(n^4) since we iterate through the whole grid at each cell that has a value of 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[1,0],[0,1]]",
                    "output": " 3",
                    "explanation": " Change one 0 to 1 and connect two 1s, then we get an island with area = 3."
                },
                {
                    "input": " grid = [[1,1],[1,0]]",
                    "output": " 4",
                    "explanation": " Change the 0 to 1 and make the island bigger, only one island with area = 4."
                },
                {
                    "input": " grid = [[1,1],[1,1]]",
                    "output": " 4",
                    "explanation": " Can't change any 0 to 1, only one island with area = 4."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,0],[0,1]]",
                    "output": "3"
                },
                {
                    "input": "[[1,1],[1,0]]",
                    "output": "4"
                },
                {
                    "input": "[[1,1],[1,1]]",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-94",
        "prompt": "You are given an `n x n` binary matrix `grid`. You are allowed to change **at most one** `0` to be `1`.\n\nReturn _the size of the largest **island** in_ `grid` _after applying this operation_.\n\nAn **island** is a 4-directionally connected group of `1`s."
    },
    "leetcode-benchmark-95": {
        "id": "leetcode-benchmark-95",
        "title": "Count Unique Characters of All Substrings of a Given String",
        "difficulty": "Hard",
        "content": {
            "problem": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\n*   For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ABC \"\n**Output:** 10\n**Explanation:** All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ABA \"\n**Output:** 8\n**Explanation:** The same as example 1, except `countUniqueChars`( \"ABA \") = 1.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"LEETCODE \"\n**Output:** 92"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of uppercase English letters only.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean xorGame(int[] nums) {\n    int xorSum = 0;\n    for (int num : nums) {\n        xorSum ^= num;\n    }\n    return xorSum == 0 || nums.length % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "c++": "\n    ```cpp\nbool xorGame(const std::vector<int>& nums) {\n    int xorSum = 0;\n    for (int num : nums) {\n        xorSum ^= num;\n    }\n    return xorSum == 0 || nums.size() % 2 == 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "python": "\n    ```python\ndef xor_game(nums: List[int]) -> bool:\n    xor_sum = 0\n    for num in nums:\n        xor_sum ^= num\n    return xor_sum == 0 or len(nums) % 2 == 0\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "javascript": "\n    ```javascript\nfunction xorGame(nums) {\n    let xorSum = 0;\n    for (let num of nums) {\n        xorSum ^= num;\n    }\n    return xorSum === 0 || nums.length % 2 === 0;\n}\n```\n    \n    The algorithm first calculates the bitwise XOR of all elements in the array. Then, it checks if the XOR of all elements is zero or if the total number of elements in the array is even.\n\nIf the bitwise XOR of all elements is zero, Alice wins because the game condition is already satisfied and it is her turn. If the total number of elements in the array is even, Alice wins because she can always force a situation where the bitwise XOR of the remaining elements is non-zero when it is Bob's turn to play. In all other cases, Alice will lose, and the function returns false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"ABC \"",
                    "output": " 10",
                    "explanation": " All possible substrings are:  \"A \", \"B \", \"C \", \"AB \", \"BC \" and  \"ABC \".\nEvery substring is composed with only unique letters.\nSum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10"
                },
                {
                    "input": " s =  \"ABA \"",
                    "output": " 8",
                    "explanation": " The same as example 1, except `countUniqueChars`( \"ABA \") = 1."
                },
                {
                    "input": " s =  \"LEETCODE \"",
                    "output": " 92",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"ABC\"",
                    "output": "10"
                },
                {
                    "input": "\"ABA\"",
                    "output": "8"
                },
                {
                    "input": "\"LEETCODE\"",
                    "output": "92"
                }
            ]
        },
        "task_id": "leetcode-benchmark-95",
        "prompt": "Let's define a function `countUniqueChars(s)` that returns the number of unique characters on `s`.\n\n*   For example, calling `countUniqueChars(s)` if `s = \"LEETCODE \"` then `\"L \"`, `\"T \"`, `\"C \"`, `\"O \"`, `\"D \"` are the unique characters since they appear only once in `s`, therefore `countUniqueChars(s) = 5`.\n\nGiven a string `s`, return the sum of `countUniqueChars(t)` where `t` is a substring of `s`. The test cases are generated such that the answer fits in a 32-bit integer.\n\nNotice that some substrings can be repeated so in this case you have to count the repeated ones too."
    },
    "leetcode-benchmark-96": {
        "id": "leetcode-benchmark-96",
        "title": "Sum of Distances in Tree",
        "difficulty": "Hard",
        "content": {
            "problem": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> ambiguousCoordinates(String s) {\n    int n = s.length();\n    List<String> res = new ArrayList<>();\n    \n    for (int i = 2; i < n - 1; i++) {\n        List<String> first = generateNumber(s.substring(1, i));\n        List<String> second = generateNumber(s.substring(i, n - 1));\n        \n        for (String f : first) {\n            for (String sec : second) {\n                res.add(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n\nprivate List<String> generateNumber(String s) {\n    int n = s.length();\n    List<String> res = new ArrayList<>();\n    \n    if (n == 0 || (n > 1 && s.charAt(0) == '0' && s.charAt(n - 1) == '0')) return res;\n    if (n > 1 && s.charAt(0) == '0') {\n        res.add(\"0.\" + s.substring(1));\n        return res;\n    }\n    res.add(s);\n    if (n == 1 || s.charAt(n - 1) == '0') return res;\n    \n    for (int i = 1; i < n; i++) {\n        res.add(s.substring(0, i) + \".\" + s.substring(i));\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> ambiguousCoordinates(std::string s) {\n    int n = s.size();\n    std::vector<std::string> res;\n    \n    for (int i = 2; i < n - 1; ++i) {\n        auto first = generateNumber(s.substr(1, i - 1));\n        auto second = generateNumber(s.substr(i, n - 1 - i));\n        \n        for (const auto& f : first) {\n            for (const auto& sec : second) {\n                res.push_back(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n\nstd::vector<std::string> generateNumber(const std::string& s) {\n    int n = s.size();\n    std::vector<std::string> res;\n    \n    if (n == 0 || (n > 1 && s[0] == '0' && s[n - 1] == '0')) return res;\n    if (n > 1 && s[0] == '0') {\n        res.push_back(\"0.\" + s.substr(1));\n        return res;\n    }\n    res.push_back(s);\n    if (n == 1 || s[n - 1] == '0') return res;\n    \n    for (int i = 1; i < n; ++i) {\n        res.push_back(s.substr(0, i) + \".\" + s.substr(i));\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "python": "\n    ```python\ndef ambiguousCoordinates(s):\n    def generateNumber(s):\n        if not s or (len(s) > 1 and s[0] == '0' and s[-1] == '0'):\n            return []\n        if len(s) > 1 and s[0] == '0':\n            return [\"0.\" + s[1:]]\n        res = [s]\n        if len(s) == 1 or s[-1] == '0':\n            return res\n        for i in range(1, len(s)):\n            res.append(s[:i] + \".\" + s[i:])\n        return res\n\n    n = len(s)\n    res = []\n    \n    for i in range(2, n - 1):\n        first = generateNumber(s[1:i])\n        second = generateNumber(s[i:n - 1])\n        \n        for f in first:\n            for sec in second:\n                res.append(\"(\" + f + \", \" + sec + \")\")\n    \n    return res\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "javascript": "\n    ```javascript\nfunction ambiguousCoordinates(s) {\n    function generateNumber(s) {\n        if (s.length === 0 || (s.length > 1 && s[0] === '0' && s[s.length - 1] === '0')) {\n            return [];\n        }\n        if (s.length > 1 && s[0] === '0') {\n            return [\"0.\" + s.slice(1)];\n        }\n        let res = [s];\n        if (s.length === 1 || s[s.length - 1] === '0') {\n            return res;\n        }\n        for (let i = 1; i < s.length; i++) {\n            res.push(s.slice(0, i) + \".\" + s.slice(i));\n        }\n        return res;\n    }\n    \n    let n = s.length;\n    let res = [];\n    \n    for (let i = 2; i < n - 1; i++) {\n        let first = generateNumber(s.slice(1, i));\n        let second = generateNumber(s.slice(i, n - 1));\n        \n        for (let f of first) {\n            for (let sec of second) {\n                res.push(\"(\" + f + \", \" + sec + \")\");\n            }\n        }\n    }\n    return res;\n}\n```\n\n    \n    1. Iterate over the string except the first and the last characters to create pairs of valid numbers.\n2. In the `generateNumber()` function, handle four cases:\n    a. If the length of the string is 0 or both the first and last characters are '0', then return an empty list.\n    b. If the first character is '0', return a list with the number having a decimal point after the first character.\n    c. If the last character is '0' or the string has only one digit, return a list with only the given string as the number.\n    d. Otherwise, create numbers by placing a decimal point at every valid position between digits of the string.\n3. Combine all valid pairs of numbers and return the final answer in the format of a list of strings.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]",
                    "output": " [8,12,6,10,10,10]",
                    "explanation": " The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on."
                },
                {
                    "input": " n = 1, edges = []",
                    "output": " [0]",
                    "explanation": null
                },
                {
                    "input": " n = 2, edges = [[1,0]]",
                    "output": " [1,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "6,[[0,1],[0,2],[2,3],[2,4],[2,5]]",
                    "output": "[8,12,6,10,10,10]"
                },
                {
                    "input": "1,[]",
                    "output": "[0]"
                },
                {
                    "input": "2,[[1,0]]",
                    "output": "[1,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-96",
        "prompt": "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes."
    },
    "leetcode-benchmark-97": {
        "id": "leetcode-benchmark-97",
        "title": "Similar String Groups",
        "difficulty": "Hard",
        "content": {
            "problem": "Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.\n\nFor example, `\"tars \"` and `\"rats \"` are similar (swapping at positions `0` and `2`), and `\"rats \"` and `\"arts \"` are similar, but `\"star \"` is not similar to `\"tars \"`, `\"rats \"`, or `\"arts \"`.\n\nTogether, these form two connected groups by similarity: `{ \"tars \", \"rats \", \"arts \"}` and `{ \"star \"}`. Notice that `\"tars \"` and `\"arts \"` are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n\nWe are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?",
            "examples": [
                "**Example 1:**\n\n**Input:** strs = \\[ \"tars \", \"rats \", \"arts \", \"star \"\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** strs = \\[ \"omv \", \"ovm \"\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 300`\n*   `1 <= strs[i].length <= 300`\n*   `strs[i]` consists of lowercase letters only.\n*   All words in `strs` have the same length and are anagrams of each other.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int minimalLengthEncoding(String[] words) {\n    Set<String> wordSet = new HashSet<>();\n    for (String word : words) {\n        wordSet.add(word);\n    }\n\n    for (String word : words) {\n        for (int i = 1; i < word.length(); i++) {\n            wordSet.remove(word.substring(i));\n        }\n    }\n\n    int len = 0;\n    for (String word : wordSet) {\n        len += word.length() + 1;\n    }\n    return len;\n}\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M²), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_set>\n#include <vector>\n\nint minimal_length_encoding(const std::vector<std::string>& words) {\n    std::unordered_set<std::string> word_set(words.begin(), words.end());\n\n    for (const std::string& word : words) {\n        for (int i = 1; i < word.size(); ++i) {\n            word_set.erase(word.substr(i));\n        }\n    }\n\n    int len = 0;\n    for (const std::string& word : word_set) {\n        len += word.size() + 1;\n    }\n    return len;\n}\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M²), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "python": "\n    ```python\ndef minimal_length_encoding(words):\n    word_set = set(words)\n\n    for word in words:\n        for i in range(1, len(word)):\n            word_set.discard(word[i:])\n\n    return sum(len(word) + 1 for word in word_set)\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M²), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "javascript": "\n    ```javascript\nfunction minimalLengthEncoding(words) {\n    const wordSet = new Set(words);\n\n    for (const word of words) {\n        for (let i = 1; i < word.length; i++) {\n            wordSet.delete(word.slice(i));\n        }\n    }\n\n    let len = 0;\n    for (const word of wordSet) {\n        len += word.length + 1;\n    }\n    return len;\n}\n```\n    \n    The algorithm starts by initializing a set, `wordSet`, containing all unique words in the input array `words`. Next, for each word in the input array, we iterate over its suffixes (i.e., the substring from a given index to the end of the string) and remove them from the set.\n\nAt the end of the iterations, the set `wordSet` will contain only the shortest unique suffix of each word. We then calculate the total length of the elements in the set plus the special character ('#') that separates them, which results in the length of the shortest reference string.\n\nThe algorithm's time complexity is O(N * M²), where N is the number of words and M is the max length of a word, and its space complexity is O(N * M).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " strs = [ \"tars \", \"rats \", \"arts \", \"star \"]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " strs = [ \"omv \", \"ovm \"]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"tars\",\"rats\",\"arts\",\"star\"]",
                    "output": "2"
                },
                {
                    "input": "[\"omv\",\"ovm\"]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-97",
        "prompt": "Two strings `X` and `Y` are similar if we can swap two letters (in different positions) of `X`, so that it equals `Y`. Also two strings `X` and `Y` are similar if they are equal.\n\nFor example, `\"tars \"` and `\"rats \"` are similar (swapping at positions `0` and `2`), and `\"rats \"` and `\"arts \"` are similar, but `\"star \"` is not similar to `\"tars \"`, `\"rats \"`, or `\"arts \"`.\n\nTogether, these form two connected groups by similarity: `{ \"tars \", \"rats \", \"arts \"}` and `{ \"star \"}`. Notice that `\"tars \"` and `\"arts \"` are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group.\n\nWe are given a list `strs` of strings where every string in `strs` is an anagram of every other string in `strs`. How many groups are there?"
    },
    "leetcode-benchmark-98": {
        "id": "leetcode-benchmark-98",
        "title": "Guess the Word",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an array of unique strings `words` where `words[i]` is six letters long. One word of `words` was chosen as a secret word.\n\nYou are also given the helper object `Master`. You may call `Master.guess(word)` where `word` is a six-letter-long string, and it must be from `words`. `Master.guess(word)` returns:\n\n*   `-1` if `word` is not from `words`, or\n*   an integer representing the number of exact matches (value and position) of your guess to the secret word.\n\nThere is a parameter `allowedGuesses` for each test case where `allowedGuesses` is the maximum number of times you can call `Master.guess(word)`.\n\nFor each test case, you should call `Master.guess` with the secret word without exceeding the maximum number of allowed guesses. You will get:\n\n*   **`\"Either you took too many guesses, or you did not find the secret word. \"`** if you called `Master.guess` more than `allowedGuesses` times or if you did not call `Master.guess` with the secret word, or\n*   **`\"You guessed the secret word correctly. \"`** if you called `Master.guess` with the secret word with the number of calls to `Master.guess` less than or equal to `allowedGuesses`.\n\nThe test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method).",
            "examples": [
                "**Example 1:**\n\n**Input:** secret =  \"acckzz \", words = \\[ \"acckzz \", \"ccbazz \", \"eiowzz \", \"abcczz \"\\], allowedGuesses = 10\n**Output:** You guessed the secret word correctly.\n**Explanation:**\nmaster.guess( \"aaaaaa \") returns -1, because  \"aaaaaa \" is not in wordlist.\nmaster.guess( \"acckzz \") returns 6, because  \"acckzz \" is secret and has all 6 matches.\nmaster.guess( \"ccbazz \") returns 3, because  \"ccbazz \" has 3 matches.\nmaster.guess( \"eiowzz \") returns 2, because  \"eiowzz \" has 2 matches.\nmaster.guess( \"abcczz \") returns 4, because  \"abcczz \" has 4 matches.\nWe made 5 calls to master.guess, and one of them was the secret, so we pass the test case.\n\n",
                "**Example 2:**\n\n**Input:** secret =  \"hamada \", words = \\[ \"hamada \", \"khaled \"\\], allowedGuesses = 10\n**Output:** You guessed the secret word correctly.\n**Explanation:** Since there are two words, you can guess both."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= words.length <= 100`\n*   `words[i].length == 6`\n*   `words[i]` consist of lowercase English letters.\n*   All the strings of `wordlist` are **unique**.\n*   `secret` exists in `words`.\n*   `10 <= allowedGuesses <= 30`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numFactoredBinaryTrees(int[] arr) {\n    int MOD = 1_000_000_007;\n    int n = arr.length;\n    Arrays.sort(arr);\n    HashMap<Integer, Long> dp = new HashMap<>();\n    for (int i = 0; i < n; ++i) {\n        dp.put(arr[i], 1L);\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] % arr[j] == 0 && dp.containsKey(arr[i] / arr[j]))\n                dp.put(arr[i], (dp.get(arr[i]) + dp.get(arr[j]) * dp.get(arr[i] / arr[j])) % MOD);\n        }\n    }\n    long ans = 0;\n    for (Long value : dp.values()) ans = (ans + value) % MOD;\n    return (int) ans;\n}\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "c++": "\n    ```cpp\nint numFactoredBinaryTrees(vector<int>& arr) {\n    long long MOD = 1e9 + 7;\n    int n = arr.size();\n    sort(arr.begin(), arr.end());\n    unordered_map<int, long long> dp;\n    for (int i = 0; i < n; ++i) {\n        dp[arr[i]] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (arr[i] % arr[j] == 0 && dp.count(arr[i] / arr[j]))\n                dp[arr[i]] = (dp[arr[i]] + dp[arr[j]] * dp[arr[i] / arr[j]]) % MOD;\n        }\n    }\n    long long ans = 0;\n    for (const auto& it : dp) ans = (ans + it.second) % MOD;\n    return ans;\n}\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "python": "\n    ```python\ndef numFactoredBinaryTrees(arr):\n    MOD = 10**9 + 7\n    n = len(arr)\n    arr.sort()\n    dp = {}\n    for i, x in enumerate(arr):\n        dp[x] = 1\n        for y in arr[:i]:\n            if x % y == 0 and x // y in dp:\n                dp[x] = (dp[x] + dp[y] * dp[x // y]) % MOD\n    return sum(dp.values()) % MOD\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "javascript": "\n    ```javascript\nfunction numFactoredBinaryTrees(arr) {\n    const MOD = 1e9 + 7;\n    const n = arr.length;\n    arr.sort((a, b) => a - b);\n    let dp = new Map();\n    for (let i = 0; i < n; ++i) {\n        dp.set(arr[i], 1);\n        for (let j = 0; j < i; ++j) {\n            if (arr[i] % arr[j] === 0 && dp.has(arr[i] / arr[j]))\n                dp.set(arr[i], (dp.get(arr[i]) + dp.get(arr[j]) * dp.get(arr[i] / arr[j])) % MOD);\n        }\n    }\n    let ans = 0;\n    for (const value of dp.values()) ans = (ans + value) % MOD;\n    return ans;\n}\n```\n    \n    To solve this problem, we use dynamic programming. The key insight is to recognize that the count of trees we can make with a certain root value is equal to the product of the count of trees using its possible children.\n\n1. Sort the input array so that we can iterate through it in ascending order.\n2. Initialize a hash map `dp` for dynamic programming, where the key is an element in the array and the value is the count of trees we can create using that element as root.\n3. For each element `x` in the array, we start with a count of 1 because there's always a possibility of having a tree with just the root.\n4. For each smaller element `y` in the array, if `x` is divisible by `y` (i.e., `x % y == 0`), we check if there's another element `z` in the array such that `y * z == x`. If so, we update the count of trees for `x` as `dp[x] + dp[y] * dp[z]` in a modulo manner.\n5. The answer would be the sum of all counts in the `dp` hash map.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " secret =  \"acckzz \", words = [ \"acckzz \", \"ccbazz \", \"eiowzz \", \"abcczz \"], allowedGuesses = 10",
                    "output": " You guessed the secret word correctly.",
                    "explanation": "\nmaster.guess( \"aaaaaa \") returns -1, because  \"aaaaaa \" is not in wordlist.\nmaster.guess( \"acckzz \") returns 6, because  \"acckzz \" is secret and has all 6 matches.\nmaster.guess( \"ccbazz \") returns 3, because  \"ccbazz \" has 3 matches.\nmaster.guess( \"eiowzz \") returns 2, because  \"eiowzz \" has 2 matches.\nmaster.guess( \"abcczz \") returns 4, because  \"abcczz \" has 4 matches.\nWe made 5 calls to master.guess, and one of them was the secret, so we pass the test case."
                },
                {
                    "input": " secret =  \"hamada \", words = [ \"hamada \", \"khaled \"], allowedGuesses = 10",
                    "output": " You guessed the secret word correctly.",
                    "explanation": " Since there are two words, you can guess both."
                }
            ],
            "function_input": [
                {
                    "input": "\"acckzz\",[\"acckzz\",\"ccbazz\",\"eiowzz\",\"abcczz\"],10",
                    "output": "Youguessedthesecretwordcorrectly."
                },
                {
                    "input": "\"hamada\",[\"hamada\",\"khaled\"],10",
                    "output": "Youguessedthesecretwordcorrectly."
                }
            ]
        },
        "task_id": "leetcode-benchmark-98",
        "prompt": "You are given an array of unique strings `words` where `words[i]` is six letters long. One word of `words` was chosen as a secret word.\n\nYou are also given the helper object `Master`. You may call `Master.guess(word)` where `word` is a six-letter-long string, and it must be from `words`. `Master.guess(word)` returns:\n\n*   `-1` if `word` is not from `words`, or\n*   an integer representing the number of exact matches (value and position) of your guess to the secret word.\n\nThere is a parameter `allowedGuesses` for each test case where `allowedGuesses` is the maximum number of times you can call `Master.guess(word)`.\n\nFor each test case, you should call `Master.guess` with the secret word without exceeding the maximum number of allowed guesses. You will get:\n\n*   **`\"Either you took too many guesses, or you did not find the secret word. \"`** if you called `Master.guess` more than `allowedGuesses` times or if you did not call `Master.guess` with the secret word, or\n*   **`\"You guessed the secret word correctly. \"`** if you called `Master.guess` with the secret word with the number of calls to `Master.guess` less than or equal to `allowedGuesses`.\n\nThe test cases are generated such that you can guess the secret word with a reasonable strategy (other than using the bruteforce method)."
    },
    "leetcode-benchmark-99": {
        "id": "leetcode-benchmark-99",
        "title": "Rectangle Area II",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2]` denotes the `ith` rectangle where `(xi1, yi1)` are the coordinates of the **bottom-left corner**, and `(xi2, yi2)` are the coordinates of the **top-right corner**.\n\nCalculate the **total area** covered by all `rectangles` in the plane. Any area covered by two or more rectangles should only be counted **once**.\n\nReturn _the **total area**_. Since the answer may be too large, return it **modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** rectangles = \\[\\[0,0,2,2\\],\\[1,0,2,3\\],\\[1,0,3,1\\]\\]\n**Output:** 6\n**Explanation:** A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap.\n\n",
                "**Example 2:**\n\n**Input:** rectangles = \\[\\[0,0,1000000000,1000000000\\]\\]\n**Output:** 49\n**Explanation:** The answer is 1018 modulo (109 + 7), which is 49."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= rectangles.length <= 200`\n*   `rectanges[i].length == 4`\n*   `0 <= xi1, yi1, xi2, yi2 <= 109`\n*   `xi1 <= xi2`\n*   `yi1 <= yi2`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int rectangleArea(int[][] rectangles) {\n    final int mod = 1000000007;\n    int n = rectangles.length;\n    Set<Integer> X = new HashSet<>();\n    Set<Integer> Y = new HashSet<>();\n    for (int[] rect : rectangles) {\n        X.add(rect[0]);\n        X.add(rect[2]);\n        Y.add(rect[1]);\n        Y.add(rect[3]);\n    }\n    Integer[] sortedX = X.toArray(new Integer[0]);\n    Integer[] sortedY = Y.toArray(new Integer[0]);\n    Arrays.sort(sortedX);\n    Arrays.sort(sortedY);\n\n...\n```\n(Java code is similar to C++, with minor adjustments to use Java Collections)\n\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <set>\nusing namespace std;\n\nint rectangleArea(vector<vector<int>>& rectangles) {\n    const int64_t mod = 1e9 + 7;\n    int n = rectangles.size();\n    vector<int> X, Y;\n    for (const auto &rect : rectangles) {\n        X.push_back(rect[0]);\n        X.push_back(rect[2]);\n        Y.push_back(rect[1]);\n        Y.push_back(rect[3]);\n    }\n    sort(X.begin(), X.end());\n    sort(Y.begin(), Y.end());\n\n    X.erase(unique(X.begin(), X.end()), X.end());\n    Y.erase(unique(Y.begin(), Y.end()), Y.end());\n\n    vector<vector<int>> cnt(X.size() - 1, vector<int>(Y.size() - 1));\n\n    for (const auto &rect : rectangles) {\n        int x1_idx = lower_bound(X.begin(), X.end(), rect[0]) - X.begin();\n        int x2_idx = lower_bound(X.begin(), X.end(), rect[2]) - X.begin() - 1;\n        int y1_idx = lower_bound(Y.begin(), Y.end(), rect[1]) - Y.begin();\n        int y2_idx = lower_bound(Y.begin(), Y.end(), rect[3]) - Y.begin() - 1;\n        for (int i = x1_idx; i <= x2_idx; ++i) {\n            for (int j = y1_idx; j <= y2_idx; ++j) {\n                cnt[i][j] = 1;\n            }\n        }\n    }\n    int64_t total_area = 0;\n    for (int i = 0; i < X.size() - 1; ++i) {\n        for (int j = 0; j < Y.size() - 1; ++j) {\n            if (cnt[i][j]) {\n                total_area += (int64_t)(X[i + 1] - X[i]) * (Y[j + 1] - Y[j]);\n                total_area %= mod;\n            }\n        }\n    }\n    return total_area;\n}\n```\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "python": "\n    ```python\ndef rectangleArea(rectangles):\n    mod = 10**9 + 7\n    n = len(rectangles)\n    X, Y = set(), set()\n    for rect in rectangles:\n        X.add(rect[0])\n        X.add(rect[2])\n        Y.add(rect[1])\n        Y.add(rect[3])\n    sorted_x = sorted(X)\n    sorted_y = sorted(Y)\n    cnt = [[0 for _ in range(len(Y) - 1)] for _ in range(len(X) - 1)]\n\n    for rect in rectangles:\n        x1_idx = sorted_x.index(rect[0])\n        x2_idx = sorted_x.index(rect[2]) - 1\n        y1_idx = sorted_y.index(rect[1])\n        y2_idx = sorted_y.index(rect[3]) - 1\n        for i in range(x1_idx, x2_idx + 1):\n            for j in range(y1_idx, y2_idx + 1):\n                cnt[i][j] = 1\n\n    total_area = 0\n    for i in range(len(X) - 1):\n        for j in range(len(Y) - 1):\n            if cnt[i][j]:\n                total_area += (sorted_x[i + 1] - sorted_x[i]) * (sorted_y[j + 1] - sorted_y[j])\n                total_area %= mod\n\n    return total_area\n```\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "javascript": "\n    ```javascript\nfunction rectangleArea(rectangles) {\n    const mod = 1e9 + 7;\n    let n = rectangles.length;\n    let X = new Set(), Y = new Set();\n    for (const rect of rectangles) {\n        X.add(rect[0]);\n        X.add(rect[2]);\n        Y.add(rect[1]);\n        Y.add(rect[3]);\n    }\n    let sortedX = Array.from(X).sort((a, b) => a - b);\n    let sortedY = Array.from(Y).sort((a, b) => a - b);\n\n    let cnt = Array.from({ length: X.size - 1 }, () => Array.from({ length: Y.size - 1 }, () => 0));\n\n    for (const rect of rectangles) {\n        let x1_idx = sortedX.indexOf(rect[0]);\n        let x2_idx = sortedX.indexOf(rect[2]) - 1;\n        let y1_idx = sortedY.indexOf(rect[1]);\n        let y2_idx = sortedY.indexOf(rect[3]) - 1;\n        for (let i = x1_idx; i <= x2_idx; i++) {\n            for (let j = y1_idx; j <= y2_idx; j++) {\n                cnt[i][j] = 1;\n            }\n        }\n    }\n\n    let total_area = 0;\n    for (let i = 0; i < X.size - 1; i++) {\n        for (let j = 0; j < Y.size - 1; j++) {\n            if (cnt[i][j]) {\n                total_area += (sortedX[i + 1] - sortedX[i]) * (sortedY[j + 1] - sortedY[j]);\n                total_area %= mod;\n            }\n        }\n    }\n\n    return total_area;\n}\n```\n    \n    - For each rectangle, add its x-coordinates and y-coordinates (both left and right) into two separate sets X and Y.\n- Convert the sets X and Y to sorted lists (sortedX, sortedY).\n- Create an 2D array (matrix) cnt, which will represent the overlap of rectangles, i.e., cnt[i][j] == 1 if any rectangle covers that area.\n- Iterate through the rectangles and for each rectangle, find its left and right, top and bottom boundaries in the sortedX and sortedY lists.\n- Mark cnt[i][j] = 1 for each rectangle covering the area between indices i and j.\n- Initialize a variable total_area to 0. Iterate over the cnt matrix, and for each cell with value 1, increment total_area by the area of the cell (product of the difference in x and y-coordinates).\n- Return total_area modulo 10^9 + 7.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]",
                    "output": " 6",
                    "explanation": " A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap."
                },
                {
                    "input": " rectangles = [[0,0,1000000000,1000000000]]",
                    "output": " 49",
                    "explanation": " The answer is 1018 modulo (109 + 7), which is 49."
                }
            ],
            "function_input": [
                {
                    "input": "[[0,0,2,2],[1,0,2,3],[1,0,3,1]]",
                    "output": "6"
                },
                {
                    "input": "[[0,0,1000000000,1000000000]]",
                    "output": "49"
                }
            ]
        },
        "task_id": "leetcode-benchmark-99",
        "prompt": "You are given a 2D array of axis-aligned `rectangles`. Each `rectangle[i] = [xi1, yi1, xi2, yi2]` denotes the `ith` rectangle where `(xi1, yi1)` are the coordinates of the **bottom-left corner**, and `(xi2, yi2)` are the coordinates of the **top-right corner**.\n\nCalculate the **total area** covered by all `rectangles` in the plane. Any area covered by two or more rectangles should only be counted **once**.\n\nReturn _the **total area**_. Since the answer may be too large, return it **modulo** `109 + 7`."
    },
    "leetcode-benchmark-100": {
        "id": "leetcode-benchmark-100",
        "title": "K-Similar Strings",
        "difficulty": "Hard",
        "content": {
            "problem": "Strings `s1` and `s2` are `k`**\\-similar** (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`**\\-similar**.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"ab \", s2 =  \"ba \"\n**Output:** 1\n**Explanation:** The two string are 1-similar because we can use one swap to change s1 to s2:  \"ab \" -->  \"ba \".\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"abc \", s2 =  \"bca \"\n**Output:** 2\n**Explanation:** The two strings are 2-similar because we can use two swaps to change s1 to s2:  \"abc \" -->  \"bac \" -->  \"bca \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s1.length <= 20`\n*   `s2.length == s1.length`\n*   `s1` and `s2` contain only lowercase letters from the set `{'a', 'b', 'c', 'd', 'e', 'f'}`.\n*   `s2` is an anagram of `s1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nint kSimilarity(String s1, String s2) {\n    int k = 0;\n    StringBuilder sb = new StringBuilder(s1);\n\n    for (int i = 0; i < sb.length(); i++) {\n        if (sb.charAt(i) != s2.charAt(i)) {\n            int j = i + 1;\n            while (sb.charAt(j) != s2.charAt(i) || s2.charAt(j) == sb.charAt(j)) {\n                j++;\n            }\n            sb.setCharAt(j, sb.charAt(i));\n            sb.setCharAt(i, s2.charAt(i));\n            k++;\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "c++": "\n    ```cpp\nint kSimilarity(const std::string& s1, const std::string& s2) {\n    int k = 0;\n    std::string temp = s1;\n\n    for (int i = 0; i < temp.length(); ++i) {\n        if (temp[i] != s2[i]) {\n            int j = i + 1;\n            while (temp[j] != s2[i] || s2[j] == temp[j]) {\n                ++j;\n            }\n            std::swap(temp[i], temp[j]);\n            k++;\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "python": "\n    ```python\ndef kSimilarity(s1: str, s2: str) -> int:\n    k = 0\n    temp = list(s1)\n\n    for i in range(len(temp)):\n        if temp[i] != s2[i]:\n            j = i + 1\n            while temp[j] != s2[i] or s2[j] == temp[j]:\n                j += 1\n            temp[i], temp[j] = temp[j], temp[i]\n            k += 1\n\n    return k\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "javascript": "\n    ```javascript\nfunction kSimilarity(s1, s2) {\n    let k = 0;\n    let temp = s1.split('');\n\n    for (let i = 0; i < temp.length; i++) {\n        if (temp[i] !== s2[i]) {\n            let j = i + 1;\n            while (temp[j] !== s2[i] || s2[j] === temp[j]) {\n                j++;\n            }\n            [temp[i], temp[j]] = [temp[j], temp[i]];\n            k++;\n        }\n    }\n    return k;\n}\n```\n    \n    The algorithm works by iterating over each character position in the strings, and checking if the characters in s1 and s2 are different at that position. If they are indeed different, we find the index j in the remaining substring of s1 such that swapping the characters at i and j would make s1 and s2 match at position i. We then perform that swap in s1 and increment the counter k. When we reach the end of the strings, the counter k contains the minimum number of swaps necessary to make s1 equal to s2.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s1 =  \"ab \", s2 =  \"ba \"",
                    "output": " 1",
                    "explanation": " The two string are 1-similar because we can use one swap to change s1 to s2:  \"ab \" -->  \"ba \"."
                },
                {
                    "input": " s1 =  \"abc \", s2 =  \"bca \"",
                    "output": " 2",
                    "explanation": " The two strings are 2-similar because we can use two swaps to change s1 to s2:  \"abc \" -->  \"bac \" -->  \"bca \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"ab\",\"ba\"",
                    "output": "1"
                },
                {
                    "input": "\"abc\",\"bca\"",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-100",
        "prompt": "Strings `s1` and `s2` are `k`**\\-similar** (for some non-negative integer `k`) if we can swap the positions of two letters in `s1` exactly `k` times so that the resulting string equals `s2`.\n\nGiven two anagrams `s1` and `s2`, return the smallest `k` for which `s1` and `s2` are `k`**\\-similar**."
    },
    "leetcode-benchmark-101": {
        "id": "leetcode-benchmark-101",
        "title": "Minimum Cost to Hire K Workers",
        "difficulty": "Hard",
        "content": {
            "problem": "There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted.",
            "examples": [
                "**Example 1:**\n\n**Input:** quality = \\[10,20,5\\], wage = \\[70,50,30\\], k = 2\n**Output:** 105.00000\n**Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n\n",
                "**Example 2:**\n\n**Input:** quality = \\[3,1,10,10,1\\], wage = \\[4,8,2,2,7\\], k = 3\n**Output:** 30.66667\n**Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately."
            ],
            "constraints": "**Constraints:**\n\n*   `n == quality.length == wage.length`\n*   `1 <= k <= n <= 104`\n*   `1 <= quality[i], wage[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> largeGroupPositions(String s) {\n    List<List<Integer>> result = new ArrayList<>();\n    int start = 0;\n    for (int i = 1; i < s.length(); ++i) {\n        if (s.charAt(i) != s.charAt(start)) {\n            if (i - start >= 3) {\n                List<Integer> interval = new ArrayList<>();\n                interval.add(start);\n                interval.add(i - 1);\n                result.add(interval);\n            }\n            start = i;\n        }\n    }\n    if (s.length() - start >= 3) {\n        List<Integer> interval = new ArrayList<>();\n        interval.add(start);\n        interval.add(s.length() - 1);\n        result.add(interval);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<vector<int>> largeGroupPositions(string s) {\n    vector<vector<int>> result;\n    int start = 0;\n    for (int i = 1; i < s.size(); ++i) {\n        if (s[i] != s[start]) {\n            if (i - start >= 3) {\n                result.push_back({start, i - 1});\n            }\n            start = i;\n        }\n    }\n    if (s.size() - start >= 3) {\n        result.push_back({start, static_cast<int>(s.size()) - 1});\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "python": "\n    ```python\ndef largeGroupPositions(s: str):\n    result = []\n    start = 0\n    for i in range(1, len(s)):\n        if s[i] != s[start]:\n            if i - start >= 3:\n                result.append([start, i - 1])\n            start = i\n    if len(s) - start >= 3:\n        result.append([start, len(s) - 1])\n    return result\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "javascript": "\n    ```javascript\nfunction largeGroupPositions(s) {\n    const result = [];\n    let start = 0;\n    for (let i = 1; i < s.length; ++i) {\n        if (s.charAt(i) !== s.charAt(start)) {\n            if (i - start >= 3) {\n                result.push([start, i - 1]);\n            }\n            start = i;\n        }\n    }\n    if (s.length - start >= 3) {\n        result.push([start, s.length - 1]);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm used is very simple. We initialize a variable `start` that keeps track of the index of the first character of the current group, and iterate `i` through the string `s`. When the character at position `i` is different from the character at position `start`, we know that the group ends at `i - 1`, so if the group length is greater or equal to 3, we add the interval `[start, i - 1]` to the result list. After that, we update the value of `start` to the current index `i`. To make sure we include the last group in our result, we need to do the check for the group length outside of the loop (after it completes).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " quality = [10,20,5], wage = [70,50,30], k = 2",
                    "output": " 105.00000",
                    "explanation": " We pay 70 to 0th worker and 35 to 2nd worker."
                },
                {
                    "input": " quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3",
                    "output": " 30.66667",
                    "explanation": " We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately."
                }
            ],
            "function_input": [
                {
                    "input": "[10,20,5],[70,50,30],2",
                    "output": "105.00000"
                },
                {
                    "input": "[3,1,10,10,1],[4,8,2,2,7],3",
                    "output": "30.66667"
                }
            ]
        },
        "task_id": "leetcode-benchmark-101",
        "prompt": "There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted."
    },
    "leetcode-benchmark-102": {
        "id": "leetcode-benchmark-102",
        "title": "Shortest Subarray with Sum at Least K",
        "difficulty": "Hard",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the length of the shortest non-empty **subarray** of_ `nums` _with a sum of at least_ `k`. If there is no such **subarray**, return `-1`.\n\nA **subarray** is a **contiguous** part of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1\\], k = 1\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2\\], k = 4\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,-1,2\\], k = 3\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-105 <= nums[i] <= 105`\n*   `1 <= k <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic String findReplaceString(String s, int[] indices, String[] sources, String[] targets) {\n    List<int[]> indexMapping = new ArrayList<>();\n\n    for (int i = 0; i < indices.length; i++) {\n        if (s.startsWith(sources[i], indices[i])) {\n            indexMapping.add(new int[]{indices[i], i});\n        }\n    }\n\n    indexMapping.sort((a, b) -> a[0] - b[0]);\n    StringBuilder result = new StringBuilder();\n    int lastIdx = 0;\n\n    for (int[] p : indexMapping) {\n        result.append(s, lastIdx, p[0]);\n        result.append(targets[p[1]]);\n        lastIdx = p[0] + sources[p[1]].length();\n    }\n\n    result.append(s.substring(lastIdx));\n    return result.toString();\n}\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string findReplaceString(std::string s, std::vector<int>& indices, std::vector<std::string>& sources, std::vector<std::string>& targets) {\n    std::vector<std::pair<int, int>> indexMapping(indices.size());\n    \n    for (int i = 0; i < indices.size(); ++i) {\n        if (s.substr(indices[i], sources[i].size()) == sources[i]) {\n            indexMapping[i] = {indices[i], i};\n        } else {\n            indexMapping[i] = {-1, i};\n        }\n    }\n\n    sort(indexMapping.begin(), indexMapping.end());\n    std::string result = \"\";\n    int lastIdx = 0;\n    \n    for (const auto& p : indexMapping) {\n        if (p.first >= 0) {\n            result += s.substr(lastIdx, p.first - lastIdx) + targets[p.second];\n            lastIdx = p.first + sources[p.second].size();\n        }\n    }\n    \n    result += s.substr(lastIdx);\n    return result;\n}\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "python": "\n    ```python\ndef findReplaceString(s, indices, sources, targets):\n    index_mapping = sorted(\n        [(indices[i], i) for i in range(len(indices)) if s.startswith(sources[i], indices[i])]\n    )\n    result = []\n    last_idx = 0\n\n    for idx, i in index_mapping:\n        result.append(s[last_idx:idx])\n        result.append(targets[i])\n        last_idx = idx + len(sources[i])\n\n    result.append(s[last_idx:])\n    return \"\".join(result)\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "javascript": "\n    ```javascript\nfunction findReplaceString(s, indices, sources, targets) {\n    const indexMapping = indices\n        .map((idx, i) => [s.startsWith(sources[i], idx) ? idx : -1, i])\n        .sort((a, b) => a[0] - b[0]);\n    let result = \"\";\n    let lastIdx = 0;\n\n    for (const [idx, i] of indexMapping) {\n        if (idx >= 0) {\n            result += s.slice(lastIdx, idx) + targets[i];\n            lastIdx = idx + sources[i].length;\n        }\n    }\n\n    result += s.slice(lastIdx);\n    return result;\n}\n```\n    \n    1. Create an array of index mappings where an element is a pair of index and the corresponding operation index (i). Only keep the index mappings where the source is indeed a substring starting at the given index.\n2. Sort the index mappings array based on the index.\n3. Initialize an empty result string and a variable (lastIdx) to keep track of the last added index.\n4. Iterate through the index mappings, for each index mapping, append the substring between the last added index and the current index to the result, then append the corresponding target string.\n5. Update the last added index to the sum of the current index and the length of the corresponding source string.\n6. After iterating through all the index mappings, append the substring from the last added index to the end of the input string to the result.\n7. Return the result string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1], k = 1",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2], k = 4",
                    "output": " -1",
                    "explanation": null
                },
                {
                    "input": " nums = [2,-1,2], k = 3",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1],1",
                    "output": "1"
                },
                {
                    "input": "[1,2],4",
                    "output": "-1"
                },
                {
                    "input": "[2,-1,2],3",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-102",
        "prompt": "Given an integer array `nums` and an integer `k`, return _the length of the shortest non-empty **subarray** of_ `nums` _with a sum of at least_ `k`. If there is no such **subarray**, return `-1`.\n\nA **subarray** is a **contiguous** part of an array."
    },
    "leetcode-benchmark-103": {
        "id": "leetcode-benchmark-103",
        "title": "Shortest Path to Get All Keys",
        "difficulty": "Hard",
        "content": {
            "problem": "You are given an `m x n` grid `grid` where:\n\n*   `'.'` is an empty cell.\n*   `'#'` is a wall.\n*   `'@'` is the starting point.\n*   Lowercase letters represent keys.\n*   Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\nFor some `1 <= k <= 6`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\nReturn _the lowest number of moves to acquire all keys_. If it is impossible, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[ \"@.a.. \", \"###.# \", \"b.A.B \"\\]\n**Output:** 8\n**Explanation:** Note that the goal is to obtain all the keys not to open all the locks.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[ \"@..aA \", \"..B#. \", \"....b \"\\]\n**Output:** 6\n\n",
                "**Example 3:**\n\n**Input:** grid = \\[ \"@Aa \"\\]\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either an English letter, `'.'`, `'#'`, or `'@'`.\n*   The number of keys in the grid is in the range `[1, 6]`.\n*   Each key in the grid is **unique**.\n*   Each key in the grid has a matching lock.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int largestOverlap(int[][] img1, int[][] img2) {\n    int n = img1.length;\n    List<int[]> onesImg1 = new ArrayList<>();\n    List<int[]> onesImg2 = new ArrayList<>();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (img1[i][j] == 1) onesImg1.add(new int[]{i, j});\n            if (img2[i][j] == 1) onesImg2.add(new int[]{i, j});\n        }\n    }\n\n    Map<String, Integer> overlaps = new HashMap<>();\n    for (int[] pt1 : onesImg1) {\n        for (int[] pt2 : onesImg2) {\n            int dx = pt2[0] - pt1[0];\n            int dy = pt2[1] - pt1[1];\n            String key = dx + \",\" + dy;\n            overlaps.put(key, overlaps.getOrDefault(key, 0) + 1);\n        }\n    }\n\n    int maxOverlap = 0;\n    for (Integer count : overlaps.values()) {\n        maxOverlap = Math.max(maxOverlap, count);\n    }\n    return maxOverlap;\n}\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "c++": "\n    ```cpp\nint largestOverlap(vector<vector<int>>& img1, vector<vector<int>>& img2) {\n    int n = img1.size();\n    vector<pair<int, int>> onesImg1, onesImg2;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (img1[i][j]) onesImg1.emplace_back(i, j);\n            if (img2[i][j]) onesImg2.emplace_back(i, j);\n        }\n    }\n\n    unordered_map<int, int> overlaps;\n    for (const auto& pt1 : onesImg1) {\n        for (const auto& pt2 : onesImg2) {\n            int dx = pt2.first - pt1.first;\n            int dy = pt2.second - pt1.second;\n            int key = (dx << 16) + dy;\n            ++overlaps[key];\n        }\n    }\n\n    int maxOverlap = 0;\n    for (const auto& pair : overlaps) {\n        maxOverlap = max(maxOverlap, pair.second);\n    }\n    return maxOverlap;\n}\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "python": "\n    ```python\ndef largestOverlap(img1, img2):\n    n = len(img1)\n    onesImg1 = [(i, j) for i in range(n) for j in range(n) if img1[i][j]]\n    onesImg2 = [(i, j) for i in range(n) for j in range(n) if img2[i][j]]\n\n    overlaps = {}\n    for pt1 in onesImg1:\n        for pt2 in onesImg2:\n            dx, dy = pt2[0] - pt1[0], pt2[1] - pt1[1]\n            key = (dx, dy)\n            if key not in overlaps:\n                overlaps[key] = 0\n            overlaps[key] += 1\n\n    return max(overlaps.values() or [0])\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "javascript": "\n    ```javascript\nfunction largestOverlap(img1, img2) {\n    const n = img1.length;\n    const onesImg1 = [];\n    const onesImg2 = [];\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            if (img1[i][j]) onesImg1.push([i, j]);\n            if (img2[i][j]) onesImg2.push([i, j]);\n        }\n    }\n\n    const overlaps = new Map();\n    for (const pt1 of onesImg1) {\n        for (const pt2 of onesImg2) {\n            const dx = pt2[0] - pt1[0];\n            const dy = pt2[1] - pt1[1];\n            const key = `${dx},${dy}`;\n            overlaps.set(key, (overlaps.get(key) || 0) + 1);\n        }\n    }\n\n    let maxOverlap = 0;\n    for (const count of overlaps.values()) {\n        maxOverlap = Math.max(maxOverlap, count);\n    }\n    return maxOverlap;\n}\n```\n    \n    1. Scan both images, record the coordinates of 1s in `onesImg1` and `onesImg2`.\n2. Find all possible combinations between 1s in `onesImg1` and 1s in `onesImg2` and calculate their displacement (dx, dy).\n3. Store the count of each unique displacement in a dictionary `overlaps`.\n4. Return the maximum overlap count found in the `overlaps` dictionary.\n\nThe algorithm works because we are counting the frequency of the displacement between pairs of 1s. The maximum frequency for any displacement represents the largest overlapping occurrence when translating img1 over img2.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [ \"@.a.. \", \"###.# \", \"b.A.B \"]",
                    "output": " 8",
                    "explanation": " Note that the goal is to obtain all the keys not to open all the locks."
                },
                {
                    "input": " grid = [ \"@..aA \", \"..B#. \", \"....b \"]",
                    "output": " 6",
                    "explanation": null
                },
                {
                    "input": " grid = [ \"@Aa \"]",
                    "output": " -1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"@.a..\",\"###.#\",\"b.A.B\"]",
                    "output": "8"
                },
                {
                    "input": "[\"@..aA\",\"..B#.\",\"....b\"]",
                    "output": "6"
                },
                {
                    "input": "[\"@Aa\"]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-103",
        "prompt": "You are given an `m x n` grid `grid` where:\n\n*   `'.'` is an empty cell.\n*   `'#'` is a wall.\n*   `'@'` is the starting point.\n*   Lowercase letters represent keys.\n*   Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\nFor some `1 <= k <= 6`, there is exactly one lowercase and one uppercase letter of the first `k` letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\nReturn _the lowest number of moves to acquire all keys_. If it is impossible, return `-1`."
    },
    "leetcode-benchmark-104": {
        "id": "leetcode-benchmark-104",
        "title": "Minimum Number of Refueling Stops",
        "difficulty": "Hard",
        "content": {
            "problem": "A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 1, startFuel = 1, stations = \\[\\]\n**Output:** 0\n**Explanation:** We can reach the target without refueling.\n\n",
                "**Example 2:**\n\n**Input:** target = 100, startFuel = 1, stations = \\[\\[10,100\\]\\]\n**Output:** -1\n**Explanation:** We can not reach the target (or even the first gas station).\n\n",
                "**Example 3:**\n\n**Input:** target = 100, startFuel = 10, stations = \\[\\[10,60\\],\\[20,30\\],\\[30,30\\],\\[60,40\\]\\]\n**Output:** 2\n**Explanation:** We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target, startFuel <= 109`\n*   `0 <= stations.length <= 500`\n*   `1 <= positioni < positioni+1 < target`\n*   `1 <= fueli < 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Stack;\n\npublic boolean canVisitAllRooms(List<List<Integer>> rooms) {\n    HashSet<Integer> visited = new HashSet<>();\n    Stack<Integer> stack = new Stack<>();\n    stack.push(0);\n\n    while (!stack.isEmpty()) {\n        int currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (int key : rooms.get(currentRoom)) {\n            if (!visited.contains(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_set>\n\nbool canVisitAllRooms(const std::vector<std::vector<int>>& rooms) {\n    std::unordered_set<int> visited;\n    std::vector<int> stack = {0};\n\n    while (!stack.empty()) {\n        int currentRoom = stack.back();\n        stack.pop_back();\n\n        visited.insert(currentRoom);\n\n        for (int key : rooms[currentRoom]) {\n            if (!visited.count(key)) {\n                stack.push_back(key);\n            }\n        }\n    }\n\n    return visited.size() == rooms.size();\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "python": "\n    ```python\ndef can_visit_all_rooms(rooms):\n    visited = set()\n    stack = [0]\n\n    while stack:\n        current_room = stack.pop()\n\n        visited.add(current_room)\n\n        for key in rooms[current_room]:\n            if key not in visited:\n                stack.append(key)\n\n    return len(visited) == len(rooms)\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "javascript": "\n    ```javascript\nfunction canVisitAllRooms(rooms) {\n    const visited = new Set();\n    const stack = [0];\n\n    while (stack.length > 0) {\n        const currentRoom = stack.pop();\n\n        visited.add(currentRoom);\n\n        for (const key of rooms[currentRoom]) {\n            if (!visited.has(key)) {\n                stack.push(key);\n            }\n        }\n    }\n\n    return visited.size === rooms.length;\n}\n```\n    \n    The algorithm uses a depth-first search approach to visit all the rooms. It starts with room 0 and adds it to the visited set and also adds it to the stack. Then it enters a loop and keeps visiting the rooms till the stack is empty.\n\nInside the loop, it pops a room from the stack, adds it to the visited set, and iterates through the keys in the room. If a key (i.e., a room) is not in the visited set, it adds that key to the stack to visit the respective room.\n\nAt the end, if the size of the visited set is equal to the number of rooms, it returns true, indicating that all the rooms can be visited. Otherwise, it returns false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " target = 1, startFuel = 1, stations = []",
                    "output": " 0",
                    "explanation": " We can reach the target without refueling."
                },
                {
                    "input": " target = 100, startFuel = 1, stations = [[10,100]]",
                    "output": " -1",
                    "explanation": " We can not reach the target (or even the first gas station)."
                },
                {
                    "input": " target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]",
                    "output": " 2",
                    "explanation": " We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2."
                }
            ],
            "function_input": [
                {
                    "input": "1,1,[]",
                    "output": "0"
                },
                {
                    "input": "100,1,[[10,100]]",
                    "output": "-1"
                },
                {
                    "input": "100,10,[[10,60],[20,30],[30,30],[60,40]]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-104",
        "prompt": "A car travels from a starting position to a destination which is `target` miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array `stations` where `stations[i] = [positioni, fueli]` indicates that the `ith` gas station is `positioni` miles east of the starting position and has `fueli` liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has `startFuel` liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn _the minimum number of refueling stops the car must make in order to reach its destination_. If it cannot reach the destination, return `-1`.\n\nNote that if the car reaches a gas station with `0` fuel left, the car can still refuel there. If the car reaches the destination with `0` fuel left, it is still considered to have arrived."
    },
    "leetcode-benchmark-105": {
        "id": "leetcode-benchmark-105",
        "title": "Nth Magical Number",
        "difficulty": "Hard",
        "content": {
            "problem": "A positive integer is _magical_ if it is divisible by either `a` or `b`.\n\nGiven the three integers `n`, `a`, and `b`, return the `nth` magical number. Since the answer may be very large, **return it modulo** `109 + 7`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1, a = 2, b = 3\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 4, a = 2, b = 3\n**Output:** 6"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`\n*   `2 <= a, b <= 4 * 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic class Solution {\n    public String shiftingLetters(String s, int[] shifts) {\n        int n = s.length();\n        for (int i = n - 2; i >= 0; i--) {\n            shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n        }\n        \n        char[] result = new char[n];\n        for (int i = 0; i < n; i++) {\n            result[i] = (char)(((s.charAt(i) - 'a') + shifts[i]) % 26 + 'a');\n        }\n        \n        return new String(result);\n    }\n}\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string shiftingLetters(std::string s, std::vector<int>& shifts) {\n    int n = s.size();\n    for (int i = n - 2; i >= 0; i--) {\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        s[i] = (s[i] - 'a' + shifts[i]) % 26 + 'a';\n    }\n    \n    return s;\n}\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "python": "\n    ```python\ndef shiftingLetters(s: str, shifts: list[int]) -> str:\n    n = len(s)\n    for i in range(n - 2, -1, -1):\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26\n    \n    result = []\n    for i in range(n):\n        result.append(chr(((ord(s[i]) - ord('a')) + shifts[i]) % 26 + ord('a')))\n    \n    return \"\".join(result)\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "javascript": "\n    ```javascript\nfunction shiftingLetters(s, shifts) {\n    const n = s.length;\n    for (let i = n - 2; i >= 0; i--) {\n        shifts[i] = (shifts[i] + shifts[i + 1]) % 26;\n    }\n    \n    let result = \"\";\n    for (let i = 0; i < n; i++) {\n        result += String.fromCharCode((s.charCodeAt(i) - 'a'.charCodeAt(0) + shifts[i]) % 26 + 'a'.charCodeAt(0));\n    }\n    \n    return result;\n}\n```\n    \n    First, we update the shifts array by iterating it from right to left and adding the next element in the array, mod 26, to the current element. This way, we accumulate the total shifts required for each character in the array.\n\nThen, we create an empty result string or array (depending on the language) and iterate through the input string. For each character, we calculate the new character after shifting and append/insert it to the result string.\n\nFinally, we return the resulting string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 1, a = 2, b = 3",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " n = 4, a = 2, b = 3",
                    "output": " 6",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,2,3",
                    "output": "2"
                },
                {
                    "input": "4,2,3",
                    "output": "6"
                }
            ]
        },
        "task_id": "leetcode-benchmark-105",
        "prompt": "A positive integer is _magical_ if it is divisible by either `a` or `b`.\n\nGiven the three integers `n`, `a`, and `b`, return the `nth` magical number. Since the answer may be very large, **return it modulo** `109 + 7`."
    }
}