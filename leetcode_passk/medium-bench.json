{
    "leetcode-benchmark-0": {
        "id": "leetcode-benchmark-0",
        "title": "Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, find the length of the **longest** **substring** without repeating characters.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"abcabcbb \"\n**Output:** 3\n**Explanation:** The answer is  \"abc \", with the length of 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"bbbbb \"\n**Output:** 1\n**Explanation:** The answer is  \"b \", with the length of 1.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"pwwkew \"\n**Output:** 3\n**Explanation:** The answer is  \"wke \", with the length of 3.\nNotice that the answer must be a substring,  \"pwke \" is a subsequence and not a substring."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 5 * 104`\n*   `s` consists of English letters, digits, symbols and spaces.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int lengthOfLongestSubstring(String s) {\n    int left = 0, right = 0, maxLength = 0;\n    Set<Character> characters = new HashSet<>();\n\n    while (right < s.length()) {\n        if (!characters.contains(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.remove(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int left = 0, right = 0, maxLength = 0;\n    std::unordered_set<char> characters;\n\n    while (right < s.size()) {\n        if (characters.find(s[right]) == characters.end()) {\n            characters.insert(s[right]);\n            maxLength = std::max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.erase(s[left]);\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "python": "\n    ```python\ndef length_of_longest_substring(s: str) -> int:\n    left = 0\n    right = 0\n    max_length = 0\n    characters = set()\n\n    while right < len(s):\n        if s[right] not in characters:\n            characters.add(s[right])\n            max_length = max(max_length, right - left + 1)\n            right += 1\n        else:\n            characters.remove(s[left])\n            left += 1\n\n    return max_length\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "javascript": "\n    ```javascript\nfunction lengthOfLongestSubstring(s) {\n    let left = 0, right = 0, maxLength = 0;\n    const characters = new Set();\n\n    while (right < s.length) {\n        if (!characters.has(s.charAt(right))) {\n            characters.add(s.charAt(right));\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        } else {\n            characters.delete(s.charAt(left));\n            left++;\n        }\n    }\n\n    return maxLength;\n}\n```\n    \n    The algorithm uses a sliding window with two pointers, left and right, to iterate through the string. It also uses a set to store the unique characters in the current window.\n\n1. Initialize left and right pointers to the start of the string, and maxLength to 0.\n2. Check if the character at the right index is in the set.\n   - If it's not in the set, add the character to the set, update maxLength, and move the right pointer forward.\n   - If it's in the set, remove the character at the left index from the set, and move the left pointer forward.\n3. Repeat step 2 until the right pointer reaches the end of the string.\n4. Return maxLength. \n\nThe algorithm runs in O(n) time, where n is the length of the input string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"abcabcbb \"",
                    "output": " 3",
                    "explanation": " The answer is  \"abc \", with the length of 3."
                },
                {
                    "input": " s =  \"bbbbb \"",
                    "output": " 1",
                    "explanation": " The answer is  \"b \", with the length of 1."
                },
                {
                    "input": " s =  \"pwwkew \"",
                    "output": " 3",
                    "explanation": " The answer is  \"wke \", with the length of 3.\nNotice that the answer must be a substring,  \"pwke \" is a subsequence and not a substring."
                }
            ],
            "function_input": [
                {
                    "input": "\"abcabcbb\"",
                    "output": "3"
                },
                {
                    "input": "\"bbbbb\"",
                    "output": "1"
                },
                {
                    "input": "\"pwwkew\"",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-0",
        "prompt": "Given a string `s`, find the length of the **longest** **substring** without repeating characters."
    },
    "leetcode-benchmark-1": {
        "id": "leetcode-benchmark-1",
        "title": "Longest Palindromic Substring",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"babad \"\n**Output:**  \"bab \"\n**Explanation:**  \"aba \" is also a valid answer.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"cbbd \"\n**Output:**  \"bb \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consist of only digits and English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String longestPalindromicSubstring(String s) {\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    int start = 0, maxLength = 1;\n\n    for (int i = 0; i < n; ++i) {\n        int l = i, r = i;\n\n        while (r < n - 1 && s.charAt(r) == s.charAt(r + 1))\n            r++;\n        i = r;\n\n        while (l > 0 && r < n - 1 && s.charAt(l - 1) == s.charAt(r + 1)) {\n            l--;\n            r++;\n        }\n\n        int length = r - l + 1;\n        if (length > maxLength) {\n            start = l;\n            maxLength = length;\n        }\n    }\n\n    return s.substring(start, start + maxLength);\n}\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string longestPalindromicSubstring(std::string s) {\n  int n = s.size();\n  if (n == 0) return \"\";\n  int start = 0, maxLength = 1;\n\n  for (int i = 0; i < n; ++i) {\n    int l = i, r = i;\n\n    while (r < n - 1 && s[r] == s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    int length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substr(start, maxLength);\n}\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ",
        "python": "\n    ```python\ndef longest_palindromic_substring(s: str) -> str:\n    n = len(s)\n    if n == 0: return \"\"\n\n    start, max_length = 0, 1\n\n    for i in range(n):\n        l, r = i, i\n\n        while r < n - 1 and s[r] == s[r + 1]:\n            r += 1\n        i = r\n\n        while l > 0 and r < n - 1 and s[l - 1] == s[r + 1]:\n            l -= 1\n            r += 1\n\n        length = r - l + 1\n        if length > max_length:\n            start, max_length = l, length\n\n    return s[start:start + max_length]\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ",
        "javascript": "\n    ```javascript\nfunction longestPalindromicSubstring(s) {\n  let n = s.length;\n  if (n === 0) return \"\";\n\n  let start = 0, maxLength = 1;\n\n  for (let i = 0; i < n; ++i) {\n    let l = i, r = i;\n\n    while (r < n - 1 && s[r] === s[r + 1])\n      r++;\n    i = r;\n\n    while (l > 0 && r < n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n\n    let length = r - l + 1;\n    if (length > maxLength) {\n      start = l;\n      maxLength = length;\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}\n```\n    \n    1. Initialize `start` and `maxLength` for result substring.\n2. Iterate through the given string `s` using the index `i`.\n3. For each index `i`, create two pointers `l` and `r` starting at `i`.\n4. Check if there's a consecutive sequence of identical characters, increment the right pointer `r` until the end of the sequence is reached.\n5. Update the index `i` to the current value of `r`.\n6. Expand the pointers `l` and `r` outwards to find the longest palindromic substring, checking that characters on both sides are equal.\n7. If the current length of the substring is greater than `maxLength`, update `start` and `maxLength`.\n8. Return the longest palindromic substring using the `start` and `maxLength`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"babad \"",
                    "output": "  \"bab \"",
                    "explanation": "  \"aba \" is also a valid answer."
                },
                {
                    "input": " s =  \"cbbd \"",
                    "output": "  \"bb \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"babad\"",
                    "output": "\"bab\""
                },
                {
                    "input": "\"cbbd\"",
                    "output": "\"bb\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-1",
        "prompt": "Given a string `s`, return _the longest_ _palindromic_ _substring_ in `s`."
    },
    "leetcode-benchmark-2": {
        "id": "leetcode-benchmark-2",
        "title": "Zigzag Conversion",
        "difficulty": "Medium",
        "content": {
            "problem": "The string `\"PAYPALISHIRING \"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR \"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"PAYPALISHIRING \", numRows = 3\n**Output:**  \"PAHNAPLSIIGYIR \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"PAYPALISHIRING \", numRows = 4\n**Output:**  \"PINALSIGYAHRPI \"\n**Explanation:**\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n\n",
                "**Example 3:**\n\n**Input:** s =  \"A \", numRows = 1\n**Output:**  \"A \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 1000`\n*   `s` consists of English letters (lower-case and upper-case), `','` and `'.'`.\n*   `1 <= numRows <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic class ZigzagConversion {\n    public String convert(String s, int numRows) {\n        if (numRows == 1 || numRows >= s.length()) return s;\n\n        StringBuilder[] rows = new StringBuilder[numRows];\n        for (int i = 0; i < numRows; i++) rows[i] = new StringBuilder();\n        \n        int curRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows[curRow].append(c);\n            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n            curRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) result.append(row);\n        return result.toString();\n    }\n}\n```\n    \n    1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nstd::string convert(std::string s, int numRows) {\n    if (numRows == 1 || numRows >= s.size()) return s;\n\n    std::vector<std::string> rows(std::min(numRows, int(s.size())));\n    int curRow = 0;\n    bool goingDown = false;\n\n    for (char c : s) {\n        rows[curRow] += c;\n        if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    std::string result;\n    for (std::string row : rows) result += row;\n    return result;\n}\n```\n    \n    1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it.\n    ",
        "python": "\n    ```python\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    rows = [\"\"] * numRows\n    curRow = 0\n    goingDown = False\n\n    for c in s:\n        rows[curRow] += c\n        if curRow == 0 or curRow == numRows - 1:\n            goingDown = not goingDown\n        curRow += 1 if goingDown else -1\n\n    return \"\".join(rows)\n```\n    \n    1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it.\n    ",
        "javascript": "\n    ```javascript\nfunction convert(s, numRows) {\n    if (numRows === 1 || numRows >= s.length) return s;\n\n    let rows = new Array(numRows).fill(\"\");\n    let curRow = 0;\n    let goingDown = false;\n\n    for (let c of s) {\n        rows[curRow] += c;\n        if (curRow === 0 || curRow === numRows - 1) goingDown = !goingDown;\n        curRow += goingDown ? 1 : -1;\n    }\n\n    return rows.join(\"\");\n}\n```\n    \n    1. If the number of rows is 1 or is greater than or equal to the length of the string, the string is just returned as is.\n2. Create an array called \"rows\" to contain the characters that would reside in each row of the zigzag pattern.\n3. Iterate through the string one character at a time.\n4. For each character in the string, place it into the appropriate row of the \"rows\" array.\n5. Determine whether the next character should be placed in the row above or below the current row by checking if the current row is 0 (at the top) or equal to the number of rows minus 1 (at the bottom). If at the top or the bottom, the direction will change.\n6. Update the current row index according to the direction (going up or down).\n7. After iterating through the entire string, join the rows array into a single string and return it.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"PAYPALISHIRING \", numRows = 3",
                    "output": "  \"PAHNAPLSIIGYIR \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"PAYPALISHIRING \", numRows = 4",
                    "output": "  \"PINALSIGYAHRPI \"",
                    "explanation": "\nP     I    N\nA   L S  I G\nY A   H R\nP     I"
                },
                {
                    "input": " s =  \"A \", numRows = 1",
                    "output": "  \"A \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"PAYPALISHIRING\",3",
                    "output": "\"PAHNAPLSIIGYIR\""
                },
                {
                    "input": "\"PAYPALISHIRING\",4",
                    "output": "\"PINALSIGYAHRPI\""
                },
                {
                    "input": "\"A\",1",
                    "output": "\"A\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-2",
        "prompt": "The string `\"PAYPALISHIRING \"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\n\nAnd then read line by line: `\"PAHNAPLSIIGYIR \"`\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);"
    },
    "leetcode-benchmark-3": {
        "id": "leetcode-benchmark-3",
        "title": "Reverse Integer",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 123\n**Output:** 321\n\n",
                "**Example 2:**\n\n**Input:** x = -123\n**Output:** -321\n\n",
                "**Example 3:**\n\n**Input:** x = 120\n**Output:** 21"
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= x <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int reverse(int x) {\n    long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < Integer.MIN_VALUE || res > Integer.MAX_VALUE) ? 0 : (int)res;\n}\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "c++": "\n    ```cpp\nint reverse(int x) {\n    long long res = 0;\n    while (x != 0) {\n        res = res * 10 + x % 10;\n        x /= 10;\n    }\n    return (res < INT_MIN || res > INT_MAX) ? 0 : res;\n}\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "python": "\n    ```python\ndef reverse(x: int) -> int:\n    sign = -1 if x < 0 else 1\n    x = abs(x)\n    res = 0\n    while x:\n        res = res * 10 + x % 10\n        x //= 10\n    res *= sign\n    return res if -2**31 <= res <= 2**31 - 1 else 0\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "javascript": "\n    ```javascript\nfunction reverse(x) {\n    let sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let res = 0;\n    while (x !== 0) {\n        res = res * 10 + x % 10;\n        x = Math.floor(x / 10);\n    }\n    res *= sign;\n    return (res < -(2 ** 31) || res > 2 ** 31 - 1) ? 0 : res;\n}\n```\n    \n    The algorithm initializes `res` as 0. Then, we determine the sign of the input integer and take its absolute value. We use a while loop to iterate through each digit of `x` from right to left. In each iteration, we multiply the current `res` by 10 and add the last digit of `x` to it. The last digit of `x` is obtained by `x % 10`. After adding the last digit, we remove it from `x` by doing either `x /= 10` or `x //= 10`.\n\nAfter processing all the digits, we adjust `res` with the sign we computed earlier. Finally, we check if the reversed integer is within the 32-bit integer range. If it is, we return the result; otherwise, we return 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " x = 123",
                    "output": " 321",
                    "explanation": null
                },
                {
                    "input": " x = -123",
                    "output": " -321",
                    "explanation": null
                },
                {
                    "input": " x = 120",
                    "output": " 21",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "123",
                    "output": "321"
                },
                {
                    "input": "-123",
                    "output": "-321"
                },
                {
                    "input": "120",
                    "output": "21"
                }
            ]
        },
        "task_id": "leetcode-benchmark-3",
        "prompt": "Given a signed 32-bit integer `x`, return `x` _with its digits reversed_. If reversing `x` causes the value to go outside the signed 32-bit integer range `[-231, 231 - 1]`, then return `0`.\n\n**Assume the environment does not allow you to store 64-bit integers (signed or unsigned).**"
    },
    "leetcode-benchmark-4": {
        "id": "leetcode-benchmark-4",
        "title": "String to Integer (atoi)",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"42 \"\n**Output:** 42\n**Explanation:** The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"42 \" ( \"42 \" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"   -42 \"\n**Output:** -42\n**Explanation:**\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n            ^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n             ^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"4193 with words \"\n**Output:** 4193\n**Explanation:**\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length <= 200`\n*   `s` consists of English letters (lower-case and upper-case), digits (`0-9`), `' '`, `'+'`, `'-'`, and `'.'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int myAtoi(String s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (i < s.length() && s.charAt(i) == ' ') i++;\n    if (i < s.length() && (s.charAt(i) == '-' || s.charAt(i) == '+')) {\n        sign = (s.charAt(i++) == '+') ? 1 : -1;\n    }\n    while (i < s.length() && Character.isDigit(s.charAt(i))) {\n        result = result * 10 + (s.charAt(i++) - '0');\n        if (result * sign > Integer.MAX_VALUE) return Integer.MAX_VALUE;\n        if (result * sign < Integer.MIN_VALUE) return Integer.MIN_VALUE;\n    }\n    return (int) (result * sign);\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "c++": "\n    ```cpp\nint myAtoi(string s) {\n    long result = 0;\n    int i = 0, sign = 1;\n    while (s[i] == ' ') i++;\n    if (s[i] == '-' || s[i] == '+') sign = (s[i++] == '+') ? 1 : -1;\n    while (isdigit(s[i])) {\n        result = result * 10 + (s[i++] - '0');\n        if (result * sign > INT_MAX) return INT_MAX;\n        if (result * sign < INT_MIN) return INT_MIN;\n    }\n    return result * sign;\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "python": "\n    ```python\ndef myAtoi(s):\n    result, i, sign = 0, 0, 1\n    while i < len(s) and s[i] == ' ': i += 1\n    if i < len(s) and (s[i] == '-' or s[i] == '+'):\n        sign = -1 if s[i] == '-' else 1\n        i += 1\n    while i < len(s) and s[i].isdigit():\n        result = result * 10 + int(s[i])\n        i += 1\n        if result * sign > 2**31 - 1: return 2**31 - 1\n        if result * sign < -2**31: return -2**31\n    return result * sign\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "javascript": "\n    ```javascript\nfunction myAtoi(s) {\n    let result = 0, i = 0, sign = 1;\n    while (s[i] === ' ') i++;\n    if (s[i] === '-' || s[i] === '+') sign = (s[i++] === '+') ? 1 : -1;\n    while (!isNaN(s[i]) && s[i] !== ' ') {\n        result = result * 10 + parseInt(s[i++], 10);\n        if (result * sign > 2147483647) return 2147483647;\n        if (result * sign < -2147483648) return -2147483648;\n    }\n    return result * sign;\n}\n```\n    \n    1. Initialize `result` as 0, index `i` as 0, and `sign` as 1 (positive).\n2. Loop through the string until a non-space character is found or the end of the string is reached.\n3. If the current character is '+' or '-', update the `sign` according to the character and increment the index `i`.\n4. If a digit is found, multiply the previous `result` by 10 and add the digit to it. Increment the index `i`.\n5. Check if the result multiplied by the sign is out of the 32-bit signed integer range. If so, return the appropriate boundary value.\n6. When no more digits are found, return the final result multiplied by the sign.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"42 \"",
                    "output": " 42",
                    "explanation": " The underlined characters are what is read in, the caret is the current reader position.\nStep 1:  \"42 \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"42 \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"42 \" ( \"42 \" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range \\[-231, 231 - 1\\], the final result is 42."
                },
                {
                    "input": " s =  \"   -42 \"",
                    "output": " -42",
                    "explanation": "\nStep 1:  \"   \\-42 \" (leading whitespace is read and ignored)\n            ^\nStep 2:  \"   \\-42 \" ('-' is read, so the result should be negative)\n             ^\nStep 3:  \"   -42 \" ( \"42 \" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range \\[-231, 231 - 1\\], the final result is -42."
                },
                {
                    "input": " s =  \"4193 with words \"",
                    "output": " 4193",
                    "explanation": "\nStep 1:  \"4193 with words \" (no characters read because there is no leading whitespace)\n         ^\nStep 2:  \"4193 with words \" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3:  \"4193 with words \" ( \"4193 \" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range \\[-231, 231 - 1\\], the final result is 4193."
                }
            ],
            "function_input": [
                {
                    "input": "\"42\"",
                    "output": "42"
                },
                {
                    "input": "\"-42\"",
                    "output": "-42"
                },
                {
                    "input": "\"4193withwords\"",
                    "output": "4193"
                }
            ]
        },
        "task_id": "leetcode-benchmark-4",
        "prompt": "Implement the `myAtoi(string s)` function, which converts a string to a 32-bit signed integer (similar to C/C++'s `atoi` function).\n\nThe algorithm for `myAtoi(string s)` is as follows:\n\n1.  Read in and ignore any leading whitespace.\n2.  Check if the next character (if not already at the end of the string) is `'-'` or `'+'`. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\n3.  Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\n4.  Convert these digits into an integer (i.e. `\"123 \" -> 123`, `\"0032 \" -> 32`). If no digits were read, then the integer is `0`. Change the sign as necessary (from step 2).\n5.  If the integer is out of the 32-bit signed integer range `[-231, 231 - 1]`, then clamp the integer so that it remains in the range. Specifically, integers less than `-231` should be clamped to `-231`, and integers greater than `231 - 1` should be clamped to `231 - 1`.\n6.  Return the integer as the final result.\n\n**Note:**\n\n*   Only the space character `' '` is considered a whitespace character.\n*   **Do not ignore** any characters other than the leading whitespace or the rest of the string after the digits."
    },
    "leetcode-benchmark-5": {
        "id": "leetcode-benchmark-5",
        "title": "Integer to Roman",
        "difficulty": "Medium",
        "content": {
            "problem": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.",
            "examples": [
                "**Example 1:**\n\n**Input:** num = 3\n**Output:**  \"III \"\n**Explanation:** 3 is represented as 3 ones.\n\n",
                "**Example 2:**\n\n**Input:** num = 58\n**Output:**  \"LVIII \"\n**Explanation:** L = 50, V = 5, III = 3.\n\n",
                "**Example 3:**\n\n**Input:** num = 1994\n**Output:**  \"MCMXCIV \"\n**Explanation:** M = 1000, CM = 900, XC = 90 and IV = 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num <= 3999`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RomanNumerals {\n    public static String intToRoman(int num) {\n        List<Pair> romans = Arrays.asList(\n            new Pair(1000, \"M\"), new Pair(900, \"CM\"), new Pair(500, \"D\"), \n            new Pair(400, \"CD\"), new Pair(100, \"C\"), new Pair(90, \"XC\"),\n            new Pair(50, \"L\"), new Pair(40, \"XL\"), new Pair(10, \"X\"), \n            new Pair(9, \"IX\"), new Pair(5, \"V\"), new Pair(4, \"IV\"),\n            new Pair(1, \"I\")\n        );\n        StringBuilder roman = new StringBuilder();\n        for (Pair p : romans) {\n            while (num >= p.num) {\n                roman.append(p.symbol);\n                num -= p.num;\n            }\n        }\n        return roman.toString();\n    }\n    \n    private static class Pair {\n        final int num;\n        final String symbol;\n        \n        Pair(int num, String symbol) {\n            this.num = num;\n            this.symbol = symbol;\n        }\n    }\n}\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string intToRoman(int num) {\n    std::vector<std::pair<int, std::string>> romans = {\n        {1000, \"M\"},\n        {900, \"CM\"},\n        {500, \"D\"},\n        {400, \"CD\"},\n        {100, \"C\"},\n        {90, \"XC\"},\n        {50, \"L\"},\n        {40, \"XL\"},\n        {10, \"X\"},\n        {9, \"IX\"},\n        {5, \"V\"},\n        {4, \"IV\"},\n        {1, \"I\"}\n    };\n    std::string roman = \"\";\n    for (const auto& p : romans) {\n        while (num >= p.first) {\n            roman += p.second;\n            num -= p.first;\n        }\n    }\n    return roman;\n}\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "python": "\n    ```python\ndef int_to_roman(num):\n    romans = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"),\n        (400, \"CD\"), (100, \"C\"), (90, \"XC\"),\n        (50, \"L\"), (40, \"XL\"), (10, \"X\"), \n        (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = \"\"\n    for value, symbol in romans:\n        while num >= value:\n            roman += symbol\n            num -= value\n    return roman\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "javascript": "\n    ```javascript\nfunction intToRoman(num) {\n    const romans = [\n        [1000, \"M\"], [900, \"CM\"], [500, \"D\"],\n        [400, \"CD\"], [100, \"C\"], [90, \"XC\"],\n        [50, \"L\"], [40, \"XL\"], [10, \"X\"], \n        [9, \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]\n    ];\n    let roman = \"\";\n    for (const [value, symbol] of romans) {\n        while (num >= value) {\n            roman += symbol;\n            num -= value;\n        }\n    }\n    return roman;\n}\n```\n    \n    The algorithm starts with a list of pairs, where each pair contains a decimal value and its corresponding roman numeral. Then, it iteratively go through the list of pairs and checks if the num is greater than or equal to the decimal value. If it is, it appends the roman numeral to the result, and subtracts the decimal value from the num. This is done until the num becomes 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num = 3",
                    "output": "  \"III \"",
                    "explanation": " 3 is represented as 3 ones."
                },
                {
                    "input": " num = 58",
                    "output": "  \"LVIII \"",
                    "explanation": " L = 50, V = 5, III = 3."
                },
                {
                    "input": " num = 1994",
                    "output": "  \"MCMXCIV \"",
                    "explanation": " M = 1000, CM = 900, XC = 90 and IV = 4."
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "\"III\""
                },
                {
                    "input": "58",
                    "output": "\"LVIII\""
                },
                {
                    "input": "1994",
                    "output": "\"MCMXCIV\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-5",
        "prompt": "Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.\n\n**Symbol**       **Value**\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\nFor example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:\n\n*   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.\n*   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.\n*   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral."
    },
    "leetcode-benchmark-6": {
        "id": "leetcode-benchmark-6",
        "title": "3Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,0,1,2,-1,-4\\]\n**Output:** \\[\\[-1,-1,2\\],\\[-1,0,1\\]\\]\n**Explanation:** \nnums\\[0\\] + nums\\[1\\] + nums\\[2\\] = (-1) + 0 + 1 = 0.\nnums\\[1\\] + nums\\[2\\] + nums\\[4\\] = 0 + 1 + (-1) = 0.\nnums\\[0\\] + nums\\[3\\] + nums\\[4\\] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are \\[-1,0,1\\] and \\[-1,-1,2\\].\nNotice that the order of the output and the order of the triplets does not matter.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,1\\]\n**Output:** \\[\\]\n**Explanation:** The only possible triplet does not sum up to 0.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,0,0\\]\n**Output:** \\[\\[0,0,0\\]\\]\n**Explanation:** The only possible triplet sums up to 0."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 3000`\n*   `-105 <= nums[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> threeSum(int[] nums) {\n    Arrays.sort(nums);\n    List<List<Integer>> result = new ArrayList<>();\n\n    for (int i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[k]));\n                    while (j < k && nums[j] == nums[j + 1]) j++;\n                    while (j < k && nums[k] == nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }                    \n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    std::sort(nums.begin(), nums.end());\n\n    for (int i = 0; i < (int)nums.size() - 2; ++i) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            int j = i + 1, k = nums.size() - 1;\n            while (j < k) {\n                int sum = nums[i] + nums[j] + nums[k];\n                if (sum == 0) {\n                    result.push_back({nums[i], nums[j], nums[k]});\n                    while (j < k && nums[j] == nums[j + 1]) ++j;\n                    while (j < k && nums[k] == nums[k - 1]) --k;\n                    ++j;\n                    --k;\n                } else if (sum < 0) {\n                    ++j;\n                } else {\n                    --k;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "python": "\n    ```python\ndef threeSum(nums):\n    nums.sort()\n    result = []\n\n    for i in range(len(nums) - 2):\n        if i == 0 or nums[i] != nums[i - 1]:\n            j, k = i + 1, len(nums) - 1\n            while j < k:\n                s = nums[i] + nums[j] + nums[k]\n                if s == 0:\n                    result.append([nums[i], nums[j], nums[k]])\n                    while j < k and nums[j] == nums[j + 1]:\n                        j += 1\n                    while j < k and nums[k] == nums[k - 1]:\n                        k -= 1\n                    j += 1\n                    k -= 1\n                elif s < 0:\n                    j += 1\n                else:\n                    k -= 1\n\n    return result\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "javascript": "\n    ```javascript\nfunction threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i == 0 || nums[i] != nums[i - 1]) {\n            let j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                const sum = nums[i] + nums[j] + nums[k];\n                if (sum === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                    while (j < k && nums[j] === nums[j + 1]) j++;\n                    while (j < k && nums[k] === nums[k - 1]) k--;\n                    j++;\n                    k--;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Loop through `nums` from index `0` to `length - 2`. Let the current index be `i`.\n    - If `i` is `0` or `nums[i]` is not equal to the previous element (`nums[i - 1]`), perform the following steps:\n        - Initialize two pointers `j` and `k`, where `j` is the next index after `i`, and `k` is the last index of `nums`.\n        - While `j` is less than `k`, perform the following steps:\n            - Calculate the sum `s` of the elements at indices `i`, `j`, and `k`.\n            - If the sum `s` is equal to `0`, then we've found a valid triplet. Add it to the `result` array and move the pointers, `j` and `k`, skipping duplicates if any.\n            - If the sum `s` is less than `0`, increment `j` to move towards positive values.\n            - If the sum `s` is greater than `0`, decrement `k` to move towards negative values.\n3. Return the `result` array.\n\nThe algorithm removes duplicates by checking if the current numbers being processed are equal to previously processed numbers. The sorting step helps in simplifying the algorithm and reducing the search space.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-1,0,1,2,-1,-4]",
                    "output": " [[-1,-1,2],[-1,0,1]]",
                    "explanation": " \nnums\\[0\\] + nums\\[1\\] + nums\\[2\\] = (-1) + 0 + 1 = 0.\nnums\\[1\\] + nums\\[2\\] + nums\\[4\\] = 0 + 1 + (-1) = 0.\nnums\\[0\\] + nums\\[3\\] + nums\\[4\\] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are \\[-1,0,1\\] and \\[-1,-1,2\\].\nNotice that the order of the output and the order of the triplets does not matter."
                },
                {
                    "input": " nums = [0,1,1]",
                    "output": " []",
                    "explanation": " The only possible triplet does not sum up to 0."
                },
                {
                    "input": " nums = [0,0,0]",
                    "output": " [[0,0,0]]",
                    "explanation": " The only possible triplet sums up to 0."
                }
            ],
            "function_input": [
                {
                    "input": "[-1,0,1,2,-1,-4]",
                    "output": "[[-1,-1,2],[-1,0,1]]"
                },
                {
                    "input": "[0,1,1]",
                    "output": "[]"
                },
                {
                    "input": "[0,0,0]",
                    "output": "[[0,0,0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-6",
        "prompt": "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets."
    },
    "leetcode-benchmark-7": {
        "id": "leetcode-benchmark-7",
        "title": "3Sum Closest",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-1,2,1,-4\\], target = 1\n**Output:** 2\n**Explanation:** The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,0\\], target = 1\n**Output:** 0\n**Explanation:** The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
            ],
            "constraints": "**Constraints:**\n\n*   `3 <= nums.length <= 500`\n*   `-1000 <= nums[i] <= 1000`\n*   `-104 <= target <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int threeSumClosest(int[] nums, int target) {\n    Arrays.sort(nums);\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.length - 2; ++i) {\n        int left = i + 1;\n        int right = nums.length - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1;\n        int right = nums.size() - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (sum == target) {\n                return sum;\n            }\n            if (abs(target - sum) < abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "python": "\n    ```python\ndef threeSumClosest(nums, target):\n    nums.sort()\n    closest = sum(nums[:3])\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            cur_sum = nums[i] + nums[left] + nums[right]\n            if cur_sum == target:\n                return cur_sum\n            if abs(target - cur_sum) < abs(target - closest):\n                closest = cur_sum\n            if cur_sum < target:\n                left += 1\n            else:\n                right -= 1\n    return closest\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "javascript": "\n    ```javascript\nfunction threeSumClosest(nums, target) {\n    nums.sort((a, b) => a - b);\n    let closest = nums[0] + nums[1] + nums[2];\n    for (let i = 0; i < nums.length - 2; ++i) {\n        let left = i + 1;\n        let right = nums.length - 1;\n        while (left < right) {\n            let sum = nums[i] + nums[left] + nums[right];\n            if (sum === target) {\n                return sum;\n            }\n            if (Math.abs(target - sum) < Math.abs(target - closest)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return closest;\n}\n```\n    \n    1. Sort the input array `nums`.\n2. Initialize the `closest` variable to be the sum of the first three elements.\n3. Iterate through the sorted array with a pointer `i` running from the first element to the third-to-last element.\n4. Initialize two-pointers `left` (set to `i + 1`) and `right` (set to the last element).\n5. While `left` is less than `right`:\n    a. Calculate the current sum `cur_sum` using the elements at positions `i`, `left`, and `right`.\n    b. If `cur_sum` is equal to `target`, return it as the closest sum.\n    c. Update the `closest` sum if the difference between `target` and `cur_sum` is less than the difference between `target` and `closest`.\n    d. Move the `left` pointer forward if `cur_sum` is less than `target`, otherwise move the `right` pointer backward.\n6. Return the `closest` sum found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-1,2,1,-4], target = 1",
                    "output": " 2",
                    "explanation": " The sum that is closest to the target is 2. (-1 + 2 + 1 = 2)."
                },
                {
                    "input": " nums = [0,0,0], target = 1",
                    "output": " 0",
                    "explanation": " The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
                }
            ],
            "function_input": [
                {
                    "input": "[-1,2,1,-4],1",
                    "output": "2"
                },
                {
                    "input": "[0,0,0],1",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-7",
        "prompt": "Given an integer array `nums` of length `n` and an integer `target`, find three integers in `nums` such that the sum is closest to `target`.\n\nReturn _the sum of the three integers_.\n\nYou may assume that each input would have exactly one solution."
    },
    "leetcode-benchmark-8": {
        "id": "leetcode-benchmark-8",
        "title": "Letter Combinations of a Phone Number",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.",
            "examples": [
                "**Example 1:**\n\n**Input:** digits =  \"23 \"\n**Output:** \\[ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"\\]\n\n",
                "**Example 2:**\n\n**Input:** digits =  \" \"\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** digits =  \"2 \"\n**Output:** \\[ \"a \", \"b \", \"c \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= digits.length <= 4`\n*   `digits[i]` is a digit in the range `['2', '9']`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic List<String> letterCombinations(String digits) {\n    LinkedList<String> output = new LinkedList<>();\n    if(digits.isEmpty()) return output;\n    \n    String[] phone = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    output.add(\"\");\n    \n    for(char d : digits.toCharArray()){\n        while(output.peek().length() == digits.indexOf(d)){\n            String perm = output.remove();\n            for(char c : phone[d - '2'].toCharArray()){\n                output.add(perm + c);\n            }\n        }\n    }\n    \n    return output;\n}\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\nusing namespace std;\n\nvector<string> letterCombinations(string digits) {\n    if(digits.empty()) return {};\n    vector<string> phone = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n    vector<string> result = {\"\"};\n\n    for (char d : digits) {\n        vector<string> temp;\n        for (const string &s : result) {\n            for (char c : phone[d - '2']) {\n                temp.push_back(s + c);\n            }\n        }\n        result.swap(temp);\n    }\n    return result;\n}\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "python": "\n    ```python\ndef letter_combinations(digits: str):\n    if not digits: return []\n    phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]\n    result = [\"\"]\n\n    for digit in digits:\n        temp = []\n        for s in result:\n            for c in phone[int(digit) - 2]:\n                temp.append(s + c)\n        result = temp\n\n    return result\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "javascript": "\n    ```javascript\nfunction letterCombinations(digits) {\n    if (digits.length === 0) return [];\n    \n    let phone = [\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"];\n    let result = [\"\"];\n\n    for (let i = 0; i < digits.length; i++) {\n        let digit = digits[i];\n        let temp = [];\n\n        for (let s of result) {\n            for (let c of phone[digit - 2]) {\n                temp.push(s + c);\n            }\n        }\n\n        result = temp;\n    }\n\n    return result;\n}\n```\n    \n    The algorithm visits each digit from the given `digits` string one by one. For each digit, it appends all possible characters corresponding to that digit, in a breadth-first search manner. The current stage's results are saved in the `result` list (or `output` list in Java). A temporary list `temp` is used to store the combinations formed at each stage before replacing the `result` list. The phone buttons mapping is stored in the `phone` list/array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " digits =  \"23 \"",
                    "output": " [ \"ad \", \"ae \", \"af \", \"bd \", \"be \", \"bf \", \"cd \", \"ce \", \"cf \"]",
                    "explanation": null
                },
                {
                    "input": " digits =  \" \"",
                    "output": " []",
                    "explanation": null
                },
                {
                    "input": " digits =  \"2 \"",
                    "output": " [ \"a \", \"b \", \"c \"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"23\"",
                    "output": "[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]"
                },
                {
                    "input": "\"\"",
                    "output": "[]"
                },
                {
                    "input": "\"2\"",
                    "output": "[\"a\",\"b\",\"c\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-8",
        "prompt": "Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.\n\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters."
    },
    "leetcode-benchmark-9": {
        "id": "leetcode-benchmark-9",
        "title": "4Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n*   `0 <= a, b, c, d < n`\n*   `a`, `b`, `c`, and `d` are **distinct**.\n*   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,0,-1,0,-2,2\\], target = 0\n**Output:** \\[\\[-2,-1,1,2\\],\\[-2,0,0,2\\],\\[-1,0,0,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,2,2,2,2\\], target = 8\n**Output:** \\[\\[2,2,2,2\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `-109 <= nums[i] <= 109`\n*   `-109 <= target <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> fourSum(int[] nums, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    if(nums == null || nums.length < 4)\n        return result;\n\n    Arrays.sort(nums);\n    for(int i = 0; i < nums.length - 3; i++) {\n        if(i > 0 && nums[i] == nums[i-1])\n            continue;\n\n        for(int j = i + 1; j < nums.length - 2; j++) {\n            if(j > i + 1 && nums[j] == nums[j-1])\n                continue;\n\n            int left = j + 1;\n            int right = nums.length - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                    ++left;\n                    --right;\n                    while(left < right && nums[left] == nums[left - 1]) ++left;\n                    while(left < right && nums[right] == nums[right + 1]) --right;\n                } else if(sum < target) {\n                    ++left;\n                } else {\n                    --right;\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\n    vector<vector<int>> result;\n    int n = nums.size();\n    if(n < 4)\n        return result;\n\n    sort(nums.begin(), nums.end());\n    for(int i = 0; i < n - 3; i++) {\n        if(i > 0 && nums[i] == nums[i-1])\n            continue;\n\n        for(int j = i + 1; j < n - 2; j++) {\n            if(j > i + 1 && nums[j] == nums[j-1])\n                continue;\n\n            int left = j + 1;\n            int right = n - 1;\n            while(left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if(sum == target) {\n                    result.push_back({nums[i], nums[j], nums[left], nums[right]});\n                    ++left;\n                    --right;\n                    while(left < right && nums[left] == nums[left-1]) ++left;\n                    while(left < right && nums[right] == nums[right+1]) --right;\n                } else if(sum < target) {\n                    ++left;\n                } else {\n                    --right;\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "python": "\n    ```python\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n        for j in range(i + 1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j - 1]:\n                continue\n            left = j + 1\n            right = len(nums) - 1\n            while left < right:\n                cur_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                if cur_sum == target:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    left += 1\n                    right -= 1\n                    while left < right and nums[left] == nums[left - 1]: left += 1\n                    while left < right and nums[right] == nums[right + 1]: right -= 1\n                elif cur_sum < target:\n                    left += 1\n                else:\n                    right -= 1\n    return result\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "javascript": "\n    ```javascript\nfunction fourSum(nums, target) {\n    nums.sort((a, b) => a - b);\n    let result = [];\n    for (let i = 0; i < nums.length - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n        for (let j = i + 1; j < nums.length - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n\n            let left = j + 1;\n            let right = nums.length - 1;\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum === target) {\n                    result.push([nums[i], nums[j], nums[left], nums[right]]);\n                    left++;\n                    right--;\n                    while (left < right && nums[left] === nums[left - 1]) left++;\n                    while (left < right && nums[right] === nums[right + 1]) right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    1. First, sort the given array of n integers.\n2. Iterate through the array with two nested loops to choose two (not necessarily distinct) elements (i, j) where i < j.\n3. Create two pointers, left and right, starting from j + 1 and n - 1, respectively, to find a pair of elements (left, right) with sum equal to target - (nums[i] + nums[j]).\n4. Check whether the current quadruplet [nums[i], nums[j], nums[left], nums[right]] is unique. If the same quadruplet is not already in the result, add it to the result.\n5. To avoid repetition, if the next element is the same as the current element in either i, j, left, or right, skip the current iteration and move to the next one.\n6. Return the resulting array of unique quadruplets.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,0,-1,0,-2,2], target = 0",
                    "output": " [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]",
                    "explanation": null
                },
                {
                    "input": " nums = [2,2,2,2,2], target = 8",
                    "output": " [[2,2,2,2]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,0,-1,0,-2,2],0",
                    "output": "[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]"
                },
                {
                    "input": "[2,2,2,2,2],8",
                    "output": "[[2,2,2,2]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-9",
        "prompt": "Given an array `nums` of `n` integers, return _an array of all the **unique** quadruplets_ `[nums[a], nums[b], nums[c], nums[d]]` such that:\n\n*   `0 <= a, b, c, d < n`\n*   `a`, `b`, `c`, and `d` are **distinct**.\n*   `nums[a] + nums[b] + nums[c] + nums[d] == target`\n\nYou may return the answer in **any order**."
    },
    "leetcode-benchmark-10": {
        "id": "leetcode-benchmark-10",
        "title": "Generate Parentheses",
        "difficulty": "Medium",
        "content": {
            "problem": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"()\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 8`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateParenthesis(int n) {\n    List<String> result = new ArrayList<>();\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n\nprivate void generateParenthesisHelper(int open, int close, String current, List<String> result) {\n    if (open == 0 && close == 0) {\n        result.add(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid generateParenthesisHelper(int open, int close, std::string current, std::vector<std::string>& result) {\n    if (open == 0 && close == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (open > 0) {\n        generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n    }\n    if (close > 0) {\n        generateParenthesisHelper(open, close - 1, current + ')', result);\n    }\n}\n\nstd::vector<std::string> generateParenthesis(int n) {\n    std::vector<std::string> result;\n    generateParenthesisHelper(n, 0, \"\", result);\n    return result;\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "python": "\n    ```python\ndef generate_parenthesis(n):\n    def generate_parenthesis_helper(open, close, current):\n        if open == 0 and close == 0:\n            result.append(current)\n            return\n        if open > 0:\n            generate_parenthesis_helper(open - 1, close + 1, current + '(')\n        if close > 0:\n            generate_parenthesis_helper(open, close - 1, current + ')')\n\n    result = []\n    generate_parenthesis_helper(n, 0, '')\n    return result\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "javascript": "\n    ```javascript\nfunction generateParenthesis(n) {\n    function generateParenthesisHelper(open, close, current, result) {\n        if (open === 0 && close === 0) {\n            result.push(current);\n            return;\n        }\n        if (open > 0) {\n            generateParenthesisHelper(open - 1, close + 1, current + '(', result);\n        }\n        if (close > 0) {\n            generateParenthesisHelper(open, close - 1, current + ')', result);\n        }\n    }\n\n    let result = [];\n    generateParenthesisHelper(n, 0, '', result);\n    return result;\n}\n```\n\n    \n    The algorithm uses a helper function called `generateParenthesisHelper` which receives four parameters: the number of open parentheses left to place, the number of close parentheses left to place, the current string that holds the generated parentheses so far, and the result list to store valid combinations.\n\nThe algorithm uses a depth-first search to construct valid combinations of parentheses. It starts with `n` open parentheses and increments the number of close parentheses as it places an open parenthesis. When the helper function has no open or close parentheses left to place, it means a valid combination is found, so it adds the combination to the result list.\n\nThe helper function recursively calls itself. If there are open parentheses left to place, it calls itself with one less open parenthesis and one more close parenthesis. If there are close parentheses left to place, it calls itself without changing the number of open parentheses and with one less close parenthesis. Finally, the current string in each case is updated with the placed open or close parenthesis.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " [\"()\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
                },
                {
                    "input": "1",
                    "output": "[\"()\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-10",
        "prompt": "Given `n` pairs of parentheses, write a function to _generate all combinations of well-formed parentheses_."
    },
    "leetcode-benchmark-11": {
        "id": "leetcode-benchmark-11",
        "title": "Swap Nodes in Pairs",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4\\]\n**Output:** \\[2,1,4,3\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** head = \\[1\\]\n**Output:** \\[1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is in the range `[0, 100]`.\n*   `0 <= Node.val <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic ListNode swapPairs(ListNode head) {\n    if (head == null || head.next == null) return head;\n    \n    ListNode second = head.next;\n    head.next = swapPairs(second.next);\n    second.next = head;\n    \n    return second;\n}\n```\n    \n    The algorithm uses recursion to solve the problem. It starts by checking if the list has remaining pairs to swap. If not, the head of the current section of the list is returned.\n\nIf there are pairs left to swap, it takes the second node (which will become the new head of the current pair) and sets its next node to the result of the recursive call with the node after it as the new head.\n\nThen, it sets the current head's next node to the second node and returns the second node as the new head of the pair. As the recursion unfolds, the pairs get swapped, and the final swapped linked list head is returned.\n    ",
        "c++": "\n    ```cpp\nListNode* swapPairs(ListNode* head) {\n    if (!head || !head->next) return head;\n\n    ListNode* second = head->next;\n    head->next = swapPairs(second->next);\n    second->next = head;\n    \n    return second;\n}\n```\n    \n    The algorithm uses recursion to solve the problem. It starts by checking if the list has remaining pairs to swap. If not, the head of the current section of the list is returned.\n\nIf there are pairs left to swap, it takes the second node (which will become the new head of the current pair) and sets its next node to the result of the recursive call with the node after it as the new head.\n\nThen, it sets the current head's next node to the second node and returns the second node as the new head of the pair. As the recursion unfolds, the pairs get swapped, and the final swapped linked list head is returned.\n    ",
        "python": "\n    ```python\ndef swapPairs(head: Optional[ListNode]) -> Optional[ListNode]:\n    if not head or not head.next:\n        return head\n\n    second = head.next\n    head.next = swapPairs(second.next)\n    second.next = head\n\n    return second\n```\n    \n    The algorithm uses recursion to solve the problem. It starts by checking if the list has remaining pairs to swap. If not, the head of the current section of the list is returned.\n\nIf there are pairs left to swap, it takes the second node (which will become the new head of the current pair) and sets its next node to the result of the recursive call with the node after it as the new head.\n\nThen, it sets the current head's next node to the second node and returns the second node as the new head of the pair. As the recursion unfolds, the pairs get swapped, and the final swapped linked list head is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction swapPairs(head) {\n    if (!head || !head.next) return head;\n\n    let second = head.next;\n    head.next = swapPairs(second.next);\n    second.next = head;\n\n    return second;\n}\n```\n    \n    The algorithm uses recursion to solve the problem. It starts by checking if the list has remaining pairs to swap. If not, the head of the current section of the list is returned.\n\nIf there are pairs left to swap, it takes the second node (which will become the new head of the current pair) and sets its next node to the result of the recursive call with the node after it as the new head.\n\nThen, it sets the current head's next node to the second node and returns the second node as the new head of the pair. As the recursion unfolds, the pairs get swapped, and the final swapped linked list head is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " head = [1,2,3,4]",
                    "output": " [2,1,4,3]",
                    "explanation": null
                },
                {
                    "input": " head = []",
                    "output": " []",
                    "explanation": null
                },
                {
                    "input": " head = [1]",
                    "output": " [1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4]",
                    "output": "[2,1,4,3]"
                },
                {
                    "input": "[]",
                    "output": "[]"
                },
                {
                    "input": "[1]",
                    "output": "[1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-11",
        "prompt": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)"
    },
    "leetcode-benchmark-12": {
        "id": "leetcode-benchmark-12",
        "title": "Divide Two Integers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers `dividend` and `divisor`, divide two integers **without** using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`.\n\nReturn _the **quotient** after dividing_ `dividend` _by_ `divisor`.\n\n**Note:** Assume we are dealing with an environment that could only store integers within the **32-bit** signed integer range: `[-231, 231 - 1]`. For this problem, if the quotient is **strictly greater than** `231 - 1`, then return `231 - 1`, and if the quotient is **strictly less than** `-231`, then return `-231`.",
            "examples": [
                "**Example 1:**\n\n**Input:** dividend = 10, divisor = 3\n**Output:** 3\n**Explanation:** 10/3 = 3.33333.. which is truncated to 3.\n\n",
                "**Example 2:**\n\n**Input:** dividend = 7, divisor = -3\n**Output:** -2\n**Explanation:** 7/-3 = -2.33333.. which is truncated to -2."
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= dividend, divisor <= 231 - 1`\n*   `divisor != 0`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int divide(int dividend, int divisor) {\n    if (dividend == Integer.MIN_VALUE && divisor == -1) {\n        return Integer.MAX_VALUE;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long dvd = Math.abs((long) dividend);\n    long dvs = Math.abs((long) divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "c++": "\n    ```cpp\nint divide(int dividend, int divisor) {\n    if (dividend == INT_MIN && divisor == -1) {\n        return INT_MAX;\n    }\n\n    int sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n    int ans = 0;\n\n    while (dvd >= dvs) {\n        long long temp = dvs, multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "python": "\n    ```python\ndef divide(dividend: int, divisor: int) -> int:\n    if dividend == -(2**31) and divisor == -1:\n        return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n    ans = 0\n\n    while dvd >= dvs:\n        temp = dvs\n        multiple = 1\n        while dvd >= (temp << 1):\n            temp <<= 1\n            multiple <<= 1\n        dvd -= temp\n        ans += multiple\n\n    return ans * sign\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "javascript": "\n    ```javascript\nfunction divide(dividend, divisor) {\n    if (dividend === -Math.pow(2, 31) && divisor === -1) {\n        return Math.pow(2, 31) - 1;\n    }\n\n    const sign = (dividend > 0) ^ (divisor > 0) ? -1 : 1;\n\n    let dvd = Math.abs(dividend);\n    let dvs = Math.abs(divisor);\n    let ans = 0;\n\n    while (dvd >= dvs) {\n        let temp = dvs;\n        let multiple = 1;\n        while (dvd >= (temp << 1)) {\n            temp <<= 1;\n            multiple <<= 1;\n        }\n        dvd -= temp;\n        ans += multiple;\n    }\n\n    return ans * sign;\n}\n```\n    \n    1. First, we handle the edge case where dividend = -2^31 and divisor = -1. The result must be 2^31, but since it's out of the signed integer range, we should return 2^31 - 1.\n2. Calculate the sign of the result based on the signs of dividend and divisor.\n3. We use the bitwise shift operator to handle divisions by powers of 2. In each iteration, we initialize the temp variable as the absolute value of the divisor to calculate how many times it fits into the remaining dividend. We then use another loop to repeatedly double the temp variable (by bitwise left shift) and check if the dividend is still greater or equal. If so, we also double the 'multiple' value associated with temp, as that's the actual quotient in the current iteration.\n4. When the shifting loop exits, we subtract the current temp from dividend and accumulate the current multiple to our answer.\n5. Once the dividend is less than the divisor, we break the loop and return the signed quotient by multiplying the sign variable to our answer.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " dividend = 10, divisor = 3",
                    "output": " 3",
                    "explanation": " 10/3 = 3.33333.. which is truncated to 3."
                },
                {
                    "input": " dividend = 7, divisor = -3",
                    "output": " -2",
                    "explanation": " 7/-3 = -2.33333.. which is truncated to -2."
                }
            ],
            "function_input": [
                {
                    "input": "10,3",
                    "output": "3"
                },
                {
                    "input": "7,-3",
                    "output": "-2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-12",
        "prompt": "Given two integers `dividend` and `divisor`, divide two integers **without** using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, `8.345` would be truncated to `8`, and `-2.7335` would be truncated to `-2`.\n\nReturn _the **quotient** after dividing_ `dividend` _by_ `divisor`.\n\n**Note:** Assume we are dealing with an environment that could only store integers within the **32-bit** signed integer range: `[-231, 231 - 1]`. For this problem, if the quotient is **strictly greater than** `231 - 1`, then return `231 - 1`, and if the quotient is **strictly less than** `-231`, then return `-231`."
    },
    "leetcode-benchmark-13": {
        "id": "leetcode-benchmark-13",
        "title": "Next Permutation",
        "difficulty": "Medium",
        "content": {
            "problem": "A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.\n\n*   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.\n\nThe **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n*   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n*   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n*   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\n\nGiven an array of integers `nums`, _find the next permutation of_ `nums`.\n\nThe replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,3,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,1\\]\n**Output:** \\[1,2,3\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,1,5\\]\n**Output:** \\[1,5,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void nextPermutation(int[] nums) {\n    int n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        Arrays.sort(nums);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        int temp = nums[k];\n        nums[k] = nums[l];\n        nums[l] = temp;\n        Arrays.sort(nums, k + 1, n);\n    }\n}\n```\n    \n    We can solve this problem by following the steps below:\n\n1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.\n2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\n3. Swap the value of `nums[k]` with that of `nums[l]`.\n4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.\n\nBy making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\nvoid nextPermutation(vector<int>& nums) {\n    int n = nums.size(), k, l;\n    for (k = n - 2; k >= 0; k--) {\n        if (nums[k] < nums[k + 1]) break;\n    }\n    if (k < 0) {\n        reverse(nums.begin(), nums.end());\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        swap(nums[k], nums[l]);\n        reverse(nums.begin() + k + 1, nums.end());\n    }\n}\n```\n    \n    We can solve this problem by following the steps below:\n\n1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.\n2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\n3. Swap the value of `nums[k]` with that of `nums[l]`.\n4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.\n\nBy making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums.\n    ",
        "python": "\n    ```python\ndef nextPermutation(nums):\n    n, k = len(nums), -1\n    for i in range(n - 1, 0, -1):\n        if nums[i - 1] < nums[i]:\n            k = i - 1\n            break\n    if k == -1:\n        nums.reverse()\n    else:\n        l = 0\n        for i in range(n - 1, k, -1):\n            if nums[i] > nums[k]:\n                l = i\n                break\n        nums[k], nums[l] = nums[l], nums[k]\n        nums[k + 1:] = reversed(nums[k + 1:])\n```\n    \n    We can solve this problem by following the steps below:\n\n1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.\n2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\n3. Swap the value of `nums[k]` with that of `nums[l]`.\n4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.\n\nBy making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums.\n    ",
        "javascript": "\n    ```javascript\nfunction nextPermutation(nums) {\n    let n = nums.length, k = n - 2, l;\n    while(k >= 0 && nums[k] >= nums[k + 1]) k--;\n\n    if(k < 0) {\n        nums.sort((a, b) => a - b);\n    } else {\n        for (l = n - 1; l > k; l--) {\n            if (nums[l] > nums[k]) break;\n        }\n        [nums[k], nums[l]] = [nums[l], nums[k]];\n        let tempArr = nums.slice(k + 1).sort((a, b) => a - b);\n        nums.splice(k + 1, n - k - 1, ...tempArr);\n    }\n}\n```\n    \n    We can solve this problem by following the steps below:\n\n1. Identify the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, the permutation is sorted in descending order, so we just need to reverse the array.\n2. Identify the largest index `l` greater than `k` such that `nums[k] < nums[l]`.\n3. Swap the value of `nums[k]` with that of `nums[l]`.\n4. Reverse the sub-array `nums[k + 1:]` which is guaranteed to be in non-increasing order.\n\nBy making these changes in place and only using constant extra memory, we obtain the next permutation of the array nums.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3]",
                    "output": " [1,3,2]",
                    "explanation": null
                },
                {
                    "input": " nums = [3,2,1]",
                    "output": " [1,2,3]",
                    "explanation": null
                },
                {
                    "input": " nums = [1,1,5]",
                    "output": " [1,5,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "[1,3,2]"
                },
                {
                    "input": "[3,2,1]",
                    "output": "[1,2,3]"
                },
                {
                    "input": "[1,1,5]",
                    "output": "[1,5,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-13",
        "prompt": "A **permutation** of an array of integers is an arrangement of its members into a sequence or linear order.\n\n*   For example, for `arr = [1,2,3]`, the following are all the permutations of `arr`: `[1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]`.\n\nThe **next permutation** of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the **next permutation** of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n*   For example, the next permutation of `arr = [1,2,3]` is `[1,3,2]`.\n*   Similarly, the next permutation of `arr = [2,3,1]` is `[3,1,2]`.\n*   While the next permutation of `arr = [3,2,1]` is `[1,2,3]` because `[3,2,1]` does not have a lexicographical larger rearrangement.\n\nGiven an array of integers `nums`, _find the next permutation of_ `nums`.\n\nThe replacement must be **[in place](http://en.wikipedia.org/wiki/In-place_algorithm)** and use only constant extra memory."
    },
    "leetcode-benchmark-14": {
        "id": "leetcode-benchmark-14",
        "title": "Search in Rotated Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\n\nGiven the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 0\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\], target = 3\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\], target = 0\n**Output:** -1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   All values of `nums` are **unique**.\n*   `nums` is an ascending array that is possibly rotated.\n*   `-104 <= target <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "c++": "\n    ```cpp\nint search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "python": "\n    ```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return mid\n        if nums[mid] >= nums[left]:\n            if target >= nums[left] and target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if target > nums[mid] and target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return -1\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "javascript": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        }\n        if (nums[mid] >= nums[left]) {\n            if (target >= nums[left] && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (target > nums[mid] && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return -1;\n}\n```\n    \n    The algorithm is a variation of binary search. The main idea is to decide whether the target is in the left or the right half of the current subarray. If nums[mid] >= nums[left], the left half is sorted. If target is in the range [nums[left], nums[mid]), set right = mid - 1. Otherwise, set left = mid + 1. If nums[mid] < nums[left], the right half must be sorted. If target is in the range (nums[mid], nums[right]], set left = mid + 1. Otherwise, set right = mid - 1. Continue the process until the target is found or the subarray is empty, in which case return -1. This algorithm has a runtime complexity of O(log n) because it eliminates half of the remaining elements at each step, similar to a binary search.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [4,5,6,7,0,1,2], target = 0",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " nums = [4,5,6,7,0,1,2], target = 3",
                    "output": " -1",
                    "explanation": null
                },
                {
                    "input": " nums = [1], target = 0",
                    "output": " -1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[4,5,6,7,0,1,2],0",
                    "output": "4"
                },
                {
                    "input": "[4,5,6,7,0,1,2],3",
                    "output": "-1"
                },
                {
                    "input": "[1],0",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-14",
        "prompt": "There is an integer array `nums` sorted in ascending order (with **distinct** values).\n\nPrior to being passed to your function, `nums` is **possibly rotated** at an unknown pivot index `k` (`1 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,5,6,7]` might be rotated at pivot index `3` and become `[4,5,6,7,0,1,2]`.\n\nGiven the array `nums` **after** the possible rotation and an integer `target`, return _the index of_ `target` _if it is in_ `nums`_, or_ `-1` _if it is not in_ `nums`.\n\nYou must write an algorithm with `O(log n)` runtime complexity."
    },
    "leetcode-benchmark-15": {
        "id": "leetcode-benchmark-15",
        "title": "Find First and Last Position of Element in Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 8\n**Output:** \\[3,4\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,7,7,8,8,10\\], target = 6\n**Output:** \\[-1,-1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** \\[-1,-1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`\n*   `nums` is a non-decreasing array.\n*   `-109 <= target <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] searchRange(int[] nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0;\n    right = nums.length - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return new int[] {start, end};\n}\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> searchRange(std::vector<int>& nums, int target) {\n    int start = -1, end = -1;\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] == target) {\n                start = mid;\n            }\n        }\n    }\n    \n    left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] == target) {\n                end = mid;\n            }\n        }\n    }\n    \n    return {start, end};\n}\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "python": "\n    ```python\ndef searchRange(nums, target):\n    start, end = -1, -1\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n            if nums[mid] == target:\n                start = mid\n\n    left, right = 0, len(nums) - 1\n    \n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] > target:right = mid - 1\n        else:\n            left = mid + 1\n            if nums[mid] == target:\n                end = mid\n    \n    return [start, end]\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "javascript": "\n    ```javascript\nfunction searchRange(nums, target) {\n    let start = -1, end = -1;\n    let left = 0, right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n            if (nums[mid] === target) {\n                start = mid;\n            }\n        }\n    }\n\n    left = 0;\n    right = nums.length - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > target) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n            if (nums[mid] === target) {\n                end = mid;\n            }\n        }\n    }\n\n    return [start, end];\n}\n```\n    \n    1. Initialize `start` and `end` variables to -1 as default return values.\n2. Setup `left` and `right` pointers at the beginning and end of the `nums` array.\n3. Loop until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is smaller than `target`, move the `left` pointer to `mid + 1`.\n   c. If the value at the `mid` index is greater than or equal to `target`, move the `right` pointer to `mid - 1`. If the value at the `mid` index is equal to `target`, update `start` with `mid`.\n4. Reset `left` and `right` pointers to the beginning and end of the `nums` array.\n5. Loop again until `left` is greater than `right`:\n   a. Calculate the `mid` index.\n   b. If the value at the `mid` index is greater than `target`, move the `right` pointer to `mid - 1`.\n   c. If the value at the `mid` index is smaller than or equal to `target`, move the `left` pointer to `mid + 1`. If the value at the `mid` index is equal to `target`, update `end` with `mid`.\n6. Return the resulting `start` and `end` values as an array/list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [5,7,7,8,8,10], target = 8",
                    "output": " [3,4]",
                    "explanation": null
                },
                {
                    "input": " nums = [5,7,7,8,8,10], target = 6",
                    "output": " [-1,-1]",
                    "explanation": null
                },
                {
                    "input": " nums = [], target = 0",
                    "output": " [-1,-1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[5,7,7,8,8,10],8",
                    "output": "[3,4]"
                },
                {
                    "input": "[5,7,7,8,8,10],6",
                    "output": "[-1,-1]"
                },
                {
                    "input": "[],0",
                    "output": "[-1,-1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-15",
        "prompt": "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.\n\nIf `target` is not found in the array, return `[-1, -1]`.\n\nYou must write an algorithm with `O(log n)` runtime complexity."
    },
    "leetcode-benchmark-16": {
        "id": "leetcode-benchmark-16",
        "title": "Valid Sudoku",
        "difficulty": "Medium",
        "content": {
            "problem": "Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:\n\n1.  Each row must contain the digits `1-9` without repetition.\n2.  Each column must contain the digits `1-9` without repetition.\n3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.\n\n**Note:**\n\n*   A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n*   Only the filled cells need to be validated according to the mentioned rules.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \n\\[\\[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\]\n,\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\]\n,\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\]\n,\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\]\n,\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\]\n,\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\]\n,\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\]\n,\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\]\n,\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** board = \n\\[\\[ \"8 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"\\]\n,\\[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"\\]\n,\\[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"\\]\n,\\[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"\\]\n,\\[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"\\]\n,\\[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"\\]\n,\\[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"\\]\n,\\[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"\\]\n,\\[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"\\]\\]\n**Output:** false\n**Explanation:** Same as Example 1, except with the **5** in the top left corner being modified to **8**. Since there are two 8's in the top left 3x3 sub-box, it is invalid."
            ],
            "constraints": "**Constraints:**\n\n*   `board.length == 9`\n*   `board[i].length == 9`\n*   `board[i][j]` is a digit `1-9` or `'.'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isValidSudoku(char[][] board) {\n    HashSet<String> seen = new HashSet<>();\n    \n    for(int i = 0; i < 9; i++) {\n        for(int j = 0; j < 9; j++) {\n            char current_val = board[i][j];\n            if(current_val != '.') {\n                String row = current_val + \" in row \" + i;\n                String col = current_val + \" in col \" + j;\n                String box = current_val + \" in box \" + i / 3 + \"-\" + j / 3;\n                if(seen.contains(row) || seen.contains(col) || seen.contains(box)) {\n                    return false;\n                }\n                seen.add(row);\n                seen.add(col);\n                seen.add(box);\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    Iterate through the entire board and check each value. If it's not an empty cell, construct a row identifier, a column identifier, and a box identifier. Check if any of these identifiers have been seen before; if so, return false. If not, add these identifiers to the 'seen' set. Once the entire board has been traversed, return true as no conflicts have been found.\n    ",
        "c++": "\n    ```cpp\nbool isValidSudoku(vector<vector<char>>& board) {\n    unordered_set<string> seen;\n    \n    for(int i = 0; i < 9; i++) {\n        for(int j = 0; j < 9; j++) {\n            char current_val = board[i][j];\n            if(current_val != '.') {\n                string row = to_string(current_val) + \" in row \" + to_string(i);\n                string col = to_string(current_val) + \" in col \" + to_string(j);\n                string box = to_string(current_val) + \" in box \" + to_string(i/3) + \"-\" + to_string(j/3);\n                if(seen.count(row) || seen.count(col) || seen.count(box)) {\n                    return false;\n                }\n                seen.insert(row);\n                seen.insert(col);\n                seen.insert(box);\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    Iterate through the entire board and check each value. If it's not an empty cell, construct a row identifier, a column identifier, and a box identifier. Check if any of these identifiers have been seen before; if so, return false. If not, add these identifiers to the 'seen' set. Once the entire board has been traversed, return true as no conflicts have been found.\n    ",
        "python": "\n    ```python\ndef isValidSudoku(board):\n    seen = set()\n\n    for i in range(9):\n        for j in range(9):\n            current_val = board[i][j]\n            \n            if current_val != '.':\n                row = f\"{current_val} in row {i}\"\n                col = f\"{current_val} in col {j}\"\n                box = f\"{current_val} in box {i // 3}-{j // 3}\"\n                \n                if row in seen or col in seen or box in seen:\n                    return False\n\n                seen.add(row)\n                seen.add(col)\n                seen.add(box)\n\n    return True\n```\n\n    \n    Iterate through the entire board and check each value. If it's not an empty cell, construct a row identifier, a column identifier, and a box identifier. Check if any of these identifiers have been seen before; if so, return false. If not, add these identifiers to the 'seen' set. Once the entire board has been traversed, return true as no conflicts have been found.\n    ",
        "javascript": "\n    ```javascript\nfunction isValidSudoku(board) {\n    let seen = new Set();\n    \n    for(let i = 0; i < 9; i++) {\n        for(let j = 0; j < 9; j++) {\n            let current_val = board[i][j];\n            if(current_val !== '.') {\n                let row = `${current_val} in row ${i}`;\n                let col = `${current_val} in col ${j}`;\n                let box = `${current_val} in box ${Math.floor(i/3)}-${Math.floor(j/3)}`;\n                \n                if(seen.has(row) || seen.has(col) || seen.has(box)) {\n                    return false;\n                }\n                seen.add(row);\n                seen.add(col);\n                seen.add(box);\n            }\n        }\n    }\n    return true;\n}\n```\n\n    \n    Iterate through the entire board and check each value. If it's not an empty cell, construct a row identifier, a column identifier, and a box identifier. Check if any of these identifiers have been seen before; if so, return false. If not, add these identifiers to the 'seen' set. Once the entire board has been traversed, return true as no conflicts have been found.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = \n[[ \"5 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"]\n,[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"]\n,[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"]\n,[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"]\n,[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"]\n,[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"]\n,[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"]\n,[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"]\n,[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"]]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " board = \n[[ \"8 \", \"3 \", \". \", \". \", \"7 \", \". \", \". \", \". \", \". \"]\n,[ \"6 \", \". \", \". \", \"1 \", \"9 \", \"5 \", \". \", \". \", \". \"]\n,[ \". \", \"9 \", \"8 \", \". \", \". \", \". \", \". \", \"6 \", \". \"]\n,[ \"8 \", \". \", \". \", \". \", \"6 \", \". \", \". \", \". \", \"3 \"]\n,[ \"4 \", \". \", \". \", \"8 \", \". \", \"3 \", \". \", \". \", \"1 \"]\n,[ \"7 \", \". \", \". \", \". \", \"2 \", \". \", \". \", \". \", \"6 \"]\n,[ \". \", \"6 \", \". \", \". \", \". \", \". \", \"2 \", \"8 \", \". \"]\n,[ \". \", \". \", \". \", \"4 \", \"1 \", \"9 \", \". \", \". \", \"5 \"]\n,[ \". \", \". \", \". \", \". \", \"8 \", \". \", \". \", \"7 \", \"9 \"]]",
                    "output": " False",
                    "explanation": " Same as Example 1, except with the **5** in the top left corner being modified to **8**. Since there are two 8's in the top left 3x3 sub-box, it is invalid."
                }
            ],
            "function_input": [
                {
                    "input": "\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "True"
                },
                {
                    "input": "\n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-16",
        "prompt": "Determine if a `9 x 9` Sudoku board is valid. Only the filled cells need to be validated **according to the following rules**:\n\n1.  Each row must contain the digits `1-9` without repetition.\n2.  Each column must contain the digits `1-9` without repetition.\n3.  Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without repetition.\n\n**Note:**\n\n*   A Sudoku board (partially filled) could be valid but is not necessarily solvable.\n*   Only the filled cells need to be validated according to the mentioned rules."
    },
    "leetcode-benchmark-17": {
        "id": "leetcode-benchmark-17",
        "title": "Count and Say",
        "difficulty": "Medium",
        "content": {
            "problem": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n\n*   `countAndSay(1) = \"1 \"`\n*   `countAndSay(n)` is the way you would \"say \" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say \" a digit string, split it into the **minimal** number of substrings such that each substring contains exactly **one** unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n\nFor example, the saying and conversion for digit string `\"3322251 \"`:\n\nGiven a positive integer `n`, return _the_ `nth` _term of the **count-and-say** sequence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:**  \"1 \"\n**Explanation:** This is the base case.\n\n",
                "**Example 2:**\n\n**Input:** n = 4\n**Output:**  \"1211 \"\n**Explanation:**\ncountAndSay(1) =  \"1 \"\ncountAndSay(2) = say  \"1 \" = one 1 =  \"11 \"\ncountAndSay(3) = say  \"11 \" = two 1's =  \"21 \"\ncountAndSay(4) = say  \"21 \" = one 2 + one 1 =  \"12 \" +  \"11 \" =  \"1211 \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 30`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String countAndSay(int n) {\n    if (n == 1) return \"1\";\n    String previous = countAndSay(n-1);\n    StringBuilder result = new StringBuilder();\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous.charAt(i) == previous.charAt(i-1)) {\n            count++;\n        } else {\n            result.append(count).append(previous.charAt(i-1));\n            count = 1;\n        }\n    }\n    result.append(count).append(previous.charAt(previous.length()-1));\n    return result.toString();\n}\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string previous = countAndSay(n-1);\n    std::string result = \"\";\n    int count = 1;\n    for (int i = 1; i < previous.length(); i++) {\n        if (previous[i] == previous[i-1]) {\n            count++;\n        } else {\n            result += std::to_string(count) + previous[i-1];\n            count = 1;\n        }\n    }\n    result += std::to_string(count) + previous.back();\n    return result;\n}\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "python": "\n    ```python\ndef count_and_say(n):\n    if n == 1:\n        return \"1\"\n    previous = count_and_say(n - 1)\n    result = []\n    count = 1\n    for i in range(1, len(previous)):\n        if previous[i] == previous[i - 1]:\n            count += 1\n        else:\n            result.append(str(count))\n            result.append(previous[i - 1])\n            count = 1\n    result.append(str(count))\n    result.append(previous[-1])\n    return \"\".join(result)\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "javascript": "\n    ```javascript\nfunction countAndSay(n) {\n    if (n === 1) return \"1\";\n    let previous = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n    for (let i = 1; i < previous.length; i++) {\n        if (previous[i] === previous[i - 1]) {\n            count++;\n        } else {\n            result += count.toString() + previous[i - 1];\n            count = 1;\n        }\n    }\n    result += count.toString() + previous[previous.length - 1];\n    return result;\n}\n```\n    \n    The algorithm is a recursive solution. It starts with the base case, when `n` is 1, it returns the first term of the sequence \"1\". In other cases, it makes a recursive call to the function with `n-1` to get the previous term in the sequence. Then it iterates through the previous term, comparing each character with the previous one to count the number of consecutive equal digits. When it encounters a different character, it appends the count and the character to the result string and resets the count to 1. Finally, it appends the last count and character to the result string and returns it.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 1",
                    "output": "  \"1 \"",
                    "explanation": " This is the base case."
                },
                {
                    "input": " n = 4",
                    "output": "  \"1211 \"",
                    "explanation": "\ncountAndSay(1) =  \"1 \"\ncountAndSay(2) = say  \"1 \" = one 1 =  \"11 \"\ncountAndSay(3) = say  \"11 \" = two 1's =  \"21 \"\ncountAndSay(4) = say  \"21 \" = one 2 + one 1 =  \"12 \" +  \"11 \" =  \"1211 \""
                }
            ],
            "function_input": [
                {
                    "input": "1",
                    "output": "\"1\""
                },
                {
                    "input": "4",
                    "output": "\"1211\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-17",
        "prompt": "The **count-and-say** sequence is a sequence of digit strings defined by the recursive formula:\n\n*   `countAndSay(1) = \"1 \"`\n*   `countAndSay(n)` is the way you would \"say \" the digit string from `countAndSay(n-1)`, which is then converted into a different digit string.\n\nTo determine how you \"say \" a digit string, split it into the **minimal** number of substrings such that each substring contains exactly **one** unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\n\nFor example, the saying and conversion for digit string `\"3322251 \"`:\n\nGiven a positive integer `n`, return _the_ `nth` _term of the **count-and-say** sequence_."
    },
    "leetcode-benchmark-18": {
        "id": "leetcode-benchmark-18",
        "title": "Combination Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.",
            "examples": [
                "**Example 1:**\n\n**Input:** candidates = \\[2,3,6,7\\], target = 7\n**Output:** \\[\\[2,2,3\\],\\[7\\]\\]\n**Explanation:**\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\n\n",
                "**Example 2:**\n\n**Input:** candidates = \\[2,3,5\\], target = 8\n**Output:** \\[\\[2,2,2,2\\],\\[2,3,3\\],\\[3,5\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** candidates = \\[2\\], target = 1\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= candidates.length <= 30`\n*   `2 <= candidates[i] <= 40`\n*   All elements of `candidates` are **distinct**.\n*   `1 <= target <= 40`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    findCombinations(candidates, target, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void findCombinations(int[] candidates, int target, int startIndex, List<Integer> current, List<List<Integer>> result) {\n    if (target == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n    if (startIndex == candidates.length || target < 0) {\n        return;\n    }\n\n    findCombinations(candidates, target, startIndex + 1, current, result);\n\n    current.add(candidates[startIndex]);\n    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\n    current.remove(current.size() - 1);\n}\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid findCombinations(std::vector<int>& candidates, int target, int startIndex, std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    if (target == 0) {\n        result.push_back(current);\n        return;\n    }\n    if (startIndex == candidates.size() || target < 0) {\n        return;\n    }\n\n    findCombinations(candidates, target, startIndex + 1, current, result);\n\n    current.push_back(candidates[startIndex]);\n    findCombinations(candidates, target - candidates[startIndex], startIndex, current, result);\n    current.pop_back();\n}\n\nstd::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {\n    std::vector<int> current;\n    std::vector<std::vector<int>> result;\n    findCombinations(candidates, target, 0, current, result);\n    return result;\n}\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "python": "\n    ```python\ndef combinationSum(candidates, target):\n    def findCombinations(startIndex, remaining):\n        if remaining == 0:\n            return [[]]\n        if startIndex == len(candidates) or remaining < 0:\n            return []\n\n        result = []\n        result.extend(findCombinations(startIndex + 1, remaining))\n        result.extend([x + [candidates[startIndex]] for x in findCombinations(startIndex, remaining - candidates[startIndex])])\n        \n        return result\n\n    return findCombinations(0, target)\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "javascript": "\n    ```javascript\nfunction combinationSum(candidates, target) {\n    function findCombinations(startIndex, remaining) {\n        if (remaining === 0) {\n            return [[]];\n        }\n        if (startIndex === candidates.length || remaining < 0) {\n            return [];\n        }\n\n        let result = [];\n        result = result.concat(findCombinations(startIndex + 1, remaining));\n        result = result.concat(findCombinations(startIndex, remaining - candidates[startIndex]).map(x => x.concat([candidates[startIndex]])));\n\n        return result;\n    }\n\n    return findCombinations(0, target);\n}\n```\n\n    \n    The algorithm is a recursive backtracking algorithm. We define a helper function `findCombinations` that takes the following parameters:\n\n1. `startIndex`: the index of the candidates array from which it can start choosing numbers.\n2. `remaining`: the remaining sum needed to reach the target.\n\nThe base cases are:\n- If `remaining` is 0, it means we have found a valid combination, so we return a list containing an empty list.\n- If `startIndex` is equal to the length of candidates, or `remaining` is negative, there are no valid combinations, so we return an empty list.\n\nIn the function, we first initialize an empty list called `result`. Then, we make two recursive calls to `findCombinations`:\n\n1. Excluding the current candidate at `startIndex` and incrementing `startIndex`, to search for combinations without this candidate.\n2. Including the current candidate in the combination, and decreasing `remaining` accordingly (without updating `startIndex`).\n\nAfter getting results from both recursive calls, we merge them and return the final list of combinations.\n\nThe main function `combinationSum` calls `findCombinations` with `startIndex` as 0 and `remaining` as the target, and returns the result after the recursion is done.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " candidates = [2,3,6,7], target = 7",
                    "output": " [[2,2,3],[7]]",
                    "explanation": "\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations."
                },
                {
                    "input": " candidates = [2,3,5], target = 8",
                    "output": " [[2,2,2,2],[2,3,3],[3,5]]",
                    "explanation": null
                },
                {
                    "input": " candidates = [2], target = 1",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,6,7],7",
                    "output": "[[2,2,3],[7]]"
                },
                {
                    "input": "[2,3,5],8",
                    "output": "[[2,2,2,2],[2,3,3],[3,5]]"
                },
                {
                    "input": "[2],1",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-18",
        "prompt": "Given an array of **distinct** integers `candidates` and a target integer `target`, return _a list of all **unique combinations** of_ `candidates` _where the chosen numbers sum to_ `target`_._ You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input."
    },
    "leetcode-benchmark-19": {
        "id": "leetcode-benchmark-19",
        "title": "Combination Sum II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:** The solution set must not contain duplicate combinations.",
            "examples": [
                "**Example 1:**\n\n**Input:** candidates = \\[10,1,2,7,6,1,5\\], target = 8\n**Output:** \n\\[\n\\[1,1,6\\],\n\\[1,2,5\\],\n\\[1,7\\],\n\\[2,6\\]\n\\]\n\n",
                "**Example 2:**\n\n**Input:** candidates = \\[2,5,2,1,2\\], target = 5\n**Output:** \n\\[\n\\[1,2,2\\],\n\\[5\\]\n\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= candidates.length <= 100`\n*   `1 <= candidates[i] <= 50`\n*   `1 <= target <= 30`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(candidates);\n    combine(candidates, target, 0, result, new ArrayList<Integer>());\n    return result;\n}\n\nprivate void combine(int[] candidates, int target, int start, List<List<Integer>> result, List<Integer> current) {\n    if (target == 0) {\n        result.add(new ArrayList<>(current));\n        return;\n    }\n\n    for (int i = start; i < candidates.length && target >= candidates[i]; i++) {\n        if (i == start || candidates[i] != candidates[i - 1]) {\n            current.add(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, result, current);\n            current.remove(current.size() - 1);\n        }\n    }\n}\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nvoid combine(std::vector<int>& candidates, int target, std::vector<std::vector<int>>& result, std::vector<int>& combination, int index) {\n    if (target == 0) {\n        result.push_back(combination);\n        return;\n    }\n\n    for (int i = index; i < candidates.size() && target >= candidates[i]; ++i) {\n        if (i == index || candidates[i] != candidates[i - 1]) {\n            combination.push_back(candidates[i]);\n            combine(candidates, target - candidates[i], result, combination, i + 1);\n            combination.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum2(std::vector<int>& candidates, int target) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> combination;\n    std::sort(candidates.begin(), candidates.end());\n    combine(candidates, target, result, combination, 0);\n    return result;\n}\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "python": "\n    ```python\ndef combinationSum2(candidates, target):\n    def combine(candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > target:\n                break\n            combine(candidates, target - candidates[i], i+1, path + [candidates[i]], res)\n\n    candidates.sort()\n    res = []\n    combine(candidates, target, 0, [], res)\n    return res\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "javascript": "\n    ```javascript\nfunction combinationSum2(candidates, target) {\n    const result = [];\n    candidates.sort((a, b) => a - b);\n    combine(candidates, target, 0, [], result);\n    return result;\n}\n\nfunction combine(candidates, target, start, current, result) {\n    if (target === 0) {\n        result.push([...current]);\n        return;\n    }\n\n    for (let i = start; i < candidates.length && target >= candidates[i]; i++) {\n        if (i === start || candidates[i] !== candidates[i - 1]) {\n            current.push(candidates[i]);\n            combine(candidates, target - candidates[i], i + 1, current, result);\n            current.pop();\n        }\n    }\n}\n```\n\n    \n    The algorithm uses a backtracking approach to find all possible combinations. It starts by sorting the input `candidates` array/list. Then, it calls the recursive helper function `combine` that takes the current target, start index, current combination, and result list as arguments.\n\n1. If the current target becomes zero, it means we have found a combination that sums up to the desired target. Add the current combination to the result list and return.\n2. Iterate through the `candidates` list starting from the given index.\n   - If the current candidate is greater than the target, break the loop as adding more numbers won't make a valid combination.\n   - Skip the current iteration if the current candidate is equal to the previous one to avoid duplicate combinations.\n   - Add the current candidate to the current combination, and then call the `combine` function recursively with the updated target (target - current candidate) and incrementing the start index.\n   - After returning from the recursive call, remove the added candidate from the current combination (backtracking).\n\nAfter the backtracking process is completed, return the result list containing all unique combinations.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " candidates = [10,1,2,7,6,1,5], target = 8",
                    "output": " \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]",
                    "explanation": null
                },
                {
                    "input": " candidates = [2,5,2,1,2], target = 5",
                    "output": " \n[\n[1,2,2],\n[5]\n]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[10,1,2,7,6,1,5],8",
                    "output": "\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]"
                },
                {
                    "input": "[2,5,2,1,2],5",
                    "output": "\n[\n[1,2,2],\n[5]\n]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-19",
        "prompt": "Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:** The solution set must not contain duplicate combinations."
    },
    "leetcode-benchmark-20": {
        "id": "leetcode-benchmark-20",
        "title": "Multiply Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly.",
            "examples": [
                "**Example 1:**\n\n**Input:** num1 = \"2\", num2 = \"3\"\n**Output:** \"6\"\n\n",
                "**Example 2:**\n\n**Input:** num1 = \"123\", num2 = \"456\"\n**Output:** \"56088\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num1.length, num2.length <= 200`\n*   `num1` and `num2` consist of digits only.\n*   Both `num1` and `num2` do not contain any leading zero, except the number `0` itself.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String multiply(String num1, String num2) {\n    int m = num1.length(), n = num2.length();\n    int[] pos = new int[m + n];\n    \n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            int mult = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n            int p1 = i + j, p2 = i + j + 1;\n            int sum = mult + pos[p2];\n            pos[p1] += sum / 10;\n            pos[p2] = sum % 10;\n        }\n    }\n    \n    StringBuilder res = new StringBuilder();\n    for (int p : pos) if (!(res.length() == 0 && p == 0)) res.append(p);\n    return res.length() == 0 ? \"0\" : res.toString();\n}\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "c++": "\n    ```cpp\nstring multiply(string num1, string num2) {\n    int m = num1.size(), n = num2.size();\n    string res(m + n, '0');\n    for (int i = m - 1; i >= 0; i--) {\n        for (int j = n - 1; j >= 0; j--) {\n            int p1 = i + j, p2 = i + j + 1;\n            int mult = (num1[i] - '0') * (num2[j] - '0') + (res[p2] - '0');\n            res[p1] += mult / 10;\n            res[p2] = (mult % 10) + '0';\n        }\n    }\n    while (res.size() > 1 && res[0] == '0')\n        res.erase(res.begin());\n    return res;\n}\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "python": "\n    ```python\ndef multiply(num1, num2):\n    m, n = len(num1), len(num2)\n    pos = [0] * (m + n)\n    \n    for i in range(m-1, -1, -1):\n        for j in range(n-1, -1, -1):\n            mult = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))\n            p1, p2 = i + j, i + j + 1\n            total_pos = mult + pos[p2]\n            pos[p1] += total_pos // 10\n            pos[p2] = total_pos % 10\n            \n    res = ''.join(str(p) for p in pos if not (len(res) == 0 and p == 0))            \n    return '0' if len(res) == 0 else res\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "javascript": "\n    ```javascript\nfunction multiply(num1, num2) {\n    let m = num1.length, n = num2.length;\n    let pos = new Array(m + n).fill(0);\n    \n    for (let i = m - 1; i >= 0; i--) {\n        for (let j = n - 1; j >= 0; j--) {\n            let mult = (num1[i] - '0') * (num2[j] - '0');\n            let p1 = i + j, p2 = i + j + 1;\n            let sum = mult + pos[p2];\n            pos[p1] += Math.floor(sum / 10);\n            pos[p2] = sum % 10;\n        }\n    }\n    \n    while (pos.length > 1 && pos[0] == 0)\n        pos.shift();\n    return pos.join('');\n}\n```\n    \n    The algorithm follows a typical multiplication method where each digit of both numbers is multiplied pairwise, with the correct position shifted as you move through the digits. Then, the products of these digits are combined to form the final result.\n\n1. Initialize an array `pos` to store the intermediate results, with a size equal to the sum of the lengths of both input strings.\n2. Run two nested loops for each digit of both input numbers (from right to left).\n3. Calculate the product of the two digits.\n4. Determine the indices to store the product values in the `pos` array, e.g., in the form of tens and units.\n5. Update the `pos` array with the new product values.\n6. Combine the values in the `pos` array to form the final result string.\n\nThe time complexity is O(m*n) where `m` and `n` are the lengths of the input strings, `num1` and `num2`. The space complexity is also O(m+n).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num1 = \"2\", num2 = \"3\"",
                    "output": " \"6\"",
                    "explanation": null
                },
                {
                    "input": " num1 = \"123\", num2 = \"456\"",
                    "output": " \"56088\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"2\",\"3\"",
                    "output": "\"6\""
                },
                {
                    "input": "\"123\",\"456\"",
                    "output": "\"56088\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-20",
        "prompt": "Given two non-negative integers `num1` and `num2` represented as strings, return the product of `num1` and `num2`, also represented as a string.\n\n**Note:** You must not use any built-in BigInteger library or convert the inputs to integer directly."
    },
    "leetcode-benchmark-21": {
        "id": "leetcode-benchmark-21",
        "title": "Jump Game II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** 2\n**Explanation:** The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,3,0,1,4\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 1000`\n*   It's guaranteed that you can reach `nums[n - 1]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int jump(int[] nums) {\n    int jumps = 0, currentEnd = 0, currentFarthest = 0;\n    \n    for (int i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i == currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "c++": "\n    ```cpp\nint jump(vector<int>& nums) {\n    int jumps = 0, current_end = 0, current_farthest = 0;\n    \n    for (int i = 0; i < nums.size() - 1; i++) {\n        current_farthest = max(current_farthest, i + nums[i]);\n        if (i == current_end) {\n            jumps++;\n            current_end = current_farthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "python": "\n    ```python\ndef jump(nums):\n    jumps = 0\n    current_end = 0\n    current_farthest = 0\n\n    for i in range(len(nums) - 1):\n        current_farthest = max(current_farthest, i + nums[i])\n        if i == current_end:\n            jumps += 1\n            current_end = current_farthest\n\n    return jumps\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "javascript": "\n    ```javascript\nfunction jump(nums) {\n    let jumps = 0, currentEnd = 0, currentFarthest = 0;\n\n    for (let i = 0; i < nums.length - 1; i++) {\n        currentFarthest = Math.max(currentFarthest, i + nums[i]);\n        if (i === currentEnd) {\n            jumps++;\n            currentEnd = currentFarthest;\n        }\n    }\n    return jumps;\n}\n```\n    \n    We initialize jumps to count the number of jumps, current_end to keep track of the farthest index we can reach with the current number of jumps, and current_farthest to keep track of the farthest index that can be reached from the current position.\n\nWe loop through the array up to the second last element. For each index, we calculate and store the farthest index that can be reached from the current index. If the current index equals the current end, we increment the jumps, as we need one more jump to reach or go beyond the current end, and update the current_end with the current_farthest value.\n\nFinally, we return the number of jumps which represents the minimum number of jumps needed to reach the last index.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,3,1,1,4]",
                    "output": " 2",
                    "explanation": " The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index."
                },
                {
                    "input": " nums = [2,3,0,1,4]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,1,1,4]",
                    "output": "2"
                },
                {
                    "input": "[2,3,0,1,4]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-21",
        "prompt": "You are given a **0-indexed** array of integers `nums` of length `n`. You are initially positioned at `nums[0]`.\n\nEach element `nums[i]` represents the maximum length of a forward jump from index `i`. In other words, if you are at `nums[i]`, you can jump to any `nums[i + j]` where:\n\n*   `0 <= j <= nums[i]` and\n*   `i + j < n`\n\nReturn _the minimum number of jumps to reach_ `nums[n - 1]`. The test cases are generated such that you can reach `nums[n - 1]`."
    },
    "leetcode-benchmark-22": {
        "id": "leetcode-benchmark-22",
        "title": "Rotate Image",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[\\[7,4,1\\],\\[8,5,2\\],\\[9,6,3\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[5,1,9,11\\],\\[2,4,8,10\\],\\[13,3,6,7\\],\\[15,14,12,16\\]\\]\n**Output:** \\[\\[15,13,2,5\\],\\[14,3,4,1\\],\\[12,6,8,9\\],\\[16,7,10,11\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == matrix.length == matrix[i].length`\n*   `1 <= n <= 20`\n*   `-1000 <= matrix[i][j] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void rotate(int[][] matrix) {\n    int n = matrix.length;\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated.\n    ",
        "c++": "\n    ```cpp\nvoid rotate(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; i++) {\n        for (int j = i; j < n - i - 1; j++) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated.\n    ",
        "python": "\n    ```python\ndef rotate(matrix):\n    n = len(matrix)\n    for i in range(n // 2):\n        for j in range(i, n - i - 1):\n            temp = matrix[i][j]\n            matrix[i][j] = matrix[n - j - 1][i]\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]\n            matrix[j][n - i - 1] = temp\n```\n    \n    The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated.\n    ",
        "javascript": "\n    ```javascript\nfunction rotate(matrix) {\n    let n = matrix.length;\n    for (let i = 0; i < Math.floor(n / 2); i++) {\n        for (let j = i; j < n - i - 1; j++) {\n            let temp = matrix[i][j];\n            matrix[i][j] = matrix[n - j - 1][i];\n            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n            matrix[j][n - i - 1] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm iterates over each layer of the matrix gradually working inwards. For each element in the current layer, it performs a 4-way swap (moving elements from left -> top, bottom -> left, right -> bottom, and top -> right). This moves each element in the layer to its new position after rotation without using any additional memory. The algorithm proceeds with this strategy until it reaches the center of the matrix, ensuring that all elements are correctly rotated.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": " [[7,4,1],[8,5,2],[9,6,3]]",
                    "explanation": null
                },
                {
                    "input": " matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
                    "output": " [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[[7,4,1],[8,5,2],[9,6,3]]"
                },
                {
                    "input": "[[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]",
                    "output": "[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-22",
        "prompt": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by **90** degrees (clockwise).\n\nYou have to rotate the image [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm), which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation."
    },
    "leetcode-benchmark-23": {
        "id": "leetcode-benchmark-23",
        "title": "Pow(x, n)",
        "difficulty": "Medium",
        "content": {
            "problem": "Implement [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculates `x` raised to the power `n` (i.e., `xn`).",
            "examples": [
                "**Example 1:**\n\n**Input:** x = 2.00000, n = 10\n**Output:** 1024.00000\n\n",
                "**Example 2:**\n\n**Input:** x = 2.10000, n = 3\n**Output:** 9.26100\n\n",
                "**Example 3:**\n\n**Input:** x = 2.00000, n = -2\n**Output:** 0.25000\n**Explanation:** 2\\-2 = 1/22 = 1/4 = 0.25"
            ],
            "constraints": "**Constraints:**\n\n*   `-100.0 < x < 100.0`\n*   `-231 <= n <= 231-1`\n*   `n` is an integer.\n*   `-104 <= xn <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long i = n; i > 0; i /= 2) {\n        if ((i % 2) == 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "c++": "\n    ```cpp\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    double result = 1;\n    double currentProduct = x;\n    for (long long i = n; i; i /= 2) {\n        if ((i % 2) == 1) {\n            result = result * currentProduct;\n        }\n        currentProduct = currentProduct * currentProduct;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "python": "\n    ```python\ndef myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    result = 1\n    currentProduct = x\n    i = n\n    while i:\n        if i % 2 == 1:\n            result *= currentProduct\n        currentProduct *= currentProduct\n        i //= 2\n    return result\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "javascript": "\n    ```javascript\nfunction myPow(x, n) {\n    if (n === 0) return 1;\n    if (n < 0) {\n        x = 1 / x;\n        n = -n;\n    }\n    let result = 1;\n    let currentProduct = x;\n    for (let i = n; i > 0; i = Math.floor(i / 2)) {\n        if (i % 2 === 1) {\n            result *= currentProduct;\n        }\n        currentProduct *= currentProduct;\n    }\n    return result;\n}\n```\n    \n    The algorithm uses the binary exponentiation technique, which is a faster method of calculating x^n compared to the naive approach. It relies on the process of repeatedly multiplying the current product by itself and updating it after each iteration. The loop iterates through the bits of the exponent n, from the least significant to the most significant. If the current bit of n is 1, the result is multiplied by the current product. At the end of the loop, the current product is updated by squaring it. This process continues until all bits of the exponent have been processed.\n\nThe time complexity of the algorithm is O(log(n)) because the loop iterates through the bits of n, and the number of bits in n is proportional to the logarithm of n. The space complexity is O(1), as the space used by the temporary variables does not depend on the size of n.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " x = 2.00000, n = 10",
                    "output": " 1024.00000",
                    "explanation": null
                },
                {
                    "input": " x = 2.10000, n = 3",
                    "output": " 9.26100",
                    "explanation": null
                },
                {
                    "input": " x = 2.00000, n = -2",
                    "output": " 0.25000",
                    "explanation": " 2\\-2 = 1/22 = 1/4 = 0.25"
                }
            ],
            "function_input": [
                {
                    "input": "2.00000,10",
                    "output": "1024.00000"
                },
                {
                    "input": "2.10000,3",
                    "output": "9.26100"
                },
                {
                    "input": "2.00000,-2",
                    "output": "0.25000"
                }
            ]
        },
        "task_id": "leetcode-benchmark-23",
        "prompt": "Implement [pow(x, n)](http://www.cplusplus.com/reference/valarray/pow/), which calculates `x` raised to the power `n` (i.e., `xn`)."
    },
    "leetcode-benchmark-24": {
        "id": "leetcode-benchmark-24",
        "title": "Maximum Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,1,-3,4,-1,2,1,-5,4\\]\n**Output:** 6\n**Explanation:** The subarray \\[4,-1,2,1\\] has the largest sum 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 1\n**Explanation:** The subarray \\[1\\] has the largest sum 1.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[5,4,-1,7,8\\]\n**Output:** 23\n**Explanation:** The subarray \\[5,4,-1,7,8\\] has the largest sum 23."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`\n\n**",
            "follow_up": "Follow up:** If you have figured out the `O(n)` solution, try coding another solution using the **divide and conquer** approach, which is more subtle."
        },
        "java": "\n    ```java\npublic int maxSubArray(int[] nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n\n    for (int i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "c++": "\n    ```cpp\nint maxSubArray(vector<int>& nums) {\n    int max_sum = nums[0];\n    int current_sum = max_sum;\n    \n    for (int i = 1; i < nums.size(); i++) {\n        current_sum = max(current_sum + nums[i], nums[i]);\n        max_sum = max(max_sum, current_sum);\n    }\n    \n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "python": "\n    ```python\ndef maxSubArray(nums):\n    max_sum = current_sum = nums[0]\n\n    for num in nums[1:]:\n        current_sum = max(current_sum + num, num)\n        max_sum = max(max_sum, current_sum)\n\n    return max_sum\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "javascript": "\n    ```javascript\nfunction maxSubArray(nums) {\n    let max_sum = nums[0];\n    let current_sum = max_sum;\n\n    for (let i = 1; i < nums.length; i++) {\n        current_sum = Math.max(current_sum + nums[i], nums[i]);\n        max_sum = Math.max(max_sum, current_sum);\n    }\n\n    return max_sum;\n}\n```\n    \n    The algorithm uses the \"Kadane's Algorithm\" approach to find the maximum contiguous subarray sum. It iterates through the given array once and tracks the maximum sum found so far and the current sum.\n\nFor each element, we compare the sum of the current_sum with the element itself, and select the maximum of the two. This helps us to decide whether to continue the current contiguous subarray or start a new one from that element. Then, we compare the new current_sum with our global max_sum, and update max_sum if we find a larger value.\n\nIn the end, max_sum contains the largest sum of the contiguous subarray.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-2,1,-3,4,-1,2,1,-5,4]",
                    "output": " 6",
                    "explanation": " The subarray \\[4,-1,2,1\\] has the largest sum 6."
                },
                {
                    "input": " nums = [1]",
                    "output": " 1",
                    "explanation": " The subarray \\[1\\] has the largest sum 1."
                },
                {
                    "input": " nums = [5,4,-1,7,8]",
                    "output": " 23",
                    "explanation": " The subarray \\[5,4,-1,7,8\\] has the largest sum 23."
                }
            ],
            "function_input": [
                {
                    "input": "[-2,1,-3,4,-1,2,1,-5,4]",
                    "output": "6"
                },
                {
                    "input": "[1]",
                    "output": "1"
                },
                {
                    "input": "[5,4,-1,7,8]",
                    "output": "23"
                }
            ]
        },
        "task_id": "leetcode-benchmark-24",
        "prompt": "Given an integer array `nums`, find the subarray with the largest sum, and return _its sum_."
    },
    "leetcode-benchmark-25": {
        "id": "leetcode-benchmark-25",
        "title": "Spiral Matrix",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,2,3\\],\\[4,5,6\\],\\[7,8,9\\]\\]\n**Output:** \\[1,2,3,6,9,8,7,4,5\\]\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,2,3,4\\],\\[5,6,7,8\\],\\[9,10,11,12\\]\\]\n**Output:** \\[1,2,3,4,8,12,11,10,9,5,6,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 10`\n*   `-100 <= matrix[i][j] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> spiralOrder(int[][] matrix) {\n    List<Integer> result = new ArrayList<>();\n    if (matrix == null || matrix.length == 0) return result;\n    int m = matrix.length, n = matrix[0].length;\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; i++) {\n            result.add(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; i++) {\n            result.add(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; i--) {\n                result.add(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; i--) {\n                result.add(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\n    vector<int> result;\n    if (matrix.empty()) return result;\n    int m = matrix.size(), n = matrix[0].size();\n    int rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (int i = colStart; i <= colEnd; ++i) {\n            result.push_back(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (int i = rowStart; i <= rowEnd; ++i) {\n            result.push_back(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (int i = colEnd; i >= colStart; --i) {\n                result.push_back(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (int i = rowEnd; i >= rowStart; --i) {\n                result.push_back(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "python": "\n    ```python\ndef spiralOrder(matrix):\n    result = []\n    if not matrix: return result\n    m, n = len(matrix), len(matrix[0])\n    rowStart, colStart, rowEnd, colEnd = 0, 0, m - 1, n - 1\n\n    while rowStart <= rowEnd and colStart <= colEnd:\n        for i in range(colStart, colEnd + 1): \n            result.append(matrix[rowStart][i])\n        rowStart += 1\n        \n        for i in range(rowStart, rowEnd + 1): \n            result.append(matrix[i][colEnd]) \n        colEnd -= 1\n        \n        if rowStart <= rowEnd:\n            for i in range(colEnd, colStart - 1, -1): \n                result.append(matrix[rowEnd][i]) \n        rowEnd -= 1\n        \n        if colStart <= colEnd:\n            for i in range(rowEnd, rowStart - 1, -1): \n                result.append(matrix[i][colStart]) \n        colStart += 1\n        \n    return result\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "javascript": "\n    ```javascript\nfunction spiralOrder(matrix) {\n    const result = [];\n    if (!matrix.length) return result;\n    let m = matrix.length, n = matrix[0].length;\n    let rowStart = 0, colStart = 0, rowEnd = m - 1, colEnd = n - 1;\n\n    while (rowStart <= rowEnd && colStart <= colEnd) {\n        for (let i = colStart; i <= colEnd; i++) {\n            result.push(matrix[rowStart][i]);\n        }\n        rowStart++;\n        for (let i = rowStart; i <= rowEnd; i++) {\n            result.push(matrix[i][colEnd]);\n        }\n        colEnd--;\n        if (rowStart <= rowEnd) {\n            for (let i = colEnd; i >= colStart; i--) {\n                result.push(matrix[rowEnd][i]);\n            }\n        }\n        rowEnd--;\n        if (colStart <= colEnd) {\n            for (let i = rowEnd; i >= rowStart; i--) {\n                result.push(matrix[i][colStart]);\n            }\n        }\n        colStart++;\n    }\n    return result;\n}\n```\n    \n    The algorithm iterates over the matrix in a spiral order. Initialize the indices to keep track of the matrix boundaries. The algorithm goes from left to right, from top to bottom, from right to left, and then from bottom to top. With each iteration, update the matrix boundaries. The process continues until the row and column boundaries cross each other.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[1,2,3],[4,5,6],[7,8,9]]",
                    "output": " [1,2,3,6,9,8,7,4,5]",
                    "explanation": null
                },
                {
                    "input": " matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
                    "output": " [1,2,3,4,8,12,11,10,9,5,6,7]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2,3],[4,5,6],[7,8,9]]",
                    "output": "[1,2,3,6,9,8,7,4,5]"
                },
                {
                    "input": "[[1,2,3,4],[5,6,7,8],[9,10,11,12]]",
                    "output": "[1,2,3,4,8,12,11,10,9,5,6,7]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-25",
        "prompt": "Given an `m x n` `matrix`, return _all elements of the_ `matrix` _in spiral order_."
    },
    "leetcode-benchmark-26": {
        "id": "leetcode-benchmark-26",
        "title": "Jump Game",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,1,1,4\\]\n**Output:** true\n**Explanation:** Jump 1 step from index 0 to 1, then 3 steps to the last index.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,1,0,4\\]\n**Output:** false\n**Explanation:** You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 104`\n*   `0 <= nums[i] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canJump(int[] nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ",
        "c++": "\n    ```cpp\nbool canJump(vector<int>& nums) {\n    int maxReach = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i > maxReach) return false;\n        maxReach = max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ",
        "python": "\n    ```python\ndef canJump(nums):\n    max_reach = 0\n    for i, num in enumerate(nums):\n        if i > max_reach:\n            return False\n        max_reach = max(max_reach, i + num)\n    return True\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ",
        "javascript": "\n    ```javascript\nfunction canJump(nums) {\n    let maxReach = 0;\n    for (let i = 0; i < nums.length; ++i) {\n        if (i > maxReach) return false;\n        maxReach = Math.max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n```\n    \n    The algorithm iterates through the `nums` array, keeping track of the maximum reachable index in `maxReach`. In each iteration, it compares the current index `i` with `maxReach`. If `i` is greater than `maxReach`, it means that the last index cannot be reached. Otherwise, it updates the `maxReach` by taking the maximum value between the current `maxReach` and the sum of the current index `i` and the value of `nums[i]`. If the end of iteration is reached, it means that the last index can be reached, so the function returns true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,3,1,1,4]",
                    "output": " True",
                    "explanation": " Jump 1 step from index 0 to 1, then 3 steps to the last index."
                },
                {
                    "input": " nums = [3,2,1,0,4]",
                    "output": " False",
                    "explanation": " You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,1,1,4]",
                    "output": "True"
                },
                {
                    "input": "[3,2,1,0,4]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-26",
        "prompt": "You are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` _if you can reach the last index, or_ `false` _otherwise_."
    },
    "leetcode-benchmark-27": {
        "id": "leetcode-benchmark-27",
        "title": "Merge Intervals",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[2,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Output:** \\[\\[1,6\\],\\[8,10\\],\\[15,18\\]\\]\n**Explanation:** Since intervals \\[1,3\\] and \\[2,6\\] overlap, merge them into \\[1,6\\].\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[4,5\\]\\]\n**Output:** \\[\\[1,5\\]\\]\n**Explanation:** Intervals \\[1,4\\] and \\[4,5\\] are considered overlapping."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 104`\n*   `intervals[i].length == 2`\n*   `0 <= starti <= endi <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> merge(int[][] intervals) {\n    if (intervals.length == 0) return new ArrayList<>();\n\n    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n    List<int[]> result = new ArrayList<>();\n    result.add(intervals[0]);\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (result.get(result.size() - 1)[1] >= intervals[i][0]) {\n            result.get(result.size() - 1)[1] = Math.max(result.get(result.size() - 1)[1], intervals[i][1]);\n        } else {\n            result.add(intervals[i]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::vector<int>> merge(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return {};\n\n    std::sort(intervals.begin(), intervals.end());\n    std::vector<std::vector<int>> result;\n    result.push_back(intervals[0]);\n\n    for (int i = 1; i < intervals.size(); i++) {\n        if (result.back()[1] >= intervals[i][0]) {\n            result.back()[1] = std::max(result.back()[1], intervals[i][1]);\n        } else {\n            result.push_back(intervals[i]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "python": "\n    ```python\ndef merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort()\n    result = [intervals[0]]\n\n    for i in range(1, len(intervals)):\n        if result[-1][1] >= intervals[i][0]:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n        else:\n            result.append(intervals[i])\n\n    return result\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "javascript": "\n    ```javascript\nfunction merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    intervals.sort((a, b) => a[0] - b[0]);\n    const result = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (result[result.length - 1][1] >= intervals[i][0]) {\n            result[result.length - 1][1] = Math.max(result[result.length - 1][1], intervals[i][1]);\n        } else {\n            result.push(intervals[i]);\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm first sorts the intervals based on their start time. Then, it initializes an empty list `result` to store the merged intervals, and adds the first interval to `result`. Next, it iterates through the remaining intervals, comparing the end time of the last interval in `result` to the start time of the current interval. If they overlap (i.e., the end time of the last interval in `result` is greater than or equal to the start time of the current interval), then the end time of the last interval in `result` is updated to the maximum of its own end time and the end time of the current interval. Otherwise, the current interval is added to `result`. The process continues until all intervals have been processed, and `result` contains the merged, non-overlapping intervals covering the input intervals.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " intervals = [[1,3],[2,6],[8,10],[15,18]]",
                    "output": " [[1,6],[8,10],[15,18]]",
                    "explanation": " Since intervals \\[1,3\\] and \\[2,6\\] overlap, merge them into \\[1,6\\]."
                },
                {
                    "input": " intervals = [[1,4],[4,5]]",
                    "output": " [[1,5]]",
                    "explanation": " Intervals \\[1,4\\] and \\[4,5\\] are considered overlapping."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,3],[2,6],[8,10],[15,18]]",
                    "output": "[[1,6],[8,10],[15,18]]"
                },
                {
                    "input": "[[1,4],[4,5]]",
                    "output": "[[1,5]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-27",
        "prompt": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_."
    },
    "leetcode-benchmark-28": {
        "id": "leetcode-benchmark-28",
        "title": "Spiral Matrix II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** \\[\\[1,2,3\\],\\[8,9,4\\],\\[7,6,5\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 20`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic int[][] generateMatrix(int n) {\n    int[][] matrix = new int[n][n];\n    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (int i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (int i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (int i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (int i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++; bottom--; left++; right--;\n    }\n\n    return matrix;\n}\n```\n    \n    The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> generateMatrix(int n) {\n    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));\n    int value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (int i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (int i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (int i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (int i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++, bottom--, left++, right--;\n    }\n\n    return matrix;\n}\n```\n    \n    The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled.\n    ",
        "python": "\n    ```python\ndef generateMatrix(n: int) -> List[List[int]]:\n    matrix = [[0] * n for _ in range(n)]\n    value, top, bottom, left, right = 1, 0, n - 1, 0, n - 1\n\n    while value <= n * n:\n        for i in range(left, right + 1):\n            matrix[top][i] = value\n            value += 1\n\n        for i in range(top + 1, bottom + 1):\n            matrix[i][right] = value\n            value += 1\n\n        if top < bottom and left < right:\n            for i in range(right - 1, left - 1, -1):\n                matrix[bottom][i] = value\n                value += 1\n\n            for i in range(bottom - 1, top, -1):\n                matrix[i][left] = value\n                value += 1\n\n        top, bottom, left, right = top + 1, bottom - 1, left + 1, right - 1\n\n    return matrix\n```\n    \n    The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled.\n    ",
        "javascript": "\n    ```javascript\nfunction generateMatrix(n) {\n    const matrix = Array.from({ length: n }, () => new Array(n).fill(0));\n    let value = 1, top = 0, bottom = n - 1, left = 0, right = n - 1;\n\n    while (value <= n * n) {\n        for (let i = left; i <= right; i++) {\n            matrix[top][i] = value++;\n        }\n\n        for (let i = top + 1; i <= bottom; i++) {\n            matrix[i][right] = value++;\n        }\n\n        if (top < bottom && left < right) {\n            for (let i = right - 1; i >= left; i--) {\n                matrix[bottom][i] = value++;\n            }\n\n            for (let i = bottom - 1; i > top; i--) {\n                matrix[i][left] = value++;\n            }\n        }\n\n        top++, bottom--, left++, right--;\n    }\n\n    return matrix;\n}\n```\n    \n    The algorithm initializes an n x n matrix and defines variables to maintain the current top (row), bottom (row), left (column), and right (column) positions. The algorithm then loops through the four sides of the outer square/boundary of the matrix in clockwise order (top row left to right, right column top to bottom, bottom row right to left, left column bottom to top) and fills the elements with the numbers in sequence from 1 to n. After completing a boundary, update the top, bottom, left, and right variables to point to the next inner square/boundary, and repeat the process until every position in the matrix has been filled.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " [[1,2,3],[8,9,4],[7,6,5]]",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " [[1]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "[[1,2,3],[8,9,4],[7,6,5]]"
                },
                {
                    "input": "1",
                    "output": "[[1]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-28",
        "prompt": "Given a positive integer `n`, generate an `n x n` `matrix` filled with elements from `1` to `n2` in spiral order."
    },
    "leetcode-benchmark-29": {
        "id": "leetcode-benchmark-29",
        "title": "Unique Paths",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 3, n = 7\n**Output:** 28\n\n",
                "**Example 2:**\n\n**Input:** m = 3, n = 2\n**Output:** 3\n**Explanation:** From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int uniquePaths(int m, int n) {\n    int[][] dp = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "c++": "\n    ```cpp\nint uniquePaths(int m, int n) {\n    vector<vector<int>> dp(m, vector<int>(n, 1));\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "python": "\n    ```python\ndef uniquePaths(m, n):\n    dp = [[1] * n for _ in range(m)]\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    return dp[m - 1][n - 1]\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "javascript": "\n    ```javascript\nfunction uniquePaths(m, n) {\n    const dp = Array.from({ length: m }, () => Array(n).fill(1));\n    for (let i = 1; i < m; i++) {\n        for (let j = 1; j < n; j++) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n```\n    \n    The idea is to use dynamic programming to solve this problem. We create a 2D array `dp` with dimensions `m` x `n` to store the number of unique paths to reach each cell in the grid.\n\nInitially, we fill out the first row and first column of the `dp` array with 1 since there is only one way to reach any cell in the first row or first column: by moving either right along the first row or down along the first column.\n\nThen, for every other cell in the `dp` array, we can calculate the number of unique paths to that cell by summing the number of unique paths to the cell above it and to the cell to its left. We can do this because the robot can only move down or right, so the paths to the current cell must have come from those two directions.\n\nFinally, we return the value at the bottom-right corner of the `dp` array, which represents the number of unique paths the robot can take to reach the destination.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " m = 3, n = 7",
                    "output": " 28",
                    "explanation": null
                },
                {
                    "input": " m = 3, n = 2",
                    "output": " 3",
                    "explanation": " From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down"
                }
            ],
            "function_input": [
                {
                    "input": "3,7",
                    "output": "28"
                },
                {
                    "input": "3,2",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-29",
        "prompt": "There is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 109`."
    },
    "leetcode-benchmark-30": {
        "id": "leetcode-benchmark-30",
        "title": "Unique Paths II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`.",
            "examples": [
                "**Example 1:**\n\n**Input:** obstacleGrid = \\[\\[0,0,0\\],\\[0,1,0\\],\\[0,0,0\\]\\]\n**Output:** 2\n**Explanation:** There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right\n\n",
                "**Example 2:**\n\n**Input:** obstacleGrid = \\[\\[0,1\\],\\[0,0\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == obstacleGrid.length`\n*   `n == obstacleGrid[i].length`\n*   `1 <= m, n <= 100`\n*   `obstacleGrid[i][j]` is `0` or `1`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int uniquePathsWithObstacles(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0)\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else\n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "c++": "\n    ```cpp\nint uniquePathsWithObstacles(vector<vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    if (grid[0][0] == 1) return 0;\n    \n    grid[0][0] = 1;\n    for (int i = 1; i < m; ++i)\n        grid[i][0] = (grid[i][0] == 0 && grid[i - 1][0] == 1) ? 1 : 0;\n    for (int i = 1; i < n; ++i)\n        grid[0][i] = (grid[0][i] == 0 && grid[0][i - 1] == 1) ? 1 : 0;\n\n    for (int i = 1; i < m; ++i)\n        for (int j = 1; j < n; ++j)\n            if (grid[i][j] == 0) \n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            else \n                grid[i][j] = 0;\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "python": "\n    ```python\ndef uniquePathsWithObstacles(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] == 1:\n        return 0\n\n    grid[0][0] = 1\n    for i in range(1, m):\n        grid[i][0] = 1 if grid[i][0] == 0 and grid[i - 1][0] == 1 else 0\n    for i in range(1, n):\n        grid[0][i] = 1 if grid[0][i] == 0 and grid[0][i - 1] == 1 else 0\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j] == 0:\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n            else:\n                grid[i][j] = 0\n\n    return grid[m - 1][n - 1]\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "javascript": "\n    ```javascript\nfunction uniquePathsWithObstacles(grid) {\n    const m = grid.length;\n    const n = grid[0].length;\n    if (grid[0][0] === 1) return 0;\n\n    grid[0][0] = 1;\n    for (let i = 1; i < m; ++i) {\n        grid[i][0] = (grid[i][0] === 0 && grid[i - 1][0] === 1) ? 1 : 0;\n    }\n    for (let i = 1; i < n; ++i) {\n        grid[0][i] = (grid[0][i] === 0 && grid[0][i - 1] === 1) ? 1 : 0;\n    }\n\n    for (let i = 1; i < m; ++i) {\n        for (let j = 1; j < n; ++j) {\n            if (grid[i][j] === 0) {\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1];\n            } else {\n                grid[i][j] = 0;\n            }\n        }\n    }\n\n    return grid[m - 1][n - 1];\n}\n```\n    \n    1. If the starting point has an obstacle, return 0 as there is no valid path.\n2. Initialize the first cell of the grid as 1 and process the first row and column,\n   setting their values to 1 if the cell is not an obstacle and if the previous cell is not an obstacle.\n3. Iterate through the grid starting from the second row and column, and for each cell, if it's not an obstacle, set its value to the sum of the values of the cells above it and to its left.\n4. Return the value of the bottom-right corner of the grid, which is the number of unique paths.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]",
                    "output": " 2",
                    "explanation": " There is one obstacle in the middle of the 3x3 grid above.\nThere are two ways to reach the bottom-right corner:\n1. Right -> Right -> Down -> Down\n2. Down -> Down -> Right -> Right"
                },
                {
                    "input": " obstacleGrid = [[0,1],[0,0]]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,0,0],[0,1,0],[0,0,0]]",
                    "output": "2"
                },
                {
                    "input": "[[0,1],[0,0]]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-30",
        "prompt": "You are given an `m x n` integer array `grid`. There is a robot initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nAn obstacle and space are marked as `1` or `0` respectively in `grid`. A path that the robot takes cannot include **any** square that is an obstacle.\n\nReturn _the number of possible unique paths that the robot can take to reach the bottom-right corner_.\n\nThe testcases are generated so that the answer will be less than or equal to `2 * 109`."
    },
    "leetcode-benchmark-31": {
        "id": "leetcode-benchmark-31",
        "title": "Minimum Path Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[1,3,1\\],\\[1,5,1\\],\\[4,2,1\\]\\]\n**Output:** 7\n**Explanation:** Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum.\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[1,2,3\\],\\[4,5,6\\]\\]\n**Output:** 12"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= grid[i][j] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minPathSum(int[][] grid) {\n    int m = grid.length, n = grid[0].length;\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "c++": "\n    ```cpp\nint minPathSum(vector<vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n        \n    for(int i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(int i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(int i = 1; i < m; i++){\n        for(int j = 1; j < n; j++){\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "python": "\n    ```python\ndef minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n\n    for i in range(1, m):\n        grid[i][0] += grid[i - 1][0]\n\n    for i in range(1, n):\n        grid[0][i] += grid[0][i - 1]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n\n    return grid[m - 1][n - 1]\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "javascript": "\n    ```javascript\nfunction minPathSum(grid) {\n    let m = grid.length, n = grid[0].length;\n        \n    for(let i = 1; i < m; i++)\n        grid[i][0] += grid[i - 1][0];\n        \n    for(let i = 1; i < n; i++)\n        grid[0][i] += grid[0][i - 1];\n        \n    for(let i = 1; i < m; i++){\n        for(let j = 1; j < n; j++){\n            grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n        }\n    }\n    return grid[m - 1][n - 1];\n}\n```\n    \n    The algorithm solves the problem through dynamic programming. It creates a table and fills it by the following rules:\n1. The first element of each row will be the sum of its previous row element and its current value.\n2. The first element of each column will be the sum of its previous column element and its current value.\n3. For all other elements, find the minimum path/components from its top (i-1,j) and left (i,j-1) neighbors, and then add its current value.\n\nAt the end of the loop, the bottom right cell contains the minimum path sum from the top left corner to the bottom right corner.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[1,3,1],[1,5,1],[4,2,1]]",
                    "output": " 7",
                    "explanation": " Because the path 1 -> 3 -> 1 -> 1 -> 1 minimizes the sum."
                },
                {
                    "input": " grid = [[1,2,3],[4,5,6]]",
                    "output": " 12",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,3,1],[1,5,1],[4,2,1]]",
                    "output": "7"
                },
                {
                    "input": "[[1,2,3],[4,5,6]]",
                    "output": "12"
                }
            ]
        },
        "task_id": "leetcode-benchmark-31",
        "prompt": "Given a `m x n` `grid` filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\n\n**Note:** You can only move either down or right at any point in time."
    },
    "leetcode-benchmark-32": {
        "id": "leetcode-benchmark-32",
        "title": "Simplify Path",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.\n\nIn a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.\n\nThe **canonical path** should have the following format:\n\n*   The path starts with a single slash `'/'`.\n*   Any two directories are separated by a single slash `'/'`.\n*   The path does not end with a trailing `'/'`.\n*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)\n\nReturn _the simplified **canonical path**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** path =  \"/home/ \"\n**Output:**  \"/home \"\n**Explanation:** Note that there is no trailing slash after the last directory name.\n\n",
                "**Example 2:**\n\n**Input:** path =  \"/../ \"\n**Output:**  \"/ \"\n**Explanation:** Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\n\n",
                "**Example 3:**\n\n**Input:** path =  \"/home//foo/ \"\n**Output:**  \"/home/foo \"\n**Explanation:** In the canonical path, multiple consecutive slashes are replaced by a single one."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= path.length <= 3000`\n*   `path` consists of English letters, digits, period `'.'`, slash `'/'` or `'_'`.\n*   `path` is a valid absolute Unix path.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.LinkedList;\n\npublic String simplifyPath(String path) {\n    String[] parts = path.split(\"/\");\n    LinkedList<String> stack = new LinkedList<>();\n\n    for (String part : parts) {\n        if (part.isEmpty() || part.equals(\".\")) continue;\n        if (part.equals(\"..\")) {\n            if (!stack.isEmpty()) stack.removeLast();\n        } else {\n            stack.addLast(part);\n        }\n    }\n\n    StringBuilder canonicalPath = new StringBuilder();\n    for (String piece : stack) {\n        canonicalPath.append('/').append(piece);\n    }\n    return stack.isEmpty() ? \"/\" : canonicalPath.toString();\n}\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <sstream>\n\nstd::string simplifyPath(std::string path) {\n    std::vector<std::string> stack;\n    std::istringstream ss{path};\n    std::string part;\n\n    while (std::getline(ss, part, '/')) {\n        if (part.empty() || part == \".\") continue;\n        if (part == \"..\") {\n            if (!stack.empty()) stack.pop_back();\n        } else {\n            stack.push_back(part);\n        }\n    }\n\n    std::string canonicalPath;\n    for (const auto &piece : stack) {\n        canonicalPath += '/' + piece;\n    }\n    return stack.empty() ? \"/\" : canonicalPath;\n}\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "python": "\n    ```python\ndef simplifyPath(path: str) -> str:\n    stack = []\n    parts = path.split(\"/\")\n\n    for part in parts:\n        if not part or part == \".\":\n            continue\n        if part == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(part)\n\n    return \"/\" + \"/\".join(stack)\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "javascript": "\n    ```javascript\nfunction simplifyPath(path) {\n    let stack = [];\n    let parts = path.split(\"/\");\n\n    for (let part of parts) {\n        if (!part || part === \".\") continue;\n        if (part === \"..\") {\n            if (stack.length) stack.pop();\n        } else {\n            stack.push(part);\n        }\n    }\n\n    return \"/\" + stack.join(\"/\");\n}\n```\n    \n    The algorithm uses a stack to keep track of the directory hierarchy. It starts by splitting the input string by '/', iterating over each part, and processing them according to the following rules:\n1. If the part is empty or \".\", skip it.\n2. If the part is \"..\", pop off the top element of the stack (if it's non-empty).\n3. Otherwise, push the part onto the stack.\n\nAfter processing all parts, concatenate the elements in the stack separated by '/' and return the canonical path.\n\nThe implementations are very similar across the four languages, with differences stemming primarily from the syntax and conventions of each language.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " path =  \"/home/ \"",
                    "output": "  \"/home \"",
                    "explanation": " Note that there is no trailing slash after the last directory name."
                },
                {
                    "input": " path =  \"/../ \"",
                    "output": "  \"/ \"",
                    "explanation": " Going one level up from the root directory is a no-op, as the root level is the highest level you can go."
                },
                {
                    "input": " path =  \"/home//foo/ \"",
                    "output": "  \"/home/foo \"",
                    "explanation": " In the canonical path, multiple consecutive slashes are replaced by a single one."
                }
            ],
            "function_input": [
                {
                    "input": "\"/home/\"",
                    "output": "\"/home\""
                },
                {
                    "input": "\"/../\"",
                    "output": "\"/\""
                },
                {
                    "input": "\"/home//foo/\"",
                    "output": "\"/home/foo\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-32",
        "prompt": "Given a string `path`, which is an **absolute path** (starting with a slash `'/'`) to a file or directory in a Unix-style file system, convert it to the simplified **canonical path**.\n\nIn a Unix-style file system, a period `'.'` refers to the current directory, a double period `'..'` refers to the directory up a level, and any multiple consecutive slashes (i.e. `'//'`) are treated as a single slash `'/'`. For this problem, any other format of periods such as `'...'` are treated as file/directory names.\n\nThe **canonical path** should have the following format:\n\n*   The path starts with a single slash `'/'`.\n*   Any two directories are separated by a single slash `'/'`.\n*   The path does not end with a trailing `'/'`.\n*   The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period `'.'` or double period `'..'`)\n\nReturn _the simplified **canonical path**_."
    },
    "leetcode-benchmark-33": {
        "id": "leetcode-benchmark-33",
        "title": "Set Matrix Zeroes",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,1,1\\],\\[1,0,1\\],\\[1,1,1\\]\\]\n**Output:** \\[\\[1,0,1\\],\\[0,0,0\\],\\[1,0,1\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[0,1,2,0\\],\\[3,4,5,2\\],\\[1,3,1,5\\]\\]\n**Output:** \\[\\[0,0,0,0\\],\\[0,4,5,0\\],\\[0,3,1,0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[0].length`\n*   `1 <= m, n <= 200`\n*   `-231 <= matrix[i][j] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:**\n\n*   A straightforward solution using `O(mn)` space is probably a bad idea.\n*   A simple improvement uses `O(m + n)` space, but still not the best solution.\n*   Could you devise a constant space solution?"
        },
        "java": "\n    ```java\npublic void setZeroes(int[][] matrix) {\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    boolean firstRow = false, firstCol = false;\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 0) {\n                if (i == 0) firstRow = true;\n                if (j == 0) firstCol = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 1; i < rows; i++) {\n        for (int j = 1; j < cols; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        }\n    }\n\n    if (firstRow) {\n        for (int j = 0; j < cols; j++)\n            matrix[0][j] = 0;\n    }\n\n    if (firstCol) {\n        for (int i = 0; i < rows; i++)\n            matrix[i][0] = 0;\n    }\n}\n```\n    \n    1. Iterate over the matrix, marking the first element of the row and column for every 0 encountered.\n2. Set a flag if the first row or the first column has a 0.\n3. Iterate over the matrix, ignoring the first row and first column. Set the element to 0 if the corresponding first row or column is marked.\n4. Finally, set the first row and column to 0 if their flags are set.\n    ",
        "c++": "\n    ```cpp\nvoid setZeroes(vector<vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n    bool firstRow = false, firstCol = false;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (matrix[i][j] == 0) {\n                if (i == 0) firstRow = true;\n                if (j == 0) firstCol = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 1; i < rows; i++) {\n        for (int j = 1; j < cols; j++) {\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\n                matrix[i][j] = 0;\n        }\n    }\n\n    if (firstRow) {\n        for (int j = 0; j < cols; j++)\n            matrix[0][j] = 0;\n    }\n\n    if (firstCol) {\n        for (int i = 0; i < rows; i++)\n            matrix[i][0] = 0;\n    }\n}\n```\n    \n    1. Iterate over the matrix, marking the first element of the row and column for every 0 encountered.\n2. Set a flag if the first row or the first column has a 0.\n3. Iterate over the matrix, ignoring the first row and first column. Set the element to 0 if the corresponding first row or column is marked.\n4. Finally, set the first row and column to 0 if their flags are set.\n    ",
        "python": "\n    ```python\ndef setZeroes(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    firstRow, firstCol = False, False\n\n    for i in range(rows):\n        for j in range(cols):\n            if matrix[i][j] == 0:\n                if i == 0: firstRow = True\n                if j == 0: firstCol = True\n                matrix[i][0] = 0\n                matrix[0][j] = 0\n\n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][0] == 0 or matrix[0][j] == 0:\n                matrix[i][j] = 0\n\n    if firstRow:\n        for j in range(cols):\n            matrix[0][j] = 0\n\n    if firstCol:\n        for i in range(rows):\n            matrix[i][0] = 0\n```\n    \n    1. Iterate over the matrix, marking the first element of the row and column for every 0 encountered.\n2. Set a flag if the first row or the first column has a 0.\n3. Iterate over the matrix, ignoring the first row and first column. Set the element to 0 if the corresponding first row or column is marked.\n4. Finally, set the first row and column to 0 if their flags are set.\n    ",
        "javascript": "\n    ```javascript\nfunction setZeroes(matrix) {\n    let rows = matrix.length;\n    let cols = matrix[0].length;\n    let firstRow = false;\n    let firstCol = false;\n \n    for (let i = 0; i < rows; i++) {\n        for (let j = 0; j < cols; j++) {\n            if (matrix[i][j] === 0) {\n                if (i === 0) firstRow = true;\n                if (j === 0) firstCol = true;\n                matrix[i][0] = 0;\n                matrix[0][j] = 0;\n            }\n        }\n    }\n    \n    for (let i = 1; i < rows; i++) {\n        for (let j = 1; j < cols; j++) {\n            if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n    \n    if (firstRow) {\n        for (let j = 0; j < cols; j++) \n            matrix[0][j] = 0;\n    }\n    \n    if (firstCol) {\n        for (let i = 0; i < rows; i++)\n            matrix[i][0] = 0;\n    }\n}\n```\n    \n    1. Iterate over the matrix, marking the first element of the row and column for every 0 encountered.\n2. Set a flag if the first row or the first column has a 0.\n3. Iterate over the matrix, ignoring the first row and first column. Set the element to 0 if the corresponding first row or column is marked.\n4. Finally, set the first row and column to 0 if their flags are set.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[1,1,1],[1,0,1],[1,1,1]]",
                    "output": " [[1,0,1],[0,0,0],[1,0,1]]",
                    "explanation": null
                },
                {
                    "input": " matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
                    "output": " [[0,0,0,0],[0,4,5,0],[0,3,1,0]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1,1],[1,0,1],[1,1,1]]",
                    "output": "[[1,0,1],[0,0,0],[1,0,1]]"
                },
                {
                    "input": "[[0,1,2,0],[3,4,5,2],[1,3,1,5]]",
                    "output": "[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-33",
        "prompt": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm)."
    },
    "leetcode-benchmark-34": {
        "id": "leetcode-benchmark-34",
        "title": "Search a 2D Matrix",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an `m x n` integer matrix `matrix` with the following two properties:\n\n*   Each row is sorted in non-decreasing order.\n*   The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_.\n\nYou must write a solution in `O(log(m * n))` time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,3,5,7\\],\\[10,11,16,20\\],\\[23,30,34,60\\]\\], target = 3\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,3,5,7\\],\\[10,11,16,20\\],\\[23,30,34,60\\]\\], target = 13\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 100`\n*   `-104 <= matrix[i][j], target <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int l = 0, r = m * n - 1;\n\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        int midVal = matrix[mid / n][mid % n];\n\n        if (midVal == target) {\n            return true;\n        } else if (midVal < target) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n\n    return false;\n}\n```\n    \n    The algorithm uses binary search on an m x n matrix.\n\nFirstly, the number of rows and columns (m and n) are computed. Then, we initialize the left and right pointers (l and r).\n\nIn each step of the binary search, we calculate the middle index (mid) and get the corresponding value (mid_val) in the matrix. To get the value in the matrix, we divide mid by n and take the remainder.\n\nWe then compare the mid_val with the target. If it is equal to the target, we return true. If it's less than the target, we move the left pointer to the next position (mid + 1). Otherwise, we move the right pointer (mid - 1).\n\nIf the search space has been fully explored and the target is not found, we return false.\n    ",
        "c++": "\n    ```cpp\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    int l = 0, r = m * n - 1;\n    \n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        int midVal = matrix[mid / n][mid % n];\n        \n        if (midVal == target) {\n            return true;\n        } else if (midVal < target) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n    \n    return false;\n}\n```\n    \n    The algorithm uses binary search on an m x n matrix.\n\nFirstly, the number of rows and columns (m and n) are computed. Then, we initialize the left and right pointers (l and r).\n\nIn each step of the binary search, we calculate the middle index (mid) and get the corresponding value (mid_val) in the matrix. To get the value in the matrix, we divide mid by n and take the remainder.\n\nWe then compare the mid_val with the target. If it is equal to the target, we return true. If it's less than the target, we move the left pointer to the next position (mid + 1). Otherwise, we move the right pointer (mid - 1).\n\nIf the search space has been fully explored and the target is not found, we return false.\n    ",
        "python": "\n    ```python\ndef searchMatrix(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    l, r = 0, m * n - 1\n\n    while l <= r:\n        mid = l + (r - l) // 2\n        mid_val = matrix[mid // n][mid % n]\n\n        if mid_val == target:\n            return True\n        elif mid_val < target:\n            l = mid + 1\n        else:\n            r = mid - 1\n\n    return False\n```\n    \n    The algorithm uses binary search on an m x n matrix.\n\nFirstly, the number of rows and columns (m and n) are computed. Then, we initialize the left and right pointers (l and r).\n\nIn each step of the binary search, we calculate the middle index (mid) and get the corresponding value (mid_val) in the matrix. To get the value in the matrix, we divide mid by n and take the remainder.\n\nWe then compare the mid_val with the target. If it is equal to the target, we return true. If it's less than the target, we move the left pointer to the next position (mid + 1). Otherwise, we move the right pointer (mid - 1).\n\nIf the search space has been fully explored and the target is not found, we return false.\n    ",
        "javascript": "\n    ```javascript\nfunction searchMatrix(matrix, target) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    let l = 0, r = m * n - 1;\n\n    while (l <= r) {\n        const mid = l+ Math.floor((r - l) / 2);\n        const midVal = matrix[Math.floor(mid / n)][mid % n];\n\n        if (midVal === target) {\n            return true;\n        } else if (midVal < target) {\n            l = mid + 1;\n        } else {\n            r = mid - 1;\n        }\n    }\n\n    return false;\n}\n```\n    \n    The algorithm uses binary search on an m x n matrix.\n\nFirstly, the number of rows and columns (m and n) are computed. Then, we initialize the left and right pointers (l and r).\n\nIn each step of the binary search, we calculate the middle index (mid) and get the corresponding value (mid_val) in the matrix. To get the value in the matrix, we divide mid by n and take the remainder.\n\nWe then compare the mid_val with the target. If it is equal to the target, we return true. If it's less than the target, we move the left pointer to the next position (mid + 1). Otherwise, we move the right pointer (mid - 1).\n\nIf the search space has been fully explored and the target is not found, we return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]],3",
                    "output": "True"
                },
                {
                    "input": "[[1,3,5,7],[10,11,16,20],[23,30,34,60]],13",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-34",
        "prompt": "You are given an `m x n` integer matrix `matrix` with the following two properties:\n\n*   Each row is sorted in non-decreasing order.\n*   The first integer of each row is greater than the last integer of the previous row.\n\nGiven an integer `target`, return `true` _if_ `target` _is in_ `matrix` _or_ `false` _otherwise_.\n\nYou must write a solution in `O(log(m * n))` time complexity."
    },
    "leetcode-benchmark-35": {
        "id": "leetcode-benchmark-35",
        "title": "Sort Colors",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,0,2,1,1,0\\]\n**Output:** \\[0,0,1,1,2,2\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,0,1\\]\n**Output:** \\[0,1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 300`\n*   `nums[i]` is either `0`, `1`, or `2`.\n\n**",
            "follow_up": "Follow up:** Could you come up with a one-pass algorithm using only constant extra space?"
        },
        "java": "\n    ```java\npublic void sortColors(int[] nums) {\n    int red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            int temp = nums[red];\n            nums[red++] = nums[white];\n            nums[white++] = temp;\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            int temp = nums[white];\n            nums[white] = nums[blue];\n            nums[blue--] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.\n\nWhile `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.\n\nThis will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage.\n    ",
        "c++": "\n    ```cpp\nvoid sortColors(vector<int>& nums) {\n    int red = 0, white = 0, blue = nums.size() - 1;\n    while (white <= blue) {\n        if (nums[white] == 0) {\n            swap(nums[red++], nums[white++]);\n        } else if (nums[white] == 1) {\n            white++;\n        } else {\n            swap(nums[white], nums[blue--]);\n        }\n    }\n}\n```\n    \n    The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.\n\nWhile `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.\n\nThis will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage.\n    ",
        "python": "\n    ```python\ndef sortColors(nums: List[int]) -> None:\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            red += 1\n            white += 1\n        elif nums[white] == 1:\n            white += 1\n        else:\n            nums[white], nums[blue] = nums[blue], nums[white]\n            blue -= 1\n```\n    \n    The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.\n\nWhile `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.\n\nThis will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage.\n    ",
        "javascript": "\n    ```javascript\nfunction sortColors(nums) {\n    let red = 0, white = 0, blue = nums.length - 1;\n    while (white <= blue) {\n        if (nums[white] === 0) {\n            [nums[red], nums[white]] = [nums[white], nums[red]];\n            red++;\n            white++;\n        } else if (nums[white] === 1) {\n            white++;\n        } else {\n            [nums[white], nums[blue]] = [nums[blue], nums[white]];\n            blue--;\n        }\n    }\n}\n```\n    \n    The algorithm can be explained using three pointers: `red`, `white`, and `blue`. `red` is responsible for tracking the position where the next 0 should be moved to, starting from the beginning of the array. Likewise, `blue` is responsible for tracking the position where the next 2 should be swapped to, starting from the end of the array. `white` is responsible for iterating through the array.\n\nWhile `white` is less than or equal to `blue`, check the current `nums[white]` value. If it is 0, swap it with the value at index `red`, and increment both `red` and `white`. If it is 1, simply increment `white`. If it is 2, swap the value at index `white` with the value at index `blue`, and decrement `blue` without incrementing `white` since the newly swapped value at index `white` might be 0 or 2.\n\nThis will sort the colors in the required order with a linear-time complexity, as we only go through the array once with the `white` pointer. Also, it sorts the colors in-place without the need for additional storage.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,0,2,1,1,0]",
                    "output": " [0,0,1,1,2,2]",
                    "explanation": null
                },
                {
                    "input": " nums = [2,0,1]",
                    "output": " [0,1,2]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,0,2,1,1,0]",
                    "output": "[0,0,1,1,2,2]"
                },
                {
                    "input": "[2,0,1]",
                    "output": "[0,1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-35",
        "prompt": "Given an array `nums` with `n` objects colored red, white, or blue, sort them **[in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function."
    },
    "leetcode-benchmark-36": {
        "id": "leetcode-benchmark-36",
        "title": "Subsets",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[\\[\\],\\[1\\],\\[2\\],\\[1,2\\],\\[3\\],\\[1,3\\],\\[2,3\\],\\[1,2,3\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0\\]\n**Output:** \\[\\[\\],\\[0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 10`\n*   `-10 <= nums[i] <= 10`\n*   All the numbers of `nums` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    int n = nums.length;\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        List<Integer> subset = new ArrayList<>();\n        for (int j = 0; j < n; ++j) {\n            if ((i & (1 << j)) != 0) {\n                subset.add(nums[j]);\n            }\n        }\n        result.add(subset);\n    }\n    return result;\n}\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) {\n    std::vector<std::vector<int>> result;\n    int n = nums.size();\n    int num_subsets = 1 << n;\n\n    for (int i = 0; i < num_subsets; ++i) {\n        std::vector<int> subset;\n        for (int j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push_back(nums[j]);\n            }\n        }\n        result.push_back(subset);\n    }\n    return result;\n}\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "python": "\n    ```python\ndef subsets(nums):\n    n = len(nums)\n    num_subsets = 1 << n\n    result = []\n\n    for i in range(num_subsets):\n        subset = []\n        for j in range(n):\n            if i & (1 << j):\n                subset.append(nums[j])\n        result.append(subset)\n    return result\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "javascript": "\n    ```javascript\nfunction subsets(nums) {\n    let result = [];\n    let n = nums.length;\n    let num_subsets = 1 << n;\n\n    for (let i = 0; i < num_subsets; ++i) {\n        let subset = [];\n        for (let j = 0; j < n; ++j) {\n            if (i & (1 << j)) {\n                subset.push(nums[j]);\n            }\n        }\n        result.push(subset);\n    }\n    return result;\n}\n```\n    \n    1. Calculate the number of subsets in the power set (2^n) using bit manipulation.\n2. Loop through all numbers from 0 to 2^n - 1.\n3. For each number, loop through its bits, and if the bit is set (1), include the corresponding element from the input array in the current subset.\n4. Add the current subset to the result list.\n5. After the loops finish, return the result list containing all subsets.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3]",
                    "output": " [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
                    "explanation": null
                },
                {
                    "input": " nums = [0]",
                    "output": " [[],[0]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
                },
                {
                    "input": "[0]",
                    "output": "[[],[0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-36",
        "prompt": "Given an integer array `nums` of **unique** elements, return _all possible_ _subsets_ _(the power set)_.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**."
    },
    "leetcode-benchmark-37": {
        "id": "leetcode-benchmark-37",
        "title": "Word Search",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"ABCCED \"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"SEE \"\n**Output:** true\n\n",
                "**Example 3:**\n\n**Input:** board = \\[\\[ \"A \", \"B \", \"C \", \"E \"\\],\\[ \"S \", \"F \", \"C \", \"S \"\\],\\[ \"A \", \"D \", \"E \", \"E \"\\]\\], word =  \"ABCB \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n = board[i].length`\n*   `1 <= m, n <= 6`\n*   `1 <= word.length <= 15`\n*   `board` and `word` consists of only lowercase and uppercase English letters.\n\n**",
            "follow_up": "Follow up:** Could you use search pruning to make your solution faster with a larger `board`?"
        },
        "java": "\n    ```java\npublic boolean exist(char[][] board, String word) {\n    int m = board.length;\n    int n = board[0].length;\n\n    boolean[][] visited = new boolean[m][n];\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dfs(board, i, j, 0, word, visited)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean dfs(char[][] board, int i, int j, int k, String word, boolean[][] visited) {\n    if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != word.charAt(k) || visited[i][j]) {\n        return false;\n    }\n\n    if (k == word.length() - 1) {\n        return true;\n    }\n\n    visited[i][j] = true;\n    boolean result = dfs(board, i + 1, j, k + 1, word, visited)\n            || dfs(board, i - 1, j, k + 1, word, visited)\n            || dfs(board, i, j + 1, k + 1, word, visited)\n            || dfs(board, i, j - 1, k + 1, word, visited);\n    visited[i][j] = false;\n\n    return result;\n}\n```\n\n    \n    For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).\n\nThe base cases are:\n- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.\n- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.\n\nFor each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true.\n    ",
        "c++": "\n    ```cpp\nbool exist(vector<vector<char>>& board, string word) {\n    int m = board.size();\n    int n = board[0].size();\n    \n    function<bool(int, int, int)> dfs = [&](int i, int j, int k) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[k])\n            return false;\n        if (k == word.length() - 1)\n            return true;\n        \n        char temp = board[i][j];\n        board[i][j] = '/';\n        bool res = dfs(i + 1, j, k + 1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    };\n    \n    for (int i = 0; i < m; i++)\n        for (int j = 0; j < n; j++)\n            if (dfs(i, j, 0))\n                return true;\n    return false;\n}\n```\n\n    \n    For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).\n\nThe base cases are:\n- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.\n- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.\n\nFor each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true.\n    ",
        "python": "\n    ```python\ndef exist(board, word):\n    m, n = len(board), len(board[0])\n\n    def dfs(i, j, k):\n        if not 0 <= i < m or not 0 <= j < n or board[i][j] != word[k]:\n            return False\n        if k == len(word) - 1:\n            return True\n\n        tmp, board[i][j] = board[i][j], '/'\n        res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n        board[i][j] = tmp\n        return res\n\n    for i in range(m):\n        for j in range(n):\n            if dfs(i, j, 0):\n                return True\n    return False\n```\n\n    \n    For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).\n\nThe base cases are:\n- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.\n- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.\n\nFor each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true.\n    ",
        "javascript": "\n    ```javascript\nfunction exist(board, word) {\n    const m = board.length;\n    const n = board[0].length;\n\n    function dfs(i, j, k) {\n        if (i < 0 || i === m || j < 0 || j === n || board[i][j] !== word[k])\n            return false;\n        if (k === word.length - 1)\n            return true;\n        \n        const temp = board[i][j];\n        board[i][j] = '/';\n        const res = dfs(i + 1, j, k +1) || dfs(i - 1, j, k + 1) || dfs(i, j + 1, k + 1) || dfs(i, j - 1, k + 1);\n        board[i][j] = temp;\n        return res;\n    }\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (dfs(i, j, 0))\n                return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    For each of the implementation above, we use a Depth-First Search (DFS) based algorithm to traverse the grid board. The DFS function takes the current cell index i and j and the index of the character in the input word that we are looking for (k).\n\nThe base cases are:\n- If the cell indexes i or j are out of boundaries, or the board[i][j] character does not match word[k], return false.\n- If k (current character index) is equal to word.length - 1, we find the word in the grid, so return true.\n\nFor each cell, we run the DFS function with the given input parameters. If DFS returns true (found the word), the whole function will return true.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[ \"A \", \"B \", \"C \", \"E \"],[ \"S \", \"F \", \"C \", \"S \"],[ \"A \", \"D \", \"E \", \"E \"]], word =  \"ABCCED \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " board = [[ \"A \", \"B \", \"C \", \"E \"],[ \"S \", \"F \", \"C \", \"S \"],[ \"A \", \"D \", \"E \", \"E \"]], word =  \"SEE \"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " board = [[ \"A \", \"B \", \"C \", \"E \"],[ \"S \", \"F \", \"C \", \"S \"],[ \"A \", \"D \", \"E \", \"E \"]], word =  \"ABCB \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]],\"ABCCED\"",
                    "output": "True"
                },
                {
                    "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]],\"SEE\"",
                    "output": "True"
                },
                {
                    "input": "[[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]],\"ABCB\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-37",
        "prompt": "Given an `m x n` grid of characters `board` and a string `word`, return `true` _if_ `word` _exists in the grid_.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once."
    },
    "leetcode-benchmark-38": {
        "id": "leetcode-benchmark-38",
        "title": "Remove Duplicates from Sorted Array II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_ `k` _slots of_ `nums`.\n\nDo **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,1,1,2,2,3\\]\n**Output:** 5, nums = \\[1,1,2,2,3,\\_\\]\n**Explanation:** Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,0,1,1,1,1,2,3,3\\]\n**Output:** 7, nums = \\[0,0,1,1,2,3,3,\\_,\\_\\]\n**Explanation:** Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is sorted in **non-decreasing** order.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int removeDuplicates(int[] nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (i < 2 || num > nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses a two-pointer technique. The variable `i` represents the pointer to the position in the array where the next unique element will be placed. For each element in the input array, we check if either `i < 2` (meaning we haven't encountered 2 unique elements yet) or the current element (`num`) is greater than the element in the array at index `i - 2` (this condition ensures that the current element appears at most twice in the array). If either of these conditions are true, we place the current element at index `i` and increment `i`. The function returns the value of `i` at the end, which represents the length of the modified array after removing duplicates.\n    ",
        "c++": "\n    ```cpp\nint removeDuplicates(vector<int>& nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (i < 2 || num > nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses a two-pointer technique. The variable `i` represents the pointer to the position in the array where the next unique element will be placed. For each element in the input array, we check if either `i < 2` (meaning we haven't encountered 2 unique elements yet) or the current element (`num`) is greater than the element in the array at index `i - 2` (this condition ensures that the current element appears at most twice in the array). If either of these conditions are true, we place the current element at index `i` and increment `i`. The function returns the value of `i` at the end, which represents the length of the modified array after removing duplicates.\n    ",
        "python": "\n    ```python\ndef remove_duplicates(nums):\n    i = 0\n    for num in nums:\n        if i < 2 or num > nums[i - 2]:\n            nums[i] = num\n            i += 1\n    return i\n```\n    \n    The algorithm uses a two-pointer technique. The variable `i` represents the pointer to the position in the array where the next unique element will be placed. For each element in the input array, we check if either `i < 2` (meaning we haven't encountered 2 unique elements yet) or the current element (`num`) is greater than the element in the array at index `i - 2` (this condition ensures that the current element appears at most twice in the array). If either of these conditions are true, we place the current element at index `i` and increment `i`. The function returns the value of `i` at the end, which represents the length of the modified array after removing duplicates.\n    ",
        "javascript": "\n    ```javascript\nfunction removeDuplicates(nums) {\n    let i = 0;\n    for (let num of nums) {\n        if (i < 2 || num > nums[i - 2]) {\n            nums[i++] = num;\n        }\n    }\n    return i;\n}\n```\n    \n    The algorithm uses a two-pointer technique. The variable `i` represents the pointer to the position in the array where the next unique element will be placed. For each element in the input array, we check if either `i < 2` (meaning we haven't encountered 2 unique elements yet) or the current element (`num`) is greater than the element in the array at index `i - 2` (this condition ensures that the current element appears at most twice in the array). If either of these conditions are true, we place the current element at index `i` and increment `i`. The function returns the value of `i` at the end, which represents the length of the modified array after removing duplicates.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,1,1,2,2,3]",
                    "output": " 5, nums = [1,1,2,2,3,_]",
                    "explanation": " Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
                },
                {
                    "input": " nums = [0,0,1,1,1,1,2,3,3]",
                    "output": " 7, nums = [0,0,1,1,2,3,3,_,_]",
                    "explanation": " Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
                }
            ],
            "function_input": [
                {
                    "input": "[1,1,1,2,2,3]",
                    "output": "5,nums=[1,1,2,2,3,_]"
                },
                {
                    "input": "[0,0,1,1,1,1,2,3,3]",
                    "output": "7,nums=[0,0,1,1,2,3,3,_,_]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-38",
        "prompt": "Given an integer array `nums` sorted in **non-decreasing order**, remove some duplicates [**in-place**](https://en.wikipedia.org/wiki/In-place_algorithm) such that each unique element appears **at most twice**. The **relative order** of the elements should be kept the **same**.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the **first part** of the array `nums`. More formally, if there are `k` elements after removing the duplicates, then the first `k` elements of `nums` should hold the final result. It does not matter what you leave beyond the first `k` elements.\n\nReturn `k` _after placing the final result in the first_ `k` _slots of_ `nums`.\n\nDo **not** allocate extra space for another array. You must do this by **modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm)** with O(1) extra memory.\n\n**Custom Judge:**\n\nThe judge will test your solution with the following code:\n\nint\\[\\] nums = \\[...\\]; // Input array\nint\\[\\] expectedNums = \\[...\\]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums\\[i\\] == expectedNums\\[i\\];\n}\n\nIf all assertions pass, then your solution will be **accepted**."
    },
    "leetcode-benchmark-39": {
        "id": "leetcode-benchmark-39",
        "title": "Search in Rotated Sorted Array II",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values).\n\nBefore being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._\n\nYou must decrease the overall operation steps as much as possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,5,6,0,0,1,2\\], target = 0\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,5,6,0,0,1,2\\], target = 3\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-104 <= nums[i] <= 104`\n*   `nums` is guaranteed to be rotated at some pivot.\n*   `-104 <= target <= 104`\n\n**",
            "follow_up": "Follow up:** This problem is similar to Search in Rotated Sorted Array, but `nums` may contain **duplicates**. Would this affect the runtime complexity? How and why?"
        },
        "java": "\n    ```java\npublic boolean search(int[] nums, int target) {\n    int left = 0, right = nums.length - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return true;\n\n        if (nums[mid] == nums[left]) {\n            left++;\n        } else if (nums[mid] > nums[left]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm is based on a modified binary search. We start by setting two pointers named `left` and `right` at the first and last element of the array, respectively. We then enter a loop, which continues until the `left` pointer is less than or equal to the `right` pointer.\n\nInside the loop, we first calculate the middle index `mid` using the `left` and `right` pointers. If the middle element of the array is equal to the target, we return true, indicating that the target is found.\n\nIf the middle element is equal to the left element, we increment the `left` pointer. If the middle element is greater than the left element, we check if the target is within the left and middle elements. If it is, we set the `right` pointer to the middle index minus one. Otherwise, we set the `left` pointer to the middle index plus one.\n\nIf the middle element is still smaller than the left element, we then check if the target is within the middle and right elements. If it is, we set the `left` pointer to the middle index plus one. Otherwise, we set the `right` pointer to the middle index minus one.\n\nAfter the loop, we return false if the target is not found in the array.\n    ",
        "c++": "\n    ```cpp\nbool search(vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return true;\n\n        if (nums[mid] == nums[left]) {\n            left++;\n        } else if (nums[mid] > nums[left]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm is based on a modified binary search. We start by setting two pointers named `left` and `right` at the first and last element of the array, respectively. We then enter a loop, which continues until the `left` pointer is less than or equal to the `right` pointer.\n\nInside the loop, we first calculate the middle index `mid` using the `left` and `right` pointers. If the middle element of the array is equal to the target, we return true, indicating that the target is found.\n\nIf the middle element is equal to the left element, we increment the `left` pointer. If the middle element is greater than the left element, we check if the target is within the left and middle elements. If it is, we set the `right` pointer to the middle index minus one. Otherwise, we set the `left` pointer to the middle index plus one.\n\nIf the middle element is still smaller than the left element, we then check if the target is within the middle and right elements. If it is, we set the `left` pointer to the middle index plus one. Otherwise, we set the `right` pointer to the middle index minus one.\n\nAfter the loop, we return false if the target is not found in the array.\n    ",
        "python": "\n    ```python\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = left + (right - left) // 2\n        if nums[mid] == target:\n            return True\n\n        if nums[mid] == nums[left]:\n            left += 1\n        elif nums[mid] > nums[left]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    return False\n```\n    \n    The algorithm is based on a modified binary search. We start by setting two pointers named `left` and `right` at the first and last element of the array, respectively. We then enter a loop, which continues until the `left` pointer is less than or equal to the `right` pointer.\n\nInside the loop, we first calculate the middle index `mid` using the `left` and `right` pointers. If the middle element of the array is equal to the target, we return true, indicating that the target is found.\n\nIf the middle element is equal to the left element, we increment the `left` pointer. If the middle element is greater than the left element, we check if the target is within the left and middle elements. If it is, we set the `right` pointer to the middle index minus one. Otherwise, we set the `left` pointer to the middle index plus one.\n\nIf the middle element is still smaller than the left element, we then check if the target is within the middle and right elements. If it is, we set the `left` pointer to the middle index plus one. Otherwise, we set the `right` pointer to the middle index minus one.\n\nAfter the loop, we return false if the target is not found in the array.\n    ",
        "javascript": "\n    ```javascript\nfunction search(nums, target) {\n    let left = 0, right = nums.length - 1;\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] === target) return true;\n\n        if (nums[mid] === nums[left]) {\n            left++;\n        } else if (nums[mid] > nums[left]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm is based on a modified binary search. We start by setting two pointers named `left` and `right` at the first and last element of the array, respectively. We then enter a loop, which continues until the `left` pointer is less than or equal to the `right` pointer.\n\nInside the loop, we first calculate the middle index `mid` using the `left` and `right` pointers. If the middle element of the array is equal to the target, we return true, indicating that the target is found.\n\nIf the middle element is equal to the left element, we increment the `left` pointer. If the middle element is greater than the left element, we check if the target is within the left and middle elements. If it is, we set the `right` pointer to the middle index minus one. Otherwise, we set the `left` pointer to the middle index plus one.\n\nIf the middle element is still smaller than the left element, we then check if the target is within the middle and right elements. If it is, we set the `left` pointer to the middle index plus one. Otherwise, we set the `right` pointer to the middle index minus one.\n\nAfter the loop, we return false if the target is not found in the array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,5,6,0,0,1,2], target = 0",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " nums = [2,5,6,0,0,1,2], target = 3",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,5,6,0,0,1,2],0",
                    "output": "True"
                },
                {
                    "input": "[2,5,6,0,0,1,2],3",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-39",
        "prompt": "There is an integer array `nums` sorted in non-decreasing order (not necessarily with **distinct** values).\n\nBefore being passed to your function, `nums` is **rotated** at an unknown pivot index `k` (`0 <= k < nums.length`) such that the resulting array is `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]` (**0-indexed**). For example, `[0,1,2,4,4,4,5,6,6,7]` might be rotated at pivot index `5` and become `[4,5,6,6,7,0,1,2,4,4]`.\n\nGiven the array `nums` **after** the rotation and an integer `target`, return `true` _if_ `target` _is in_ `nums`_, or_ `false` _if it is not in_ `nums`_._\n\nYou must decrease the overall operation steps as much as possible."
    },
    "leetcode-benchmark-40": {
        "id": "leetcode-benchmark-40",
        "title": "Gray Code",
        "difficulty": "Medium",
        "content": {
            "problem": "An **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n*   Every integer is in the **inclusive** range `[0, 2n - 1]`,\n*   The first integer is `0`,\n*   An integer appears **no more than once** in the sequence,\n*   The binary representation of every pair of **adjacent** integers differs by **exactly one bit**, and\n*   The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n`, return _any valid **n-bit gray code sequence**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[0,1,3,2\\]\n**Explanation:**\nThe binary representation of \\[0,1,3,2\\] is \\[00,01,11,10\\].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\\[0,2,3,1\\] is also a valid gray code sequence, whose binary representation is \\[00,10,11,01\\].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[0,1\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 16`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> grayCode(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < (1 << n); i++) {\n        result.add(i ^ (i >> 1));\n    }\n    return result;\n}\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<int> grayCode(int n) {\n    std::vector<int> result;\n    for (int i = 0; i < (1 << n); i++) {\n        result.push_back(i ^ (i >> 1));\n    }\n    return result;\n}\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "python": "\n    ```python\ndef grayCode(n):\n    result = []\n    for i in range(1 << n):\n        result.append(i ^ (i >> 1))\n    return result\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "javascript": "\n    ```javascript\nfunction grayCode(n) {\n    const result = [];\n    for (let i = 0; i < (1 << n); i++) {\n        result.push(i ^ (i >> 1));\n    }\n    return result;\n}\n```\n    \n    The algorithm generates an n-bit gray code sequence by following the simple bitwise operation:\n\n1. Loop through all numbers from 0 to 2^n - 1.\n2. For each number i, calculate the gray code value by performing the bitwise XOR operation (i ^ (i >> 1))\n3. Add the gray code value to the result list or vector.\n\nThe algorithm has a time complexity of O(2^n) which is the size of the output sequence. The space complexity is also O(2^n), as we store the sequence in a list or vector.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " [0,1,3,2]",
                    "explanation": "\nThe binary representation of \\[0,1,3,2\\] is \\[00,01,11,10\\].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n\\[0,2,3,1\\] is also a valid gray code sequence, whose binary representation is \\[00,10,11,01\\].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit"
                },
                {
                    "input": " n = 1",
                    "output": " [0,1]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "[0,1,3,2]"
                },
                {
                    "input": "1",
                    "output": "[0,1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-40",
        "prompt": "An **n-bit gray code sequence** is a sequence of `2n` integers where:\n\n*   Every integer is in the **inclusive** range `[0, 2n - 1]`,\n*   The first integer is `0`,\n*   An integer appears **no more than once** in the sequence,\n*   The binary representation of every pair of **adjacent** integers differs by **exactly one bit**, and\n*   The binary representation of the **first** and **last** integers differs by **exactly one bit**.\n\nGiven an integer `n`, return _any valid **n-bit gray code sequence**_."
    },
    "leetcode-benchmark-41": {
        "id": "leetcode-benchmark-41",
        "title": "Decode Ways",
        "difficulty": "Medium",
        "content": {
            "problem": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"12 \"\n**Output:** 2\n**Explanation:**  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12).\n\n",
                "**Example 2:**\n\n**Input:** s =  \"226 \"\n**Output:** 3\n**Explanation:**  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6).\n\n",
                "**Example 3:**\n\n**Input:** s =  \"06 \"\n**Output:** 0\n**Explanation:**  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \")."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 100`\n*   `s` contains only digits and may contain leading zero(s).",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numDecodings(String s) {\n    int n = s.length();\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = s.charAt(0) != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; i++) {\n        int oneDigit = Integer.parseInt(s.substring(i - 1, i));\n        int twoDigits = Integer.parseInt(s.substring(i - 2, i));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    dp[1] = s[0] != '0' ? 1 : 0;\n\n    for (int i = 2; i <= n; ++i) {\n        int oneDigit = stoi(s.substr(i - 1, 1));\n        int twoDigits = stoi(s.substr(i - 2, 2));\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n}\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "python": "\n    ```python\ndef numDecodings(s: str) -> int:\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1 if s[0] != '0' else 0\n\n    for i in range(2, n + 1):\n        one_digit = int(s[i - 1:i])\n        two_digits = int(s[i - 2:i])\n\n        if one_digit >= 1:\n            dp[i] += dp[i - 1]\n        if two_digits >= 10 and two_digits <= 26:\n            dp[i] += dp[i - 2]\n    return dp[n]\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "javascript": "\n    ```javascript\nvar numDecodings = function(s) {\n    const n = s.length;\n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = s[0] !== '0' ? 1 : 0;\n\n    for (let i = 2; i <= n; i++) {\n        const oneDigit = parseInt(s.slice(i - 1, i), 10);\n        const twoDigits = parseInt(s.slice(i - 2, i), 10);\n\n        if (oneDigit >= 1)\n            dp[i] += dp[i - 1];\n        if (twoDigits >= 10 && twoDigits <= 26)\n            dp[i] += dp[i - 2];\n    }\n    return dp[n];\n};\n```\n\n    \n    We use dynamic programming (DP) to solve this problem. The `dp` array is of size `n+1`, where `n` is the length of the input string `s`. `dp[i]` stores the number of ways to decode the substring `s[0:i]`.\n\nInitialize `dp[0]` to 1 because there is always one way to decode an empty string.\n\nFor each character in the string `s`, consider its corresponding one-digit and two-digits representations. If the one-digit representation is valid (>=1), we can increment `dp[i]` by `dp[i-1]`, which means one more way to decode the string by using the one-digit representation of the current character. If the two-digits representation is valid (>=10 and <=26), we can increment `dp[i]` by `dp[i-2]`, meaning one way to decode the string by using the two-digits representation of the current character.\n\nAfter we finished iterating through the string `s`, `dp[n]` will store the number of ways to decode the entire string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"12 \"",
                    "output": " 2",
                    "explanation": "  \"12 \" could be decoded as  \"AB \" (1 2) or  \"L \" (12)."
                },
                {
                    "input": " s =  \"226 \"",
                    "output": " 3",
                    "explanation": "  \"226 \" could be decoded as  \"BZ \" (2 26),  \"VF \" (22 6), or  \"BBF \" (2 2 6)."
                },
                {
                    "input": " s =  \"06 \"",
                    "output": " 0",
                    "explanation": "  \"06 \" cannot be mapped to  \"F \" because of the leading zero ( \"6 \" is different from  \"06 \")."
                }
            ],
            "function_input": [
                {
                    "input": "\"12\"",
                    "output": "2"
                },
                {
                    "input": "\"226\"",
                    "output": "3"
                },
                {
                    "input": "\"06\"",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-41",
        "prompt": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' ->  \"1 \"\n'B' ->  \"2 \"\n...\n'Z' ->  \"26 \"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106 \"` can be mapped into:\n\n*   `\"AAJF \"` with the grouping `(1 1 10 6)`\n*   `\"KJF \"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06 \"` cannot be mapped into `'F'` since `\"6 \"` is different from `\"06 \"`.\n\nGiven a string `s` containing only digits, return _the **number** of ways to **decode** it_.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer."
    },
    "leetcode-benchmark-42": {
        "id": "leetcode-benchmark-42",
        "title": "Reverse Linked List II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `head` of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return _the reversed list_.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[1,2,3,4,5\\], left = 2, right = 4\n**Output:** \\[1,4,3,2,5\\]\n\n",
                "**Example 2:**\n\n**Input:** head = \\[5\\], left = 1, right = 1\n**Output:** \\[5\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the list is `n`.\n*   `1 <= n <= 500`\n*   `-500 <= Node.val <= 500`\n*   `1 <= left <= right <= n`\n\n**",
            "follow_up": "Follow up:** Could you do it in one pass?"
        },
        "java": "\n    ```java\npublic ListNode reverseBetween(ListNode head, int left, int right) {\n    if (head == null || left == right) return head;\n    ListNode dummy = new ListNode(0);\n    dummy.next = head;\n    ListNode pre = dummy;\n    for (int i = 1; i < left; ++i) pre = pre.next;\n    ListNode cur = pre.next;\n    for (int i = left; i < right; ++i) {\n        ListNode t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}\n```\n    \n    The algorithm creates a dummy node and connects it to the head of the linked list. It then iterates through the list, reversing the nodes from position `left` to `right`. It maintains pointers `pre` and `cur` to accomplish this. During each iteration, it temporarily stores the next node using a pointer `t`, then reverses the connections between the nodes.\n\nThis process is repeated for all languages; the only differences in implementation are syntax-related. \n\nIn C++, use pointers and \"->\" to access the next node. In Java and Python, we use dot notation to access the next attribute. In JavaScript, we also use dot notation and \"===\" for equality comparison between left and right.\n    ",
        "c++": "\n    ```cpp\nListNode* reverseBetween(ListNode* head, int left, int right) {\n    if (!head || left == right) return head;\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode* pre = &dummy;\n    for (int i = 1; i < left; ++i) pre = pre->next;\n    ListNode* cur = pre->next;\n    for (int i = left; i < right; ++i) {\n        ListNode* t = cur->next;\n        cur->next = t->next;\n        t->next = pre->next;\n        pre->next = t;\n    }\n    return dummy.next;\n}\n```\n    \n    The algorithm creates a dummy node and connects it to the head of the linked list. It then iterates through the list, reversing the nodes from position `left` to `right`. It maintains pointers `pre` and `cur` to accomplish this. During each iteration, it temporarily stores the next node using a pointer `t`, then reverses the connections between the nodes.\n\nThis process is repeated for all languages; the only differences in implementation are syntax-related. \n\nIn C++, use pointers and \"->\" to access the next node. In Java and Python, we use dot notation to access the next attribute. In JavaScript, we also use dot notation and \"===\" for equality comparison between left and right.\n    ",
        "python": "\n    ```python\ndef reverseBetween(self, head: Optional[ListNode], left: int, right: int) -> Optional[ListNode]:\n    if not head or left == right:\n        return head\n    dummy = ListNode(0)\n    dummy.next = head\n    pre = dummy\n    for _ in range(left - 1):\n        pre = pre.next\n    cur = pre.next\n    for _ in range(left, right):\n        t = cur.next\n        cur.next = t.next\n        t.next = pre.next\n        pre.next = t\n    return dummy.next\n```\n    \n    The algorithm creates a dummy node and connects it to the head of the linked list. It then iterates through the list, reversing the nodes from position `left` to `right`. It maintains pointers `pre` and `cur` to accomplish this. During each iteration, it temporarily stores the next node using a pointer `t`, then reverses the connections between the nodes.\n\nThis process is repeated for all languages; the only differences in implementation are syntax-related. \n\nIn C++, use pointers and \"->\" to access the next node. In Java and Python, we use dot notation to access the next attribute. In JavaScript, we also use dot notation and \"===\" for equality comparison between left and right.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseBetween(head, left, right) {\n    if (!head || left === right) return head;\n    const dummy = new ListNode(0);\n    dummy.next = head;\n    let pre = dummy;\n    for (let i = 1; i < left; ++i) pre = pre.next;\n    let cur = pre.next;\n    for (let i = left; i < right; ++i) {\n        const t = cur.next;\n        cur.next = t.next;\n        t.next = pre.next;\n        pre.next = t;\n    }\n    return dummy.next;\n}\n```\n    \n    The algorithm creates a dummy node and connects it to the head of the linked list. It then iterates through the list, reversing the nodes from position `left` to `right`. It maintains pointers `pre` and `cur` to accomplish this. During each iteration, it temporarily stores the next node using a pointer `t`, then reverses the connections between the nodes.\n\nThis process is repeated for all languages; the only differences in implementation are syntax-related. \n\nIn C++, use pointers and \"->\" to access the next node. In Java and Python, we use dot notation to access the next attribute. In JavaScript, we also use dot notation and \"===\" for equality comparison between left and right.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " head = [1,2,3,4,5], left = 2, right = 4",
                    "output": " [1,4,3,2,5]",
                    "explanation": null
                },
                {
                    "input": " head = [5], left = 1, right = 1",
                    "output": " [5]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5],2,4",
                    "output": "[1,4,3,2,5]"
                },
                {
                    "input": "[5],1,1",
                    "output": "[5]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-42",
        "prompt": "Given the `head` of a singly linked list and two integers `left` and `right` where `left <= right`, reverse the nodes of the list from position `left` to position `right`, and return _the reversed list_."
    },
    "leetcode-benchmark-43": {
        "id": "leetcode-benchmark-43",
        "title": "Restore IP Addresses",
        "difficulty": "Medium",
        "content": {
            "problem": "A **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.\n\n*   For example, `\"0.1.2.201 \"` and `\"192.168.1.1 \"` are **valid** IP addresses, but `\"0.011.255.245 \"`, `\"192.168.1.312 \"` and `\"192.168@1.1 \"` are **invalid** IP addresses.\n\nGiven a string `s` containing only digits, return _all possible valid IP addresses that can be formed by inserting dots into_ `s`. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any** order.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"25525511135 \"\n**Output:** \\[ \"255.255.11.135 \", \"255.255.111.35 \"\\]\n\n",
                "**Example 2:**\n\n**Input:** s =  \"0000 \"\n**Output:** \\[ \"0.0.0.0 \"\\]\n\n",
                "**Example 3:**\n\n**Input:** s =  \"101023 \"\n**Output:** \\[ \"1.0.10.23 \", \"1.0.102.3 \", \"10.1.0.23 \", \"10.10.2.3 \", \"101.0.2.3 \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 20`\n*   `s` consists of digits only.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> restoreIpAddresses(String s) {\n    List<String> result = new ArrayList<>();\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nprivate void dfs(String s, int start, String ip, List<String> result, int part) {\n    if (part == 4 && start == s.length()) {\n        result.add(ip.substring(0, ip.length() - 1));\n        return;\n    }\n    if (part == 4 || start >= s.length()) return;\n\n    int num = 0;\n    for (int i = start; i < s.length(); i++) {\n        num = num * 10 + (s.charAt(i) - '0');\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s.charAt(i) + \".\", result, part + 1);\n        if (num == 0) break;\n    }\n}\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<string>\nusing namespace std;\n\nvector<string> restore_ip_address(string s) {\n    vector<string> result;\n    string ip;\n    dfs(result, s, ip, 0, 0);\n    return result;\n}\n\nvoid dfs(vector<string>& result, string s, string ip, int start, int part) {\n    if (part == 4 && start == s.size()) {\n        ip.pop_back();\n        result.push_back(ip);\n        return;\n    }\n    if (part == 4 || start == s.size()) return;\n\n    int num = 0;\n    for (int i = start; i < s.size(); i++) {\n        num = num * 10 + (s[i] - '0');\n        if (num > 255) break;\n        ip += s[i];\n        dfs(result, s, ip + '.', i + 1, part + 1);\n        if (num == 0) break;\n    }\n}\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "python": "\n    ```python\ndef restore_ip_addresses(s):\n    def dfs(s, start, ip, result, part):\n        if part == 4 and start == len(s):\n            result.append(ip[:-1])\n            return\n        if part == 4 or start >= len(s):\n            return\n\n        num = 0\n        for i in range(start, len(s)):\n            num = num * 10 + int(s[i])\n            if num > 255:\n                break\n            dfs(s, i + 1, ip + s[i] + \".\", result, part + 1)\n            if num == 0:\n                break\n\n    result = []\n    dfs(s, 0, \"\", result, 0)\n    return result\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "javascript": "\n    ```javascript\nfunction restoreIpAddresses(s) {\n    const result = [];\n    dfs(s, 0, \"\", result, 0);\n    return result;\n}\n\nfunction dfs(s, start, ip, result, part) {\n    if (part === 4 && start === s.length) {\n        result.push(ip.slice(0, -1));\n        return;\n    }\n    if (part === 4 || start >= s.length) return;\n\n    let num = 0;\n    for (let i = start; i < s.length; i++) {\n        num = num * 10 + parseInt(s[i]);\n        if (num > 255) break;\n        dfs(s, i + 1, ip + s[i] + \".\", result, part + 1);\n        if (num === 0) break;\n    }\n}\n```\n\n    \n    We use a Depth-First Search algorithm to explore all possible configurations of the IP address. The function takes in the input string (s), the starting index (start), the partially constructed IP address (ip), and the current part count (part).\n\nIn each call to the function, we try to add one part to the IP address. If 4 parts have been added and we have reached the end of the input string, we have found a valid IP address and add it to the result list.\n\nThe algorithm iterates through the string s, starting at the current index. It keeps track of the current number (0-255) being constructed by multiplying the current number by 10 and adding the current digit. If the current number is greater than 255, we break the iteration.\n\nWe then call the dfs function recursively, with the current index incremented by one, the current IP appended with the current character and a dot, and incrementing part by 1. If the current number is 0 (which indicates a leading zero), we also break the iteration.\n\nThis process is repeated for all valid parts and combinations, eventually forming all possible valid IP addresses.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"25525511135 \"",
                    "output": " [ \"255.255.11.135 \", \"255.255.111.35 \"]",
                    "explanation": null
                },
                {
                    "input": " s =  \"0000 \"",
                    "output": " [ \"0.0.0.0 \"]",
                    "explanation": null
                },
                {
                    "input": " s =  \"101023 \"",
                    "output": " [ \"1.0.10.23 \", \"1.0.102.3 \", \"10.1.0.23 \", \"10.10.2.3 \", \"101.0.2.3 \"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"25525511135\"",
                    "output": "[\"255.255.11.135\",\"255.255.111.35\"]"
                },
                {
                    "input": "\"0000\"",
                    "output": "[\"0.0.0.0\"]"
                },
                {
                    "input": "\"101023\"",
                    "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-43",
        "prompt": "A **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.\n\n*   For example, `\"0.1.2.201 \"` and `\"192.168.1.1 \"` are **valid** IP addresses, but `\"0.011.255.245 \"`, `\"192.168.1.312 \"` and `\"192.168@1.1 \"` are **invalid** IP addresses.\n\nGiven a string `s` containing only digits, return _all possible valid IP addresses that can be formed by inserting dots into_ `s`. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any** order."
    },
    "leetcode-benchmark-44": {
        "id": "leetcode-benchmark-44",
        "title": "Unique Binary Search Trees",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 19`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numTrees(int n) {\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "c++": "\n    ```cpp\nint numTrees(int n) {\n    vector<int> dp(n + 1, 0);\n    dp[0] = dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        for (int j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "python": "\n    ```python\ndef numTrees(n):\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, n + 1):\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "javascript": "\n    ```javascript\nfunction numTrees(n) {\n    let dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    dp[1] = 1;\n    for (let i = 2; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            dp[i] += dp[j] * dp[i - j - 1];\n        }\n    }\n    return dp[n];\n}\n```\n    \n    The algorithm is based on dynamic programming. We create an array `dp` of length `n + 1`, with `dp[0]` and `dp[1]` equal to 1, which corresponds to the cases of 0 and 1 node respectively. Next, we iterate from 2 to `n`, and for each value `i`, we iterate from 0 to `i` and accumulate `dp[j] * dp[i - j - 1]` in `dp[i]`. This process represents the number of structurally unique BSTs for the left subtree and right subtree for each possible node arrangement of the BST. At the end, `dp[n]` represents the number of structurally unique BSTs with precisely n nodes.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " 5",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "5"
                },
                {
                    "input": "1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-44",
        "prompt": "Given an integer `n`, return _the number of structurally unique **BST'**s (binary search trees) which has exactly_ `n` _nodes of unique values from_ `1` _to_ `n`."
    },
    "leetcode-benchmark-45": {
        "id": "leetcode-benchmark-45",
        "title": "Interleaving String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n*   `s = s1 + s2 + ... + sn`\n*   `t = t1 + t2 + ... + tm`\n*   `|n - m| <= 1`\n*   The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbcbcac \"\n**Output:** true\n**Explanation:** One way to obtain s3 is:\nSplit s1 into s1 =  \"aa \" +  \"bc \" +  \"c \", and s2 into s2 =  \"dbbc \" +  \"a \".\nInterleaving the two splits, we get  \"aa \" +  \"dbbc \" +  \"bc \" +  \"a \" +  \"c \" =  \"aadbbcbcac \".\nSince s3 can be obtained by interleaving s1 and s2, we return true.\n\n",
                "**Example 2:**\n\n**Input:** s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbbaccc \"\n**Output:** false\n**Explanation:** Notice how it is impossible to interleave s2 with any other string to obtain s3.\n\n",
                "**Example 3:**\n\n**Input:** s1 =  \" \", s2 =  \" \", s3 =  \" \"\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s1.length, s2.length <= 100`\n*   `0 <= s3.length <= 200`\n*   `s1`, `s2`, and `s3` consist of lowercase English letters.\n\n**",
            "follow_up": "Follow up:** Could you solve it using only `O(s2.length)` additional memory space?"
        },
        "java": "\n    ```java\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    boolean[][] dp = new boolean[m + 1][n + 1];\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                       (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ",
        "c++": "\n    ```cpp\nbool isInterleave(string s1, string s2, string s3) {\n    int m = s1.length(), n = s2.length();\n    if (m + n != s3.length()) return false;\n\n    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n    dp[0][0] = true;\n    for (int i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1];\n    for (int j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1];\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ",
        "python": "\n    ```python\ndef isInterleave(s1, s2, s3):\n    m, n = len(s1), len(s2)\n    if m + n != len(s3):\n        return False\n\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or \\\n                       (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ",
        "javascript": "\n    ```javascript\nfunction isInterleave(s1, s2, s3) {\n    let m = s1.length, n = s2.length;\n    if (m + n !== s3.length) return false;\n\n    let dp = new Array(m + 1).fill(null).map(() => new Array(n + 1).fill(false));\n    dp[0][0] = true;\n    for (let i = 1; i <= m; i++)\n        dp[i][0] = dp[i - 1][0] && s1[i - 1] === s3[i - 1];\n    for (let j = 1; j <= n; j++)\n        dp[0][j] = dp[0][j - 1] && s2[j - 1] === s3[j - 1];\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = (dp[i - 1][j] && s1[i - 1] === s3[i + j - 1]) ||\n                       (dp[i][j - 1] && s2[j - 1] === s3[i + j - 1]);\n        }\n    }\n\n    return dp[m][n];\n}\n```\n    \n    We use a dynamic programming approach (2D DP) to solve this problem. The algorithm checks whether the s3[position] is equal to s1 or s2 in the same dp[position]. If so, we take the value of the previous dp[i-1] or dp[j-1] accordingly if the characters match. For the base case, we start with initializing dp[0][0] to true since two empty strings can form an empty s3.\n\nAt the end of the iterations, the last element in the dp matrix (i.e. dp[m][n]) will represent whether s3 can be formed by an interleaving of s1 and s2.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbcbcac \"",
                    "output": " True",
                    "explanation": " One way to obtain s3 is:\nSplit s1 into s1 =  \"aa \" +  \"bc \" +  \"c \", and s2 into s2 =  \"dbbc \" +  \"a \".\nInterleaving the two splits, we get  \"aa \" +  \"dbbc \" +  \"bc \" +  \"a \" +  \"c \" =  \"aadbbcbcac \".\nSince s3 can be obtained by interleaving s1 and s2, we return true."
                },
                {
                    "input": " s1 =  \"aabcc \", s2 =  \"dbbca \", s3 =  \"aadbbbaccc \"",
                    "output": " False",
                    "explanation": " Notice how it is impossible to interleave s2 with any other string to obtain s3."
                },
                {
                    "input": " s1 =  \" \", s2 =  \" \", s3 =  \" \"",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aabcc\",\"dbbca\",\"aadbbcbcac\"",
                    "output": "True"
                },
                {
                    "input": "\"aabcc\",\"dbbca\",\"aadbbbaccc\"",
                    "output": "False"
                },
                {
                    "input": "\"\",\"\",\"\"",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-45",
        "prompt": "Given strings `s1`, `s2`, and `s3`, find whether `s3` is formed by an **interleaving** of `s1` and `s2`.\n\nAn **interleaving** of two strings `s` and `t` is a configuration where `s` and `t` are divided into `n` and `m` substrings respectively, such that:\n\n*   `s = s1 + s2 + ... + sn`\n*   `t = t1 + t2 + ... + tm`\n*   `|n - m| <= 1`\n*   The **interleaving** is `s1 + t1 + s2 + t2 + s3 + t3 + ...` or `t1 + s1 + t2 + s2 + t3 + s3 + ...`\n\n**Note:** `a + b` is the concatenation of strings `a` and `b`."
    },
    "leetcode-benchmark-46": {
        "id": "leetcode-benchmark-46",
        "title": "Recover Binary Search Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. _Recover the tree without changing its structure_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,3,null,null,2\\]\n**Output:** \\[3,1,null,null,2\\]\n**Explanation:** 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,1,4,null,null,2\\]\n**Output:** \\[2,1,4,null,null,3\\]\n**Explanation:** 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[2, 1000]`.\n*   `-231 <= Node.val <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** A solution using `O(n)` space is pretty straight-forward. Could you devise a constant `O(1)` space solution?"
        },
        "java": "\n    ```java\nvoid inorder(TreeNode node, TreeNode[] nodes) {\n    if (node == null) return;\n    inorder(node.left, nodes);\n    if (nodes[1] != null && nodes[1].val > node.val) {\n        if (nodes[0] == null) nodes[0] = nodes[1];\n        nodes[2] = node;\n    }\n    nodes[1] = node;\n    inorder(node.right, nodes);\n}\n\npublic void recoverTree(TreeNode root) {\n    TreeNode[] nodes = new TreeNode[3];\n    inorder(root, nodes);\n    int temp = nodes[0].val;\n    nodes[0].val = nodes[2].val;\n    nodes[2].val = temp;\n}\n```\n    \n    We will solve this problem using the Inorder traversal of the binary search tree.\n\n1. Traverse the BST using Inorder traversal, and at each node, compare its value with the previous node.\n2. If the previous node's value is greater than the current node's value, it means they are swapped. So, mark the first such node as `first` and the second such node as `second`.\n3. After completing the Inorder traversal, swap the values of the `first` and `second` nodes.\n4. This approach is implemented in all four languages: C++, Java, Python, and JavaScript.\n\nNote that the TreeNode class should be defined for each implementation as it's not provided in the problem statement.\n    ",
        "c++": "\n    ```cpp\nvoid inorder(TreeNode* node, TreeNode*& first, TreeNode*& second, TreeNode*& prev) {\n    if (!node) return;\n    inorder(node->left, first, second, prev);\n    if (prev && prev->val > node->val) {\n        if (!first) first = prev;\n        second = node;\n    }\n    prev = node;\n    inorder(node->right, first, second, prev);\n}\n\nvoid recoverTree(TreeNode* root) {\n    TreeNode *first = nullptr, *second = nullptr, *prev = nullptr;\n    inorder(root, first, second, prev);\n    std::swap(first->val, second->val);\n}\n```\n    \n    We will solve this problem using the Inorder traversal of the binary search tree.\n\n1. Traverse the BST using Inorder traversal, and at each node, compare its value with the previous node.\n2. If the previous node's value is greater than the current node's value, it means they are swapped. So, mark the first such node as `first` and the second such node as `second`.\n3. After completing the Inorder traversal, swap the values of the `first` and `second` nodes.\n4. This approach is implemented in all four languages: C++, Java, Python, and JavaScript.\n\nNote that the TreeNode class should be defined for each implementation as it's not provided in the problem statement.\n    ",
        "python": "\n    ```python\ndef inorder(node, nodes):\n    if not node: return\n    inorder(node.left, nodes)\n    if nodes[1] and nodes[1].val > node.val:\n        if not nodes[0]: nodes[0] = nodes[1]\n        nodes[2] = node\n    nodes[1] = node\n    inorder(node.right, nodes)\n\ndef recoverTree(root):\n    nodes = [None, None, None]\n    inorder(root, nodes)\n    nodes[0].val, nodes[2].val = nodes[2].val, nodes[0].val\n```\n    \n    We will solve this problem using the Inorder traversal of the binary search tree.\n\n1. Traverse the BST using Inorder traversal, and at each node, compare its value with the previous node.\n2. If the previous node's value is greater than the current node's value, it means they are swapped. So, mark the first such node as `first` and the second such node as `second`.\n3. After completing the Inorder traversal, swap the values of the `first` and `second` nodes.\n4. This approach is implemented in all four languages: C++, Java, Python, and JavaScript.\n\nNote that the TreeNode class should be defined for each implementation as it's not provided in the problem statement.\n    ",
        "javascript": "\n    ```javascript\nfunction inorder(node, nodes) {\n    if (!node) return;\n    inorder(node.left, nodes);\n    if (nodes[1] && nodes[1].val > node.val) {\n        if (!nodes[0]) nodes[0] = nodes[1];\n        nodes[2] = node;\n    }\n    nodes[1] = node;\n    inorder(node.right, nodes);\n}\n\nfunction recoverTree(root) {\n    const nodes = [null, null, null];\n    inorder(root, nodes);\n    const temp = nodes[0].val;\n    nodes[0].val = nodes[2].val;\n    nodes[2].val = temp;\n}\n```\n    \n    We will solve this problem using the Inorder traversal of the binary search tree.\n\n1. Traverse the BST using Inorder traversal, and at each node, compare its value with the previous node.\n2. If the previous node's value is greater than the current node's value, it means they are swapped. So, mark the first such node as `first` and the second such node as `second`.\n3. After completing the Inorder traversal, swap the values of the `first` and `second` nodes.\n4. This approach is implemented in all four languages: C++, Java, Python, and JavaScript.\n\nNote that the TreeNode class should be defined for each implementation as it's not provided in the problem statement.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,3,null,null,2]",
                    "output": " [3,1,null,null,2]",
                    "explanation": " 3 cannot be a left child of 1 because 3 > 1. Swapping 1 and 3 makes the BST valid."
                },
                {
                    "input": " root = [3,1,4,null,null,2]",
                    "output": " [2,1,4,null,null,3]",
                    "explanation": " 2 cannot be in the right subtree of 3 because 2 < 3. Swapping 2 and 3 makes the BST valid."
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,null,null,2]",
                    "output": "[3,1,null,null,2]"
                },
                {
                    "input": "[3,1,4,null,null,2]",
                    "output": "[2,1,4,null,null,3]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-46",
        "prompt": "You are given the `root` of a binary search tree (BST), where the values of **exactly** two nodes of the tree were swapped by mistake. _Recover the tree without changing its structure_."
    },
    "leetcode-benchmark-47": {
        "id": "leetcode-benchmark-47",
        "title": "Flatten Binary Tree to Linked List",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree, flatten the tree into a \"linked list \":\n\n*   The \"linked list \" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n*   The \"linked list \" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,5,3,4,null,6\\]\n**Output:** \\[1,null,2,null,3,null,4,null,5,null,6\\]\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]\n\n",
                "**Example 3:**\n\n**Input:** root = \\[0\\]\n**Output:** \\[0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 2000]`.\n*   `-100 <= Node.val <= 100`\n\n**",
            "follow_up": "Follow up:** Can you flatten the tree in-place (with `O(1)` extra space)?"
        },
        "java": "\n    ```java\npublic void flatten(TreeNode root) {\n    if (root == null) return;\n    flatten(root.left);\n    flatten(root.right);\n    if (root.left != null) {\n        TreeNode temp = root.right;\n        root.right = root.left;\n        root.left = null;\n        while (root.right != null) root = root.right;\n        root.right = temp;\n    }\n}\n```\n    \n    1. Check if the root is null, then return.\n2. Recursively flatten the left and right subtrees.\n3. If there is a left subtree, temporarily store the right subtree in a variable `temp`.\n4. Make the right subtree the left subtree and set the left subtree to null.\n5. Move to the rightmost node in the new right subtree.\n6. Set the right node of the rightmost node to the `temp` variable.\n7. The tree will now be flattened into a \"linked list\" where all nodes are right child nodes.\n    ",
        "c++": "\n    ```cpp\nvoid flatten(TreeNode* root) {\n    if (!root) return;\n    flatten(root->left);\n    flatten(root->right);\n    if (root->left) {\n        TreeNode* temp = root->right;\n        root->right = root->left;\n        root->left = nullptr;\n        while (root->right) root = root->right;\n        root->right = temp;\n    }\n}\n```\n    \n    1. Check if the root is null, then return.\n2. Recursively flatten the left and right subtrees.\n3. If there is a left subtree, temporarily store the right subtree in a variable `temp`.\n4. Make the right subtree the left subtree and set the left subtree to null.\n5. Move to the rightmost node in the new right subtree.\n6. Set the right node of the rightmost node to the `temp` variable.\n7. The tree will now be flattened into a \"linked list\" where all nodes are right child nodes.\n    ",
        "python": "\n    ```python\ndef flatten(root):\n    if not root:\n        return\n    flatten(root.left)\n    flatten(root.right)\n    if root.left:\n        temp = root.right\n        root.right = root.left\n        root.left = None\n        while root.right:\n            root = root.right\n        root.right = temp\n```\n    \n    1. Check if the root is null, then return.\n2. Recursively flatten the left and right subtrees.\n3. If there is a left subtree, temporarily store the right subtree in a variable `temp`.\n4. Make the right subtree the left subtree and set the left subtree to null.\n5. Move to the rightmost node in the new right subtree.\n6. Set the right node of the rightmost node to the `temp` variable.\n7. The tree will now be flattened into a \"linked list\" where all nodes are right child nodes.\n    ",
        "javascript": "\n    ```javascript\nfunction flatten(root) {\n    if (!root) return;\n    flatten(root.left);\n    flatten(root.right);\n    if (root.left) {\n        let temp = root.right;\n        root.right = root.left;\n        root.left = null;\n        while (root.right) root = root.right;\n        root.right = temp;\n    }\n}\n```\n    \n    1. Check if the root is null, then return.\n2. Recursively flatten the left and right subtrees.\n3. If there is a left subtree, temporarily store the right subtree in a variable `temp`.\n4. Make the right subtree the left subtree and set the left subtree to null.\n5. Move to the rightmost node in the new right subtree.\n6. Set the right node of the rightmost node to the `temp` variable.\n7. The tree will now be flattened into a \"linked list\" where all nodes are right child nodes.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,2,5,3,4,null,6]",
                    "output": " [1,null,2,null,3,null,4,null,5,null,6]",
                    "explanation": null
                },
                {
                    "input": " root = []",
                    "output": " []",
                    "explanation": null
                },
                {
                    "input": " root = [0]",
                    "output": " [0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,5,3,4,null,6]",
                    "output": "[1,null,2,null,3,null,4,null,5,null,6]"
                },
                {
                    "input": "[]",
                    "output": "[]"
                },
                {
                    "input": "[0]",
                    "output": "[0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-47",
        "prompt": "Given the `root` of a binary tree, flatten the tree into a \"linked list \":\n\n*   The \"linked list \" should use the same `TreeNode` class where the `right` child pointer points to the next node in the list and the `left` child pointer is always `null`.\n*   The \"linked list \" should be in the same order as a [**pre-order** **traversal**](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR) of the binary tree."
    },
    "leetcode-benchmark-48": {
        "id": "leetcode-benchmark-48",
        "title": "Populating Next Right Pointers in Each Node",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node \\*left;\n  Node \\*right;\n  Node \\*next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3,4,5,6,7\\]\n**Output:** \\[1,#,2,3,#,4,5,6,7,#\\]\n**Explanation:** Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 212 - 1]`.\n*   `-1000 <= Node.val <= 1000`\n\n**",
            "follow_up": "Follow-up:**\n\n*   You may only use constant extra space.\n*   The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem."
        },
        "java": "\n    ```java\npublic void connect(TreeLinkNode root) {\n    if (root == null || root.left == null) return;\n    root.left.next = root.right;\n    if (root.next != null) {\n        root.right.next = root.next.left;\n    }\n    connect(root.left);\n    connect(root.right);\n}\n```\n\n    \n    The algorithm to populate the next pointers is a simple modification of the pre-order traversal of the binary tree. We start with the root, and for each node, we check if it has left and right children. If so, we set the left child's next pointer to point to the right child. If the current node's next pointer is not null, we set its right child's next pointer to the left child of its next node. Finally, we recursively call the function on the left and right children.\n    ",
        "c++": "\n    ```cpp\nvoid connect(Node* root) {\n    if (!root) return;\n    if (root->left) {\n        root->left->next = root->right;\n        if (root->next) {\n            root->right->next = root->next->left;\n        }\n    }\n    connect(root->left);\n    connect(root->right);\n}\n```\n\n    \n    The algorithm to populate the next pointers is a simple modification of the pre-order traversal of the binary tree. We start with the root, and for each node, we check if it has left and right children. If so, we set the left child's next pointer to point to the right child. If the current node's next pointer is not null, we set its right child's next pointer to the left child of its next node. Finally, we recursively call the function on the left and right children.\n    ",
        "python": "\n    ```python\ndef connect(self, root: 'Node') -> 'Node':\n    if not root or not root.left:\n        return root\n    root.left.next = root.right\n    if root.next:\n        root.right.next = root.next.left\n    self.connect(root.left)\n    self.connect(root.right)\n    return root\n```\n\n    \n    The algorithm to populate the next pointers is a simple modification of the pre-order traversal of the binary tree. We start with the root, and for each node, we check if it has left and right children. If so, we set the left child's next pointer to point to the right child. If the current node's next pointer is not null, we set its right child's next pointer to the left child of its next node. Finally, we recursively call the function on the left and right children.\n    ",
        "javascript": "\n    ```javascript\nfunction connect(root) {\n    if (root === null || root.left === null) return root;\n    root.left.next = root.right;\n    if (root.next !== null) {\n        root.right.next = root.next.left;\n    }\n    connect(root.left);\n    connect(root.right);\n    return root;\n}\n```\n\n    \n    The algorithm to populate the next pointers is a simple modification of the pre-order traversal of the binary tree. We start with the root, and for each node, we check if it has left and right children. If so, we set the left child's next pointer to point to the right child. If the current node's next pointer is not null, we set its right child's next pointer to the left child of its next node. Finally, we recursively call the function on the left and right children.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,2,3,4,5,6,7]",
                    "output": " [1,#,2,3,#,4,5,6,7,#]",
                    "explanation": " Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level."
                },
                {
                    "input": " root = []",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5,6,7]",
                    "output": "[1,#,2,3,#,4,5,6,7,#]"
                },
                {
                    "input": "[]",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-48",
        "prompt": "You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\n\nstruct Node {\n  int val;\n  Node \\*left;\n  Node \\*right;\n  Node \\*next;\n}\n\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.\n\nInitially, all next pointers are set to `NULL`."
    },
    "leetcode-benchmark-49": {
        "id": "leetcode-benchmark-49",
        "title": "Triangle",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.",
            "examples": [
                "**Example 1:**\n\n**Input:** triangle = \\[\\[2\\],\\[3,4\\],\\[6,5,7\\],\\[4,1,8,3\\]\\]\n**Output:** 11\n**Explanation:** The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\n\n",
                "**Example 2:**\n\n**Input:** triangle = \\[\\[-10\\]\\]\n**Output:** -10"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= triangle.length <= 200`\n*   `triangle[0].length == 1`\n*   `triangle[i].length == triangle[i - 1].length + 1`\n*   `-104 <= triangle[i][j] <= 104`\n\n**",
            "follow_up": "Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?"
        },
        "java": "\n    ```java\npublic int minimumTotal(List<List<Integer>> triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle.get(row).size(); col++) {\n            int minSum = Math.min(triangle.get(row + 1).get(col), triangle.get(row + 1).get(col + 1));\n            triangle.get(row).set(col, triangle.get(row).get(col) + minSum);\n        }\n    }\n    return triangle.get(0).get(0);\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "c++": "\n    ```cpp\nint minimumTotal(vector<vector<int>>& triangle) {\n    for (int row = triangle.size() - 2; row >= 0; row--) {\n        for (int col = 0; col < triangle[row].size(); col++) {\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "python": "\n    ```python\ndef minimumTotal(triangle):\n    for row in range(len(triangle) - 2, -1, -1):\n        for col in range(len(triangle[row])):\n            triangle[row][col] += min(triangle[row + 1][col], triangle[row + 1][col + 1])\n    return triangle[0][0]\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "javascript": "\n    ```javascript\nfunction minimumTotal(triangle) {\n    for (let row = triangle.length - 2; row >= 0; row--) {\n        for (let col = 0; col < triangle[row].length; col++) {\n            triangle[row][col] += Math.min(triangle[row + 1][col], triangle[row + 1][col + 1]);\n        }\n    }\n    return triangle[0][0];\n}\n```\n    \n    The algorithm starts from the second last row of the triangle, moving bottom-up. For each number in the current row, we add the minimum adjacent number in the row below it. This is done for all numbers in the current row. Then, we move to the row above and repeat the process. This way, we are calculating the minimum path sum for each number in the triangle until we reach the top. Finally, the minimum path sum from top to bottom can be found in the top-most number (triangle[0][0]) after these operations are complete.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": " 11",
                    "explanation": " The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above)."
                },
                {
                    "input": " triangle = [[-10]]",
                    "output": " -10",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[2],[3,4],[6,5,7],[4,1,8,3]]",
                    "output": "11"
                },
                {
                    "input": "[[-10]]",
                    "output": "-10"
                }
            ]
        },
        "task_id": "leetcode-benchmark-49",
        "prompt": "Given a `triangle` array, return _the minimum path sum from top to bottom_.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row."
    },
    "leetcode-benchmark-50": {
        "id": "leetcode-benchmark-50",
        "title": "Best Time to Buy and Sell Stock II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_.",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[7,1,5,3,6,4\\]\n**Output:** 7\n**Explanation:** Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1,2,3,4,5\\]\n**Output:** 4\n**Explanation:** Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n\n",
                "**Example 3:**\n\n**Input:** prices = \\[7,6,4,3,1\\]\n**Output:** 0\n**Explanation:** There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 3 * 104`\n*   `0 <= prices[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int max_profit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "python": "\n    ```python\ndef max_profit(prices):\n    max_profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return max_profit\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let max_profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i - 1]) {\n            max_profit += prices[i] - prices[i - 1];\n        }\n    }\n    return max_profit;\n}\n```\n    \n    The algorithm loops through the given array of stock prices, starting from the second day. For each day, it checks if the price of the stock is higher than the previous day's price. If so, it calculates the difference between the two prices and adds this profit to the total maximum profit. By doing this, we are considering all the possible profitable transactions and accumulating the maximum profit we can achieve.\n\nThis approach has a runtime complexity of O(n), where n is the number of days in the input array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " prices = [7,1,5,3,6,4]",
                    "output": " 7",
                    "explanation": " Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7."
                },
                {
                    "input": " prices = [1,2,3,4,5]",
                    "output": " 4",
                    "explanation": " Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4."
                },
                {
                    "input": " prices = [7,6,4,3,1]",
                    "output": " 0",
                    "explanation": " There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
                }
            ],
            "function_input": [
                {
                    "input": "[7,1,5,3,6,4]",
                    "output": "7"
                },
                {
                    "input": "[1,2,3,4,5]",
                    "output": "4"
                },
                {
                    "input": "[7,6,4,3,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-50",
        "prompt": "You are given an integer array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold **at most one** share of the stock at any time. However, you can buy it then immediately sell it on the **same day**.\n\nFind and return _the **maximum** profit you can achieve_."
    },
    "leetcode-benchmark-51": {
        "id": "leetcode-benchmark-51",
        "title": "Longest Consecutive Sequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[100,4,200,1,3,2\\]\n**Output:** 4\n**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,3,7,2,5,8,4,6,0,1\\]\n**Output:** 9"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= nums.length <= 105`\n*   `-109 <= nums[i] <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int longestConsecutive(int[] nums) {\n    Set<Integer> elements = new HashSet<>();\n    for (int num : nums) {\n        elements.add(num);\n    }\n    \n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (!elements.contains(num - 1)) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.contains(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n            \n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "c++": "\n    ```cpp\nint longestConsecutive(vector<int>& nums) {\n    unordered_set<int> elements(nums.begin(), nums.end());\n    int longestSeq = 0;\n    \n    for (int num : nums) {\n        if (elements.find(num - 1) == elements.end()) {\n            int currentNum = num;\n            int currentSeq = 1;\n            \n            while (elements.find(currentNum + 1) != elements.end()) {\n                currentNum += 1;\n                currentSeq += 1;\n            }\n            \n            longestSeq = max(longestSeq, currentSeq);\n        }\n    }\n    return longestSeq;\n}\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "python": "\n    ```python\ndef longest_consecutive(nums):\n    elements = set(nums)\n    longest_seq = 0\n\n    for num in nums:\n        if num - 1 not in elements:\n            current_num = num\n            current_seq = 1\n            \n            while current_num + 1 in elements:\n                current_num += 1\n                current_seq += 1\n\n            longest_seq = max(longest_seq, current_seq)\n    \n    return longest_seq\n```\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "javascript": "\n    ```javascript\nfunction longestConsecutive(nums) {\n    const elements = new Set(nums);\n    let longestSeq = 0;\n\n    for (const num of nums) {\n        if (!elements.has(num - 1)) {\n            let currentNum = num;\n            let currentSeq = 1;\n\n            while (elements.has(currentNum + 1)) {\n                currentNum++;\n                currentSeq++;\n            }\n\n            longestSeq = Math.max(longestSeq, currentSeq);\n        }\n    }\n\n    return longestSeq;\n}\n```\n\n    \n    The algorithm first creates a set (or hash set) with the given array of integers called `elements`. The set will allow us to have a fast O(1) lookup on our next step.\nNow we iterate through the original array of numbers, and for each number, we check if `(number - 1)` is not in the `elements` set. If it's not in the set, it means we can start counting a new consecutive sequence.\nNext, we create two variables, `currentNum` and `currentSeq`, and initialize them with the current number and 1, respectively.\nWe then use a while loop to check if the next number (`currentNum + 1`) is in the `elements` set. If it is, we increment both `currentNum` and `currentSeq`. This process will continue, finding consecutive elements in the set, until no more consecutive elements are found.\nFinally, to get the length of the longest consecutive sequence, we update the `longestSeq` variable by choosing the maximum value between itself and `currentSeq`. This will keep track of the longest consecutive sequence found so far.\nThe process continues until all numbers in the original array have been checked, and at the end, `longestSeq` will store the answer - the length of the longest consecutive elements sequence.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [100,4,200,1,3,2]",
                    "output": " 4",
                    "explanation": " The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4."
                },
                {
                    "input": " nums = [0,3,7,2,5,8,4,6,0,1]",
                    "output": " 9",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[100,4,200,1,3,2]",
                    "output": "4"
                },
                {
                    "input": "[0,3,7,2,5,8,4,6,0,1]",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-51",
        "prompt": "Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._\n\nYou must write an algorithm that runs in `O(n)` time."
    },
    "leetcode-benchmark-52": {
        "id": "leetcode-benchmark-52",
        "title": "Sum Root to Leaf Numbers",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given the `root` of a binary tree containing digits from `0` to `9` only.\n\nEach root-to-leaf path in the tree represents a number.\n\n*   For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.\n\nReturn _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a **32-bit** integer.\n\nA **leaf** node is a node with no children.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[1,2,3\\]\n**Output:** 25\n**Explanation:**\nThe root-to-leaf path `1->2` represents the number `12`.\nThe root-to-leaf path `1->3` represents the number `13`.\nTherefore, sum = 12 + 13 = `25`.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[4,9,0,5,1\\]\n**Output:** 1026\n**Explanation:**\nThe root-to-leaf path `4->9->5` represents the number 495.\nThe root-to-leaf path `4->9->1` represents the number 491.\nThe root-to-leaf path `4->0` represents the number 40.\nTherefore, sum = 495 + 491 + 40 = `1026`."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 1000]`.\n*   `0 <= Node.val <= 9`\n*   The depth of the tree will not exceed `10`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int sumNumbers(TreeNode root) {\n    return sumNumbersHelper(root, 0);\n}\n\nprivate int sumNumbersHelper(TreeNode root, int cur) {\n    if (root == null) return 0;\n    cur = cur * 10 + root.val;\n    if (root.left == null && root.right == null) return cur;\n    return sumNumbersHelper(root.left, cur) + sumNumbersHelper(root.right, cur);\n}\n```\n\n    \n    The algorithm is a depth-first search (DFS) algorithm that traverses the binary tree. The function is called recursively with the current node and the sum of the numbers traversed till that node. At the beginning, the sum is initialized to zero.\n\nIf the root is null, it means we have reached the end of a path, so we return 0.\n\nWe update the current sum by multiplying it with 10 and adding the value of the current root to it. If the current node is a leaf node (both left and right are null), we return the current sum.\n\nFinally, the result is a sum of the values returned from the left and right subtrees. Since we use the same code for all languages, the only difference lies in the syntax and how the null values are handled. \n    ",
        "c++": "\n    ```cpp\nint sumNumbers(TreeNode* root, int cur = 0) {\n    if (!root) return 0;\n    cur = cur * 10 + root->val;\n    if (!root->left && !root->right) return cur;\n    return sumNumbers(root->left, cur) + sumNumbers(root->right, cur);\n}\n```\n\n    \n    The algorithm is a depth-first search (DFS) algorithm that traverses the binary tree. The function is called recursively with the current node and the sum of the numbers traversed till that node. At the beginning, the sum is initialized to zero.\n\nIf the root is null, it means we have reached the end of a path, so we return 0.\n\nWe update the current sum by multiplying it with 10 and adding the value of the current root to it. If the current node is a leaf node (both left and right are null), we return the current sum.\n\nFinally, the result is a sum of the values returned from the left and right subtrees. Since we use the same code for all languages, the only difference lies in the syntax and how the null values are handled. \n    ",
        "python": "\n    ```python\ndef sumNumbers(root, cur=0):\n    if root is None: return 0\n    cur = cur * 10 + root.val\n    if root.left is None and root.right is None: return cur\n    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur)\n```\n\n    \n    The algorithm is a depth-first search (DFS) algorithm that traverses the binary tree. The function is called recursively with the current node and the sum of the numbers traversed till that node. At the beginning, the sum is initialized to zero.\n\nIf the root is null, it means we have reached the end of a path, so we return 0.\n\nWe update the current sum by multiplying it with 10 and adding the value of the current root to it. If the current node is a leaf node (both left and right are null), we return the current sum.\n\nFinally, the result is a sum of the values returned from the left and right subtrees. Since we use the same code for all languages, the only difference lies in the syntax and how the null values are handled. \n    ",
        "javascript": "\n    ```javascript\nfunction sumNumbers(root, cur = 0) {\n    if (!root) return 0;\n    cur = cur * 10 + root.val;\n    if (!root.left && !root.right) return cur;\n    return sumNumbers(root.left, cur) + sumNumbers(root.right, cur);\n}\n```\n\n    \n    The algorithm is a depth-first search (DFS) algorithm that traverses the binary tree. The function is called recursively with the current node and the sum of the numbers traversed till that node. At the beginning, the sum is initialized to zero.\n\nIf the root is null, it means we have reached the end of a path, so we return 0.\n\nWe update the current sum by multiplying it with 10 and adding the value of the current root to it. If the current node is a leaf node (both left and right are null), we return the current sum.\n\nFinally, the result is a sum of the values returned from the left and right subtrees. Since we use the same code for all languages, the only difference lies in the syntax and how the null values are handled. \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [1,2,3]",
                    "output": " 25",
                    "explanation": "\nThe root-to-leaf path `1->2` represents the number `12`.\nThe root-to-leaf path `1->3` represents the number `13`.\nTherefore, sum = 12 + 13 = `25`."
                },
                {
                    "input": " root = [4,9,0,5,1]",
                    "output": " 1026",
                    "explanation": "\nThe root-to-leaf path `4->9->5` represents the number 495.\nThe root-to-leaf path `4->9->1` represents the number 491.\nThe root-to-leaf path `4->0` represents the number 40.\nTherefore, sum = 495 + 491 + 40 = `1026`."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "25"
                },
                {
                    "input": "[4,9,0,5,1]",
                    "output": "1026"
                }
            ]
        },
        "task_id": "leetcode-benchmark-52",
        "prompt": "You are given the `root` of a binary tree containing digits from `0` to `9` only.\n\nEach root-to-leaf path in the tree represents a number.\n\n*   For example, the root-to-leaf path `1 -> 2 -> 3` represents the number `123`.\n\nReturn _the total sum of all root-to-leaf numbers_. Test cases are generated so that the answer will fit in a **32-bit** integer.\n\nA **leaf** node is a node with no children."
    },
    "leetcode-benchmark-53": {
        "id": "leetcode-benchmark-53",
        "title": "Palindrome Partitioning",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return _all possible palindrome partitioning of_ `s`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"aab\"\n**Output:** \\[\\[\"a\",\"a\",\"b\"\\],\\[\"aa\",\"b\"\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \"a\"\n**Output:** \\[\\[\"a\"\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 16`\n*   `s` contains only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start++) != s.charAt(end--)) return false;\n        }\n        return true;\n    }\n\n    private void dfs(String s, int start, List<List<String>> results, List<String> current) {\n        if (start == s.length()) {\n            results.add(new ArrayList<>(current));\n            return;\n        }\n        \n        for (int end = start; end < s.length(); end++) {\n            if (isPalindrome(s, start, end)) {\n                current.add(s.substring(start, end + 1));\n                dfs(s, end + 1, results, current);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        List<List<String>> results = new ArrayList<>();\n        List<String> current = new ArrayList<>();\n        dfs(s, 0, results, current);\n        return results;\n    }\n}\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nbool isPalindrome(const std::string& s, int start, int end) {\n    while (start < end) {\n        if (s[start++] != s[end--]) return false;\n    }\n    return true;\n}\n\nvoid dfs(const std::string& s, int start, std::vector<std::vector<std::string>>& results, std::vector<std::string> current) {\n    if (start == s.length()) {\n        results.push_back(current);\n        return;\n    }\n    \n    for (int end = start; end < s.length(); ++end) {\n        if (isPalindrome(s, start, end)) {\n            current.push_back(s.substr(start, end - start + 1));\n            dfs(s, end + 1, results, current);\n            current.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> results;\n    std::vector<std::string> current;\n    dfs(s, 0, results, current);\n    return results;\n}\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ",
        "python": "\n    ```python\ndef isPalindrome(s, start, end):\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef dfs(s, start, results, current):\n    if start == len(s):\n        results.append(current[:])\n        return\n    \n    for end in range(start, len(s)):\n        if isPalindrome(s, start, end):\n            current.append(s[start:end+1])\n            dfs(s, end + 1, results, current)\n            current.pop()\n\ndef partition(s):\n    results = []\n    dfs(s, 0, results, [])\n    return results\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ",
        "javascript": "\n    ```javascript\nfunction isPalindrome(s, start, end) {\n    while (start < end) {\n        if (s[start++] !== s[end--]) return false;\n    }\n    return true;\n}\n\nfunction dfs(s, start, results, current) {\n    if (start === s.length) {\n        results.push([...current]);\n        return;\n    }\n    \n    for (let end = start; end < s.length; end++) {\n        if (isPalindrome(s, start, end)) {\n            current.push(s.slice(start, end + 1));\n            dfs(s, end + 1, results, current);\n            current.pop();\n        }\n    }\n}\n\nfunction partition(s) {\n    let results = [];\n    dfs(s, 0, results, []);\n    return results;\n}\n```\n    \n    The algorithm is based on depth-first search (DFS). It starts by iterating over substrings at each position and checks if the substring is a palindrome. If it is a palindrome, it adds the substring to the current list and does a depth-first search at the next position. When the search reaches the end of the string, it adds the current list to the results list. After searching at a given position, it backtracks to the previous position and continues to search for palindromes. The overall time complexity is O(N * 2^N) where N is the length of the string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"aab\"",
                    "output": " [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]",
                    "explanation": null
                },
                {
                    "input": " s = \"a\"",
                    "output": " [[\"a\"]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"aab\"",
                    "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]"
                },
                {
                    "input": "\"a\"",
                    "output": "[[\"a\"]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-53",
        "prompt": "Given a string `s`, partition `s` such that every substring of the partition is a **palindrome**. Return _all possible palindrome partitioning of_ `s`."
    },
    "leetcode-benchmark-54": {
        "id": "leetcode-benchmark-54",
        "title": "Gas Station",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**",
            "examples": [
                "**Example 1:**\n\n**Input:** gas = \\[1,2,3,4,5\\], cost = \\[3,4,5,1,2\\]\n**Output:** 3\n**Explanation:**\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\n\n",
                "**Example 2:**\n\n**Input:** gas = \\[2,3,4\\], cost = \\[3,4,3\\]\n**Output:** -1\n**Explanation:**\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start."
            ],
            "constraints": "**Constraints:**\n\n*   `n == gas.length == cost.length`\n*   `1 <= n <= 105`\n*   `0 <= gas[i], cost[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int canCompleteCircuit(int[] gas, int[] cost) {\n    int totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (int i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "c++": "\n    ```cpp\nint can_complete_circuit(vector<int>& gas, vector<int>& cost) {\n    int total_gas = 0, total_cost = 0, start = 0, gas_tank = 0;\n    for (int i = 0; i < gas.size(); ++i) {\n        total_gas += gas[i];\n        total_cost += cost[i];\n        gas_tank += gas[i] - cost[i];\n        if (gas_tank < 0) {\n            start = i + 1;\n            gas_tank = 0;\n        }\n    }\n    return (total_gas < total_cost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "python": "\n    ```python\ndef can_complete_circuit(gas, cost):\n    total_gas, total_cost, start, gas_tank = 0, 0, 0, 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        gas_tank += gas[i] - cost[i]\n        if gas_tank < 0:\n            start = i + 1\n            gas_tank = 0\n    return -1 if total_gas < total_cost else start\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "javascript": "\n    ```javascript\nfunction canCompleteCircuit(gas, cost) {\n    let totalGas = 0, totalCost = 0, start = 0, gasTank = 0;\n    for (let i = 0; i < gas.length; i++) {\n        totalGas += gas[i];\n        totalCost += cost[i];\n        gasTank += gas[i] - cost[i];\n        if (gasTank < 0) {\n            start = i + 1;\n            gasTank = 0;\n        }\n    }\n    return (totalGas < totalCost) ? -1 : start;\n}\n```\n    \n    The algorithm maintains four variables: `total_gas`, `total_cost`, `start`, and `gas_tank`. We initialize these variables to 0. We then loop through each gas station and perform the following steps:\n\n1. Add the gas at the current station to `total_gas`.\n2. Add the cost of traveling from this station to the next one to `total_cost`.\n3. Add the net gain/loss of gas (gas[i] - cost[i]) to `gas_tank`.\n4. If the `gas_tank` is negative, update the `start` position to the next station and reset the `gas_tank` to 0.\n\nAfter looping through all the gas stations, we check if `total_gas` is greater than or equal to `total_cost`. If it is, we return the `start` position, as this is the first gas station from which we can make a complete trip. If not, we return -1, because it is not possible to complete the circuit. \n\nThis algorithm guarantees a unique solution because if there are multiple valid starting points, there must be a gas station with a lower cost to travel from it to the next station for each solution. As a result, the one with the lowest starting cost would always be chosen, ensuring uniqueness.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " gas = [1,2,3,4,5], cost = [3,4,5,1,2]",
                    "output": " 3",
                    "explanation": "\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index."
                },
                {
                    "input": " gas = [2,3,4], cost = [3,4,3]",
                    "output": " -1",
                    "explanation": "\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5],[3,4,5,1,2]",
                    "output": "3"
                },
                {
                    "input": "[2,3,4],[3,4,3]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-54",
        "prompt": "There are `n` gas stations along a circular route, where the amount of gas at the `ith` station is `gas[i]`.\n\nYou have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from the `ith` station to its next `(i + 1)th` station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays `gas` and `cost`, return _the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return_ `-1`. If there exists a solution, it is **guaranteed** to be **unique**"
    },
    "leetcode-benchmark-55": {
        "id": "leetcode-benchmark-55",
        "title": "Single Number II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. _Find the single element and return it_.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,2,3,2\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,0,1,0,1,99\\]\n**Output:** 99"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 3 * 104`\n*   `-231 <= nums[i] <= 231 - 1`\n*   Each element in `nums` appears exactly **three times** except for one element which appears **once**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int singleNumber(int[] nums) {\n    int ones = 0, twos = 0;\n    for (int n : nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "c++": "\n    ```cpp\nint singleNumber(vector<int>& nums) {\n    int ones = 0, twos = 0;\n    for (int n : nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "python": "\n    ```python\ndef singleNumber(nums):\n    ones, twos = 0, 0\n    for n in nums:\n        ones = (ones ^ n) & ~twos\n        twos = (twos ^ n) & ~ones\n    return ones\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "javascript": "\n    ```javascript\nfunction singleNumber(nums) {\n    let ones = 0, twos = 0;\n    for (let n of nums) {\n        ones = (ones ^ n) & ~twos;\n        twos = (twos ^ n) & ~ones;\n    }\n    return ones;\n}\n```\n    \n    In this problem, we use two variables, ones and twos, to represent the number of occurrences of each bit in the array's elements.\n\nInitially, both ones and twos are set to 0. We use XOR (^) to count the occurrences of each bit in the array. The reason we use XOR is that it cancels out the same bits, so if a bit occurs twice, it will be 0.\n\nWe then loop through each element of the array and use XOR to count the bit occurrences. If a bit occurs for the first time, it's XORed into ones; if it occurs for the second time, it's XORed into twos. If it appears for the third time, it should be removed from both ones and twos. To achieve this, we use the bitwise AND (&) along with the bitwise NOT (~) to clear the bits that appear in twos from ones and vice versa.\n\nFinally, after looping through all the elements of the array, the variable ones will only contain the bits that occurred once in the array, and that is our result. So we return the ones variable.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,2,3,2]",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " nums = [0,1,0,1,0,1,99]",
                    "output": " 99",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,2,3,2]",
                    "output": "3"
                },
                {
                    "input": "[0,1,0,1,0,1,99]",
                    "output": "99"
                }
            ]
        },
        "task_id": "leetcode-benchmark-55",
        "prompt": "Given an integer array `nums` where every element appears **three times** except for one, which appears **exactly once**. _Find the single element and return it_.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space."
    },
    "leetcode-benchmark-56": {
        "id": "leetcode-benchmark-56",
        "title": "Word Break",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"leetcode \", wordDict = \\[ \"leet \", \"code \"\\]\n**Output:** true\n**Explanation:** Return true because  \"leetcode \" can be segmented as  \"leet code \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"applepenapple \", wordDict = \\[ \"apple \", \"pen \"\\]\n**Output:** true\n**Explanation:** Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"catsandog \", wordDict = \\[ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 300`\n*   `1 <= wordDict.length <= 1000`\n*   `1 <= wordDict[i].length <= 20`\n*   `s` and `wordDict[i]` consist of only lowercase English letters.\n*   All the strings of `wordDict` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.Set;\nimport java.util.HashSet;\n\npublic boolean wordBreak(String s, List<String> wordDict) {\n    Set<String> dict = new HashSet<>(wordDict);\n    boolean[] dp = new boolean[s.length() + 1];\n    dp[0] = true;\n    for (int i = 1; i <= s.length(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (dp[j] && dict.contains(s.substring(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length()];\n}\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <unordered_set>\n\nbool wordBreak(std::string s, std::vector<std::string>& wordDict) {\n    std::unordered_set<std::string> dict(wordDict.begin(), wordDict.end());\n    std::vector<bool> dp(s.size() + 1, false);\n    dp[0] = true;\n    for (size_t i = 1; i <= s.size(); ++i) {\n        for (size_t j = 0; j < i; ++j) {\n            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.size()];\n}\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ",
        "python": "\n    ```python\ndef word_break(s, word_dict):\n    word_set = set(word_dict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ",
        "javascript": "\n    ```javascript\nfunction wordBreak(s, wordDict) {\n    const dict = new Set(wordDict);\n    const dp = Array(s.length + 1).fill(false);\n    dp[0] = true;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (dp[j] && dict.has(s.slice(j, i))) {\n                dp[i] = true;\n                break;\n            }\n        }\n    }\n    return dp[s.length];\n}\n```\n\n    \n    The algorithm uses dynamic programming to solve the problem. The dp array is created with the size of the input string s plus 1. dp[i] is true if there exists a segmentation of the first i characters of the string s into words from the dictionary. The algorithm initializes dp[0] as true since an empty string can be segmented.\n\nFor each character in the input string s, the algorithm checks all substrings ending at this character. If the substring s[j:i] is in the dictionary (or wordDict for Java and C++) and dp[j] is true, set dp[i] to true and break from the inner loop.\n\nAt the end of the algorithm, dp[s.size()] (or dp[s.length()] for Java and JavaScript, or dp[len(s)] in Python) contains the result for the entire input string s. If this value is true, the input string can be segmented into a sequence of one or more dictionary words, otherwise it cannot.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"leetcode \", wordDict = [ \"leet \", \"code \"]",
                    "output": " True",
                    "explanation": " Return true because  \"leetcode \" can be segmented as  \"leet code \"."
                },
                {
                    "input": " s =  \"applepenapple \", wordDict = [ \"apple \", \"pen \"]",
                    "output": " True",
                    "explanation": " Return true because  \"applepenapple \" can be segmented as  \"apple pen apple \".\nNote that you are allowed to reuse a dictionary word."
                },
                {
                    "input": " s =  \"catsandog \", wordDict = [ \"cats \", \"dog \", \"sand \", \"and \", \"cat \"]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"leetcode\",[\"leet\",\"code\"]",
                    "output": "True"
                },
                {
                    "input": "\"applepenapple\",[\"apple\",\"pen\"]",
                    "output": "True"
                },
                {
                    "input": "\"catsandog\",[\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-56",
        "prompt": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation."
    },
    "leetcode-benchmark-57": {
        "id": "leetcode-benchmark-57",
        "title": "Evaluate Reverse Polish Notation",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nEvaluate the expression. Return _an integer that represents the value of the expression_.\n\n**Note** that:\n\n*   The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Each operand may be an integer or another expression.\n*   The division between two integers always **truncates toward zero**.\n*   There will not be any division by zero.\n*   The input represents a valid arithmetic expression in a reverse polish notation.\n*   The answer and all the intermediate calculations can be represented in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** tokens = \\[ \"2 \", \"1 \", \"+ \", \"3 \", \"\\* \"\\]\n**Output:** 9\n**Explanation:** ((2 + 1) \\* 3) = 9\n\n",
                "**Example 2:**\n\n**Input:** tokens = \\[ \"4 \", \"13 \", \"5 \", \"/ \", \"+ \"\\]\n**Output:** 6\n**Explanation:** (4 + (13 / 5)) = 6\n\n",
                "**Example 3:**\n\n**Input:** tokens = \\[ \"10 \", \"6 \", \"9 \", \"3 \", \"+ \", \"-11 \", \"\\* \", \"/ \", \"\\* \", \"17 \", \"+ \", \"5 \", \"+ \"\\]\n**Output:** 22\n**Explanation:** ((10 \\* (6 / ((9 + 3) \\* -11))) + 17) + 5\n= ((10 \\* (6 / (12 \\* -11))) + 17) + 5\n= ((10 \\* (6 / -132)) + 17) + 5\n= ((10 \\* 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= tokens.length <= 104`\n*   `tokens[i]` is either an operator: `\"+ \"`, `\"- \"`, `\"* \"`, or `\"/ \"`, or an integer in the range `[-200, 200]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int evalRPN(String[] tokens) {\n    Stack<Integer> stack = new Stack<>();\n    for (String token : tokens) {\n        if (token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\")) {\n            int b = stack.pop();\n            int a = stack.pop();\n            if (token.equals(\"+\")) stack.push(a + b);\n            else if (token.equals(\"-\")) stack.push(a - b);\n            else if (token.equals(\"*\")) stack.push(a * b);\n            else stack.push(a / b);\n        } else {\n            stack.push(Integer.parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n```\n    \n    The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <stack>\n\nint evalRPN(vector<string>& tokens) {\n    stack<int> s;\n    for (const string& token : tokens) {\n        if(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            if (token == \"+\") s.push(a + b);\n            else if (token == \"-\") s.push(a - b);\n            else if (token == \"*\") s.push(a * b);\n            else s.push(a / b);\n        } else {\n            s.push(stoi(token));\n        }\n    }\n    return s.top();\n}\n```\n    \n    The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively.\n    ",
        "python": "\n    ```python\ndef evalRPN(tokens):\n    stack = []\n    for token in tokens:\n        if token in {\"+\", \"-\", \"*\", \"/\"}:\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\":\n                stack.append(a + b)\n            elif token == \"-\":\n                stack.append(a - b)\n            elif token == \"*\":\n                stack.append(a * b)\n            else:\n                stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[-1]\n```\n    \n    The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively.\n    ",
        "javascript": "\n    ```javascript\nfunction evalRPN(tokens) {\n    const stack = [];\n    for (const token of tokens) {\n        if (token === \"+\" || token === \"-\" || token === \"*\" || token === \"/\") {\n            const b = stack.pop();\n            const a = stack.pop();\n            if (token === \"+\") stack.push(a + b);\n            else if (token === \"-\") stack.push(a - b);\n            else if (token === \"*\") stack.push(a * b);\n            else stack.push(Math.trunc(a / b));\n        } else {\n            stack.push(parseInt(token));\n        }\n    }\n    return stack.pop();\n}\n```\n    \n    The algorithm for evaluating the Reverse Polish Notation (RPN) expression is based on the stack data structure. Iterate through the given tokens array, and for each token:\n\n1. If the token is an operator (+, -, *, /), pop the top two elements from the stack, apply the operation, and push the result back onto the stack.\n2. If the token is a number, push it onto the stack.\n\nAfter the loop, the top element on the stack is the final result of the evaluated RPN expression.\n\nNote that in Python and JavaScript, we need to make sure the division result is truncated toward zero using `int(a / b)` and `Math.trunc(a / b)` respectively.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " tokens = [ \"2 \", \"1 \", \"+ \", \"3 \", \"* \"]",
                    "output": " 9",
                    "explanation": " ((2 + 1) \\* 3) = 9"
                },
                {
                    "input": " tokens = [ \"4 \", \"13 \", \"5 \", \"/ \", \"+ \"]",
                    "output": " 6",
                    "explanation": " (4 + (13 / 5)) = 6"
                },
                {
                    "input": " tokens = [ \"10 \", \"6 \", \"9 \", \"3 \", \"+ \", \"-11 \", \"* \", \"/ \", \"* \", \"17 \", \"+ \", \"5 \", \"+ \"]",
                    "output": " 22",
                    "explanation": " ((10 \\* (6 / ((9 + 3) \\* -11))) + 17) + 5\n= ((10 \\* (6 / (12 \\* -11))) + 17) + 5\n= ((10 \\* (6 / -132)) + 17) + 5\n= ((10 \\* 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22"
                }
            ],
            "function_input": [
                {
                    "input": "[\"2\",\"1\",\"+\",\"3\",\"*\"]",
                    "output": "9"
                },
                {
                    "input": "[\"4\",\"13\",\"5\",\"/\",\"+\"]",
                    "output": "6"
                },
                {
                    "input": "[\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]",
                    "output": "22"
                }
            ]
        },
        "task_id": "leetcode-benchmark-57",
        "prompt": "You are given an array of strings `tokens` that represents an arithmetic expression in a [Reverse Polish Notation](http://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nEvaluate the expression. Return _an integer that represents the value of the expression_.\n\n**Note** that:\n\n*   The valid operators are `'+'`, `'-'`, `'*'`, and `'/'`.\n*   Each operand may be an integer or another expression.\n*   The division between two integers always **truncates toward zero**.\n*   There will not be any division by zero.\n*   The input represents a valid arithmetic expression in a reverse polish notation.\n*   The answer and all the intermediate calculations can be represented in a **32-bit** integer."
    },
    "leetcode-benchmark-58": {
        "id": "leetcode-benchmark-58",
        "title": "Reverse Words in a String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an input string `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.\n\nReturn _a string of the words in reverse order concatenated by a single space._\n\n**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"the sky is blue \"\n**Output:**  \"blue is sky the \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"  hello world   \"\n**Output:**  \"world hello \"\n**Explanation:** Your reversed string should not contain leading or trailing spaces.\n\n",
                "**Example 3:**\n\n**Input:** s =  \"a good   example \"\n**Output:**  \"example good a \"\n**Explanation:** You need to reduce multiple spaces between two words to a single space in the reversed string."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` contains English letters (upper-case and lower-case), digits, and spaces `' '`.\n*   There is **at least one** word in `s`.\n\n**",
            "follow_up": "Follow-up:** If the string data type is mutable in your language, can you solve it **in-place** with `O(1)` extra space?"
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic String reverseWords(String s) {\n    String[] words = s.trim().split(\"\\\\s+\");\n    Collections.reverse(Arrays.asList(words));\n    return String.join(\" \", words);\n}\n```\n    \n    The algorithm to reverse the order of the words is as follows:\n\n1. First, split the input string using spaces. In C++, we use `stringstream` and a while loop to read words, while in Java and JavaScript, we use `split` with regex to split the string based on one or more spaces. In Python, we can simply use `split()` since it splits on whitespace by default and ignores leading and trailing spaces.\n\n2. Reverse the array of words. In C++, we use the `reverse` function from the `algorithm` library. In Java, we can use `Collections.reverse()` method. In Python, we use list `reverse()` method. In JavaScript, we use the `reverse()` method on the array.\n\n3. Join the reversed array of words into a single string with a space delimiter. In C++, we concatenate words with a space but avoid adding an extra space at the end. In Java, we use `String.join()`, in Python, use `join()` on the delimiter string, and in JavaScript, use `join()` on the array.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nstd::string reverseWords(std::string s) {\n    std::stringstream ss(s);\n    std::vector<std::string> words;\n    std::string temp;\n\n    while (ss >> temp) {\n        words.push_back(temp);\n    }\n\n    std::reverse(words.begin(), words.end());\n\n    std::string result;\n    for (size_t i = 0; i < words.size(); ++i) {\n        result += words[i] + (i < words.size() - 1 ? \" \" : \"\");\n    }\n\n    return result;\n}\n```\n    \n    The algorithm to reverse the order of the words is as follows:\n\n1. First, split the input string using spaces. In C++, we use `stringstream` and a while loop to read words, while in Java and JavaScript, we use `split` with regex to split the string based on one or more spaces. In Python, we can simply use `split()` since it splits on whitespace by default and ignores leading and trailing spaces.\n\n2. Reverse the array of words. In C++, we use the `reverse` function from the `algorithm` library. In Java, we can use `Collections.reverse()` method. In Python, we use list `reverse()` method. In JavaScript, we use the `reverse()` method on the array.\n\n3. Join the reversed array of words into a single string with a space delimiter. In C++, we concatenate words with a space but avoid adding an extra space at the end. In Java, we use `String.join()`, in Python, use `join()` on the delimiter string, and in JavaScript, use `join()` on the array.\n    ",
        "python": "\n    ```python\ndef reverseWords(s):\n    words = s.split()\n    words.reverse()\n    return ' '.join(words)\n```\n    \n    The algorithm to reverse the order of the words is as follows:\n\n1. First, split the input string using spaces. In C++, we use `stringstream` and a while loop to read words, while in Java and JavaScript, we use `split` with regex to split the string based on one or more spaces. In Python, we can simply use `split()` since it splits on whitespace by default and ignores leading and trailing spaces.\n\n2. Reverse the array of words. In C++, we use the `reverse` function from the `algorithm` library. In Java, we can use `Collections.reverse()` method. In Python, we use list `reverse()` method. In JavaScript, we use the `reverse()` method on the array.\n\n3. Join the reversed array of words into a single string with a space delimiter. In C++, we concatenate words with a space but avoid adding an extra space at the end. In Java, we use `String.join()`, in Python, use `join()` on the delimiter string, and in JavaScript, use `join()` on the array.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseWords(s) {\n    return s.trim().split(/\\s+/).reverse().join(' ');\n}\n```\n    \n    The algorithm to reverse the order of the words is as follows:\n\n1. First, split the input string using spaces. In C++, we use `stringstream` and a while loop to read words, while in Java and JavaScript, we use `split` with regex to split the string based on one or more spaces. In Python, we can simply use `split()` since it splits on whitespace by default and ignores leading and trailing spaces.\n\n2. Reverse the array of words. In C++, we use the `reverse` function from the `algorithm` library. In Java, we can use `Collections.reverse()` method. In Python, we use list `reverse()` method. In JavaScript, we use the `reverse()` method on the array.\n\n3. Join the reversed array of words into a single string with a space delimiter. In C++, we concatenate words with a space but avoid adding an extra space at the end. In Java, we use `String.join()`, in Python, use `join()` on the delimiter string, and in JavaScript, use `join()` on the array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"the sky is blue \"",
                    "output": "  \"blue is sky the \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"  hello world   \"",
                    "output": "  \"world hello \"",
                    "explanation": " Your reversed string should not contain leading or trailing spaces."
                },
                {
                    "input": " s =  \"a good   example \"",
                    "output": "  \"example good a \"",
                    "explanation": " You need to reduce multiple spaces between two words to a single space in the reversed string."
                }
            ],
            "function_input": [
                {
                    "input": "\"theskyisblue\"",
                    "output": "\"blueisskythe\""
                },
                {
                    "input": "\"helloworld\"",
                    "output": "\"worldhello\""
                },
                {
                    "input": "\"agoodexample\"",
                    "output": "\"examplegooda\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-58",
        "prompt": "Given an input string `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.\n\nReturn _a string of the words in reverse order concatenated by a single space._\n\n**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces."
    },
    "leetcode-benchmark-59": {
        "id": "leetcode-benchmark-59",
        "title": "Maximum Product Subarray",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,-2,4\\]\n**Output:** 6\n**Explanation:** \\[2,3\\] has the largest product 6.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-2,0,-1\\]\n**Output:** 0\n**Explanation:** The result cannot be 2, because \\[-2,-1\\] is not a subarray."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `-10 <= nums[i] <= 10`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxProduct(int[] nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            int temp = max_so_far;\n            max_so_far = min_so_far;\n            min_so_far = temp;\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "c++": "\n    ```cpp\nint maxProduct(vector<int>& nums) {\n    int max_so_far = nums[0];\n    int min_so_far = nums[0];\n    int result = nums[0];\n    \n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 0)\n            swap(max_so_far, min_so_far);\n        \n        max_so_far = max(nums[i], max_so_far * nums[i]);\n        min_so_far = min(nums[i], min_so_far * nums[i]);\n        result = max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "python": "\n    ```python\ndef maxProduct(nums):\n    max_so_far = min_so_far = result = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_so_far, min_so_far = min_so_far, max_so_far\n        \n        max_so_far = max(nums[i], max_so_far * nums[i])\n        min_so_far = min(nums[i], min_so_far * nums[i])\n        result = max(result, max_so_far)\n    \n    return result\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProduct(nums) {\n    let max_so_far = nums[0];\n    let min_so_far = nums[0];\n    let result = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        if (nums[i] < 0) {\n            [max_so_far, min_so_far] = [min_so_far, max_so_far];\n        }\n        \n        max_so_far = Math.max(nums[i], max_so_far * nums[i]);\n        min_so_far = Math.min(nums[i], min_so_far * nums[i]);\n        result = Math.max(result, max_so_far);\n    }\n    return result;\n}\n```\n\n    \n    The algorithm maintains the maximum and minimum product subarray ending at the current position. For each position, it checks if the current element is negative. If it is, it swaps the maximum and minimum product subarray, since multiplying by a negative number reverses their order.\n\nAfter the swap, it calculates the maximum and minimum product subarray ending at the current position by considering the current element and the product of the maximum and minimum product subarray ending at the previous position, multiplied by the current element. It updates the result as the maximum of the result and the maximum product subarray ending at the current position.\n\nThis process continues for all elements of the array, and the result is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,3,-2,4]",
                    "output": " 6",
                    "explanation": " \\[2,3\\] has the largest product 6."
                },
                {
                    "input": " nums = [-2,0,-1]",
                    "output": " 0",
                    "explanation": " The result cannot be 2, because \\[-2,-1\\] is not a subarray."
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,-2,4]",
                    "output": "6"
                },
                {
                    "input": "[-2,0,-1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-59",
        "prompt": "Given an integer array `nums`, find a subarray that has the largest product, and return _the product_.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer."
    },
    "leetcode-benchmark-60": {
        "id": "leetcode-benchmark-60",
        "title": "Find Minimum in Rotated Sorted Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n*   `[0,1,2,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.\n\nYou must write an algorithm that runs in `O(log n) time.`",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,4,5,1,2\\]\n**Output:** 1\n**Explanation:** The original array was \\[1,2,3,4,5\\] rotated 3 times.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[4,5,6,7,0,1,2\\]\n**Output:** 0\n**Explanation:** The original array was \\[0,1,2,4,5,6,7\\] and it was rotated 4 times.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[11,13,15,17\\]\n**Output:** 11\n**Explanation:** The original array was \\[11,13,15,17\\] and it was rotated 4 times."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 5000`\n*   `-5000 <= nums[i] <= 5000`\n*   All the integers of `nums` are **unique**.\n*   `nums` is sorted and rotated between `1` and `n` times.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findMin(int[] nums) {\n    int left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "c++": "\n    ```c++\nint findMin(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "python": "\n    ```python\ndef find_min(nums):\n    left, right = 0, len(nums) - 1\n\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "javascript": "\n    ```javascript\nfunction findMin(nums) {\n    let left = 0, right = nums.length - 1;\n\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n    \n    The algorithm uses a binary search approach to find the minimum element in the sorted rotated array. Initially, pointers `left` and `right` are set to the start and end of the array. The midpoint `mid` is calculated as the average of `left` and `right`. The main idea is that whenever `nums[mid]` is greater than `nums[right]`, the minimum element must be in the right half of the array; otherwise, we search in the left half. This ensures that the algorithm runs in O(log n) time, as the search space is reduced by half each iteration. When `left` and `right` meet, the minimum element is found at `left`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,4,5,1,2]",
                    "output": " 1",
                    "explanation": " The original array was \\[1,2,3,4,5\\] rotated 3 times."
                },
                {
                    "input": " nums = [4,5,6,7,0,1,2]",
                    "output": " 0",
                    "explanation": " The original array was \\[0,1,2,4,5,6,7\\] and it was rotated 4 times."
                },
                {
                    "input": " nums = [11,13,15,17]",
                    "output": " 11",
                    "explanation": " The original array was \\[11,13,15,17\\] and it was rotated 4 times."
                }
            ],
            "function_input": [
                {
                    "input": "[3,4,5,1,2]",
                    "output": "1"
                },
                {
                    "input": "[4,5,6,7,0,1,2]",
                    "output": "0"
                },
                {
                    "input": "[11,13,15,17]",
                    "output": "11"
                }
            ]
        },
        "task_id": "leetcode-benchmark-60",
        "prompt": "Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:\n\n*   `[4,5,6,7,0,1,2]` if it was rotated `4` times.\n*   `[0,1,2,4,5,6,7]` if it was rotated `7` times.\n\nNotice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.\n\nGiven the sorted rotated array `nums` of **unique** elements, return _the minimum element of this array_.\n\nYou must write an algorithm that runs in `O(log n) time.`"
    },
    "leetcode-benchmark-61": {
        "id": "leetcode-benchmark-61",
        "title": "Longest Substring with At Most Two Distinct Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"eceba \"\n**Output:** 3\n**Explanation:** The substring is  \"ece \" which its length is 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ccaabbb \"\n**Output:** 5\n**Explanation:** The substring is  \"aabbb \" which its length is 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int lengthOfLongestSubstringTwoDistinct(String s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    HashMap<Character, Integer> char_count = new HashMap<>();\n\n    while (r < s.length()) {\n        char_count.put(s.charAt(r), char_count.getOrDefault(s.charAt(r), 0) + 1);\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count.put(s.charAt(l), char_count.get(s.charAt(l)) - 1);\n                if (char_count.get(s.charAt(l)) == 0) {\n                    char_count.remove(s.charAt(l));\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLongestSubstringTwoDistinct(string s) {\n    int l = 0, r = 0, max_len = 0, cur_len = 0;\n    unordered_map<char, int> char_count;\n\n    while (r < s.length()) {\n        char_count[s[r]]++;\n        if (char_count.size() <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size() > 2 && l <= r) {\n                char_count[s[l]]--;\n                if (char_count[s[l]] == 0) {\n                    char_count.erase(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "python": "\n    ```python\ndef lengthOfLongestSubstringTwoDistinct(s: str) -> int:\n    l, r, max_len, cur_len = 0, 0, 0, 0\n    char_count = {}\n\n    while r < len(s):\n        if s[r] in char_count:\n            char_count[s[r]] += 1\n        else:\n            char_count[s[r]] = 1\n        if len(char_count) <= 2:\n            cur_len += 1\n        else:\n            while len(char_count) > 2 and l <= r:\n                char_count[s[l]] -= 1\n                if char_count[s[l]] == 0:\n                    del char_count[s[l]]\n                l += 1\n                cur_len -= 1\n            cur_len += 1\n        max_len = max(max_len, cur_len)\n        r += 1\n    return max_len\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "javascript": "\n    ```javascript\nfunction lengthOfLongestSubstringTwoDistinct(s) {\n    let l = 0, r = 0, max_len = 0, cur_len = 0;\n    const char_count = new Map();\n\n    while (r < s.length) {\n        char_count.set(s[r], (char_count.get(s[r]) || 0) + 1);\n        if (char_count.size <= 2) {\n            cur_len++;\n        } else {\n            while (char_count.size > 2 && l <= r) {\n                char_count.set(s[l], char_count.get(s[l]) - 1);\n                if (char_count.get(s[l]) === 0) {\n                    char_count.delete(s[l]);\n                }\n                l++;\n                cur_len--;\n            }\n            cur_len++;\n        }\n        max_len = Math.max(max_len, cur_len);\n        r++;\n    }\n    return max_len;\n}\n```\n    \n    The algorithm implements a sliding window approach. We maintain two pointers `l` and `r` representing the left and right ends of the current substring. We also maintain a hash map `char_count` to store the counts of distinct characters in the current substring.\n\nWe iterate through the string with pointer `r`. For each character, we increment its count in the hash map. If we have two or fewer distinct characters in the current substring, we update the current length `cur_len`. If we have more than two distinct characters, we move the pointer `l` to the right, decrementing the count of the character at `l` in the hash map, and removing it if its count becomes zero. We update `cur_len` accordingly in the process.\n\nAt each step, we update the maximum length `max_len` with the maximum of `max_len` and `cur_len`. We return `max_len` at the end.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"eceba \"",
                    "output": " 3",
                    "explanation": " The substring is  \"ece \" which its length is 3."
                },
                {
                    "input": " s =  \"ccaabbb \"",
                    "output": " 5",
                    "explanation": " The substring is  \"aabbb \" which its length is 5."
                }
            ],
            "function_input": [
                {
                    "input": "\"eceba\"",
                    "output": "3"
                },
                {
                    "input": "\"ccaabbb\"",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-61",
        "prompt": "Given a string `s`, return _the length of the longest_ _substring_ _that contains at most **two distinct characters**_."
    },
    "leetcode-benchmark-62": {
        "id": "leetcode-benchmark-62",
        "title": "One Edit Distance",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`.\n\nA string `s` is said to be one distance apart from a string `t` if you can:\n\n*   Insert **exactly one** character into `s` to get `t`.\n*   Delete **exactly one** character from `s` to get `t`.\n*   Replace **exactly one** character of `s` with **a different character** to get `t`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ab \", t =  \"acb \"\n**Output:** true\n**Explanation:** We can insert 'c' into s to get t.\n\n",
                "**Example 2:**\n\n**Input:** s =  \" \", t =  \" \"\n**Output:** false\n**Explanation:** We cannot get t from s by only one step."
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= s.length, t.length <= 104`\n*   `s` and `t` consist of lowercase letters, uppercase letters, and digits.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isOneEditDistance(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (int i = 0; i < m; ++i) {\n        if (s.charAt(i) != t.charAt(i)) {\n            if (m < n) {\n                return s.substring(i).equals(t.substring(i + 1));\n            } else {\n                return s.substring(i + 1).equals(t.substring(i + 1));\n            }\n        }\n    }\n    return m + 1 == n;\n}\n```\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "c++": "\n    ```cpp\nbool isOneEditDistance(string s, string t) {\n    int m = s.length(), n = t.length();\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    bool flag = false;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] != t[i]) {\n          if (m < n) {\n              return s.substr(i) == t.substr(i + 1);\n          } else {\n              return s.substr(i + 1) == t.substr(i + 1);\n          }\n      }\n    }\n    return m + 1 == n;\n}\n```\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "python": "\n    ```python\ndef isOneEditDistance(s: str, t: str) -> bool:\n    m, n = len(s), len(t)\n    if m > n:\n        return isOneEditDistance(t, s)\n    if n - m > 1:\n        return False\n    for i in range(m):\n        if s[i] != t[i]:\n            return s[i + (m < n):] == t[i + 1:]\n    return m + 1 == n\n```\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "javascript": "\n    ```javascript\nfunction isOneEditDistance(s, t) {\n    let m = s.length, n = t.length;\n    if (m > n) {\n        return isOneEditDistance(t, s);\n    }\n    if (n - m > 1) {\n        return false;\n    }\n    for (let i = 0; i < m; ++i) {\n        if (s[i] !== t[i]) {\n            if (m < n) {\n                return s.slice(i) === t.slice(i + 1);\n            } else {\n                return s.slice(i + 1) === t.slice(i + 1);\n            }\n        }\n    }\n    return m + 1 === n;\n}\n```\n\n    \n    The algorithm first checks if the length of string `s` is greater than the length of string `t`. If true, it swaps the two strings and continues the checks. Next, the algorithm checks if the length difference between the strings is greater than 1, returning `false` if so since it's not possible to meet the one edit distance criteria in that case.\n\nThe algorithm iterates through the characters of the two strings. If it encounters a mismatched character it checks if the insertion or deletion of a character can yield the other string, and if not, it checks if the replacement of the mismatched character in string `s` can yield string `t`. If it iterates through both strings without finding a mismatch, it returns `true` if the length difference of the strings is 1 to ensure only one character has been inserted. Otherwise, it returns `false`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"ab \", t =  \"acb \"",
                    "output": " True",
                    "explanation": " We can insert 'c' into s to get t."
                },
                {
                    "input": " s =  \" \", t =  \" \"",
                    "output": " False",
                    "explanation": " We cannot get t from s by only one step."
                }
            ],
            "function_input": [
                {
                    "input": "\"ab\",\"acb\"",
                    "output": "True"
                },
                {
                    "input": "\"\",\"\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-62",
        "prompt": "Given two strings `s` and `t`, return `true` if they are both one edit distance apart, otherwise return `false`.\n\nA string `s` is said to be one distance apart from a string `t` if you can:\n\n*   Insert **exactly one** character into `s` to get `t`.\n*   Delete **exactly one** character from `s` to get `t`.\n*   Replace **exactly one** character of `s` with **a different character** to get `t`."
    },
    "leetcode-benchmark-63": {
        "id": "leetcode-benchmark-63",
        "title": "Find Peak Element",
        "difficulty": "Medium",
        "content": {
            "problem": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in `O(log n)` time.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 2\n**Explanation:** 3 is a peak element and your function should return the index number 2.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,1,3,5,6,4\\]\n**Output:** 5\n**Explanation:** Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `nums[i] != nums[i + 1]` for all valid `i`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findPeakElement(int[] nums) {\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "c++": "\n    ```cpp\nint findPeakElement(vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "python": "\n    ```python\ndef findPeakElement(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = left + (right - left) // 2\n        if nums[mid] < nums[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "javascript": "\n    ```javascript\nfunction findPeakElement(nums) {\n    let left = 0, right = nums.length - 1;\n    while (left < right) {\n        let mid = left + Math.floor((right - left) / 2);\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n```\n    \n    For this problem, we can use the binary search. Instead of comparing the mid-element to the target value, we compare it with its neighbors. Based on the comparison, we adjust the left and right pointers accordingly:\n\n1. Initialize left and right pointer, `left = 0` and `right = nums.length - 1`.\n2. While `left < right`, do the following:\n   a. Calculate the mid index, `mid = left + (right - left) // 2`.\n   b. If `nums[mid] < nums[mid + 1]`, move the left pointer to `mid + 1`.\n   c. Else, move the right pointer to the `mid`.\n3. When `left >= right`, the peak index is found, so return `left`.\n\nSince we use a binary search, the algorithm runs in O(log n) time.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,1]",
                    "output": " 2",
                    "explanation": " 3 is a peak element and your function should return the index number 2."
                },
                {
                    "input": " nums = [1,2,1,3,5,6,4]",
                    "output": " 5",
                    "explanation": " Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,1]",
                    "output": "2"
                },
                {
                    "input": "[1,2,1,3,5,6,4]",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-63",
        "prompt": "A peak element is an element that is strictly greater than its neighbors.\n\nGiven a **0-indexed** integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.\n\nYou may imagine that `nums[-1] = nums[n] = -`. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in `O(log n)` time."
    },
    "leetcode-benchmark-64": {
        "id": "leetcode-benchmark-64",
        "title": "Compare Version Numbers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two version numbers, `version1` and `version2`, compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.\n\nTo compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.\n\n_Return the following:_\n\n*   If `version1 < version2`, return `-1`.\n*   If `version1 > version2`, return `1`.\n*   Otherwise, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** version1 =  \"1.01 \", version2 =  \"1.001 \"\n**Output:** 0\n**Explanation:** Ignoring leading zeroes, both  \"01 \" and  \"001 \" represent the same integer  \"1 \".\n\n",
                "**Example 2:**\n\n**Input:** version1 =  \"1.0 \", version2 =  \"1.0.0 \"\n**Output:** 0\n**Explanation:** version1 does not specify revision 2, which means it is treated as  \"0 \".\n\n",
                "**Example 3:**\n\n**Input:** version1 =  \"0.1 \", version2 =  \"1.1 \"\n**Output:** -1\n**Explanation:** version1's revision 0 is  \"0 \", while version2's revision 0 is  \"1 \". 0 < 1, so version1 < version2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= version1.length, version2.length <= 500`\n*   `version1` and `version2` only contain digits and `'.'`.\n*   `version1` and `version2` **are valid version numbers**.\n*   All the given revisions in `version1` and `version2` can be stored in a **32-bit integer**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int compareVersion(String version1, String version2) {\n    int i = 0, j = 0;\n    while (i < version1.length() || j < version2.length()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.length() && version1.charAt(i) != '.') {\n            num1 = num1 * 10 + (version1.charAt(i++) - '0');\n        }\n        while (j < version2.length() && version2.charAt(j) != '.') {\n            num2 = num2 * 10 + (version2.charAt(j++) - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "c++": "\n    ```cpp\nint compareVersion(string version1, string version2) {\n    int i = 0, j = 0;\n    while (i < version1.size() || j < version2.size()) {\n        int num1 = 0, num2 = 0;\n        while (i < version1.size() && version1[i] != '.') {\n            num1 = num1 * 10 + (version1[i++] - '0');\n        }\n        while (j < version2.size() && version2[j] != '.') {\n            num2 = num2 * 10 + (version2[j++] - '0');\n        }\n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n        i++; j++;\n    }\n    return 0;\n}\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "python": "\n    ```python\ndef compare_version(version1, version2):\n    v1 = version1.split('.')\n    v2 = version2.split('.')\n    \n    while v1 or v2:\n        num1 = int(v1.pop(0)) if v1 else 0\n        num2 = int(v2.pop(0)) if v2 else 0\n        \n        if num1 < num2:\n            return -1\n        if num1 > num2:\n            return 1\n    return 0\n```\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "javascript": "\n    ```javascript\nfunction compareVersion(version1, version2) {\n    const v1 = version1.split('.');\n    const v2 = version2.split('.');\n    \n    while (v1.length > 0 || v2.length > 0) {\n        const num1 = v1.length > 0 ? parseInt(v1.shift()) : 0;\n        const num2 = v2.length > 0 ? parseInt(v2.shift()) : 0;\n        \n        if (num1 < num2) return -1;\n        if (num1 > num2) return 1;\n    }\n    return 0;\n}\n```\n\n    \n    1. Set two pointers `i` and `j` at the beginning of each version string.\n2. Start a while loop that runs while either pointer has not reached the end of its version string.\n3. Initialize two integer variables `num1` and `num2`.\n4. Inside the while loop, extract the integer revision values by scanning the digits at the current pointer locations and incrementing the pointers while skipping dot separators.\n5. Compare the extracted revisions. If `num1` is smaller, return -1. If `num2` is smaller, return 1.\n6. After comparing revisions or if both pointers reach the end of their version strings, increment the pointers.\n7. If the while loop finishes without finding a difference in the revisions, the version numbers are equal, so return 0.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " version1 =  \"1.01 \", version2 =  \"1.001 \"",
                    "output": " 0",
                    "explanation": " Ignoring leading zeroes, both  \"01 \" and  \"001 \" represent the same integer  \"1 \"."
                },
                {
                    "input": " version1 =  \"1.0 \", version2 =  \"1.0.0 \"",
                    "output": " 0",
                    "explanation": " version1 does not specify revision 2, which means it is treated as  \"0 \"."
                },
                {
                    "input": " version1 =  \"0.1 \", version2 =  \"1.1 \"",
                    "output": " -1",
                    "explanation": " version1's revision 0 is  \"0 \", while version2's revision 0 is  \"1 \". 0 < 1, so version1 < version2."
                }
            ],
            "function_input": [
                {
                    "input": "\"1.01\",\"1.001\"",
                    "output": "0"
                },
                {
                    "input": "\"1.0\",\"1.0.0\"",
                    "output": "0"
                },
                {
                    "input": "\"0.1\",\"1.1\"",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-64",
        "prompt": "Given two version numbers, `version1` and `version2`, compare them.\n\nVersion numbers consist of **one or more revisions** joined by a dot `'.'`. Each revision consists of **digits** and may contain leading **zeros**. Every revision contains **at least one character**. Revisions are **0-indexed from left to right**, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example `2.5.33` and `0.1` are valid version numbers.\n\nTo compare version numbers, compare their revisions in **left-to-right order**. Revisions are compared using their **integer value ignoring any leading zeros**. This means that revisions `1` and `001` are considered **equal**. If a version number does not specify a revision at an index, then **treat the revision as `0`**. For example, version `1.0` is less than version `1.1` because their revision 0s are the same, but their revision 1s are `0` and `1` respectively, and `0 < 1`.\n\n_Return the following:_\n\n*   If `version1 < version2`, return `-1`.\n*   If `version1 > version2`, return `1`.\n*   Otherwise, return `0`."
    },
    "leetcode-benchmark-65": {
        "id": "leetcode-benchmark-65",
        "title": "Fraction to Recurring Decimal",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers representing the `numerator` and `denominator` of a fraction, return _the fraction in string format_.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return **any of them**.\n\nIt is **guaranteed** that the length of the answer string is less than `104` for all the given inputs.",
            "examples": [
                "**Example 1:**\n\n**Input:** numerator = 1, denominator = 2\n**Output:**  \"0.5 \"\n\n",
                "**Example 2:**\n\n**Input:** numerator = 2, denominator = 1\n**Output:**  \"2 \"\n\n",
                "**Example 3:**\n\n**Input:** numerator = 4, denominator = 333\n**Output:**  \"0.(012) \""
            ],
            "constraints": "**Constraints:**\n\n*   `-231 <= numerator, denominator <= 231 - 1`\n*   `denominator != 0`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic String fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    StringBuilder res = new StringBuilder();\n    if ((numerator > 0) ^ (denominator > 0)) res.append('-');\n    long num = Math.abs((long)numerator), den = Math.abs((long)denominator);\n    res.append(num / den);\n    num %= den;\n    if (num == 0) return res.toString();\n    res.append('.');\n    HashMap<Long, Integer> map = new HashMap<>();\n    while (num != 0) {\n        if (map.containsKey(num)) {\n            res.insert(map.get(num), \"(\");\n            res.append(\")\");\n            break;\n        }\n        map.put(num, res.length());\n        num *= 10;\n        res.append(num / den);\n        num %= den;\n    }\n    return res.toString();\n}\n```\n\n    \n    The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\nstd::string fractionToDecimal(int numerator, int denominator) {\n    if (numerator == 0) return \"0\";\n    std::string res;\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    long num = std::abs((long)numerator), den = std::abs((long)denominator);\n    res += std::to_string(num / den);\n    num %= den;\n    if (num == 0) return res;\n    res += '.';\n    std::unordered_map<int, int> map;\n    while (num) {\n        if (map.find(num) != map.end()) {\n            res.insert(map[num], \"(\");\n            res += \")\";\n            break;\n        }\n        map[num] = res.size();\n        num *= 10;\n        res += std::to_string(num / den);\n        num %= den;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string.\n    ",
        "python": "\n    ```python\ndef fraction_to_decimal(numerator, denominator):\n    if numerator == 0:\n        return \"0\"\n    res = []\n    if (numerator > 0) ^ (denominator > 0):\n        res.append(\"-\")\n    num = abs(numerator)\n    den = abs(denominator)\n    res.append(str(num // den))\n    num %= den\n    if num == 0:\n        return \"\".join(res)\n    res.append(\".\")\n    map = {}\n    while num:\n        if num in map:\n            res.insert(map[num], \"(\")\n            res.append(\")\")\n            break\n        map[num] = len(res)\n        num *= 10\n        res.append(str(num // den))\n        num %= den\n    return \"\".join(res)\n```\n\n    \n    The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string.\n    ",
        "javascript": "\n    ```javascript\nfunction fractionToDecimal(numerator, denominator) {\n    if (numerator === 0) return \"0\";\n    let res = \"\";\n    if ((numerator > 0) ^ (denominator > 0)) res += '-';\n    let num = Math.abs(numerator), den = Math.abs(denominator);\n    res += Math.floor(num / den);\n    num %= den;\n    if (num === 0) return res;\n    res += '.';\n    let map = new Map();\n    while (num) {\n        if (map.has(num)) {\n            res = res.slice(0, map.get(num)) + \"(\" + res.slice(map.get(num)) + \")\";\n            break;\n        }\n        map.set(num, res.length);\n        num *= 10;\n        res += Math.floor(num / den);\n        num %= den;\n    }\n    return res;\n}\n```\n\n    \n    The algorithm follows the steps:\n1. If numerator is 0, the result is 0.\n2. Add the sign to the result string if necessary, and make both numerator and denominator positive.\n3. Calculate integer part using integer division and add it to the result string.\n4. Calculate the remainder of the division.\n5. If the remainder is 0, return the result. Otherwise, add a dot to the result string.\n6. Use a hash map to store remainder positions. Iterate while the remainder is not 0.\n   - If the remainder is in the map, add parentheses around the repeating part and break the loop.\n   - Update the hash map with the current remainder and its position in the result string.\n   - Multiply the remainder by 10, add the new integer part to the result string, and update the remainder.\n7. Return the result string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " numerator = 1, denominator = 2",
                    "output": "  \"0.5 \"",
                    "explanation": null
                },
                {
                    "input": " numerator = 2, denominator = 1",
                    "output": "  \"2 \"",
                    "explanation": null
                },
                {
                    "input": " numerator = 4, denominator = 333",
                    "output": "  \"0.(012) \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,2",
                    "output": "\"0.5\""
                },
                {
                    "input": "2,1",
                    "output": "\"2\""
                },
                {
                    "input": "4,333",
                    "output": "\"0.(012)\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-65",
        "prompt": "Given two integers representing the `numerator` and `denominator` of a fraction, return _the fraction in string format_.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return **any of them**.\n\nIt is **guaranteed** that the length of the answer string is less than `104` for all the given inputs."
    },
    "leetcode-benchmark-66": {
        "id": "leetcode-benchmark-66",
        "title": "Two Sum II - Input Array Is Sorted",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** numbers = \\[2,7,11,15\\], target = 9\n**Output:** \\[1,2\\]\n**Explanation:** The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return \\[1, 2\\].\n\n",
                "**Example 2:**\n\n**Input:** numbers = \\[2,3,4\\], target = 6\n**Output:** \\[1,3\\]\n**Explanation:** The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return \\[1, 3\\].\n\n",
                "**Example 3:**\n\n**Input:** numbers = \\[\\-1,0\\], target = -1\n**Output:** \\[1,2\\]\n**Explanation:** The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return \\[1, 2\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= numbers.length <= 3 * 104`\n*   `-1000 <= numbers[i] <= 1000`\n*   `numbers` is sorted in **non-decreasing order**.\n*   `-1000 <= target <= 1000`\n*   The tests are generated such that there is **exactly one solution**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] twoSum(int[] numbers, int target) {\n    int left = 0, right = numbers.length - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return new int[]{left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{};\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> twoSum(vector<int>& numbers, int target) {\n    int left = 0, right = numbers.size() - 1;\n    while (left < right) {\n        int current_sum = numbers[left] + numbers[right];\n        if (current_sum == target) {\n            return {left + 1, right + 1};\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return {};\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "python": "\n    ```python\ndef twoSum(numbers, target):\n    left, right = 0, len(numbers) - 1\n    while left < right:\n        current_sum = numbers[left] + numbers[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n    return []\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "javascript": "\n    ```javascript\nfunction twoSum(numbers, target) {\n    let left = 0, right = numbers.length - 1;\n    while (left < right) {\n        let current_sum = numbers[left] + numbers[right];\n        if (current_sum === target) {\n            return [left + 1, right + 1];\n        } else if (current_sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return [];\n}\n```\n    \n    The algorithm uses a two-pointer approach. Initialize two pointers, `left` and `right`, to the first and last elements of the sorted array. Then, iterate until `left < right`. In each iteration, calculate the sum of the elements pointed to by `left` and `right`. If the sum equals the target, return the indices of the two numbers (1-indexed). If the sum is less than the target, increment `left` to consider a larger number. If the sum is greater than the target, decrement `right` to consider a smaller number. Since the input is guaranteed to have a solution, the loop will always return a valid result. This algorithm has a constant space complexity as it does not use any additional data structures.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " numbers = [2,7,11,15], target = 9",
                    "output": " [1,2]",
                    "explanation": " The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return \\[1, 2\\]."
                },
                {
                    "input": " numbers = [2,3,4], target = 6",
                    "output": " [1,3]",
                    "explanation": " The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return \\[1, 3\\]."
                },
                {
                    "input": " numbers = [-1,0], target = -1",
                    "output": " [1,2]",
                    "explanation": " The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return \\[1, 2\\]."
                }
            ],
            "function_input": [
                {
                    "input": "[2,7,11,15],9",
                    "output": "[1,2]"
                },
                {
                    "input": "[2,3,4],6",
                    "output": "[1,3]"
                },
                {
                    "input": "[-1,0],-1",
                    "output": "[1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-66",
        "prompt": "Given a **1-indexed** array of integers `numbers` that is already **_sorted in non-decreasing order_**, find two numbers such that they add up to a specific `target` number. Let these two numbers be `numbers[index1]` and `numbers[index2]` where `1 <= index1 < index2 <= numbers.length`.\n\nReturn _the indices of the two numbers,_ `index1` _and_ `index2`_, **added by one** as an integer array_ `[index1, index2]` _of length 2._\n\nThe tests are generated such that there is **exactly one solution**. You **may not** use the same element twice.\n\nYour solution must use only constant extra space."
    },
    "leetcode-benchmark-67": {
        "id": "leetcode-benchmark-67",
        "title": "Factorial Trailing Zeroes",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the number of trailing zeroes in_ `n!`.\n\nNote that `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 0\n**Explanation:** 3! = 6, no trailing zero.\n\n",
                "**Example 2:**\n\n**Input:** n = 5\n**Output:** 1\n**Explanation:** 5! = 120, one trailing zero.\n\n",
                "**Example 3:**\n\n**Input:** n = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 104`\n\n**",
            "follow_up": "Follow up:** Could you write a solution that works in logarithmic time complexity?"
        },
        "java": "\n    ```java\npublic int trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n = n / 5;\n        count += n;\n    }\n    return count;\n}\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "c++": "\n    ```cpp\nint trailingZeroes(int n) {\n    int count = 0;\n    while (n > 0) {\n        n /= 5;\n        count += n;\n    }\n    return count;\n}\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "python": "\n    ```python\ndef trailing_zeroes(n: int) -> int:\n    count = 0\n    while n > 0:\n        n //= 5\n        count += n\n    return count\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "javascript": "\n    ```javascript\nfunction trailingZeroes(n) {\n    let count = 0;\n    while (n > 0) {\n        n = Math.floor(n / 5);\n        count += n;\n    }\n    return count;\n}\n```\n\n    \n    The given problem requires us to calculate the number of trailing zeroes in n! (factorial of n). Trailing zeroes are formed by the product of 2 and 5. For example, 20! has 4 trailing zeroes as there are 4 instances of 2 * 5 (10, 20, 30, and 50). We know there are plenty of even factors in a factorial, so we just need to count how many times the factor 5 appears.\n\nThe algorithm we use here is dividing n by 5 iteratively until n becomes 0. In each step, we divide n by 5 and add the quotient to the count. Finally, we return the count as the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " 0",
                    "explanation": " 3! = 6, no trailing zero."
                },
                {
                    "input": " n = 5",
                    "output": " 1",
                    "explanation": " 5! = 120, one trailing zero."
                },
                {
                    "input": " n = 0",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "0"
                },
                {
                    "input": "5",
                    "output": "1"
                },
                {
                    "input": "0",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-67",
        "prompt": "Given an integer `n`, return _the number of trailing zeroes in_ `n!`.\n\nNote that `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`."
    },
    "leetcode-benchmark-68": {
        "id": "leetcode-benchmark-68",
        "title": "Reverse Words in a String II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a character array `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by a single space.\n\nYour code must solve the problem **in-place,** i.e. without allocating extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \\[\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"\\]\n**Output:** \\[\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"\\]\n\n",
                "**Example 2:**\n\n**Input:** s = \\[\"a\"\\]\n**Output:** \\[\"a\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is an English letter (uppercase or lowercase), digit, or space `' '`.\n*   There is **at least one** word in `s`.\n*   `s` does not contain leading or trailing spaces.\n*   All the words in `s` are guaranteed to be separated by a single space.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void reverseWords(char[] s) {\n    reverse(s, 0, s.length - 1);\n    int start = 0;\n    for (int i = 0; i <= s.length; i++) {\n        if (i == s.length || s[i] == ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n\nprivate void reverse(char[] s, int start, int end) {\n    while (start < end) {\n        char temp = s[start];\n        s[start++] = s[end];\n        s[end--] = temp;\n    }\n}\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "c++": "\n    ```cpp\nvoid reverseWords(vector<char>& s) {\n    reverse(s.begin(), s.end());\n    int start = 0, end;\n    while ((end = find(s.begin() + start, s.end(), ' ') - s.begin()) < s.size()) {\n        reverse(s.begin() + start, s.begin() + end);\n        start = end + 1;\n    }\n    reverse(s.begin() + start, s.end());\n}\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "python": "\n    ```python\ndef reverseWords(s: list) -> None:\n    def reverse(s, start, end):\n        while start < end:\n            s[start], s[end] = s[end], s[start]\n            start += 1\n            end -= 1\n\n    reverse(s, 0, len(s)-1)\n    start = 0\n    for i, char in enumerate(s + [' ']):\n        if char == ' ':\n            reverse(s, start, i - 1)\n            start = i + 1\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "javascript": "\n    ```javascript\nfunction reverseWords(s) {\n    function reverse(s, start, end) {\n        while (start < end) {\n            [s[start], s[end]] = [s[end], s[start]];\n            start++;\n            end--;\n        }\n    }\n\n    reverse(s, 0, s.length - 1);\n    let start = 0;\n    for (let i = 0; i <= s.length; i++) {\n        if (i === s.length || s[i] === ' ') {\n            reverse(s, start, i - 1);\n            start = i + 1;\n        }\n    }\n}\n```\n    \n    1. Reverse the whole array.\n2. Traverse elements in the reversed array.\n3. If the current element is a space, reverse the sub-array from the start of the word to the last element before the space. Then, set start to the next element after space.\n4. If it's the end of the array, reverse the sub-array from the start of the array to the last element.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = [\"t\",\"h\",\"e\",\" \",\"s\",\"k\",\"y\",\" \",\"i\",\"s\",\" \",\"b\",\"l\",\"u\",\"e\"]",
                    "output": " [\"b\",\"l\",\"u\",\"e\",\" \",\"i\",\"s\",\" \",\"s\",\"k\",\"y\",\" \",\"t\",\"h\",\"e\"]",
                    "explanation": null
                },
                {
                    "input": " s = [\"a\"]",
                    "output": " [\"a\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"t\",\"h\",\"e\",\"\",\"s\",\"k\",\"y\",\"\",\"i\",\"s\",\"\",\"b\",\"l\",\"u\",\"e\"]",
                    "output": "[\"b\",\"l\",\"u\",\"e\",\"\",\"i\",\"s\",\"\",\"s\",\"k\",\"y\",\"\",\"t\",\"h\",\"e\"]"
                },
                {
                    "input": "[\"a\"]",
                    "output": "[\"a\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-68",
        "prompt": "Given a character array `s`, reverse the order of the **words**.\n\nA **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by a single space.\n\nYour code must solve the problem **in-place,** i.e. without allocating extra space."
    },
    "leetcode-benchmark-69": {
        "id": "leetcode-benchmark-69",
        "title": "Rotate Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7\\], k = 3\n**Output:** \\[5,6,7,1,2,3,4\\]\n**Explanation:**\nrotate 1 steps to the right: \\[7,1,2,3,4,5,6\\]\nrotate 2 steps to the right: \\[6,7,1,2,3,4,5\\]\nrotate 3 steps to the right: \\[5,6,7,1,2,3,4\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,-100,3,99\\], k = 2\n**Output:** \\[3,99,-1,-100\\]\n**Explanation:** \nrotate 1 steps to the right: \\[99,-1,-100,3\\]\nrotate 2 steps to the right: \\[3,99,-1,-100\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 105`\n*   `-231 <= nums[i] <= 231 - 1`\n*   `0 <= k <= 105`\n\n**",
            "follow_up": "Follow up:**\n\n*   Try to come up with as many solutions as you can. There are at least **three** different ways to solve this problem.\n*   Could you do it in-place with `O(1)` extra space?"
        },
        "java": "\n    ```java\npublic void rotate(int[] nums, int k) {\n    int n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nprivate void reverse(int[] nums, int start, int end) {\n    while (start < end) {\n        int temp = nums[start];\n        nums[start++] = nums[end];\n        nums[end--] = temp;\n    }\n}\n```\n    \n    The algorithm first reverses the entire array, then reverses the first `k` elements, and finally reverses the remaining `n-k` elements where `n` is the length of the array. The reversing operation is done in-place so as not to use extra memory.\n\nThis is achieved using a `reverse` function that swaps elements at positions `start` and `end` and increment `start` and decrement `end` until `start` is greater than or equal to `end`. The `reverse` function basically reverses the elements between the given positions.\n\nIn Python, we use slicing to achieve the rotation without the explicit `reverse` function.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvoid rotate(vector<int>& nums, int k) {\n    int n = nums.size();\n    k %= n;\n    reverse(nums.begin(), nums.end());\n    reverse(nums.begin(), nums.begin() + k);\n    reverse(nums.begin() + k, nums.end());\n}\n```\n    \n    The algorithm first reverses the entire array, then reverses the first `k` elements, and finally reverses the remaining `n-k` elements where `n` is the length of the array. The reversing operation is done in-place so as not to use extra memory.\n\nThis is achieved using a `reverse` function that swaps elements at positions `start` and `end` and increment `start` and decrement `end` until `start` is greater than or equal to `end`. The `reverse` function basically reverses the elements between the given positions.\n\nIn Python, we use slicing to achieve the rotation without the explicit `reverse` function.\n    ",
        "python": "\n    ```python\ndef rotate(nums, k):\n    n = len(nums)\n    k %= n\n    nums[:] = nums[-k:] + nums[:-k]\n```\n    \n    The algorithm first reverses the entire array, then reverses the first `k` elements, and finally reverses the remaining `n-k` elements where `n` is the length of the array. The reversing operation is done in-place so as not to use extra memory.\n\nThis is achieved using a `reverse` function that swaps elements at positions `start` and `end` and increment `start` and decrement `end` until `start` is greater than or equal to `end`. The `reverse` function basically reverses the elements between the given positions.\n\nIn Python, we use slicing to achieve the rotation without the explicit `reverse` function.\n    ",
        "javascript": "\n    ```javascript\nfunction rotate(nums, k) {\n    const n = nums.length;\n    k %= n;\n    reverse(nums, 0, n - 1);\n    reverse(nums, 0, k - 1);\n    reverse(nums, k, n - 1);\n}\n\nfunction reverse(nums, start, end) {\n    while (start < end) {\n        [nums[start], nums[end]] = [nums[end], nums[start]];\n        start++;\n        end--;\n    }\n}\n```\n    \n    The algorithm first reverses the entire array, then reverses the first `k` elements, and finally reverses the remaining `n-k` elements where `n` is the length of the array. The reversing operation is done in-place so as not to use extra memory.\n\nThis is achieved using a `reverse` function that swaps elements at positions `start` and `end` and increment `start` and decrement `end` until `start` is greater than or equal to `end`. The `reverse` function basically reverses the elements between the given positions.\n\nIn Python, we use slicing to achieve the rotation without the explicit `reverse` function.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,4,5,6,7], k = 3",
                    "output": " [5,6,7,1,2,3,4]",
                    "explanation": "\nrotate 1 steps to the right: \\[7,1,2,3,4,5,6\\]\nrotate 2 steps to the right: \\[6,7,1,2,3,4,5\\]\nrotate 3 steps to the right: \\[5,6,7,1,2,3,4\\]"
                },
                {
                    "input": " nums = [-1,-100,3,99], k = 2",
                    "output": " [3,99,-1,-100]",
                    "explanation": " \nrotate 1 steps to the right: \\[99,-1,-100,3\\]\nrotate 2 steps to the right: \\[3,99,-1,-100\\]"
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5,6,7],3",
                    "output": "[5,6,7,1,2,3,4]"
                },
                {
                    "input": "[-1,-100,3,99],2",
                    "output": "[3,99,-1,-100]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-69",
        "prompt": "Given an integer array `nums`, rotate the array to the right by `k` steps, where `k` is non-negative."
    },
    "leetcode-benchmark-70": {
        "id": "leetcode-benchmark-70",
        "title": "House Robber",
        "difficulty": "Medium",
        "content": {
            "problem": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[2,7,9,3,1\\]\n**Output:** 12\n**Explanation:** Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 400`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int rob(int[] nums) {\n    int prev1 = 0, prev2 = 0;\n    for (int num : nums) {\n        int temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "c++": "\n    ```cpp\nint rob(vector<int>& nums) {\n    int prev1 = 0, prev2 = 0;\n    for (const auto& num : nums) {\n        int tmp = prev1;\n        prev1 = max(prev2 + num, prev1);\n        prev2 = tmp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "python": "\n    ```python\ndef rob(nums):\n    prev1, prev2 = 0, 0\n    for num in nums:\n        prev1, prev2 = max(prev2 + num, prev1), prev1\n    return prev1\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "javascript": "\n    ```javascript\nfunction rob(nums) {\n    let prev1 = 0, prev2 = 0;\n    for (let num of nums) {\n        let temp = prev1;\n        prev1 = Math.max(prev2 + num, prev1);\n        prev2 = temp;\n    }\n    return prev1;\n}\n```\n    \n    We use dynamic programming, maintaining two variables `prev1` and `prev2`. `prev1` represents the maximum amount of money that can be robbed up to the current house, and `prev2` represents the maximum amount of money that can be robbed up to the house before the current house (because we cannot rob two adjacent houses). \n\nAt each house, we calculate the updated maximum amount of money that can be robbed up to the current house. This can be either the sum of the current house's money and the maximum amount of money that can be robbed up to the house before the current house (which is stored in `prev2`) or the maximum amount of money that can be robbed up to the previous house (which is stored in `prev1`). We pick the greater one and update `prev1` accordingly. At the same time, we update `prev2` by setting it to the old `prev1` value.\n\nBy the end of the loop, `prev1` will represent the maximum amount of money that can be robbed without alerting the police, which we return.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,1]",
                    "output": " 4",
                    "explanation": " Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4."
                },
                {
                    "input": " nums = [2,7,9,3,1]",
                    "output": " 12",
                    "explanation": " Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,1]",
                    "output": "4"
                },
                {
                    "input": "[2,7,9,3,1]",
                    "output": "12"
                }
            ]
        },
        "task_id": "leetcode-benchmark-70",
        "prompt": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_."
    },
    "leetcode-benchmark-71": {
        "id": "leetcode-benchmark-71",
        "title": "Number of Islands",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\n  \\[ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"\\],\n  \\[ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"\\],\n  \\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n  \\[ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"\\]\n\\]\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\n  \\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n  \\[ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"\\],\n  \\[ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\n  \\[ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"\\]\n\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `grid[i][j]` is `'0'` or `'1'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nclass Solution {\n    private void dfs(char[][] grid, int i, int j) {\n        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == '0')\n            return;\n\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == '1') {\n                    count++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        return count;\n    }\n}\n```\n    \n    The base algorithm is depth-first search (DFS). The idea is to loop through the entire grid and for each cell with a value of '1', increment the island count by 1 and run the DFS algorithm starting on this cell. During the DFS traversal, we modify the grid by setting the visited cells containing '1' to '0', which will avoid visiting the same land cell again. The DFS traversal stops when the boundaries of the grid are reached or a '0' cell is hit. The DFS runs recursively on the neighboring cells (up, down, left, and right) of the current cell.\n\nThe time complexity of this algorithm is O(m * n) since we may have to visit every cell in the worst case, where m and n are the row and column dimensions of the grid.\n    ",
        "c++": "\n    ```cpp\nvoid dfs(vector<vector<char>>& grid, int i, int j) {\n    if(i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nint numIslands(vector<vector<char>>& grid) {\n    int count = 0;\n    for(int i = 0; i < grid.size(); i++) {\n        for(int j = 0; j < grid[0].size(); j++) {\n            if(grid[i][j] == '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The base algorithm is depth-first search (DFS). The idea is to loop through the entire grid and for each cell with a value of '1', increment the island count by 1 and run the DFS algorithm starting on this cell. During the DFS traversal, we modify the grid by setting the visited cells containing '1' to '0', which will avoid visiting the same land cell again. The DFS traversal stops when the boundaries of the grid are reached or a '0' cell is hit. The DFS runs recursively on the neighboring cells (up, down, left, and right) of the current cell.\n\nThe time complexity of this algorithm is O(m * n) since we may have to visit every cell in the worst case, where m and n are the row and column dimensions of the grid.\n    ",
        "python": "\n    ```python\ndef dfs(grid, i, j):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] == '0':\n        return\n\n    grid[i][j] = '0'\n    dfs(grid, i + 1, j)\n    dfs(grid, i - 1, j)\n    dfs(grid, i, j + 1)\n    dfs(grid, i, j - 1)\n\ndef numIslands(grid):\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(grid, i, j)\n    return count\n```\n    \n    The base algorithm is depth-first search (DFS). The idea is to loop through the entire grid and for each cell with a value of '1', increment the island count by 1 and run the DFS algorithm starting on this cell. During the DFS traversal, we modify the grid by setting the visited cells containing '1' to '0', which will avoid visiting the same land cell again. The DFS traversal stops when the boundaries of the grid are reached or a '0' cell is hit. The DFS runs recursively on the neighboring cells (up, down, left, and right) of the current cell.\n\nThe time complexity of this algorithm is O(m * n) since we may have to visit every cell in the worst case, where m and n are the row and column dimensions of the grid.\n    ",
        "javascript": "\n    ```javascript\nfunction dfs(grid, i, j) {\n    if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] === '0')\n        return;\n\n    grid[i][j] = '0';\n    dfs(grid, i + 1, j);\n    dfs(grid, i - 1, j);\n    dfs(grid, i, j + 1);\n    dfs(grid, i, j - 1);\n}\n\nfunction numIslands(grid) {\n    let count = 0;\n    for(let i = 0; i < grid.length; i++) {\n        for(let j = 0; j < grid[0].length; j++) {\n            if(grid[i][j] === '1') {\n                count++;\n                dfs(grid, i, j);\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The base algorithm is depth-first search (DFS). The idea is to loop through the entire grid and for each cell with a value of '1', increment the island count by 1 and run the DFS algorithm starting on this cell. During the DFS traversal, we modify the grid by setting the visited cells containing '1' to '0', which will avoid visiting the same land cell again. The DFS traversal stops when the boundaries of the grid are reached or a '0' cell is hit. The DFS runs recursively on the neighboring cells (up, down, left, and right) of the current cell.\n\nThe time complexity of this algorithm is O(m * n) since we may have to visit every cell in the worst case, where m and n are the row and column dimensions of the grid.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [\n  [ \"1 \", \"1 \", \"1 \", \"1 \", \"0 \"],\n  [ \"1 \", \"1 \", \"0 \", \"1 \", \"0 \"],\n  [ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"],\n  [ \"0 \", \"0 \", \"0 \", \"0 \", \"0 \"]\n]",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " grid = [\n  [ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"],\n  [ \"1 \", \"1 \", \"0 \", \"0 \", \"0 \"],\n  [ \"0 \", \"0 \", \"1 \", \"0 \", \"0 \"],\n  [ \"0 \", \"0 \", \"0 \", \"1 \", \"1 \"]\n]",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\n[\"1\",\"1\",\"1\",\"1\",\"0\"],\n[\"1\",\"1\",\"0\",\"1\",\"0\"],\n[\"1\",\"1\",\"0\",\"0\",\"0\"],\n[\"0\",\"0\",\"0\",\"0\",\"0\"]\n]",
                    "output": "1"
                },
                {
                    "input": "[\n[\"1\",\"1\",\"0\",\"0\",\"0\"],\n[\"1\",\"1\",\"0\",\"0\",\"0\"],\n[\"0\",\"0\",\"1\",\"0\",\"0\"],\n[\"0\",\"0\",\"0\",\"1\",\"1\"]\n]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-71",
        "prompt": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return _the number of islands_.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water."
    },
    "leetcode-benchmark-72": {
        "id": "leetcode-benchmark-72",
        "title": "Bitwise AND of Numbers Range",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers `left` and `right` that represent the range `[left, right]`, return _the bitwise AND of all numbers in this range, inclusive_.",
            "examples": [
                "**Example 1:**\n\n**Input:** left = 5, right = 7\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** left = 0, right = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** left = 1, right = 2147483647\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= left <= right <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "c++": "\n    ```cpp\nint rangeBitwiseAnd(int left, int right) {\n    int shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        ++shift;\n    }\n    return left << shift;\n}\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "python": "\n    ```python\ndef range_bitwise_and(left: int, right: int) -> int:\n    shift = 0\n    while left != right:\n        left >>= 1\n        right >>= 1\n        shift += 1\n    return left << shift\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "javascript": "\n    ```javascript\nfunction rangeBitwiseAnd(left, right) {\n    let shift = 0;\n    while (left != right) {\n        left >>= 1;\n        right >>= 1;\n        shift++;\n    }\n    return left << shift;\n}\n```\n    \n    The algorithm works by performing a bitwise right shift on both the left and right edge of the range until both numbers become equal. This is done because the common bits to the left of the different bits are the bits that will survive the AND operation for all numbers in the range.\n\nSince we right shifted x times, we perform a left shift x times on the equal numbers to restore the original position of the bits. As a result, we get the final bitwise AND of all the numbers in the range. This algorithm has a complexity of O(log N) due to the bitwise manipulation.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " left = 5, right = 7",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " left = 0, right = 0",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " left = 1, right = 2147483647",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5,7",
                    "output": "4"
                },
                {
                    "input": "0,0",
                    "output": "0"
                },
                {
                    "input": "1,2147483647",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-72",
        "prompt": "Given two integers `left` and `right` that represent the range `[left, right]`, return _the bitwise AND of all numbers in this range, inclusive_."
    },
    "leetcode-benchmark-73": {
        "id": "leetcode-benchmark-73",
        "title": "Count Primes",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the number of prime numbers that are strictly less than_ `n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation:** There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 5 * 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countPrimes(int n) {\n    if (n <= 2) return 0;\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    int count = 0;\n    for (boolean prime : isPrime) {\n        if (prime) count++;\n    }\n    return count;\n}\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "c++": "\n    ```cpp\nint countPrimes(int n) {\n    if (n <= 2) return 0;\n    vector<bool> isPrime(n, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (isPrime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return count(isPrime.begin(), isPrime.end(), true);\n}\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "python": "\n    ```python\ndef countPrimes(n: int) -> int:\n    if n <= 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "javascript": "\n    ```javascript\nfunction countPrimes(n) {\n    if (n <= 2) return 0;\n    const isPrime = Array(n).fill(true);\n    isPrime[0] = isPrime[1] = false;\n    for (let i = 2; i * i < n; i++) {\n        if (isPrime[i]) {\n            for (let j = i * i; j < n; j += i) {\n                isPrime[j] = false;\n            }\n        }\n    }\n    return isPrime.filter(prime => prime).length;\n}\n```\n    \n    1. Initialize an array of booleans with value `true` and named `isPrime` to keep track of prime numbers from 0 to `n`.\n2. Set `isPrime[0]` and `isPrime[1]` to `false` since 0 and 1 are not prime numbers.\n3. Loop through numbers from 2 to the square root of `n`, and for each `i` that is still marked `true` in the `isPrime` array, loop through all its multiples starting from `i*i` (skipping `i` itself) and mark them as `false` because they won't be prime since they are divisible by `i`.\n4. Count all `true` values remaining in the `isPrime` array which indicates the count of prime numbers less than `n`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 10",
                    "output": " 4",
                    "explanation": " There are 4 prime numbers less than 10, they are 2, 3, 5, 7."
                },
                {
                    "input": " n = 0",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "10",
                    "output": "4"
                },
                {
                    "input": "0",
                    "output": "0"
                },
                {
                    "input": "1",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-73",
        "prompt": "Given an integer `n`, return _the number of prime numbers that are strictly less than_ `n`."
    },
    "leetcode-benchmark-74": {
        "id": "leetcode-benchmark-74",
        "title": "Minimum Size Subarray Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _subarray_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** target = 7, nums = \\[2,3,1,2,4,3\\]\n**Output:** 2\n**Explanation:** The subarray \\[4,3\\] has the minimal length under the problem constraint.\n\n",
                "**Example 2:**\n\n**Input:** target = 4, nums = \\[1,4,4\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** target = 11, nums = \\[1,1,1,1,1,1,1,1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= target <= 109`\n*   `1 <= nums.length <= 105`\n*   `1 <= nums[i] <= 104`\n\n**",
            "follow_up": "Follow up:** If you have figured out the `O(n)` solution, try coding another solution of which the time complexity is `O(n log(n))`."
        },
        "java": "\n    ```java\npublic int minSubArrayLen(int target, int[] nums) {\n    int left = 0, cur_sum = 0, min_len = Integer.MAX_VALUE;\n    for (int right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == Integer.MAX_VALUE ? 0 : min_len;\n}\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "c++": "\n    ```cpp\n#include <climits>\nint minSubArrayLen(int target, vector<int>& nums) {\n    int left = 0, cur_sum = 0, min_len = INT_MAX;\n    for (int right = 0; right < nums.size(); right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len == INT_MAX ? 0 : min_len;\n}\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "python": "\n    ```python\ndef minSubArrayLen(target: int, nums: List[int]) -> int:\n    left, cur_sum, min_len = 0, 0, float('inf')\n    for right in range(len(nums)):\n        cur_sum += nums[right]\n        while cur_sum >= target:\n            min_len = min(min_len, right - left + 1)\n            cur_sum -= nums[left]\n            left += 1\n    return min_len if min_len != float('inf') else 0\n```\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "javascript": "\n    ```javascript\nfunction minSubArrayLen(target, nums) {\n    let left = 0, cur_sum = 0, min_len = Number.MAX_VALUE;\n    for (let right = 0; right < nums.length; right++) {\n        cur_sum += nums[right];\n        while (cur_sum >= target) {\n            min_len = Math.min(min_len, right - left + 1);\n            cur_sum -= nums[left++];\n        }\n    }\n    return min_len === Number.MAX_VALUE ? 0 : min_len;\n}\n```\n\n    \n    The algorithm initializes pointers left and right, sum cur_sum, and minimum length min_len. The right pointer traverses nums. During traversal, update cur_sum by adding nums[right]. Then check if cur_sum is greater than or equal to target. If so, update min_len by comparing min_len and the length of the current subarray (right - left + 1). Then update cur_sum by subtracting nums[left] and increment the left pointer. Continue this process until the end of nums is reached. If min_len is still at its max value at the end, return 0. Otherwise, return min_len.\n\nThis algorithm uses a sliding window technique to iterate through the array while maintaining subarray sums greater than or equal to the target.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " target = 7, nums = [2,3,1,2,4,3]",
                    "output": " 2",
                    "explanation": " The subarray \\[4,3\\] has the minimal length under the problem constraint."
                },
                {
                    "input": " target = 4, nums = [1,4,4]",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " target = 11, nums = [1,1,1,1,1,1,1,1]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "7,[2,3,1,2,4,3]",
                    "output": "2"
                },
                {
                    "input": "4,[1,4,4]",
                    "output": "1"
                },
                {
                    "input": "11,[1,1,1,1,1,1,1,1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-74",
        "prompt": "Given an array of positive integers `nums` and a positive integer `target`, return _the **minimal length** of a_ _subarray_ _whose sum is greater than or equal to_ `target`. If there is no such subarray, return `0` instead."
    },
    "leetcode-benchmark-75": {
        "id": "leetcode-benchmark-75",
        "title": "House Robber II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[2,3,2\\]\n**Output:** 3\n**Explanation:** You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,1\\]\n**Output:** 4\n**Explanation:** Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 100`\n*   `0 <= nums[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int rob(int[] nums) {\n    if (nums.length == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.length - 1; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.length; i++) {\n        int temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "c++": "\n    ```cpp\nint rob(vector<int>& nums) {\n    if (nums.size() == 1) return nums[0];\n    int prev = 0, curr = 0;\n    for (int i = 0; i < nums.size() - 1; i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    int res = curr;\n    prev = 0;\n    curr = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        int temp = max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "python": "\n    ```python\ndef rob(nums):\n    if len(nums) == 1:\n        return nums[0]\n    prev, curr = 0, 0\n    for i in range(len(nums) - 1):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    res = curr\n    prev, curr = 0, 0\n    for i in range(1, len(nums)):\n        temp = max(curr, prev + nums[i])\n        prev, curr = curr, temp\n    return max(res, curr)\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "javascript": "\n    ```javascript\nfunction rob(nums) {\n    if (nums.length === 1) return nums[0];\n    let prev = 0, curr = 0;\n    for (let i = 0; i < nums.length - 1; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    let res = curr;\n    prev = 0;\n    curr = 0;\n    for (let i = 1; i < nums.length; i++) {\n        let temp = Math.max(curr, prev + nums[i]);\n        prev = curr;\n        curr = temp;\n    }\n    return Math.max(res, curr);\n}\n```\n    \n    The main idea here is to divide the problem into two subproblems: rob houses from the first to the second last, and rob houses from the second to the last. First, initialize two variables prev and curr to store the maximum amount obtained till the current house. Then, loop through the houses from the first to the second last, and at each step, update the maximum amount till the current house by choosing between two options: rob the current house (prev + nums[i]) or skip it (curr). Repeat the process for houses from the second to the last. Finally, return the maximum amount among both subproblems.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [2,3,2]",
                    "output": " 3",
                    "explanation": " You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses."
                },
                {
                    "input": " nums = [1,2,3,1]",
                    "output": " 4",
                    "explanation": " Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4."
                },
                {
                    "input": " nums = [1,2,3]",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[2,3,2]",
                    "output": "3"
                },
                {
                    "input": "[1,2,3,1]",
                    "output": "4"
                },
                {
                    "input": "[1,2,3]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-75",
        "prompt": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return _the maximum amount of money you can rob tonight **without alerting the police**_."
    },
    "leetcode-benchmark-76": {
        "id": "leetcode-benchmark-76",
        "title": "Kth Largest Element in an Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,1,5,6,4\\], k = 2\n**Output:** 5\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,2,3,1,2,4,5,5,6\\], k = 4\n**Output:** 4"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= nums.length <= 105`\n*   `-104 <= nums[i] <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.PriorityQueue;\n\npublic int findKthLargest(int[] nums, int k) {\n    PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n    for (int num : nums) {\n        minHeap.add(num);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n    }\n    return minHeap.poll();\n}\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\n#include <vector>\n\nint findKthLargest(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end(), std::greater<int>());\n    return nums[k-1];\n}\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "python": "\n    ```python\ndef findKthLargest(nums: List[int], k: int) -> int:\n    nums.sort(reverse=True)\n    return nums[k-1]\n```\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "javascript": "\n    ```javascript\nfunction findKthLargest(nums, k) {\n    nums.sort((a, b) => b - a);\n    return nums[k - 1];\n}\n```\n\n    \n    The algorithm sorts the input array in descending order (non-increasing order). Then it returns the element at the index `k-1`. In the case of the C++ and Python implementations, the built-in `sort()` method was used to sort the array in descending order, while in the Java implementation, a min-heap was used for efficiency. In the Javascript implementation, the custom comparator `(a, b) => b - a` was used to sort the input array in descending order.\n\nSorting the array in descending order ensures that the kth largest element will be located at the index `k-1` (since indexing starts at 0).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,2,1,5,6,4], k = 2",
                    "output": " 5",
                    "explanation": null
                },
                {
                    "input": " nums = [3,2,3,1,2,4,5,5,6], k = 4",
                    "output": " 4",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,1,5,6,4],2",
                    "output": "5"
                },
                {
                    "input": "[3,2,3,1,2,4,5,5,6],4",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-76",
        "prompt": "Given an integer array `nums` and an integer `k`, return _the_ `kth` _largest element in the array_.\n\nNote that it is the `kth` largest element in the sorted order, not the `kth` distinct element.\n\nYou must solve it in `O(n)` time complexity."
    },
    "leetcode-benchmark-77": {
        "id": "leetcode-benchmark-77",
        "title": "Combination Sum III",
        "difficulty": "Medium",
        "content": {
            "problem": "Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n*   Only numbers `1` through `9` are used.\n*   Each number is used **at most once**.\n\nReturn _a list of all possible valid combinations_. The list must not contain the same combination twice, and the combinations may be returned in any order.",
            "examples": [
                "**Example 1:**\n\n**Input:** k = 3, n = 7\n**Output:** \\[\\[1,2,4\\]\\]\n**Explanation:**\n1 + 2 + 4 = 7\nThere are no other valid combinations.\n\n",
                "**Example 2:**\n\n**Input:** k = 3, n = 9\n**Output:** \\[\\[1,2,6\\],\\[1,3,5\\],\\[2,3,4\\]\\]\n**Explanation:**\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n\n",
                "**Example 3:**\n\n**Input:** k = 4, n = 1\n**Output:** \\[\\]\n**Explanation:** There are no valid combinations.\nUsing 4 different numbers in the range \\[1,9\\], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= k <= 9`\n*   `1 <= n <= 60`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> combinationSum3(int k, int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(k, n, 0, new ArrayList<>(), result);\n    return result;\n}\n\nprivate void helper(int k, int n, int current, List<Integer> currentComb, List<List<Integer>> result) {\n    if (k == 0 && n == 0) {\n        result.add(new ArrayList<>(currentComb));\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; i++) {\n            currentComb.add(i);\n            helper(k - 1, n - i, i, currentComb, result);\n            currentComb.remove(currentComb.size() - 1);\n        }\n    }\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid helper(int k, int n, int current, std::vector<int>& current_comb, std::vector<std::vector<int>>& result) {\n    if (k == 0 && n == 0) {\n        result.push_back(current_comb);\n    } else if (k > 0 && n > 0) {\n        for (int i = current + 1; i <= 9; ++i) {\n            current_comb.push_back(i);\n            helper(k - 1, n - i, i, current_comb, result);\n            current_comb.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current_comb;\n    helper(k, n, 0, current_comb, result);\n    return result;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "python": "\n    ```python\ndef combinationSum3(k, n):\n    def helper(k, n, current, current_comb, result):\n        if k == 0 and n == 0:\n            result.append(list(current_comb))\n        elif k > 0 and n > 0:\n            for i in range(current + 1, 10):\n                current_comb.append(i)\n                helper(k - 1, n - i, i, current_comb, result)\n                current_comb.pop()\n\n    result = []\n    helper(k, n, 0, [], result)\n    return result\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "javascript": "\n    ```javascript\nfunction combinationSum3(k, n) {\n  function helper(k, n, current, currentComb, result) {\n    if (k === 0 && n === 0) {\n      result.push([...currentComb]);\n    } else if (k > 0 && n > 0) {\n      for (let i = current + 1; i <= 9; i++) {\n        currentComb.push(i);\n        helper(k - 1, n - i, i, currentComb, result);\n        currentComb.pop();\n      }\n    }\n  }\n\n  const result = [];\n  helper(k, n, 0, [], result);\n  return result;\n}\n```\n\n    \n    The algorithm is based on a backtracking approach. We use a helper function which takes some parameters: `k` and `n` to limit the combinations, `current` which is the last considered element, `current_comb` which is the current combination being formed, and `result` which is the list of all valid combinations found so far.\n\nWe keep updating the current combination and decreasing `k` and `n` accordingly as we call the helper function recursively. When we have `k = 0` and `n = 0`, we know we have reached a valid combination and add it to our result list. To prevent revisiting the same combinations, we make sure that the numbers are considered in increasing order (thus, the current value being picked always starts at `current + 1`).\n\nWhen backtracking, we remove the last considered element from the current combination so that we can try another combination. Following this approach ensures that we visit every potential combination only once and store it if it is valid.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " k = 3, n = 7",
                    "output": " [[1,2,4]]",
                    "explanation": "\n1 + 2 + 4 = 7\nThere are no other valid combinations."
                },
                {
                    "input": " k = 3, n = 9",
                    "output": " [[1,2,6],[1,3,5],[2,3,4]]",
                    "explanation": "\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations."
                },
                {
                    "input": " k = 4, n = 1",
                    "output": " []",
                    "explanation": " There are no valid combinations.\nUsing 4 different numbers in the range \\[1,9\\], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination."
                }
            ],
            "function_input": [
                {
                    "input": "3,7",
                    "output": "[[1,2,4]]"
                },
                {
                    "input": "3,9",
                    "output": "[[1,2,6],[1,3,5],[2,3,4]]"
                },
                {
                    "input": "4,1",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-77",
        "prompt": "Find all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n*   Only numbers `1` through `9` are used.\n*   Each number is used **at most once**.\n\nReturn _a list of all possible valid combinations_. The list must not contain the same combination twice, and the combinations may be returned in any order."
    },
    "leetcode-benchmark-78": {
        "id": "leetcode-benchmark-78",
        "title": "Maximal Square",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"\\],\\[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"\\],\\[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"\\]\\]\n**Output:** 4\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[ \"0 \", \"1 \"\\],\\[ \"1 \", \"0 \"\\]\\]\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** matrix = \\[\\[ \"0 \"\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 300`\n*   `matrix[i][j]` is `'0'` or `'1'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maximalSquare(char[][] matrix) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int[][] dp = new int[m + 1][n + 1];\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "c++": "\n    ```cpp\nint maximalSquare(vector<vector<char>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    int maxSize = 0;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] == '1') {\n                dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                maxSize = max(maxSize, dp[i][j]);\n            }\n        }\n    }\n    \n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "python": "\n    ```python\ndef maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    maxSize = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                maxSize = max(maxSize, dp[i][j])\n\n    return maxSize * maxSize\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "javascript": "\n    ```javascript\nfunction maximalSquare(matrix) {\n    const m = matrix.length;\n    const n = matrix[0].length;\n    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n    let maxSize = 0;\n\n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (matrix[i - 1][j - 1] === '1') {\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;\n                maxSize = Math.max(maxSize, dp[i][j]);\n            }\n        }\n    }\n\n    return maxSize * maxSize;\n}\n```\n    \n    The algorithm uses dynamic programming to find the largest square containing only 1's. It starts by creating a 2D table, `dp`, where `dp[i][j]` represents the size of the largest square ending at position (i, j) in the input matrix. The dimensions of `dp` are m+1 and n+1 to accommodate zero-indexing, and all elements are initialized to zero. \n\nThe algorithm iterates through each element in the input matrix. If the current element is 1, it sets the corresponding entry in `dp` to the minimum of the neighboring `dp` values (i.e., the values at top, left, and top-left) plus 1, which represents the size of the current square. The maxSize variable keeps track of the current largest square size, and at the end, the area of the largest square is returned by squaring maxSize.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[ \"1 \", \"0 \", \"1 \", \"0 \", \"0 \"],[ \"1 \", \"0 \", \"1 \", \"1 \", \"1 \"],[ \"1 \", \"1 \", \"1 \", \"1 \", \"1 \"],[ \"1 \", \"0 \", \"0 \", \"1 \", \"0 \"]]",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " matrix = [[ \"0 \", \"1 \"],[ \"1 \", \"0 \"]]",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " matrix = [[ \"0 \"]]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
                    "output": "4"
                },
                {
                    "input": "[[\"0\",\"1\"],[\"1\",\"0\"]]",
                    "output": "1"
                },
                {
                    "input": "[[\"0\"]]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-78",
        "prompt": "Given an `m x n` binary `matrix` filled with `0`'s and `1`'s, _find the largest square containing only_ `1`'s _and return its area_."
    },
    "leetcode-benchmark-79": {
        "id": "leetcode-benchmark-79",
        "title": "Rectangle Area",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the coordinates of two **rectilinear** rectangles in a 2D plane, return _the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1, ay1)` and its **top-right** corner `(ax2, ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1, by1)` and its **top-right** corner `(bx2, by2)`.",
            "examples": [
                "**Example 1:**\n\n**Input:** ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n**Output:** 45\n\n",
                "**Example 2:**\n\n**Input:** ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n**Output:** 16"
            ],
            "constraints": "**Constraints:**\n\n*   `-104 <= ax1 <= ax2 <= 104`\n*   `-104 <= ay1 <= ay2 <= 104`\n*   `-104 <= bx1 <= bx2 <= 104`\n*   `-104 <= by1 <= by2 <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n\n    int overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    int overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n\n    int overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "c++": "\n    ```cpp\nint totalArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\n    int area1 = (ax2 - ax1) * (ay2 - ay1);\n    int area2 = (bx2 - bx1) * (by2 - by1);\n\n    int overlapWidth = min(ax2, bx2) - max(ax1, bx1);\n    int overlapHeight = min(ay2, by2) - max(ay1, by1);\n\n    int overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "python": "\n    ```python\ndef total_area(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlap_width = min(ax2, bx2) - max(ax1, bx1)\n    overlap_height = min(ay2, by2) - max(ay1, by1)\n\n    overlap_area = max(overlap_width, 0) * max(overlap_height, 0)\n\n    return area1 + area2 - overlap_area\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "javascript": "\n    ```javascript\nfunction totalArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n    const area1 = (ax2 - ax1) * (ay2 - ay1);\n    const area2 = (bx2 - bx1) * (by2 - by1);\n\n    const overlapWidth = Math.min(ax2, bx2) - Math.max(ax1, bx1);\n    const overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);\n\n    const overlapArea = Math.max(overlapWidth, 0) * Math.max(overlapHeight, 0);\n\n    return area1 + area2 - overlapArea;\n}\n```\n\n    \n    1. Calculate the area of the first rectangle (area1) by subtracting the x coordinates (ax2 - ax1) and y coordinates (ay2 - ay1) and multiplying them together.\n2. Calculate the area of the second rectangle (area2) by subtracting the x coordinates (bx2 - bx1) and y coordinates (by2 - by1) and multiplying them together.\n3. Calculate the overlapping width by subtracting the larger bottom left x-coordinate (max(ax1, bx1)) from the smaller top-right x-coordinate (min(ax2, bx2)).\n4. Calculate the overlapping height by subtracting the larger bottom left y-coordinate (max(ay1, by1)) from the smaller top-right y-coordinate (min(ay2, by2)).\n5. Calculate the overlapping area by multiplying the overlapping width and height together. If either width or height is negative (rectangles do not overlap in that dimension), set the value to zero.\n6. Return the total area covered by the two rectangles (area1 + area2 - overlapArea).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2",
                    "output": " 45",
                    "explanation": null
                },
                {
                    "input": " ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2",
                    "output": " 16",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "-3,0,3,4,0,-1,9,2",
                    "output": "45"
                },
                {
                    "input": "-2,-2,2,2,-2,-2,2,2",
                    "output": "16"
                }
            ]
        },
        "task_id": "leetcode-benchmark-79",
        "prompt": "Given the coordinates of two **rectilinear** rectangles in a 2D plane, return _the total area covered by the two rectangles_.\n\nThe first rectangle is defined by its **bottom-left** corner `(ax1, ay1)` and its **top-right** corner `(ax2, ay2)`.\n\nThe second rectangle is defined by its **bottom-left** corner `(bx1, by1)` and its **top-right** corner `(bx2, by2)`."
    },
    "leetcode-benchmark-80": {
        "id": "leetcode-benchmark-80",
        "title": "Basic Calculator II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` which represents an expression, _evaluate this expression and return its value_.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.\n\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"3+2\\*2\"\n**Output:** 7\n\n",
                "**Example 2:**\n\n**Input:** s = \" 3/2 \"\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** s = \" 3+5 / 2 \"\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 3 * 105`\n*   `s` consists of integers and operators `('+', '-', '*', '/')` separated by some number of spaces.\n*   `s` represents **a valid expression**.\n*   All the integers in the expression are non-negative integers in the range `[0, 231 - 1]`.\n*   The answer is **guaranteed** to fit in a **32-bit integer**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int calculate(String s) {\n    int result = 0, num = 0, sign = 1;\n    Stack<Integer> stack = new Stack<>();\n\n    for (char c : s.toCharArray()) {\n        if (Character.isDigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= stack.pop();\n            result += stack.pop();\n        }\n    }\n    if (num != 0) result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm uses an integer, `result`, to store the intermediate results throughout the evaluation process. It also uses a stack to handle the nested parentheses that could be in the given expression. \n\n1. Initialize `result`, `num`, `sign`, and a stack.\n2. Loop through the given string, character by character.\n3. If the character is a digit, update `num` accordingly.\n4. If the character is a '+' or '-', update the `result` with the current `num` and update the `sign`.\n5. If the character is an '(', push the current `result` and `sign` onto the stack and reset `result` and `sign`.\n6. If the character is a ')', update `result` with the current `num`, then multiply `result` by the top of the stack (pop), and add the next top of the stack (pop) to `result`.\n7. After the loop, add the current `num` to the result if it's not 0.\n8. Return `result`.\n    ",
        "c++": "\n    ```cpp\nint calculate(string s) {\n    int result = 0, num = 0, sign = 1;\n    stack<int> st;\n    \n    for (char c : s) {\n        if (isdigit(c)) {\n            num = num * 10 + (c - '0');\n        } else if (c == '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c == '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c == '(') {\n            st.push(result);\n            st.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c == ')') {\n            result += sign * num;\n            num = 0;\n            result *= st.top(); st.pop();\n            result += st.top(); st.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm uses an integer, `result`, to store the intermediate results throughout the evaluation process. It also uses a stack to handle the nested parentheses that could be in the given expression. \n\n1. Initialize `result`, `num`, `sign`, and a stack.\n2. Loop through the given string, character by character.\n3. If the character is a digit, update `num` accordingly.\n4. If the character is a '+' or '-', update the `result` with the current `num` and update the `sign`.\n5. If the character is an '(', push the current `result` and `sign` onto the stack and reset `result` and `sign`.\n6. If the character is a ')', update `result` with the current `num`, then multiply `result` by the top of the stack (pop), and add the next top of the stack (pop) to `result`.\n7. After the loop, add the current `num` to the result if it's not 0.\n8. Return `result`.\n    ",
        "python": "\n    ```python\ndef calculate(s: str) -> int:\n    result, num, sign, stack = 0, 0, 1, []\n\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c == '+':\n            result += sign * num\n            num = 0\n            sign = 1\n        elif c == '-':\n            result += sign * num\n            num = 0\n            sign = -1\n        elif c == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif c == ')':\n            result += sign * num\n            num = 0\n            result *= stack.pop()\n            result += stack.pop()\n    \n    if num:\n        result += sign * num\n        \n    return result\n```\n    \n    The algorithm uses an integer, `result`, to store the intermediate results throughout the evaluation process. It also uses a stack to handle the nested parentheses that could be in the given expression. \n\n1. Initialize `result`, `num`, `sign`, and a stack.\n2. Loop through the given string, character by character.\n3. If the character is a digit, update `num` accordingly.\n4. If the character is a '+' or '-', update the `result` with the current `num` and update the `sign`.\n5. If the character is an '(', push the current `result` and `sign` onto the stack and reset `result` and `sign`.\n6. If the character is a ')', update `result` with the current `num`, then multiply `result` by the top of the stack (pop), and add the next top of the stack (pop) to `result`.\n7. After the loop, add the current `num` to the result if it's not 0.\n8. Return `result`.\n    ",
        "javascript": "\n    ```javascript\nfunction calculate(s) {\n    let result = 0, num = 0, sign = 1;\n    const stack = [];\n\n    for (const c of s) {\n        if ('0' <= c && c <= '9') {\n            num = num * 10 + parseInt(c);\n        } else if (c === '+') {\n            result += sign * num;\n            num = 0;\n            sign = 1;\n        } else if (c === '-') {\n            result += sign * num;\n            num = 0;\n            sign = -1;\n        } else if (c === '(') {\n            stack.push(result);\n            stack.push(sign);\n            result = 0;\n            sign = 1;\n        } else if (c === ')') {\n            result += sign * num;\n            num = 0;\n            result *= stack.pop();\n            result += stack.pop();\n        }\n    }\n    if (num) result += sign * num;\n    return result;\n}\n```\n    \n    The algorithm uses an integer, `result`, to store the intermediate results throughout the evaluation process. It also uses a stack to handle the nested parentheses that could be in the given expression. \n\n1. Initialize `result`, `num`, `sign`, and a stack.\n2. Loop through the given string, character by character.\n3. If the character is a digit, update `num` accordingly.\n4. If the character is a '+' or '-', update the `result` with the current `num` and update the `sign`.\n5. If the character is an '(', push the current `result` and `sign` onto the stack and reset `result` and `sign`.\n6. If the character is a ')', update `result` with the current `num`, then multiply `result` by the top of the stack (pop), and add the next top of the stack (pop) to `result`.\n7. After the loop, add the current `num` to the result if it's not 0.\n8. Return `result`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"3+2*2\"",
                    "output": " 7",
                    "explanation": null
                },
                {
                    "input": " s = \" 3/2 \"",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " s = \" 3+5 / 2 \"",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"3+2*2\"",
                    "output": "7"
                },
                {
                    "input": "\"3/2\"",
                    "output": "1"
                },
                {
                    "input": "\"3+5/2\"",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-80",
        "prompt": "Given a string `s` which represents an expression, _evaluate this expression and return its value_.\n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of `[-231, 231 - 1]`.\n\n**Note:** You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as `eval()`."
    },
    "leetcode-benchmark-81": {
        "id": "leetcode-benchmark-81",
        "title": "Majority Element II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array of size `n`, find all elements that appear more than ` n/3 ` times.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,2,3\\]\n**Output:** \\[3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2\\]\n**Output:** \\[1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `-109 <= nums[i] <= 109`\n\n**",
            "follow_up": "Follow up:** Could you solve the problem in linear time and in `O(1)` space?"
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\npublic List<Integer> majorityElement(int[] nums) {\n    int n = nums.length;\n    HashMap<Integer, Integer> count = new HashMap<>();\n    ArrayList<Integer> result = new ArrayList<>();\n\n    for (int num : nums) {\n        count.put(num, count.getOrDefault(num, 0) + 1);\n        if (count.get(num) > n / 3 && !result.contains(num)) {\n            result.add(num);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nvector<int> majorityElement(vector<int>& nums) {\n    int n = nums.size();\n    unordered_map<int, int> count;\n    vector<int> result;\n\n    for (int num : nums) {\n        if (count.find(num) == count.end()) {\n            count[num] = 1;\n        } else {\n            count[num]++;\n        }\n        if (count[num] > n / 3 && find(result.begin(), result.end(), num) == result.end()) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "python": "\n    ```python\ndef majorityElement(nums):\n    n = len(nums)\n    count = {}\n    result = []\n\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n        if count[num] > n / 3 and num not in result:\n            result.append(num)\n\n    return result\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "javascript": "\n    ```javascript\nfunction majorityElement(nums) {\n    const n = nums.length;\n    const count = {};\n    const result = [];\n\n    for (const num of nums) {\n        if (count.hasOwnProperty(num)) {\n            count[num]++;\n        } else {\n            count[num] = 1;\n        }\n        if (count[num] > n / 3 && !result.includes(num)) {\n            result.push(num);\n        }\n    }\n    return result;\n}\n```\n    \n    The algorithm maintains a count of occurrences of each element in the given array using a hash table. For each element, it increments its count in the hash table. If the count for the current element exceeds `n/3`, and the element is not already in the result array, it adds the element to the result array. The result array will contain all elements that appear more than `n/3` times.\n\nThis solution has linear time complexity, but requires additional space for the hashmap. A truly optimal solution in `O(1)` space can be found using the Boyer-Moore Majority Vote Algorithm. However, this algorithm may be more challenging to understand and implement.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,2,3]",
                    "output": " [3]",
                    "explanation": null
                },
                {
                    "input": " nums = [1]",
                    "output": " [1]",
                    "explanation": null
                },
                {
                    "input": " nums = [1,2]",
                    "output": " [1,2]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,3]",
                    "output": "[3]"
                },
                {
                    "input": "[1]",
                    "output": "[1]"
                },
                {
                    "input": "[1,2]",
                    "output": "[1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-81",
        "prompt": "Given an integer array of size `n`, find all elements that appear more than ` n/3 ` times."
    },
    "leetcode-benchmark-82": {
        "id": "leetcode-benchmark-82",
        "title": "Delete Node in a Linked List",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a singly-linked list `head` and we want to delete a node `node` in it.\n\nYou are given the node to be deleted `node`. You will **not be given access** to the first node of `head`.\n\nAll the values of the linked list are **unique**, and it is guaranteed that the given node `node` is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\n*   The value of the given node should not exist in the linked list.\n*   The number of nodes in the linked list should decrease by one.\n*   All the values before `node` should be in the same order.\n*   All the values after `node` should be in the same order.\n\n**Custom testing:**\n\n*   For the input, you should provide the entire linked list `head` and the node to be given `node`. `node` should not be the last node of the list and should be an actual node in the list.\n*   We will build the linked list and pass the node to your function.\n*   The output will be the entire list after calling your function.",
            "examples": [
                "**Example 1:**\n\n**Input:** head = \\[4,5,1,9\\], node = 5\n**Output:** \\[4,1,9\\]\n**Explanation:** You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\n",
                "**Example 2:**\n\n**Input:** head = \\[4,5,1,9\\], node = 1\n**Output:** \\[4,5,9\\]\n**Explanation:** You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function."
            ],
            "constraints": "**Constraints:**\n\n*   The number of the nodes in the given list is in the range `[2, 1000]`.\n*   `-1000 <= Node.val <= 1000`\n*   The value of each node in the list is **unique**.\n*   The `node` to be deleted is **in the list** and is **not a tail** node.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic void deleteNode(ListNode node) {\n    ListNode nextNode = node.next;\n    node.val = nextNode.val;\n    node.next = nextNode.next;\n}\n```\n    \n    The function takes in a node of the singly-linked list, which is the one to be deleted. Since we don't have access to the head of the list, we can't traverse the list to find the previous node.\n\nThe idea here is to replace the given node's value with the next node's value, and then update the given node's next pointer to skip the next node, effectively deleting the next node. Finally, we delete the next node if the language requires explicit memory management (e.g., C++).\n\nThis approach won't work if the node to be deleted is the tail of the list, but the problem statement guarantees that it won't be a tail node.\n    ",
        "c++": "\n    ```cpp\nvoid deleteNode(ListNode* node) {\n    ListNode* nextNode = node->next;\n    *node = *nextNode;\n    delete nextNode;\n}\n```\n    \n    The function takes in a node of the singly-linked list, which is the one to be deleted. Since we don't have access to the head of the list, we can't traverse the list to find the previous node.\n\nThe idea here is to replace the given node's value with the next node's value, and then update the given node's next pointer to skip the next node, effectively deleting the next node. Finally, we delete the next node if the language requires explicit memory management (e.g., C++).\n\nThis approach won't work if the node to be deleted is the tail of the list, but the problem statement guarantees that it won't be a tail node.\n    ",
        "python": "\n    ```python\ndef deleteNode(node):\n    next_node = node.next\n    node.val = next_node.val\n    node.next = next_node.next\n```\n    \n    The function takes in a node of the singly-linked list, which is the one to be deleted. Since we don't have access to the head of the list, we can't traverse the list to find the previous node.\n\nThe idea here is to replace the given node's value with the next node's value, and then update the given node's next pointer to skip the next node, effectively deleting the next node. Finally, we delete the next node if the language requires explicit memory management (e.g., C++).\n\nThis approach won't work if the node to be deleted is the tail of the list, but the problem statement guarantees that it won't be a tail node.\n    ",
        "javascript": "\n    ```javascript\nfunction deleteNode(node) {\n    const nextNode = node.next;\n    node.val = nextNode.val;\n    node.next = nextNode.next;\n}\n```\n    \n    The function takes in a node of the singly-linked list, which is the one to be deleted. Since we don't have access to the head of the list, we can't traverse the list to find the previous node.\n\nThe idea here is to replace the given node's value with the next node's value, and then update the given node's next pointer to skip the next node, effectively deleting the next node. Finally, we delete the next node if the language requires explicit memory management (e.g., C++).\n\nThis approach won't work if the node to be deleted is the tail of the list, but the problem statement guarantees that it won't be a tail node.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " head = [4,5,1,9], node = 5",
                    "output": " [4,1,9]",
                    "explanation": " You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function."
                },
                {
                    "input": " head = [4,5,1,9], node = 1",
                    "output": " [4,5,9]",
                    "explanation": " You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function."
                }
            ],
            "function_input": [
                {
                    "input": "[4,5,1,9],5",
                    "output": "[4,1,9]"
                },
                {
                    "input": "[4,5,1,9],1",
                    "output": "[4,5,9]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-82",
        "prompt": "There is a singly-linked list `head` and we want to delete a node `node` in it.\n\nYou are given the node to be deleted `node`. You will **not be given access** to the first node of `head`.\n\nAll the values of the linked list are **unique**, and it is guaranteed that the given node `node` is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\n*   The value of the given node should not exist in the linked list.\n*   The number of nodes in the linked list should decrease by one.\n*   All the values before `node` should be in the same order.\n*   All the values after `node` should be in the same order.\n\n**Custom testing:**\n\n*   For the input, you should provide the entire linked list `head` and the node to be given `node`. `node` should not be the last node of the list and should be an actual node in the list.\n*   We will build the linked list and pass the node to your function.\n*   The output will be the entire list after calling your function."
    },
    "leetcode-benchmark-83": {
        "id": "leetcode-benchmark-83",
        "title": "Product of Array Except Self",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** \\[24,12,8,6\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,1,0,-3,3\\]\n**Output:** \\[0,0,9,0,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 105`\n*   `-30 <= nums[i] <= 30`\n*   The product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\n**",
            "follow_up": "Follow up:** Can you solve the problem in `O(1)` extra space complexity? (The output array **does not** count as extra space for space complexity analysis.)"
        },
        "java": "\n    ```java\npublic int[] productExceptSelf(int[] nums) {\n    int n = nums.length;\n    int[] answer = new int[n];\n    \n    Arrays.fill(answer, 1);\n    \n    int left = 1;\n    for (int i = 0; i < n; i++) {\n        answer[i] *= left;\n        left *= nums[i];\n    }\n    \n    int right = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        answer[i] *= right;\n        right *= nums[i];\n    }\n    \n    return answer;\n}\n```\n    \n    The basic idea is to create an array `answer` with the same size as `nums`. We start by initializing all elements of the `answer` array to 1.\n\nWe then perform two passes through the `nums` array. During the first pass, we keep track of the running product of elements to the left of the current index in a variable called `left`, and we multiply the corresponding element in the `answer` array by this running product.\n\nDuring the second pass, we move in the reverse direction, and we perform a similar operation for the elements to the right of the current index using a variable called `right`. This will result in `answer[i]` being equal to the product of all elements in the `nums` array except for the current element, `nums[i]`.\n\nSince we only have two passes through the input array, the algorithm has an O(n) time complexity.\n    ",
        "c++": "\n    ```cpp\nvector<int> productExceptSelf(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> answer(n, 1);\n    \n    int left = 1;\n    for (int i = 0; i < n; i++) {\n        answer[i] *= left;\n        left *= nums[i];\n    }\n    \n    int right = 1;\n    for (int i = n - 1; i >= 0; i--) {\n        answer[i] *= right;\n        right *= nums[i];\n    }\n    \n    return answer;\n}\n```\n    \n    The basic idea is to create an array `answer` with the same size as `nums`. We start by initializing all elements of the `answer` array to 1.\n\nWe then perform two passes through the `nums` array. During the first pass, we keep track of the running product of elements to the left of the current index in a variable called `left`, and we multiply the corresponding element in the `answer` array by this running product.\n\nDuring the second pass, we move in the reverse direction, and we perform a similar operation for the elements to the right of the current index using a variable called `right`. This will result in `answer[i]` being equal to the product of all elements in the `nums` array except for the current element, `nums[i]`.\n\nSince we only have two passes through the input array, the algorithm has an O(n) time complexity.\n    ",
        "python": "\n    ```python\ndef productExceptSelf(nums):\n    n = len(nums)\n    answer = [1] * n\n    \n    left = 1\n    for i in range(n):\n        answer[i] *= left\n        left *= nums[i]\n    \n    right = 1\n    for i in range(n - 1, -1, -1):\n        answer[i] *= right\n        right *= nums[i]\n    \n    return answer\n```\n    \n    The basic idea is to create an array `answer` with the same size as `nums`. We start by initializing all elements of the `answer` array to 1.\n\nWe then perform two passes through the `nums` array. During the first pass, we keep track of the running product of elements to the left of the current index in a variable called `left`, and we multiply the corresponding element in the `answer` array by this running product.\n\nDuring the second pass, we move in the reverse direction, and we perform a similar operation for the elements to the right of the current index using a variable called `right`. This will result in `answer[i]` being equal to the product of all elements in the `nums` array except for the current element, `nums[i]`.\n\nSince we only have two passes through the input array, the algorithm has an O(n) time complexity.\n    ",
        "javascript": "\n    ```javascript\nfunction productExceptSelf(nums) {\n    const n = nums.length;\n    const answer = new Array(n).fill(1);\n    \n    let left = 1;\n    for (let i = 0; i < n; i++) {\n        answer[i] *= left;\n        left *= nums[i];\n    }\n    \n    let right = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        answer[i] *= right;\n        right *= nums[i];\n    }\n    \n    return answer;\n}\n```\n    \n    The basic idea is to create an array `answer` with the same size as `nums`. We start by initializing all elements of the `answer` array to 1.\n\nWe then perform two passes through the `nums` array. During the first pass, we keep track of the running product of elements to the left of the current index in a variable called `left`, and we multiply the corresponding element in the `answer` array by this running product.\n\nDuring the second pass, we move in the reverse direction, and we perform a similar operation for the elements to the right of the current index using a variable called `right`. This will result in `answer[i]` being equal to the product of all elements in the `nums` array except for the current element, `nums[i]`.\n\nSince we only have two passes through the input array, the algorithm has an O(n) time complexity.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,4]",
                    "output": " [24,12,8,6]",
                    "explanation": null
                },
                {
                    "input": " nums = [-1,1,0,-3,3]",
                    "output": " [0,0,9,0,0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4]",
                    "output": "[24,12,8,6]"
                },
                {
                    "input": "[-1,1,0,-3,3]",
                    "output": "[0,0,9,0,0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-83",
        "prompt": "Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is **guaranteed** to fit in a **32-bit** integer.\n\nYou must write an algorithm that runs in `O(n)` time and without using the division operation."
    },
    "leetcode-benchmark-84": {
        "id": "leetcode-benchmark-84",
        "title": "Search a 2D Matrix II",
        "difficulty": "Medium",
        "content": {
            "problem": "Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix `matrix`. This matrix has the following properties:\n\n*   Integers in each row are sorted in ascending from left to right.\n*   Integers in each column are sorted in ascending from top to bottom.",
            "examples": [
                "**Example 1:**\n\n**Input:** matrix = \\[\\[1,4,7,11,15\\],\\[2,5,8,12,19\\],\\[3,6,9,16,22\\],\\[10,13,14,17,24\\],\\[18,21,23,26,30\\]\\], target = 5\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** matrix = \\[\\[1,4,7,11,15\\],\\[2,5,8,12,19\\],\\[3,6,9,16,22\\],\\[10,13,14,17,24\\],\\[18,21,23,26,30\\]\\], target = 20\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= n, m <= 300`\n*   `-109 <= matrix[i][j] <= 109`\n*   All the integers in each row are **sorted** in ascending order.\n*   All the integers in each column are **sorted** in ascending order.\n*   `-109 <= target <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean searchMatrix(int[][] matrix, int target) {\n    int row = matrix.length - 1, col = 0;\n    while (row >= 0 && col < matrix[0].length) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm starts at the bottom-left corner of the matrix. Then it follows these rules:\n1. If the current value is bigger than the target, then move up in the matrix (because all values above will be smaller).\n2. If the current value is smaller than the target, then move to the right in the matrix (because all values to the right will be bigger).\n3. If the current value is equal to the target, return true.\n\nThis algorithm is efficient as it reduces the search space in every step by either eliminating a row or a column. At most, it will take m + n steps.\n    ",
        "c++": "\n    ```cpp\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\n    int row = matrix.size() - 1, col = 0;\n    while (row >= 0 && col < matrix[0].size()) {\n        if (matrix[row][col] > target) {\n            row--;\n        } else if (matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm starts at the bottom-left corner of the matrix. Then it follows these rules:\n1. If the current value is bigger than the target, then move up in the matrix (because all values above will be smaller).\n2. If the current value is smaller than the target, then move to the right in the matrix (because all values to the right will be bigger).\n3. If the current value is equal to the target, return true.\n\nThis algorithm is efficient as it reduces the search space in every step by either eliminating a row or a column. At most, it will take m + n steps.\n    ",
        "python": "\n    ```python\ndef searchMatrix(matrix, target):\n    row, col = len(matrix) - 1, 0\n    while row >= 0 and col < len(matrix[0]):\n        if matrix[row][col] > target:\n            row -= 1\n        elif matrix[row][col] < target:\n            col += 1\n        else:\n            return True\n    return False\n```\n    \n    The algorithm starts at the bottom-left corner of the matrix. Then it follows these rules:\n1. If the current value is bigger than the target, then move up in the matrix (because all values above will be smaller).\n2. If the current value is smaller than the target, then move to the right in the matrix (because all values to the right will be bigger).\n3. If the current value is equal to the target, return true.\n\nThis algorithm is efficient as it reduces the search space in every step by either eliminating a row or a column. At most, it will take m + n steps.\n    ",
        "javascript": "\n    ```javascript\nfunction searchMatrix(matrix, target) {\n    let row = matrix.length - 1, col = 0;\n    while(row >= 0 && col < matrix[0].length) {\n        if(matrix[row][col] > target) {\n            row--;\n        } else if(matrix[row][col] < target) {\n            col++;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n\n    \n    The algorithm starts at the bottom-left corner of the matrix. Then it follows these rules:\n1. If the current value is bigger than the target, then move up in the matrix (because all values above will be smaller).\n2. If the current value is smaller than the target, then move to the right in the matrix (because all values to the right will be bigger).\n3. If the current value is equal to the target, return true.\n\nThis algorithm is efficient as it reduces the search space in every step by either eliminating a row or a column. At most, it will take m + n steps.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]],5",
                    "output": "True"
                },
                {
                    "input": "[[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]],20",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-84",
        "prompt": "Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix `matrix`. This matrix has the following properties:\n\n*   Integers in each row are sorted in ascending from left to right.\n*   Integers in each column are sorted in ascending from top to bottom."
    },
    "leetcode-benchmark-85": {
        "id": "leetcode-benchmark-85",
        "title": "Different Ways to Add Parentheses",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `expression` of numbers and operators, return _all possible results from computing all the different possible ways to group numbers and operators_. You may return the answer in **any order**.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed `104`.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"2-1-1 \"\n**Output:** \\[0,2\\]\n**Explanation:**\n((2-1)-1) = 0 \n(2-(1-1)) = 2\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"2\\*3-4\\*5 \"\n**Output:** \\[-34,-14,-10,-10,10\\]\n**Explanation:**\n(2\\*(3-(4\\*5))) = -34 \n((2\\*3)-(4\\*5)) = -14 \n((2\\*(3-4))\\*5) = -10 \n(2\\*((3-4)\\*5)) = -10 \n(((2\\*3)-4)\\*5) = 10"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= expression.length <= 20`\n*   `expression` consists of digits and the operator `'+'`, `'-'`, and `'*'`.\n*   All the integer values in the input expression are in the range `[0, 99]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> diffWaysToCompute(String input) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 0; i < input.length(); i++) {\n        char c = input.charAt(i);\n        if (c == '+' || c == '-' || c == '*') {\n            List<Integer> left = diffWaysToCompute(input.substring(0, i));\n            List<Integer> right = diffWaysToCompute(input.substring(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.add(l + r);\n                    else if (c == '-') result.add(l - r);\n                    else if (c == '*') result.add(l * r);\n                }\n            }\n        }\n    }\n    if (result.isEmpty()) result.add(Integer.parseInt(input));\n    return result;\n}\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ",
        "c++": "\n    ```cpp\n#include<vector>\n#include<string>\n\nusing namespace std;\n\nvector<int> diffWaysToCompute(string input) {\n    vector<int> result;\n    for (int i = 0; i < input.size(); i++) {\n        char c = input[i];\n        if (c == '+' || c == '-' || c == '*') {\n            auto left = diffWaysToCompute(input.substr(0, i));\n            auto right = diffWaysToCompute(input.substr(i + 1));\n            for (int l : left) {\n                for (int r : right) {\n                    if (c == '+') result.push_back(l + r);\n                    else if (c == '-') result.push_back(l - r);\n                    else if (c == '*') result.push_back(l * r);\n                }\n            }\n        }\n    }\n    if (result.empty()) result.push_back(stoi(input));\n    return result;\n}\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ",
        "python": "\n    ```python\ndef diffWaysToCompute(input: str):\n    result = []\n    for i in range(len(input)):\n        c = input[i]\n        if c == '+' or c == '-' or c == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i + 1:])\n            for l in left:\n                for r in right:\n                    if c == '+': result.append(l + r)\n                    elif c == '-': result.append(l - r)\n                    elif c == '*': result.append(l * r)\n    if not result:\n        result.append(int(input))\n    return result\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ",
        "javascript": "\n    ```javascript\nfunction diffWaysToCompute(input) {\n    const result = [];\n    for (let i = 0; i < input.length; i++) {\n        const c = input[i];\n        if (c === '+' || c === '-' || c === '*') {\n            const left = diffWaysToCompute(input.slice(0, i));\n            const right = diffWaysToCompute(input.slice(i + 1));\n            for (const l of left) {\n                for (const r of right) {\n                    if (c === '+') result.push(l + r);\n                    else if (c === '-') result.push(l - r);\n                    else if (c === '*') result.push(l * r);\n                }\n            }\n        }\n    }\n    if (result.length === 0) result.push(parseInt(input));\n    return result;\n}\n```\n    \n    The algorithm is a recursive divide-and-conquer approach. It starts by iterating through the `input` string and looks for operators (+, -, *). When an operator is found, the problem is divided into two sub-problems: left and right. These sub-problems are independently solved through recursively calling the `diffWaysToCompute` function with corresponding substrings. \n\nEach recursion returns a list of possible results for each sub-problem. For each operator, we combine these results by iterating through both lists and performing the corresponding operation (addition, subtraction, or multiplication).\n\nIf no operators are present in the input string, a base case is reached, and the current number in the input string is returned as the only result. The recursion ultimately produces a list of all possible results for the original expression by combining results from all sub-problems.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " expression =  \"2-1-1 \"",
                    "output": " [0,2]",
                    "explanation": "\n((2-1)-1) = 0 \n(2-(1-1)) = 2"
                },
                {
                    "input": " expression =  \"2*3-4*5 \"",
                    "output": " [-34,-14,-10,-10,10]",
                    "explanation": "\n(2\\*(3-(4\\*5))) = -34 \n((2\\*3)-(4\\*5)) = -14 \n((2\\*(3-4))\\*5) = -10 \n(2\\*((3-4)\\*5)) = -10 \n(((2\\*3)-4)\\*5) = 10"
                }
            ],
            "function_input": [
                {
                    "input": "\"2-1-1\"",
                    "output": "[0,2]"
                },
                {
                    "input": "\"2*3-4*5\"",
                    "output": "[-34,-14,-10,-10,10]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-85",
        "prompt": "Given a string `expression` of numbers and operators, return _all possible results from computing all the different possible ways to group numbers and operators_. You may return the answer in **any order**.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed `104`."
    },
    "leetcode-benchmark-86": {
        "id": "leetcode-benchmark-86",
        "title": "Shortest Word Distance III",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return _the shortest distance between the occurrence of these two words in the list_.\n\n**Note** that `word1` and `word2` may be the same. It is guaranteed that they represent **two individual words** in the list.",
            "examples": [
                "**Example 1:**\n\n**Input:** wordsDict = \\[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"\\], word1 = \"makes\", word2 = \"coding\"\n**Output:** 1\n\n",
                "**Example 2:**\n\n**Input:** wordsDict = \\[\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"\\], word1 = \"makes\", word2 = \"makes\"\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= wordsDict.length <= 105`\n*   `1 <= wordsDict[i].length <= 10`\n*   `wordsDict[i]` consists of lowercase English letters.\n*   `word1` and `word2` are in `wordsDict`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int shortestDistance(String[] wordsDict, String word1, String word2) {\n    int index1 = -1, index2 = -1, minDistance = Integer.MAX_VALUE;\n    for (int i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i].equals(word1)) { index1 = i; }\n        if (wordsDict[i].equals(word2)) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <limits>\n\nint shortestDistance(std::vector<std::string>& wordsDict, std::string word1, std::string word2) {\n    int index1 = -1, index2 = -1, minDistance = std::numeric_limits<int>::max();\n    for (int i = 0; i < wordsDict.size(); ++i) {\n        if (wordsDict[i] == word1) { index1 = i; }\n        if (wordsDict[i] == word2) { index2 = i; }\n        if (index1 != -1 && index2 != -1) {\n            minDistance = std::min(minDistance, std::abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "python": "\n    ```python\ndef shortest_distance(words_dict, word1, word2):\n    index1, index2, min_distance = -1, -1, float('inf')\n    for i, word in enumerate(words_dict):\n        if word == word1:\n            index1 = i\n        if word == word2:\n            index2 = i\n        if index1 != -1 and(index2 != -1):\n            min_distance = min(min_distance, abs(index1 - index2))\n    return min_distance\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "javascript": "\n    ```javascript\nfunction shortestDistance(wordsDict, word1, word2) {\n    let index1 = -1, index2 = -1, minDistance = Infinity;\n    for (let i = 0; i < wordsDict.length; ++i) {\n        if (wordsDict[i] === word1) { index1 = i; }\n        if (wordsDict[i] === word2) { index2 = i; }\n        if (index1 !== -1 && index2 !== -1) {\n            minDistance = Math.min(minDistance, Math.abs(index1 - index2));\n        }\n    }\n    return minDistance;\n}\n```\n    \n    For each string in the given list `wordsDict`, initialize `index1` and `index2` to -1 and `minDistance` to the maximum possible value for the respective language. Iterate through the list of strings and update `index1` or `index2` if the current string is equal to `word1` or `word2`. If both `index1` and `index2` are not -1 (meaning both words have been found at least once), calculate the absolute difference between the indices and update `minDistance` if the current distance is less than the previous minimum distance.\n\nReturn `minDistance` once the loop is done iterating.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"coding\"",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " wordsDict = [\"practice\", \"makes\", \"perfect\", \"coding\", \"makes\"], word1 = \"makes\", word2 = \"makes\"",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"makes\",\"coding\"",
                    "output": "1"
                },
                {
                    "input": "[\"practice\",\"makes\",\"perfect\",\"coding\",\"makes\"],\"makes\",\"makes\"",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-86",
        "prompt": "Given an array of strings `wordsDict` and two strings that already exist in the array `word1` and `word2`, return _the shortest distance between the occurrence of these two words in the list_.\n\n**Note** that `word1` and `word2` may be the same. It is guaranteed that they represent **two individual words** in the list."
    },
    "leetcode-benchmark-87": {
        "id": "leetcode-benchmark-87",
        "title": "Strobogrammatic Number II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return all the **strobogrammatic numbers** that are of length `n`. You may return the answer in **any order**.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down).",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** \\[\"11\",\"69\",\"88\",\"96\"\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\"0\",\"1\",\"8\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 14`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<String> findStrobogrammatic(int n) {\n    return helper(n, n);\n}\n\nprivate List<String> helper(int n, int m) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n    \n    List<String> list = helper(n - 2, m);\n    List<String> res = new ArrayList<>();\n\n    for (int i = 0; i < list.size(); i++) {\n        String s = list.get(i);\n        \n        if (n != m) res.add(\"0\" + s + \"0\");\n\n        res.add(\"1\" + s + \"1\");\n        res.add(\"6\" + s + \"9\");\n        res.add(\"8\" + s + \"8\");\n        res.add(\"9\" + s + \"6\");\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findStrobogrammatic(int n) {\n    return helper(n, n);\n}\n\nstd::vector<std::string> helper(int n, int m) {\n    if (n == 0) return {\"\"};\n    if (n == 1) return {\"0\", \"1\", \"8\"};\n    \n    std::vector<std::string> list = helper(n - 2, m);\n    std::vector<std::string> res;\n\n    for (int i = 0; i < list.size(); i++) {\n        std::string s = list[i];\n        \n        if (n != m) res.push_back(\"0\" + s + \"0\");\n\n        res.push_back(\"1\" + s + \"1\");\n        res.push_back(\"6\" + s + \"9\");\n        res.push_back(\"8\" + s + \"8\");\n        res.push_back(\"9\" + s + \"6\");\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "python": "\n    ```python\ndef findStrobogrammatic(n):\n    def helper(n, m):\n        if n == 0:\n            return [\"\"]\n        if n == 1:\n            return [\"0\", \"1\", \"8\"]\n\n        list = helper(n - 2, m)\n        res = []\n\n        for s in list:\n            if n != m:\n                res.append(\"0\" + s + \"0\")\n\n            res.append(\"1\" + s + \"1\")\n            res.append(\"6\" + s + \"9\")\n            res.append(\"8\" + s + \"8\")\n            res.append(\"9\" + s + \"6\")\n\n        return res\n\n    return helper(n, n)\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "javascript": "\n    ```javascript\nfunction findStrobogrammatic(n) {\n    return helper(n, n);\n}\n\nfunction helper(n, m) {\n    if (n === 0) return [\"\"];\n    if (n === 1) return [\"0\", \"1\", \"8\"];\n    \n    const list = helper(n - 2, m);\n    const res = [];\n\n    for (let i = 0; i < list.length; i++) {\n        const s = list[i];\n\n        if (n !== m) res.push(\"0\" + s + \"0\");\n\n        res.push(\"1\" + s + \"1\");\n        res.push(\"6\" + s + \"9\");\n        res.push(\"8\" + s + \"8\");\n        res.push(\"9\" + s + \"6\");\n    }\n\n    return res;\n}\n```\n    \n    The algorithm uses a recursive approach to find all the strobogrammatic numbers of length n. It starts by checking the base cases when n is 0 or 1, and then recursively calls the helper function with n-2. This helps to build the strobogrammatic numbers by appending to the center of the existing numbers until the desired length is reached. Inside the loop, the code adds the possible pairs of strobogrammatic digits (\"1\" + s + \"1\", \"6\" + s + \"9\", \"8\" + s + \"8\", \"9\" + s + \"6\") and for even lengths only, it adds 0s as well (\"0\" + s + \"0\"). This is because when we are building the number from the center, we cannot have leading zeros. Finally, it returns the list of strobogrammatic numbers of length n.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " [\"11\",\"69\",\"88\",\"96\"]",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " [\"0\",\"1\",\"8\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "[\"11\",\"69\",\"88\",\"96\"]"
                },
                {
                    "input": "1",
                    "output": "[\"0\",\"1\",\"8\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-87",
        "prompt": "Given an integer `n`, return all the **strobogrammatic numbers** that are of length `n`. You may return the answer in **any order**.\n\nA **strobogrammatic number** is a number that looks the same when rotated `180` degrees (looked at upside down)."
    },
    "leetcode-benchmark-88": {
        "id": "leetcode-benchmark-88",
        "title": "Factor Combinations",
        "difficulty": "Medium",
        "content": {
            "problem": "Numbers can be regarded as the product of their factors.\n\n*   For example, `8 = 2 x 2 x 2 = 2 x 4`.\n\nGiven an integer `n`, return _all possible combinations of its factors_. You may return the answer in **any order**.\n\n**Note** that the factors should be in the range `[2, n - 1]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 1\n**Output:** \\[\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 12\n**Output:** \\[\\[2,6\\],\\[3,4\\],\\[2,2,3\\]\\]\n\n",
                "**Example 3:**\n\n**Input:** n = 37\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 107`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<List<Integer>> getFactors(int n) {\n    List<List<Integer>> result = new ArrayList<>();\n    helper(n, 2, new ArrayList<Integer>(), result);\n    return result;\n}\n\nprivate void helper(int n, int start, List<Integer> path, List<List<Integer>> result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.add(new ArrayList<>(path));\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; i++) {\n        if (n % i == 0) {\n            path.add(i);\n            helper(n / i, i, path, result);\n            path.remove(path.size() - 1);\n        }\n    }\n}\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nvoid helper(int n, int start, std::vector<int>& path, std::vector<std::vector<int>>& result) {\n    if (n == 1) {\n        if (path.size() > 1) {\n            result.push_back(path);\n        }\n        return;\n    }\n\n    for (int i = start; i <= n; ++i) {\n        if (n % i == 0) {\n            path.push_back(i);\n            helper(n / i, i, path, result);\n            path.pop_back();\n        }\n    }\n}\n\nstd::vector<std::vector<int>> getFactors(int n) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> path;\n    helper(n, 2, path, result);\n    return result;\n}\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "python": "\n    ```python\ndef getFactors(n):\n    def helper(n, start, path, result):\n        if n == 1:\n            if len(path) > 1:\n                result.append(path[:])\n            return\n\n        for i in range(start, n + 1):\n            if n % i == 0:\n                path.append(i)\n                helper(n // i, i, path, result)\n                path.pop()\n\n    result = []\n    helper(n, 2, [], result)\n    return result\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "javascript": "\n    ```javascript\nfunction getFactors(n) {\n    const result = [];\n    const helper = (n, start, path) => {\n        if (n === 1) {\n            if (path.length > 1) {\n                result.push([...path]);\n            }\n            return;\n        }\n\n        for (let i = start; i <= n; i++) {\n            if (n % i === 0) {\n                path.push(i);\n                helper(n / i, i, path);\n                path.pop();\n            }\n        }\n    };\n\n    helper(n, 2, []);\n    return result;\n}\n```\n    \n    We use a backtracking algorithm to find all possible combinations of factors. The algorithm starts with `n` and splits it into all possible factors in the range `[2, n]`. We keep track of the current path, which represents the factors found so far. When `n` equals 1, we check if the current path has more than one element. If it does, we add the current combination of factors to the result.\n\nTo avoid duplicates, we ensure that the next factor in the sequence is greater than or equal to the previous one by passing a \"start\" variable in the helper function. This ensures that we always explore factors in a non-decreasing order.\n\nAt each recursive step, we first check if the current value of `n` is divisible by the current factor (i.e., it has no remainder when divided). If it is, we update the path with the current factor and call the helper function with the updated value of `n` divided by the current factor. After the recursive call returns, we remove the last factor from the path to backtrack to the previous level and explore other factors. This continues until we've explored all factors for the given input `n`. The final result is a list of lists representing all possible combinations of factors.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 1",
                    "output": " []",
                    "explanation": null
                },
                {
                    "input": " n = 12",
                    "output": " [[2,6],[3,4],[2,2,3]]",
                    "explanation": null
                },
                {
                    "input": " n = 37",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1",
                    "output": "[]"
                },
                {
                    "input": "12",
                    "output": "[[2,6],[3,4],[2,2,3]]"
                },
                {
                    "input": "37",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-88",
        "prompt": "Numbers can be regarded as the product of their factors.\n\n*   For example, `8 = 2 x 2 x 2 = 2 x 4`.\n\nGiven an integer `n`, return _all possible combinations of its factors_. You may return the answer in **any order**.\n\n**Note** that the factors should be in the range `[2, n - 1]`."
    },
    "leetcode-benchmark-89": {
        "id": "leetcode-benchmark-89",
        "title": "Verify Preorder Sequence in Binary Search Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of **unique** integers `preorder`, return `true` _if it is the correct preorder traversal sequence of a binary search tree_.",
            "examples": [
                "**Example 1:**\n\n**Input:** preorder = \\[5,2,1,3,6\\]\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** preorder = \\[5,2,6,1,3\\]\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= preorder.length <= 104`\n*   `1 <= preorder[i] <= 104`\n*   All the elements of `preorder` are **unique**.\n\n**",
            "follow_up": "Follow up:** Could you do it using only constant space complexity?"
        },
        "java": "\n    ```java\npublic boolean isValidPreorder(int[] preorder) {\n    Stack<Integer> stack = new Stack<>();\n    int lowerBound = Integer.MIN_VALUE;\n    for (int num : preorder) {\n        if (num < lowerBound) return false;\n        while (!stack.isEmpty() && num > stack.peek()) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n}\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "c++": "\n    ```cpp\nbool isValidPreorder(vector<int>& preorder) {\n    stack<int> stk;\n    int lower_bound = INT_MIN;\n    for (int num : preorder) {\n        if (num < lower_bound) return false;\n        while (!stk.empty() && num > stk.top()) {\n            lower_bound = stk.top();\n            stk.pop();\n        }\n        stk.push(num);\n    }\n    return true;\n}\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "python": "\n    ```python\ndef isValidPreorder(preorder: List[int]) -> bool:\n    stack = []\n    lower_bound = float('-inf')\n    for num in preorder:\n        if num < lower_bound:\n            return False\n        while stack and num > stack[-1]:\n            lower_bound = stack.pop()\n        stack.append(num)\n    return True\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "javascript": "\n    ```javascript\nvar isValidPreorder = function(preorder) {\n    let stack = [];\n    let lowerBound = Number.MIN_SAFE_INTEGER;\n    for (let num of preorder) {\n        if (num < lowerBound) return false;\n        while (stack.length > 0 && num > stack[stack.length - 1]) {\n            lowerBound = stack.pop();\n        }\n        stack.push(num);\n    }\n    return true;\n};\n```\n    \n    The algorithm is mainly based on a stack. It processes each element in the given `preorder` array and uses the stack to keep track of nodes that are not yet part of a completed subtree.\n\nInitially, `lower_bound` is set to the minimum possible value.\n\nFor each number in the preorder array:\n\n1. If the number is less than lower_bound, it means the number is trying to be added as a right child but the value is less than the minimum possible value, hence breaks the binary search tree property. So return false.\n   \n2. If the number is greater than the top of the stack, it means the number is the right child of the last node encountered. So, we pop from the stack and set the lower_bound to the last popped value until the stack is empty or the number is smaller than the top of the stack.\n   \n3. Push the number onto the stack.\n\nIf no false case is encountered during the loop, return true as it is a valid preorder traversal sequence of a binary search tree.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " preorder = [5,2,1,3,6]",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " preorder = [5,2,6,1,3]",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[5,2,1,3,6]",
                    "output": "True"
                },
                {
                    "input": "[5,2,6,1,3]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-89",
        "prompt": "Given an array of **unique** integers `preorder`, return `true` _if it is the correct preorder traversal sequence of a binary search tree_."
    },
    "leetcode-benchmark-90": {
        "id": "leetcode-benchmark-90",
        "title": "Paint House",
        "difficulty": "Medium",
        "content": {
            "problem": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_.",
            "examples": [
                "**Example 1:**\n\n**Input:** costs = \\[\\[17,2,17\\],\\[16,16,5\\],\\[14,3,19\\]\\]\n**Output:** 10\n**Explanation:** Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n\n",
                "**Example 2:**\n\n**Input:** costs = \\[\\[7,6,2\\]\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `costs.length == n`\n*   `costs[i].length == 3`\n*   `1 <= n <= 100`\n*   `1 <= costs[i][j] <= 20`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int minCost(int[][] costs) {\n    if (costs.length == 0) return 0;\n    for (int i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], Math.min(costs[costs.length - 1][1], costs[costs.length - 1][2]));\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "c++": "\n    ```cpp\nint minCost(vector<vector<int>>& costs) {\n    if (costs.empty()) return 0;\n    for (int i = 1; i < costs.size(); ++i) {\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return min(costs.back()[0], min(costs.back()[1], costs.back()[2]));\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "python": "\n    ```python\ndef minCost(costs: List[List[int]]) -> int:\n    if not costs:\n        return 0\n    for i in range(1, len(costs)):\n        costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n        costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n        costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n    return min(costs[-1][0], costs[-1][1], costs[-1][2])\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "javascript": "\n    ```javascript\nfunction minCost(costs) {\n    if (costs.length === 0) return 0;\n    for (let i = 1; i < costs.length; i++) {\n        costs[i][0] += Math.min(costs[i - 1][1], costs[i - 1][2]);\n        costs[i][1] += Math.min(costs[i - 1][0], costs[i - 1][2]);\n        costs[i][2] += Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(costs[costs.length - 1][0], costs[costs.length - 1][1], costs[costs.length - 1][2]);\n}\n```\n    \n    We use a dynamic programming approach to solve this problem. Initially, if there are no houses to paint, we return 0.\nFor the rest of the houses, we iterate through the array starting from the second house. For each house i, we calculate the cost of painting it with each color considering the last colored house.\n\n1. costs[i][0] += min(costs[i - 1][1], costs[i - 1][2]);\n2. costs[i][1] += min(costs[i - 1][0], costs[i - 1][2]);\n3. costs[i][2] += min(costs[i - 1][0], costs[i - 1][1]);\n\nAfter iterating through all houses, we return the minimum cost of the possible color configurations for the last house.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " costs = [[17,2,17],[16,16,5],[14,3,19]]",
                    "output": " 10",
                    "explanation": " Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10."
                },
                {
                    "input": " costs = [[7,6,2]]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[17,2,17],[16,16,5],[14,3,19]]",
                    "output": "10"
                },
                {
                    "input": "[[7,6,2]]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-90",
        "prompt": "There is a row of `n` houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\n\nThe cost of painting each house with a certain color is represented by an `n x 3` cost matrix `costs`.\n\n*   For example, `costs[0][0]` is the cost of painting house `0` with the color red; `costs[1][2]` is the cost of painting house 1 with color green, and so on...\n\nReturn _the minimum cost to paint all houses_."
    },
    "leetcode-benchmark-91": {
        "id": "leetcode-benchmark-91",
        "title": "3Sum Smaller",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-2,0,1,3\\], target = 2\n**Output:** 2\n**Explanation:** Because there are two triplets which sums are less than 2:\n\\[-2,0,1\\]\n\\[-2,0,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[\\], target = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0\\], target = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `0 <= n <= 3500`\n*   `-100 <= nums[i] <= 100`\n*   `-100 <= target <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int threeSumSmaller(int[] nums, int target) {\n    int count = 0;\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length; ++i) {\n        int j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "c++": "\n    ```cpp\nint threeSumSmaller(vector<int>& nums, int target) {\n    int count = 0;\n    sort(nums.begin(), nums.end());\n    for (int i = 0; i < nums.size(); ++i) {\n        int j = i + 1, k = nums.size() - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "python": "\n    ```python\ndef threeSumSmaller(nums, target):\n    count = 0\n    nums.sort()\n    for i in range(len(nums)):\n        j, k = i + 1, len(nums) - 1\n        while j < k:\n            if nums[i] + nums[j] + nums[k] < target:\n                count += k - j\n                j += 1\n            else:\n                k -= 1\n    return count\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "javascript": "\n    ```javascript\nfunction threeSumSmaller(nums, target) {\n    let count = 0;\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length; ++i) {\n        let j = i + 1, k = nums.length - 1;\n        while (j < k) {\n            if (nums[i] + nums[j] + nums[k] < target) {\n                count += k - j;\n                ++j;\n            } else {\n                --k;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    To solve this problem, we first sort the input array. Then we loop through each element in the array and use two pointers, `j` and `k`, initialized to the following element and the last element in the sorted array, respectively. We repeat the process until `j` is less than `k`. Inside the loop, we check if the sum of `nums[i]`, `nums[j]`, and `nums[k]` is less than the target. If it is, we add the difference `k - j` to the count and increment `j`. Otherwise, we decrement `k`. Finally, we return the count.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-2,0,1,3], target = 2",
                    "output": " 2",
                    "explanation": " Because there are two triplets which sums are less than 2:\n\\[-2,0,1\\]\n\\[-2,0,3\\]"
                },
                {
                    "input": " nums = [], target = 0",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " nums = [0], target = 0",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[-2,0,1,3],2",
                    "output": "2"
                },
                {
                    "input": "[],0",
                    "output": "0"
                },
                {
                    "input": "[0],0",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-91",
        "prompt": "Given an array of `n` integers `nums` and an integer `target`, find the number of index triplets `i`, `j`, `k` with `0 <= i < j < k < n` that satisfy the condition `nums[i] + nums[j] + nums[k] < target`."
    },
    "leetcode-benchmark-92": {
        "id": "leetcode-benchmark-92",
        "title": "Single Number III",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.\n\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,1,3,2,5\\]\n**Output:** \\[3,5\\]\n**Explanation: ** \\[5, 3\\] is also a valid answer.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-1,0\\]\n**Output:** \\[-1,0\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[0,1\\]\n**Output:** \\[1,0\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= nums.length <= 3 * 104`\n*   `-231 <= nums[i] <= 231 - 1`\n*   Each integer in `nums` will appear twice, only two integers will appear once.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] singleNumber(int[] nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & -xor_all;\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if ((num & bit) != 0) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return new int[]{n1, n2};\n}\n```\n    \n    The algorithm uses XOR operation to find the two unique numbers. First, we XOR all numbers in the array (which cancels out the repeating numbers), and the result of this XOR operation is actually the XOR of the two unique numbers. Then, we find the rightmost bit that is set to 1 in this XOR result. This bit will be different for the two unique numbers.\n\nNext, we split the numbers into two groups: one group has that bit set, and the other group doesn't. XOR all numbers in both groups separately, and the result of the XOR operation for each group will be one of the unique numbers. This is because, within each group, the equal numbers will cancel themselves out, leaving the unique numbers as the result.\n\nThis algorithm has a linear runtime complexity (O(n)) and uses constant extra space, as required.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> singleNumber(vector<int>& nums) {\n    int xor_all = 0;\n    for (int num : nums) {\n        xor_all ^= num;\n    }\n\n    int bit = xor_all & (-xor_all);\n    int n1 = 0;\n    int n2 = 0;\n    for (int num : nums) {\n        if (num & bit) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return vector<int>{n1, n2};\n}\n```\n    \n    The algorithm uses XOR operation to find the two unique numbers. First, we XOR all numbers in the array (which cancels out the repeating numbers), and the result of this XOR operation is actually the XOR of the two unique numbers. Then, we find the rightmost bit that is set to 1 in this XOR result. This bit will be different for the two unique numbers.\n\nNext, we split the numbers into two groups: one group has that bit set, and the other group doesn't. XOR all numbers in both groups separately, and the result of the XOR operation for each group will be one of the unique numbers. This is because, within each group, the equal numbers will cancel themselves out, leaving the unique numbers as the result.\n\nThis algorithm has a linear runtime complexity (O(n)) and uses constant extra space, as required.\n    ",
        "python": "\n    ```python\ndef singleNumber(nums):\n    xor_all = 0\n    for num in nums:\n        xor_all ^= num\n\n    bit = xor_all & -xor_all\n    n1 = 0\n    n2 = 0\n    for num in nums:\n        if num & bit:\n            n1 ^= num\n        else:\n            n2 ^= num\n\n    return n1, n2\n```\n    \n    The algorithm uses XOR operation to find the two unique numbers. First, we XOR all numbers in the array (which cancels out the repeating numbers), and the result of this XOR operation is actually the XOR of the two unique numbers. Then, we find the rightmost bit that is set to 1 in this XOR result. This bit will be different for the two unique numbers.\n\nNext, we split the numbers into two groups: one group has that bit set, and the other group doesn't. XOR all numbers in both groups separately, and the result of the XOR operation for each group will be one of the unique numbers. This is because, within each group, the equal numbers will cancel themselves out, leaving the unique numbers as the result.\n\nThis algorithm has a linear runtime complexity (O(n)) and uses constant extra space, as required.\n    ",
        "javascript": "\n    ```javascript\nfunction singleNumber(nums) {\n    let xor_all = 0;\n    for (const num of nums) {\n        xor_all ^= num;\n    }\n\n    const bit = xor_all & -xor_all;\n    let n1 = 0;\n    let n2 = 0;\n    for (const num of nums) {\n        if (num & bit) {\n            n1 ^= num;\n        } else {\n            n2 ^= num;\n        }\n    }\n\n    return [n1, n2];\n}\n```\n    \n    The algorithm uses XOR operation to find the two unique numbers. First, we XOR all numbers in the array (which cancels out the repeating numbers), and the result of this XOR operation is actually the XOR of the two unique numbers. Then, we find the rightmost bit that is set to 1 in this XOR result. This bit will be different for the two unique numbers.\n\nNext, we split the numbers into two groups: one group has that bit set, and the other group doesn't. XOR all numbers in both groups separately, and the result of the XOR operation for each group will be one of the unique numbers. This is because, within each group, the equal numbers will cancel themselves out, leaving the unique numbers as the result.\n\nThis algorithm has a linear runtime complexity (O(n)) and uses constant extra space, as required.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,1,3,2,5]",
                    "output": " [3,5]\n**Explanation: ** [5, 3] is also a valid answer.",
                    "explanation": null
                },
                {
                    "input": " nums = [-1,0]",
                    "output": " [-1,0]",
                    "explanation": null
                },
                {
                    "input": " nums = [0,1]",
                    "output": " [1,0]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,1,3,2,5]",
                    "output": "[3,5]\n**Explanation:**[5,3]isalsoavalidanswer."
                },
                {
                    "input": "[-1,0]",
                    "output": "[-1,0]"
                },
                {
                    "input": "[0,1]",
                    "output": "[1,0]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-92",
        "prompt": "Given an integer array `nums`, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in **any order**.\n\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space."
    },
    "leetcode-benchmark-93": {
        "id": "leetcode-benchmark-93",
        "title": "Ugly Number II",
        "difficulty": "Medium",
        "content": {
            "problem": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return _the_ `nth` _**ugly number**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10\n**Output:** 12\n**Explanation:** \\[1, 2, 3, 4, 5, 6, 8, 9, 10, 12\\] is the sequence of the first 10 ugly numbers.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 1690`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int nthUglyNumber(int n) {\n    int[] uglyNumbers = new int[n];\n    uglyNumbers[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n\n    for (int i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ",
        "c++": "\n    ```cpp\nint nthUglyNumber(int n) {\n    vector<int> uglyNumbers(n);\n    uglyNumbers[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n\n    for (int i = 1; i < n; i++) {\n        uglyNumbers[i] = min({uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5});\n        if (uglyNumbers[i] == uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] == uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] == uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ",
        "python": "\n    ```python\ndef nthUglyNumber(n: int) -> int:\n    ugly_numbers = [0] * n\n    ugly_numbers[0] = 1\n    i2, i3, i5 = 0, 0, 0\n\n    for i in range(1, n):\n        ugly_numbers[i] = min(ugly_numbers[i2] * 2, ugly_numbers[i3] * 3, ugly_numbers[i5] * 5)\n        if ugly_numbers[i] == ugly_numbers[i2] * 2: i2 += 1\n        if ugly_numbers[i] == ugly_numbers[i3] * 3: i3 += 1\n        if ugly_numbers[i] == ugly_numbers[i5] * 5: i5 += 1\n\n    return ugly_numbers[n - 1]\n\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ",
        "javascript": "\n    ```javascript\nfunction nthUglyNumber(n) {\n    let uglyNumbers = new Array(n);\n    uglyNumbers[0] = 1;\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        uglyNumbers[i] = Math.min(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3), uglyNumbers[i5] * 5);\n        if (uglyNumbers[i] === uglyNumbers[i2] * 2) i2++;\n        if (uglyNumbers[i] === uglyNumbers[i3] * 3) i3++;\n        if (uglyNumbers[i] === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n}\n```\n\n    \n    1. Initialize an array of size n and set the first element to 1 (the first ugly number).\n2. Create three variables (i2, i3, and i5) to keep track of the current index of ugly numbers multiplied by 2, 3, and 5.\n3. Iterate through the array from index 1 to n-1, calculating the next ugly number as the minimum of (uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, and uglyNumbers[i5] * 5).\n4. Update the indices (i2, i3, and i5) based on which ugly number was used in the minimum calculation.\n5. The last element of the array is the nth ugly number.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 10",
                    "output": " 12",
                    "explanation": " \\[1, 2, 3, 4, 5, 6, 8, 9, 10, 12\\] is the sequence of the first 10 ugly numbers."
                },
                {
                    "input": " n = 1",
                    "output": " 1",
                    "explanation": " 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
                }
            ],
            "function_input": [
                {
                    "input": "10",
                    "output": "12"
                },
                {
                    "input": "1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-93",
        "prompt": "An **ugly number** is a positive integer whose prime factors are limited to `2`, `3`, and `5`.\n\nGiven an integer `n`, return _the_ `nth` _**ugly number**_."
    },
    "leetcode-benchmark-94": {
        "id": "leetcode-benchmark-94",
        "title": "Encode and Decode Strings",
        "difficulty": "Medium",
        "content": {
            "problem": "Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n\nstring encode(vector strs) {\n  // ... your code\n  return encoded\\_string;\n}\n\nMachine 2 (receiver) has the function:\n\nvector decode(string s) {\n  //... your code\n  return strs;\n}\n\nSo Machine 1 does:\n\nstring encoded\\_string = encode(strs);\n\nand Machine 2 does:\n\nvector strs2 = decode(encoded\\_string);\n\n`strs2` in Machine 2 should be the same as `strs` in Machine 1.\n\nImplement the `encode` and `decode` methods.\n\nYou are not allowed to solve the problem using any serialize methods (such as `eval`).",
            "examples": [
                "**Example 1:**\n\n**Input:** dummy\\_input = \\[ \"Hello \", \"World \"\\]\n**Output:** \\[ \"Hello \", \"World \"\\]\n**Explanation:**\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString\\[\\] strs = decoder.decode(msg);\n\n",
                "**Example 2:**\n\n**Input:** dummy\\_input = \\[ \" \"\\]\n**Output:** \\[ \" \"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= strs.length <= 200`\n*   `0 <= strs[i].length <= 200`\n*   `strs[i]` contains any possible characters out of `256` valid ASCII characters.\n\n**",
            "follow_up": "Follow up:** Could you write a generalized algorithm to work on any possible set of characters?"
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic String encode(List<String> strs) {\n    StringBuilder encodedString = new StringBuilder();\n    for (String s : strs) {\n        encodedString.append(s.length()).append('#').append(s);\n    }\n    return encodedString.toString();\n}\n\npublic List<String> decode(String s) {\n    List<String> strs = new ArrayList<>();\n    int i = 0;\n    while (i < s.length()) {\n        int delimiterPos = s.indexOf('#', i);\n        int length = Integer.parseInt(s.substring(i, delimiterPos));\n        strs.add(s.substring(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}\n```\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::string encode(const std::vector<std::string>& strs) {\n    std::string encoded_string;\n    for (const auto& s : strs) {\n        encoded_string += std::to_string(s.length()) + \"#\" + s;\n    }\n    return encoded_string;\n}\n\nstd::vector<std::string> decode(const std::string& s) {\n    std::vector<std::string> strs;\n    int i = 0;\n    while (i < s.length()) {\n        int delimiter_pos = s.find('#', i);\n        int length = std::stoi(s.substr(i, delimiter_pos - i));\n        strs.push_back(s.substr(delimiter_pos + 1, length));\n        i = delimiter_pos + length + 1;\n    }\n    return strs;\n}\n```\n\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "python": "\n    ```python\ndef encode(strs):\n    encoded_string = \"\"\n    for s in strs:\n        encoded_string += str(len(s)) + \"#\" + s\n    return encoded_string\n\ndef decode(s):\n    strs = []\n    i = 0\n    while i < len(s):\n        delimiter_pos = s.find('#', i)\n        length = int(s[i:delimiter_pos])\n        strs.append(s[delimiter_pos + 1:delimiter_pos + 1 + length])\n        i = delimiter_pos + 1 + length\n    return strs\n```\n\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "javascript": "\n    ```javascript\nfunction encode(strs) {\n    let encodedString = \"\";\n    for (const s of strs) {\n        encodedString += s.length + \"#\" + s;\n    }\n    return encodedString;\n}\n\nfunction decode(s) {\n    let strs = [];\n    let i = 0;\n    while (i < s.length) {\n        const delimiterPos = s.indexOf('#', i);\n        const length = parseInt(s.slice(i, delimiterPos));\n        strs.push(s.slice(delimiterPos + 1, delimiterPos + 1 + length));\n        i = delimiterPos + 1 + length;\n    }\n    return strs;\n}\n```\n\n    \n    The algorithm concatenates each string with its length and a delimiter (in this case '#'). For example, [\"Hello \", \"World \"] would be encoded into \"6#Hello 6#World \" (6 is the length of both \"Hello \" and \"World \").\n\nWhen decoding, the receiving side searches for the delimiter and extracts the string's length just before each delimiter. It then uses that length to extract the original string extending from the position after the delimiter. It iterates over the received encoded string until all substrings have been extracted.\n\nThis algorithm works with any valid ASCII characters as it uses the length of the string in the encoding and decoding process.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " dummy_input = [ \"Hello \", \"World \"]",
                    "output": " [ \"Hello \", \"World \"]",
                    "explanation": "\nMachine 1:\nCodec encoder = new Codec();\nString msg = encoder.encode(strs);\nMachine 1 ---msg---> Machine 2\n\nMachine 2:\nCodec decoder = new Codec();\nString\\[\\] strs = decoder.decode(msg);"
                },
                {
                    "input": " dummy_input = [ \" \"]",
                    "output": " [ \" \"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[\"Hello\",\"World\"]",
                    "output": "[\"Hello\",\"World\"]"
                },
                {
                    "input": "[\"\"]",
                    "output": "[\"\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-94",
        "prompt": "Design an algorithm to encode **a list of strings** to **a string**. The encoded string is then sent over the network and is decoded back to the original list of strings.\n\nMachine 1 (sender) has the function:\n\nstring encode(vector strs) {\n  // ... your code\n  return encoded\\_string;\n}\n\nMachine 2 (receiver) has the function:\n\nvector decode(string s) {\n  //... your code\n  return strs;\n}\n\nSo Machine 1 does:\n\nstring encoded\\_string = encode(strs);\n\nand Machine 2 does:\n\nvector strs2 = decode(encoded\\_string);\n\n`strs2` in Machine 2 should be the same as `strs` in Machine 1.\n\nImplement the `encode` and `decode` methods.\n\nYou are not allowed to solve the problem using any serialize methods (such as `eval`)."
    },
    "leetcode-benchmark-95": {
        "id": "leetcode-benchmark-95",
        "title": "H-Index",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.",
            "examples": [
                "**Example 1:**\n\n**Input:** citations = \\[3,0,6,1,5\\]\n**Output:** 3\n**Explanation:** \\[3,0,6,1,5\\] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n",
                "**Example 2:**\n\n**Input:** citations = \\[1,3,1\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 5000`\n*   `0 <= citations[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int hIndex(int[] citations) {\n    Arrays.sort(citations);\n    int h = 0;\n    for (int i = citations.length - 1; i >= 0; i--) {\n        int rank = citations.length - i;\n        if (citations[i] >= rank) {\n            h = rank;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "c++": "\n    ```cpp\nint hIndex(vector<int>& citations) {\n    sort(citations.begin(), citations.end(), greater<int>());\n    int h = 0;\n    for (int i = 0; i < citations.size(); ++i) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "python": "\n    ```python\ndef hIndex(citations: List[int]) -> int:\n    citations.sort(reverse=True)\n    h = 0\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n    return h\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "javascript": "\n    ```javascript\nfunction hIndex(citations) {\n    citations.sort((a, b) => b - a);\n    let h = 0;\n    for (let i = 0; i < citations.length; i++) {\n        if (citations[i] >= i + 1) {\n            h = i + 1;\n        } else {\n            break;\n        }\n    }\n    return h;\n}\n```\n    \n    1. First, we sort the citations array in descending order.\n2. Then, we iterate through the sorted array and compare each value with its index + 1 (zero-based index). If citations[i] is greater or equal to (i + 1), we update the h-index with the new value (i + 1). Otherwise, we break the loop since the maximum h-index is achieved.\n3. Finally, we return the h-index.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " citations = [3,0,6,1,5]",
                    "output": " 3",
                    "explanation": " \\[3,0,6,1,5\\] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3."
                },
                {
                    "input": " citations = [1,3,1]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,0,6,1,5]",
                    "output": "3"
                },
                {
                    "input": "[1,3,1]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-95",
        "prompt": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times."
    },
    "leetcode-benchmark-96": {
        "id": "leetcode-benchmark-96",
        "title": "H-Index II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in **ascending order**, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\nYou must write an algorithm that runs in logarithmic time.",
            "examples": [
                "**Example 1:**\n\n**Input:** citations = \\[0,1,3,5,6\\]\n**Output:** 3\n**Explanation:** \\[0,1,3,5,6\\] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n",
                "**Example 2:**\n\n**Input:** citations = \\[1,2,100\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 105`\n*   `0 <= citations[i] <= 1000`\n*   `citations` is sorted in **ascending order**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int hIndex(int[] citations) {\n    int n = citations.length;\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "c++": "\n    ```cpp\nint hIndex(vector<int>& citations) {\n    int n = citations.size();\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (citations[mid] == n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "python": "\n    ```python\ndef hIndex(citations: List[int]) -> int:\n    n = len(citations)\n    left, right = 0, n - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n        if citations[mid] == n - mid:\n            return n - mid\n        elif citations[mid] < n - mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return n - left\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "javascript": "\n    ```javascript\nfunction hIndex(citations) {\n    const n = citations.length;\n    let left = 0, right = n - 1;\n\n    while (left <= right) {\n        const mid = left + Math.floor((right - left) / 2);\n        if (citations[mid] === n - mid) {\n            return n - mid;\n        } else if (citations[mid] < n - mid) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return n - left;\n}\n```\n    \n    The algorithm is based on binary search. The idea is to find the pivot index 'mid' such that there are 'mid' number of elements greater than or equal to 'mid'. Since the array is sorted, we can leverage binary search by comparing the middle element's value to the number of elements on its right side (which can be calculated as 'n - mid'). If the number of elements on the right side is equal to the value at mid, we found the h-index. Otherwise, if the number of elements on the right side is less than the value at mid, we move our search to the left half of the array. If the number of elements is greater than the value at mid, we move our search to the right half of the array. This process ensures logarithmic time complexity as we eliminate half of the array in each iteration. Once our search is complete (right becomes less than left), we return the final h-index as 'n - left'.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " citations = [0,1,3,5,6]",
                    "output": " 3",
                    "explanation": " \\[0,1,3,5,6\\] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3."
                },
                {
                    "input": " citations = [1,2,100]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[0,1,3,5,6]",
                    "output": "3"
                },
                {
                    "input": "[1,2,100]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-96",
        "prompt": "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper and `citations` is sorted in **ascending order**, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\nYou must write an algorithm that runs in logarithmic time."
    },
    "leetcode-benchmark-97": {
        "id": "leetcode-benchmark-97",
        "title": "Paint Fence",
        "difficulty": "Medium",
        "content": {
            "problem": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3, k = 2\n**Output:** 6\n**Explanation:** All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color.\n\n",
                "**Example 2:**\n\n**Input:** n = 1, k = 1\n**Output:** 1\n\n",
                "**Example 3:**\n\n**Input:** n = 7, k = 2\n**Output:** 42"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 50`\n*   `1 <= k <= 105`\n*   The testcases are generated such that the answer is in the range `[0, 231 - 1]` for the given `n` and `k`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "c++": "\n    ```cpp\nint numWays(int n, int k) {\n    if (n == 0) return 0;\n    if (n == 1) return k;\n    int same = k;\n    int different = k * (k - 1);\n    for (int i = 2; i < n; ++i) {\n        int temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "python": "\n    ```python\ndef numWays(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    different = k * (k - 1)\n    for i in range(2, n):\n        temp = different\n        different = (same + different) * (k - 1)\n        same = temp\n    return same + different\n```\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "javascript": "\n    ```javascript\nfunction numWays(n, k) {\n    if (n === 0) return 0;\n    if (n === 1) return k;\n\n    let same = k;\n    let different = k * (k - 1);\n    for (let i = 2; i < n; ++i) {\n        const temp = different;\n        different = (same + different) * (k - 1);\n        same = temp;\n    }\n    return same + different;\n}\n```\n\n    \n    We start with two cases when n equals to 0 or 1.\nIf n equals 0, it means there are no posts, so the result will be 0.\nIf n equals 1, it means there is only one post and k colors to choose from, so the result will be k.\n\nAfter that, we create two variables: `same` and `different`. `same` stores the number of ways to color a fence at position i, such that the color of post i is the same as that of post i-1. `different` stores the number of ways to color the post at position i, such that the color of post i is different from that of post i-1.\n\nFor the first two posts, there are k ways to paint them the same color, and k*(k-1) ways to paint them different colors.\n\nThen we use a loop starting from the third post (i=2) to the last post (i=n-1).\nAt each iteration, we update `different` by adding the previous `same` and `different` values and multiply by (k-1). This is because for different colors, they can either come from previous same colors or different colors, hence the addition. And then we multiply it by (k-1) to consider all possible color combinations excluding the previous color. After that, we update `same` by the previous `different` value, because now we need to consider the current post having the same color as the previous post.\n\nFinally, we return the total number of ways which is the sum of `same` and `different`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3, k = 2",
                    "output": " 6",
                    "explanation": " All the possibilities are shown.\nNote that painting all the posts red or all the posts green is invalid because there cannot be three posts in a row with the same color."
                },
                {
                    "input": " n = 1, k = 1",
                    "output": " 1",
                    "explanation": null
                },
                {
                    "input": " n = 7, k = 2",
                    "output": " 42",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3,2",
                    "output": "6"
                },
                {
                    "input": "1,1",
                    "output": "1"
                },
                {
                    "input": "7,2",
                    "output": "42"
                }
            ]
        },
        "task_id": "leetcode-benchmark-97",
        "prompt": "You are painting a fence of `n` posts with `k` different colors. You must paint the posts following these rules:\n\n*   Every post must be painted **exactly one** color.\n*   There **cannot** be three or more **consecutive** posts with the same color.\n\nGiven the two integers `n` and `k`, return _the **number of ways** you can paint the fence_."
    },
    "leetcode-benchmark-98": {
        "id": "leetcode-benchmark-98",
        "title": "Find the Celebrity",
        "difficulty": "Medium",
        "content": {
            "problem": "Suppose you are at a party with `n` people labeled from `0` to `n - 1` and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know the celebrity, but the celebrity does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: \"Hi, A. Do you know B? \" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` that tells you whether `a` knows `b`. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if they are at the party.\n\nReturn _the celebrity's label if there is a celebrity at the party_. If there is no celebrity, return `-1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** graph = \\[\\[1,1,0\\],\\[0,1,0\\],\\[1,1,1\\]\\]\n**Output:** 1\n**Explanation:** There are three persons labeled with 0, 1 and 2. graph\\[i\\]\\[j\\] = 1 means person i knows person j, otherwise graph\\[i\\]\\[j\\] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.\n\n",
                "**Example 2:**\n\n**Input:** graph = \\[\\[1,0,1\\],\\[1,1,0\\],\\[0,1,1\\]\\]\n**Output:** -1\n**Explanation:** There is no celebrity."
            ],
            "constraints": "**Constraints:**\n\n*   `n == graph.length == graph[i].length`\n*   `2 <= n <= 100`\n*   `graph[i][j]` is `0` or `1`.\n*   `graph[i][i] == 1`\n\n**",
            "follow_up": "Follow up:** If the maximum number of allowed calls to the API `knows` is `3 * n`, could you find a solution without exceeding the maximum number of calls?"
        },
        "java": "\n    ```java\npublic boolean knows(int a, int b);\n\npublic int findCelebrity(int n) {\n    int candidate = 0;\n    for (int i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "c++": "\n    ```cpp\nbool knows(int a, int b);\n\nint findCelebrity(int n) {\n    int candidate = 0;\n    for (int i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n    \n    for (int i = 0; i < n; i++) {\n        if (i != candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "python": "\n    ```python\ndef knows(a: int, b:int) -> bool:\n    pass\n\ndef findCelebrity(n: int) -> int:\n    candidate = 0\n    for i in range(1, n):\n        if knows(candidate, i):\n            candidate = i\n    \n    for i in range(n):\n        if i != candidate and (knows(candidate, i) or not knows(i, candidate)):\n            return -1\n    return candidate\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "javascript": "\n    ```javascript\nfunction knows(a, b) {\n    // Implementation not shown\n}\n\nfunction findCelebrity(n) {\n    let candidate = 0;\n    for (let i = 1; i < n; i++) {\n        if (knows(candidate, i)) {\n            candidate = i;\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (i !== candidate && (knows(candidate, i) || !knows(i, candidate))) {\n            return -1;\n        }\n    }\n    return candidate;\n}\n```\n    \n    First, we select an initial candidate with a value of 0. We loop through the other people and check if the current candidate knows the current person. If the candidate knows this person, we change the candidate to the current person. The idea is to eliminate those who can't be celebrities because they know someone else.\n\nAfter the first loop, we have the final candidate. We now loop through all people to confirm that this candidate is a celebrity by checking that the candidate does not know any other person and that all other people know the candidate.\n\nIf our candidate passes both checks for all people, we have found our celebrity and return their index. If they are not a celebrity, we return -1.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " graph = [[1,1,0],[0,1,0],[1,1,1]]",
                    "output": " 1",
                    "explanation": " There are three persons labeled with 0, 1 and 2. graph\\[i\\]\\[j\\] = 1 means person i knows person j, otherwise graph\\[i\\]\\[j\\] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody."
                },
                {
                    "input": " graph = [[1,0,1],[1,1,0],[0,1,1]]",
                    "output": " -1",
                    "explanation": " There is no celebrity."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1,0],[0,1,0],[1,1,1]]",
                    "output": "1"
                },
                {
                    "input": "[[1,0,1],[1,1,0],[0,1,1]]",
                    "output": "-1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-98",
        "prompt": "Suppose you are at a party with `n` people labeled from `0` to `n - 1` and among them, there may exist one celebrity. The definition of a celebrity is that all the other `n - 1` people know the celebrity, but the celebrity does not know any of them.\n\nNow you want to find out who the celebrity is or verify that there is not one. You are only allowed to ask questions like: \"Hi, A. Do you know B? \" to get information about whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).\n\nYou are given a helper function `bool knows(a, b)` that tells you whether `a` knows `b`. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if they are at the party.\n\nReturn _the celebrity's label if there is a celebrity at the party_. If there is no celebrity, return `-1`."
    },
    "leetcode-benchmark-99": {
        "id": "leetcode-benchmark-99",
        "title": "Perfect Squares",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return _the least number of perfect square numbers that sum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 12\n**Output:** 3\n**Explanation:** 12 = 4 + 4 + 4.\n\n",
                "**Example 2:**\n\n**Input:** n = 13\n**Output:** 2\n**Explanation:** 13 = 4 + 9."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numSquares(int n) {\n    int[] dp = new int[n + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <limits>\n#include <cmath>\n\nint numSquares(int n) {\n    std::vector<int> dp(n + 1, std::numeric_limits<int>::max());\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j * j <= i; j++) {\n            dp[i] = std::min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n    \n    return dp[n];\n}\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ",
        "python": "\n    ```python\ndef numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    \n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n            \n    return dp[n]\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ",
        "javascript": "\n    ```javascript\nfunction numSquares(n) {\n    const dp = new Array(n + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j * j <= i; j++) {\n            dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        }\n    }\n\n    return dp[n];\n}\n```\n    \n    We use Dynamic Programming (DP) to solve this problem. We initialize a 1-dimensional DP array, `dp`, of size `n + 1`, where `n` is given in the problem statement. We set `dp[0]` to `0` because it takes zero square numbers to sum up to zero. We fill the rest of the DP array with a maximum or infinite value, depending on the language used.\n\nWe iterate through the DP array from index `1` to index `n`, inclusive. For each index `i`, we iterate through all perfect square numbers `j * j` smaller than or equal to `i` to find the least number of perfect square numbers that sum up to `i`. We update the `dp` array with the minimum value of the current value at `dp[i]` and `dp[i - j * j] + 1`.\n\nAfter completing the iterations, the value at `dp[n]` represents the least number of perfect squares that sum to `n`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 12",
                    "output": " 3",
                    "explanation": " 12 = 4 + 4 + 4."
                },
                {
                    "input": " n = 13",
                    "output": " 2",
                    "explanation": " 13 = 4 + 9."
                }
            ],
            "function_input": [
                {
                    "input": "12",
                    "output": "3"
                },
                {
                    "input": "13",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-99",
        "prompt": "Given an integer `n`, return _the least number of perfect square numbers that sum to_ `n`.\n\nA **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not."
    },
    "leetcode-benchmark-100": {
        "id": "leetcode-benchmark-100",
        "title": "Wiggle Sort",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.\n\nYou may assume the input array always has a valid answer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,5,2,1,6,4\\]\n**Output:** \\[3,5,1,6,2,4\\]\n**Explanation:** \\[1,6,2,5,3,4\\] is also accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[6,6,5,6,3,8\\]\n**Output:** \\[6,6,5,6,3,8\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 104`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**",
            "follow_up": "Follow up:** Could you solve the problem in `O(n)` time complexity?"
        },
        "java": "\n    ```java\npublic void wiggleSort(int[] nums) {\n    for (int i = 1; i < nums.length; i++) {\n        if (i % 2 == 0 && nums[i] > nums[i-1] || i % 2 == 1 && nums[i] < nums[i-1]) {\n            int temp = nums[i];\n            nums[i] = nums[i-1];\n            nums[i-1] = temp;\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "c++": "\n    ```cpp\nvoid wiggleSort(vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        if (i%2 == 0 && nums[i] > nums[i-1] || i%2 == 1 && nums[i] < nums[i-1]) {\n            swap(nums[i], nums[i-1]);\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "python": "\n    ```python\ndef wiggleSort(nums):\n    for i in range(1, len(nums)):\n        if (i % 2 == 0 and nums[i] > nums[i-1]) or (i % 2 == 1 and nums[i] < nums[i-1]):\n            nums[i], nums[i-1] = nums[i-1], nums[i]\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "javascript": "\n    ```javascript\nfunction wiggleSort(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        if (i % 2 === 0 && nums[i] > nums[i-1] || i % 2 === 1 && nums[i] < nums[i-1]) {\n            [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\n        }\n    }\n}\n```\n    \n    The algorithm iterates through the array from index 1 to the end. It checks whether the current element violates the wiggle condition. If the current index is even and the current element is greater than the previous element, or if the current index is odd and the current element is smaller than the previous element, it swaps the current and the previous element.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,5,2,1,6,4]",
                    "output": " [3,5,1,6,2,4]",
                    "explanation": " \\[1,6,2,5,3,4\\] is also accepted."
                },
                {
                    "input": " nums = [6,6,5,6,3,8]",
                    "output": " [6,6,5,6,3,8]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,5,2,1,6,4]",
                    "output": "[3,5,1,6,2,4]"
                },
                {
                    "input": "[6,6,5,6,3,8]",
                    "output": "[6,6,5,6,3,8]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-100",
        "prompt": "Given an integer array `nums`, reorder it such that `nums[0] <= nums[1] >= nums[2] <= nums[3]...`.\n\nYou may assume the input array always has a valid answer."
    },
    "leetcode-benchmark-101": {
        "id": "leetcode-benchmark-101",
        "title": "Find the Duplicate Number",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in `nums`, return _this repeated number_.\n\nYou must solve the problem **without** modifying the array `nums` and uses only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,3,4,2,2\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[3,1,3,4,2\\]\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `nums.length == n + 1`\n*   `1 <= nums[i] <= n`\n*   All the integers in `nums` appear only **once** except for **precisely one integer** which appears **two or more** times.\n\n**",
            "follow_up": "Follow up:**\n\n*   How can we prove that at least one duplicate number must exist in `nums`?\n*   Can you solve the problem in linear runtime complexity?"
        },
        "java": "\n    ```java\npublic int findDuplicate(int[] nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "c++": "\n    ```cpp\nint findDuplicate(vector<int>& nums) {\n    int slow = nums[0];\n    int fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow != fast);\n\n    slow = nums[0];\n\n    while (slow != fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "python": "\n    ```python\ndef findDuplicate(nums):\n    slow = nums[0]\n    fast = nums[0]\n\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        if slow == fast:\n            break\n\n    slow = nums[0]\n\n    while slow != fast:\n        slow = nums[slow]\n        fast = nums[fast]\n\n    return slow\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "javascript": "\n    ```javascript\nfunction findDuplicate(nums) {\n    let slow = nums[0];\n    let fast = nums[0];\n\n    do {\n        slow = nums[slow];\n        fast = nums[nums[fast]];\n    } while (slow !== fast);\n\n    slow = nums[0];\n\n    while (slow !== fast) {\n        slow = nums[slow];\n        fast = nums[fast];\n    }\n\n    return slow;\n}\n```\n\n    \n    The algorithm is based on Floyd's Tortoise and Hare (Cycle Detection) algorithm. We treat the given array as a linked list where the value at each index is treated as the pointer to the next node in the list.\n\n1. Initialize two pointers, `slow` and `fast`, both initially pointing to the first element of the array.\n2. Loop through the array, updating `slow` to point to the next element and `fast` to point to the element after the next element, until they meet.\n3. Reset `slow` to the first element of the array and keep `fast` at the meeting point.\n4. Loop through the array, updating `slow` and `fast` to point to the next element until they meet again. This meeting point is the duplicate number.\n\nThis algorithm has a time complexity of O(n) and a space complexity of O(1).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,3,4,2,2]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " nums = [3,1,3,4,2]",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,3,4,2,2]",
                    "output": "2"
                },
                {
                    "input": "[3,1,3,4,2]",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-101",
        "prompt": "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.\n\nThere is only **one repeated number** in `nums`, return _this repeated number_.\n\nYou must solve the problem **without** modifying the array `nums` and uses only constant extra space."
    },
    "leetcode-benchmark-102": {
        "id": "leetcode-benchmark-102",
        "title": "Game of Life",
        "difficulty": "Medium",
        "content": {
            "problem": "According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. \"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by over-population.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[0,1,0\\],\\[0,0,1\\],\\[1,1,1\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[1,0,1\\],\\[0,1,1\\],\\[0,1,0\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 25`\n*   `board[i][j]` is `0` or `1`.\n\n**",
            "follow_up": "Follow up:**\n\n*   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n*   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?"
        },
        "java": "\n    ```java\npublic int[][] gameOfLife(int[][] board) {\n    int m = board.length;\n    int n = board[0].length;\n    int[][] result = new int[m][n];\n    int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int liveNeighbors = 0;\n            \n            for (int[] dir : dirs) {\n                int newRow = i + dir[0];\n                int newCol = j + dir[1];\n                \n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {\n                    liveNeighbors++;\n                }\n            }\n            \n            if (board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {\n                result[i][j] = 1;\n            } else if (board[i][j] == 0 && liveNeighbors == 3) {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    return result;\n}\n```\n    \n    Create a new board called `result` with the same dimensions as the input board. For each cell in the input board, count the live neighbors (the 8 neighboring cells). Then apply the following rules:\n1. Any live cell with two or three live neighbors survives.\n2. Any dead cell with exactly three live neighbors becomes a live cell.\n3. All other live cells die and all other dead cells stay dead.\n\nTo count live neighbors, iterate through a predefined list of relative coordinates `dirs` representing the eight neighboring cells. For each neighboring coordinate, check if it is inside the grid, and if the corresponding cell in the input board is live. If so, increment the counter of live neighbors.\n\nFinally, update the cell in the result board using the rules.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nstd::vector<std::vector<int>> gameOfLife(std::vector<std::vector<int>>& board) {\n    int m = board.size();\n    int n = board[0].size();\n    std::vector<std::vector<int>> result(m, std::vector<int>(n, 0));\n    \n    std::vector<std::vector<int>> dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            int liveNeighbors = 0;\n            \n            for (std::vector<int> dir : dirs) {\n                int newRow = i + dir[0];\n                int newCol = j + dir[1];\n                \n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] == 1) {\n                    liveNeighbors++;\n                }\n            }\n            \n            if (board[i][j] == 1 && (liveNeighbors == 2 || liveNeighbors == 3)) {\n                result[i][j] = 1;\n            } else if (board[i][j] == 0 && liveNeighbors == 3) {\n                result[i][j] = 1;\n            }\n        }\n    }\n    \n    return result;\n}\n```\n    \n    Create a new board called `result` with the same dimensions as the input board. For each cell in the input board, count the live neighbors (the 8 neighboring cells). Then apply the following rules:\n1. Any live cell with two or three live neighbors survives.\n2. Any dead cell with exactly three live neighbors becomes a live cell.\n3. All other live cells die and all other dead cells stay dead.\n\nTo count live neighbors, iterate through a predefined list of relative coordinates `dirs` representing the eight neighboring cells. For each neighboring coordinate, check if it is inside the grid, and if the corresponding cell in the input board is live. If so, increment the counter of live neighbors.\n\nFinally, update the cell in the result board using the rules.\n    ",
        "python": "\n    ```python\ndef gameOfLife(board):\n    m, n = len(board), len(board[0])\n    result = [[0] * n for _ in range(m)]\n    dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]]\n    \n    for i in range(m):\n        for j in range(n):\n            liveNeighbors = 0\n            \n            for dir in dirs:\n                newRow = i + dir[0]\n                newCol = j + dir[1]\n                \n                if newRow >= 0 and newRow < m and newCol >= 0 and newCol < n and board[newRow][newCol] == 1:\n                    liveNeighbors += 1\n            \n            if board[i][j] == 1 and (liveNeighbors == 2 or liveNeighbors == 3):\n                result[i][j] = 1\n            elif board[i][j] == 0 and liveNeighbors == 3:\n                result[i][j] = 1\n                \n    return result\n```\n    \n    Create a new board called `result` with the same dimensions as the input board. For each cell in the input board, count the live neighbors (the 8 neighboring cells). Then apply the following rules:\n1. Any live cell with two or three live neighbors survives.\n2. Any dead cell with exactly three live neighbors becomes a live cell.\n3. All other live cells die and all other dead cells stay dead.\n\nTo count live neighbors, iterate through a predefined list of relative coordinates `dirs` representing the eight neighboring cells. For each neighboring coordinate, check if it is inside the grid, and if the corresponding cell in the input board is live. If so, increment the counter of live neighbors.\n\nFinally, update the cell in the result board using the rules.\n    ",
        "javascript": "\n    ```javascript\nfunction gameOfLife(board) {\n    let m = board.length;\n    let n = board[0].length;\n    let result = new Array(m).fill(0).map(() => new Array(n).fill(0));\n    let dirs = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];\n\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            let liveNeighbors = 0;\n\n            for (let dir of dirs) {\n                let newRow = i + dir[0];\n                let newCol = j + dir[1];\n\n                if (newRow >= 0 && newRow < m && newCol >= 0 && newCol < n && board[newRow][newCol] === 1) {\n                    liveNeighbors++;\n                }\n            }\n\n            if (board[i][j] === 1 && (liveNeighbors === 2 || liveNeighbors === 3)) {\n                result[i][j] = 1;\n            } else if (board[i][j] === 0 && liveNeighbors === 3) {\n                result[i][j] = 1;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    Create a new board called `result` with the same dimensions as the input board. For each cell in the input board, count the live neighbors (the 8 neighboring cells). Then apply the following rules:\n1. Any live cell with two or three live neighbors survives.\n2. Any dead cell with exactly three live neighbors becomes a live cell.\n3. All other live cells die and all other dead cells stay dead.\n\nTo count live neighbors, iterate through a predefined list of relative coordinates `dirs` representing the eight neighboring cells. For each neighboring coordinate, check if it is inside the grid, and if the corresponding cell in the input board is live. If so, increment the counter of live neighbors.\n\nFinally, update the cell in the result board using the rules.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
                    "output": " [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
                    "explanation": null
                },
                {
                    "input": " board = [[1,1],[1,0]]",
                    "output": " [[1,1],[1,1]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,1,0],[0,0,1],[1,1,1],[0,0,0]]",
                    "output": "[[0,0,0],[1,0,1],[0,1,1],[0,1,0]]"
                },
                {
                    "input": "[[1,1],[1,0]]",
                    "output": "[[1,1],[1,1]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-102",
        "prompt": "According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. \"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by over-population.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_."
    },
    "leetcode-benchmark-103": {
        "id": "leetcode-benchmark-103",
        "title": "Word Pattern II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `pattern` and a string `s`, return `true` _if_ `s` _**matches** the_ `pattern`_._\n\nA string `s` **matches** a `pattern` if there is some **bijective mapping** of single characters to strings such that if each character in `pattern` is replaced by the string it maps to, then the resulting string is `s`. A **bijective mapping** means that no two characters map to the same string, and no character maps to two different strings.",
            "examples": [
                "**Example 1:**\n\n**Input:** pattern =  \"abab \", s =  \"redblueredblue \"\n**Output:** true\n**Explanation:** One possible mapping is as follows:\n'a' ->  \"red \"\n'b' ->  \"blue \"\n\n",
                "**Example 2:**\n\n**Input:** pattern =  \"aaaa \", s =  \"asdasdasdasd \"\n**Output:** true\n**Explanation:** One possible mapping is as follows:\n'a' ->  \"asd \"\n\n",
                "**Example 3:**\n\n**Input:** pattern =  \"aabb \", s =  \"xyzabcxzyabc \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= pattern.length, s.length <= 20`\n*   `pattern` and `s` consist of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean wordPatternMatch(String pattern, String s) {\n    Map<Character, String> patternMap = new HashMap<>();\n    Set<String> words = new HashSet<>();\n    return backtrack(pattern, 0, s, 0, patternMap, words);\n}\n\nprivate boolean backtrack(String pattern, int pIndex, String s, int sIndex, Map<Character, String> patternMap, Set<String> words) {\n    if (pIndex == pattern.length() && sIndex == s.length()) return true;\n    if (pIndex == pattern.length() || sIndex == s.length()) return false;\n\n    char p = pattern.charAt(pIndex);\n    if (patternMap.containsKey(p)) {\n        String word = patternMap.get(p);\n        if (!s.startsWith(word, sIndex)) return false;\n        return backtrack(pattern, pIndex + 1, s, sIndex + word.length(), patternMap, words);\n    } else {\n        for (int length = 1; length <= s.length() - sIndex; length++) {\n            String word = s.substring(sIndex, sIndex + length);\n            if (words.contains(word)) continue;\n            patternMap.put(p, word);\n            words.add(word);\n            if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;\n            patternMap.remove(p);\n            words.remove(word);\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "c++": "\n    ```cpp\nbool wordPatternMatch(string pattern, string s) {\n    unordered_map<char, string> pattern_map;\n    unordered_set<string> words;\n    return backtrack(pattern, 0, s, 0, pattern_map, words);\n}\n\nbool backtrack(string& pattern, int p_index, string& s, int s_index, unordered_map<char, string>& pattern_map, unordered_set<string>& words) {\n    if (p_index == pattern.size() && s_index == s.size()) return true;\n    if (p_index == pattern.size() || s_index == s.size()) return false;\n\n    char p = pattern[p_index];\n    if (pattern_map.count(p)) {\n        string word = pattern_map[p];\n        if (s.substr(s_index, word.size()) != word) return false;\n        return backtrack(pattern, p_index + 1, s, s_index + word.size(), pattern_map, words);\n    } else {\n        for (int length = 1; length <= s.size() - s_index; length++) {\n            string word = s.substr(s_index, length);\n            if (words.count(word)) continue;\n            pattern_map[p] = word;\n            words.insert(word);\n            if (backtrack(pattern, p_index + 1, s, s_index + length, pattern_map, words)) return true;\n            pattern_map.erase(p);\n            words.erase(word);\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "python": "\n    ```python\ndef wordPatternMatch(pattern: str, s: str) -> bool:\n    def backtrack(p_index, s_index, pattern_map, words):\n        if p_index == len(pattern) and s_index == len(s):\n            return True\n        if p_index == len(pattern) or s_index == len(s):\n            return False\n\n        p = pattern[p_index]\n        if p in pattern_map:\n            word = pattern_map[p]\n            if not s.startswith(word, s_index):\n                return False\n            return backtrack(p_index + 1, s_index + len(word), pattern_map, words)\n        else:\n            for length in range(1, len(s) - s_index + 1):\n                word = s[s_index : s_index + length]\n                if word in words:\n                    continue\n                pattern_map[p] = word\n                words.add(word)\n                if backtrack(p_index + 1, s_index + length, pattern_map, words):\n                    return True\n                pattern_map.pop(p)\n                words.remove(word)\n        return False\n\n    return backtrack(0, 0, {}, set())\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "javascript": "\n    ```javascript\nvar wordPatternMatch = function(pattern, s) {\n    const patternMap = new Map();\n    const words = new Set();\n    return backtrack(pattern, 0, s, 0, patternMap, words);\n    \n    function backtrack(pattern, pIndex, s, sIndex, patternMap, words) {\n        if (pIndex == pattern.length && sIndex == s.length) return true;\n        if (pIndex == pattern.length || sIndex == s.length) return false;\n\n        let p = pattern[pIndex];\n        if (patternMap.has(p)) {\n            let word = patternMap.get(p);\n            if (s.slice(sIndex, sIndex + word.length) !== word) return false;\n            return backtrack(pattern, pIndex + 1, s, sIndex + word.length, patternMap, words);\n        } else {\n            for (let length = 1; length <= s.length - sIndex; length++) {\n                let word = s.substr(sIndex, length);\n                if (words.has(word)) continue;\n                patternMap.set(p, word);\n                words.add(word);\n                if (backtrack(pattern, pIndex + 1, s, sIndex + length, patternMap, words)) return true;\n                patternMap.delete(p);\n                words.delete(word);\n            }\n        }\n        return false;\n    }\n};\n```\n    \n    The algorithm uses a recursive depth-fisrt search approach (backtracking) for solving the string matching problem. For each character in the `pattern`, it'll check if the character exists in the `pattern_map`. If it exists and it maps to the string at the current position in `s`, it'll continue checking the remaining patterns and characters in `s`. If it doesn't exist, the function will try to create the mapping of the single character to the substring in `s`. The function will return true if a mapping is found that matches the pattern, else it'll return false. The used mapping is restored (backtracked) in each iteration.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " pattern =  \"abab \", s =  \"redblueredblue \"",
                    "output": " True",
                    "explanation": " One possible mapping is as follows:\n'a' ->  \"red \"\n'b' ->  \"blue \""
                },
                {
                    "input": " pattern =  \"aaaa \", s =  \"asdasdasdasd \"",
                    "output": " True",
                    "explanation": " One possible mapping is as follows:\n'a' ->  \"asd \""
                },
                {
                    "input": " pattern =  \"aabb \", s =  \"xyzabcxzyabc \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"abab\",\"redblueredblue\"",
                    "output": "True"
                },
                {
                    "input": "\"aaaa\",\"asdasdasdasd\"",
                    "output": "True"
                },
                {
                    "input": "\"aabb\",\"xyzabcxzyabc\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-103",
        "prompt": "Given a `pattern` and a string `s`, return `true` _if_ `s` _**matches** the_ `pattern`_._\n\nA string `s` **matches** a `pattern` if there is some **bijective mapping** of single characters to strings such that if each character in `pattern` is replaced by the string it maps to, then the resulting string is `s`. A **bijective mapping** means that no two characters map to the same string, and no character maps to two different strings."
    },
    "leetcode-benchmark-104": {
        "id": "leetcode-benchmark-104",
        "title": "Flip Game II",
        "difficulty": "Medium",
        "content": {
            "problem": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn `true` _if the starting player can **guarantee a win**_, and `false` otherwise.",
            "examples": [
                "**Example 1:**\n\n**Input:** currentState =  \"++++ \"\n**Output:** true\n**Explanation:** The starting player can guarantee a win by flipping the middle  \"++ \" to become  \"+--+ \".\n\n",
                "**Example 2:**\n\n**Input:** currentState =  \"+ \"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= currentState.length <= 60`\n*   `currentState[i]` is either `'+'` or `'-'`.\n\n**",
            "follow_up": "Follow up:** Derive your algorithm's runtime complexity."
        },
        "java": "\n    ```java\npublic boolean canWin(String currentState) {\n    for (int i = 0; i < currentState.length() - 1; ++i) {\n        if (currentState.charAt(i) == '+' && currentState.charAt(i + 1) == '+') {\n            String temp = currentState.substring(0, i) + \"--\" + currentState.substring(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "c++": "\n    ```cpp\nbool canWin(string currentState) {\n    for (int i = 0; i < currentState.size() - 1; ++i) {\n        if (currentState[i] == '+' && currentState[i + 1] == '+') {\n            currentState[i] = '-';\n            currentState[i + 1] = '-';\n            bool opponentWins = canWin(currentState);\n            currentState[i] = '+';\n            currentState[i + 1] = '+';\n            if (!opponentWins) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "python": "\n    ```python\ndef canWin(currentState: str) -> bool:\n    for i in range(len(currentState) - 1):\n        if currentState[i] == '+' and currentState[i + 1] == '+':\n            temp = currentState[:i] + \"--\" + currentState[i + 2:]\n            if not canWin(temp):\n                return True\n    return False\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "javascript": "\n    ```javascript\nfunction canWin(currentState) {\n    for (let i = 0; i < currentState.length - 1; ++i) {\n        if (currentState[i] === '+' && currentState[i + 1] === '+') {\n            let temp = currentState.slice(0, i) + \"--\" + currentState.slice(i + 2);\n            if (!canWin(temp)) return true;\n        }\n    }\n    return false;\n}\n```\n    \n    The algorithm uses a recursive approach to check for all possible game states starting from the given `currentState`. At each step, the code iterates through the string to find two consecutive '+' characters. If found, it flips the two consecutive '+' to '--' and calls the function recursively with this newState to check if the opponent wins or not. If the opponent doesn't win, the function returns true as it guarantees a win for the starting player. If no such situation occurs, the function returns false.\n\nThe runtime complexity of this algorithm is O(n * 2^n) where n is the length of the input string. The reason for this complexity is that, in the worst-case, we may have to explore every possible state of the game tree, and there are 2^n possible game states.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " currentState =  \"++++ \"",
                    "output": " True",
                    "explanation": " The starting player can guarantee a win by flipping the middle  \"++ \" to become  \"+--+ \"."
                },
                {
                    "input": " currentState =  \"+ \"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"++++\"",
                    "output": "True"
                },
                {
                    "input": "\"+\"",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-104",
        "prompt": "You are playing a Flip Game with your friend.\n\nYou are given a string `currentState` that contains only `'+'` and `'-'`. You and your friend take turns to flip **two consecutive** `\"++ \"` into `\"-- \"`. The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\nReturn `true` _if the starting player can **guarantee a win**_, and `false` otherwise."
    },
    "leetcode-benchmark-105": {
        "id": "leetcode-benchmark-105",
        "title": "Bulls and Cows",
        "difficulty": "Medium",
        "content": {
            "problem": "You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n*   The number of \"bulls \", which are digits in the guess that are in the correct position.\n*   The number of \"cows \", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.\n\nThe hint should be formatted as `\"xAyB \"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.",
            "examples": [
                "**Example 1:**\n\n**Input:** secret =  \"1807 \", guess =  \"7810 \"\n**Output:**  \"1A3B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1807 \"\n  |\n \"7810 \"\n\n",
                "**Example 2:**\n\n**Input:** secret =  \"1123 \", guess =  \"0111 \"\n**Output:**  \"1A1B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1123 \"         \"1123 \"\n  |      or     |\n \"0111 \"         \"0111 \"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= secret.length, guess.length <= 1000`\n*   `secret.length == guess.length`\n*   `secret` and `guess` consist of digits only.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String getHint(String secret, String guess) {\n    int bulls = 0, cows = 0;\n    int[] secretCount = new int[10];\n    int[] guessCount = new int[10];\n\n    for (int i = 0; i < secret.length(); i++) {\n        if (secret.charAt(i) == guess.charAt(i)) {\n            bulls++;\n        } else {\n            secretCount[secret.charAt(i) - '0']++;\n            guessCount[guess.charAt(i) - '0']++;\n        }\n    }\n\n    for (int i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return bulls + \"A\" + cows + \"B\";\n}\n```\n\n    \n    The algorithm first initializes the counts for bulls and cows to be 0. We also create two arrays called secret_count and guess_count to store the count of each digit from '0' to '9' in the secret and guess strings.\n\nWe then loop through both the secret and the guess strings. For each position, if the digits are the same in both strings (i.e., secret[i] == guess[i]), we increase the bulls count. If not, we increment the corresponding count for the secret and guess digits.\n\nAfter iterating through the strings, we loop through the count arrays and add the minimum of the counts of each digit in secret_count and guess_count to the cows count.\n\nFinally, we return the result in the \"xAyB\" format by concatenating the values of bulls and cows.\n    ",
        "c++": "\n    ```cpp\nstd::string getHint(std::string secret, std::string guess) {\n    int bulls = 0, cows = 0;\n    std::vector<int> secret_count(10, 0);\n    std::vector<int> guess_count(10, 0);\n\n    for (size_t i = 0; i < secret.length(); i++) {\n        if (secret[i] == guess[i]) {\n            bulls++;\n        } else {\n            secret_count[secret[i] - '0']++;\n            guess_count[guess[i] - '0']++;\n        }\n    }\n\n    for (size_t i = 0; i < 10; i++) {\n        cows += std::min(secret_count[i], guess_count[i]);\n    }\n\n    return std::to_string(bulls) + \"A\" + std::to_string(cows) + \"B\";\n}\n```\n\n    \n    The algorithm first initializes the counts for bulls and cows to be 0. We also create two arrays called secret_count and guess_count to store the count of each digit from '0' to '9' in the secret and guess strings.\n\nWe then loop through both the secret and the guess strings. For each position, if the digits are the same in both strings (i.e., secret[i] == guess[i]), we increase the bulls count. If not, we increment the corresponding count for the secret and guess digits.\n\nAfter iterating through the strings, we loop through the count arrays and add the minimum of the counts of each digit in secret_count and guess_count to the cows count.\n\nFinally, we return the result in the \"xAyB\" format by concatenating the values of bulls and cows.\n    ",
        "python": "\n    ```python\ndef get_hint(secret: str, guess: str) -> str:\n    bulls = cows = 0\n    secret_count = [0] * 10\n    guess_count = [0] * 10\n\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            bulls += 1\n        else:\n            secret_count[int(secret[i])] += 1\n            guess_count[int(guess[i])] += 1\n   \n    for i in range(10):\n        cows += min(secret_count[i], guess_count[i])\n    \n    return f\"{bulls}A{cows}B\"\n```\n\n    \n    The algorithm first initializes the counts for bulls and cows to be 0. We also create two arrays called secret_count and guess_count to store the count of each digit from '0' to '9' in the secret and guess strings.\n\nWe then loop through both the secret and the guess strings. For each position, if the digits are the same in both strings (i.e., secret[i] == guess[i]), we increase the bulls count. If not, we increment the corresponding count for the secret and guess digits.\n\nAfter iterating through the strings, we loop through the count arrays and add the minimum of the counts of each digit in secret_count and guess_count to the cows count.\n\nFinally, we return the result in the \"xAyB\" format by concatenating the values of bulls and cows.\n    ",
        "javascript": "\n    ```javascript\nfunction getHint(secret, guess) {\n    let bulls = 0, cows = 0;\n    let secretCount = Array(10).fill(0);\n    let guessCount = Array(10).fill(0);\n\n    for (let i = 0; i < secret.length; i++) {\n        if (secret[i] === guess[i]) {\n            bulls++;\n        } else {\n            secretCount[parseInt(secret[i])]++;\n            guessCount[parseInt(guess[i])]++;\n        }\n    }\n\n    for (let i = 0; i < 10; i++) {\n        cows += Math.min(secretCount[i], guessCount[i]);\n    }\n\n    return `${bulls}A${cows}B`;\n}\n```\n\n    \n    The algorithm first initializes the counts for bulls and cows to be 0. We also create two arrays called secret_count and guess_count to store the count of each digit from '0' to '9' in the secret and guess strings.\n\nWe then loop through both the secret and the guess strings. For each position, if the digits are the same in both strings (i.e., secret[i] == guess[i]), we increase the bulls count. If not, we increment the corresponding count for the secret and guess digits.\n\nAfter iterating through the strings, we loop through the count arrays and add the minimum of the counts of each digit in secret_count and guess_count to the cows count.\n\nFinally, we return the result in the \"xAyB\" format by concatenating the values of bulls and cows.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " secret =  \"1807 \", guess =  \"7810 \"",
                    "output": "  \"1A3B \"",
                    "explanation": " Bulls are connected with a '|' and cows are underlined:\n \"1807 \"\n  |\n \"7810 \""
                },
                {
                    "input": " secret =  \"1123 \", guess =  \"0111 \"",
                    "output": "  \"1A1B \"",
                    "explanation": " Bulls are connected with a '|' and cows are underlined:\n \"1123 \"         \"1123 \"\n  |      or     |\n \"0111 \"         \"0111 \"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull."
                }
            ],
            "function_input": [
                {
                    "input": "\"1807\",\"7810\"",
                    "output": "\"1A3B\""
                },
                {
                    "input": "\"1123\",\"0111\"",
                    "output": "\"1A1B\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-105",
        "prompt": "You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n*   The number of \"bulls \", which are digits in the guess that are in the correct position.\n*   The number of \"cows \", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.\n\nThe hint should be formatted as `\"xAyB \"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits."
    },
    "leetcode-benchmark-106": {
        "id": "leetcode-benchmark-106",
        "title": "Longest Increasing Subsequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[10,9,2,5,3,7,101,18\\]\n**Output:** 4\n**Explanation:** The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[0,1,0,3,2,3\\]\n**Output:** 4\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[7,7,7,7,7,7,7\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2500`\n*   `-104 <= nums[i] <= 104`\n\n**",
            "follow_up": "Follow up:** Can you come up with an algorithm that runs in `O(n log(n))` time complexity?"
        },
        "java": "\n    ```java\npublic int lengthOfLIS(int[] nums) {\n    int[] dp = new int[nums.length];\n    int max_length = 1;\n    Arrays.fill(dp, 1);\n    for (int i = 1; i < nums.length; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "c++": "\n    ```cpp\nint lengthOfLIS(vector<int>& nums) {\n    vector<int> dp(nums.size(), 1);\n    int max_length = 1;\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "python": "\n    ```python\ndef lengthOfLIS(nums):\n    dp = [1] * len(nums)\n    max_length = 1\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n        max_length = max(max_length, dp[i])\n    return max_length\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "javascript": "\n    ```javascript\nfunction lengthOfLIS(nums) {\n    const dp = new Array(nums.length).fill(1);\n    let max_length = 1;\n    for (let i = 1; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max_length = Math.max(max_length, dp[i]);\n    }\n    return max_length;\n}\n```\n    \n    The algorithm employs dynamic programming to solve the problem. The algorithm initializes an array `dp` of the same length as the input array `nums`, and initializes all its elements with the value 1, indicating that at least a single element can be part of the longest increasing subsequence.\n\nThen, it employs a nested loop to iterate over the input array from the second element onwards. In the inner loop, we compare each element from the 0th index to `i-1` with the current element at `i`. If the current element is greater than the previous element, we update the `dp[i]` value by taking the maximum of the current `dp[i]` value and the `dp[j]` value of the previous element + 1, which indicates the length of the increasing subsequence.\n\nFinally, we update the max_length variable after each outer loop by taking its maximum from the array `dp`. After completing the iterations, we return the length of the longest increasing subsequence.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [10,9,2,5,3,7,101,18]",
                    "output": " 4",
                    "explanation": " The longest increasing subsequence is \\[2,3,7,101\\], therefore the length is 4."
                },
                {
                    "input": " nums = [0,1,0,3,2,3]",
                    "output": " 4",
                    "explanation": null
                },
                {
                    "input": " nums = [7,7,7,7,7,7,7]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[10,9,2,5,3,7,101,18]",
                    "output": "4"
                },
                {
                    "input": "[0,1,0,3,2,3]",
                    "output": "4"
                },
                {
                    "input": "[7,7,7,7,7,7,7]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-106",
        "prompt": "Given an integer array `nums`, return _the length of the longest **strictly increasing**_ _**subsequence**_."
    },
    "leetcode-benchmark-107": {
        "id": "leetcode-benchmark-107",
        "title": "Additive Number",
        "difficulty": "Medium",
        "content": {
            "problem": "An **additive number** is a string whose digits can form an **additive sequence**.\n\nA valid **additive sequence** should contain **at least** three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n\nGiven a string containing only digits, return `true` if it is an **additive number** or `false` otherwise.\n\n**Note:** Numbers in the additive sequence **cannot** have leading zeros, so sequence `1, 2, 03` or `1, 02, 3` is invalid.",
            "examples": [
                "**Example 1:**\n\n**Input:**  \"112358 \"\n**Output:** true\n**Explanation:** \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n\n",
                "**Example 2:**\n\n**Input:**  \"199100199 \"\n**Output:** true\n**Explanation:** \nThe additive sequence is: 1, 99, 100, 199. \n1 + 99 = 100, 99 + 100 = 199"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= num.length <= 35`\n*   `num` consists only of digits.\n\n**",
            "follow_up": "Follow up:** How would you handle overflow for very large input integers?"
        },
        "java": "\n    ```java\npublic boolean isAdditiveNumber(String num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substring(0, i), num.substring(i, i + j), num.substring(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nprivate boolean check(String num1, String num2, String remaining) {\n    if ((num1.length() > 1 && num1.charAt(0) == '0') || (num2.length() > 1 && num2.charAt(0) == '0')) {\n        return false;\n    }\n    String sum = add(num1, num2);\n    if (remaining.equals(sum)) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.substring(sum.length()));\n}\n\nprivate String add(String num1, String num2) {\n    int carry = 0;\n    StringBuilder result = new StringBuilder();\n    for (int i = num1.length() - 1, j = num2.length() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1.charAt(i) - '0' : 0;\n        int n2 = j >= 0 ? num2.charAt(j) - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.append((char) ('0' + sum % 10));\n    }\n    return result.reverse().toString();\n}\n```\n    \n    1. Iterate through all possible positions to split the string into two non-empty numbers num1 and num2.\n2. Check if num1 and num2 are valid, i.e., not having leading zeros for multiple digits numbers.\n3. Calculate the sum of num1 and num2.\n4. Check if the remaining part of the string starts with the sum. If not, return false.\n5. If the remaining string is exactly the sum, return true; otherwise, repeat the process with num2, sum, and the remaining string.\n6. If it's not possible to find a valid combination, return false.\n    ",
        "c++": "\n    ```cpp\nbool isAdditiveNumber(std::string num) {\n    for (int i = 1; i <= num.length() / 2; i++) {\n        for (int j = 1; j <= (num.length() - i) / 2; j++) {\n            if (check(num.substr(0, i), num.substr(i, j), num.substr(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nbool check(std::string num1, std::string num2, std::string remaining) {\n    if ((num1.size() > 1 && num1[0] == '0') || (num2.size() > 1 && num2[0] == '0')) {\n        return false;\n    }\n    std::string sum = add(num1, num2);\n    if (remaining == sum) {\n        return true;\n    }\n    if (remaining.substr(0, sum.size()) != sum) {\n        return false;\n    }\n    return check(num2, sum, remaining.substr(sum.size()));\n}\n\nstd::string add(std::string num1, std::string num2) {\n    int carry = 0;\n    std::string result;\n    for (int i = num1.size() - 1, j = num2.size() - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        int n1 = i >= 0 ? num1[i] - '0' : 0;\n        int n2 = j >= 0 ? num2[j] - '0' : 0;\n        int sum = n1 + n2 + carry;\n        carry = sum / 10;\n        result.push_back('0' + sum % 10);\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```\n    \n    1. Iterate through all possible positions to split the string into two non-empty numbers num1 and num2.\n2. Check if num1 and num2 are valid, i.e., not having leading zeros for multiple digits numbers.\n3. Calculate the sum of num1 and num2.\n4. Check if the remaining part of the string starts with the sum. If not, return false.\n5. If the remaining string is exactly the sum, return true; otherwise, repeat the process with num2, sum, and the remaining string.\n6. If it's not possible to find a valid combination, return false.\n    ",
        "python": "\n    ```python\ndef isAdditiveNumber(num):\n    for i in range(1, len(num) // 2 + 1):\n        for j in range(1, (len(num) - i) // 2 + 1):\n            if check(num[:i], num[i:i+j], num[i+j:]):\n                return True\n    return False\n\ndef check(num1, num2, remaining):\n    if (len(num1) > 1 and num1[0] == '0') or (len(num2) > 1 and num2[0] == '0'):\n        return False\n    _sum = add(num1, num2)\n    if remaining == _sum:\n        return True\n    if not remaining.startswith(_sum):\n        return False\n    return check(num2, _sum, remaining[len(_sum):])\n\ndef add(num1, num2):\n    carry, result = 0, []\n    i, j = len(num1) - 1, len(num2) - 1\n    while i >= 0 or j >= 0 or carry > 0:\n        n1 = int(num1[i]) if i >= 0 else 0\n        n2 = int(num2[j]) if j >= 0 else 0\n        _sum = n1 + n2 + carry\n        carry = _sum // 10\n        result.append(str(_sum % 10))\n        i, j = i - 1, j - 1\n    return ''.join(result[::-1])\n```\n    \n    1. Iterate through all possible positions to split the string into two non-empty numbers num1 and num2.\n2. Check if num1 and num2 are valid, i.e., not having leading zeros for multiple digits numbers.\n3. Calculate the sum of num1 and num2.\n4. Check if the remaining part of the string starts with the sum. If not, return false.\n5. If the remaining string is exactly the sum, return true; otherwise, repeat the process with num2, sum, and the remaining string.\n6. If it's not possible to find a valid combination, return false.\n    ",
        "javascript": "\n    ```javascript\nfunction isAdditiveNumber(num) {\n    for (let i = 1; i <= num.length / 2; i++) {\n        for (let j = 1; j <= (num.length - i) / 2; j++) {\n            if (check(num.slice(0, i), num.slice(i, i + j), num.slice(i + j))) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction check(num1, num2, remaining) {\n    if ((num1.length > 1 && num1[0] === '0') || (num2.length > 1 && num2[0] === '0')) {\n        return false;\n    }\n    let sum = add(num1, num2);\n    if (remaining === sum) {\n        return true;\n    }\n    if (!remaining.startsWith(sum)) {\n        return false;\n    }\n    return check(num2, sum, remaining.slice(sum.length));\n}\n\nfunction add(num1, num2) {\n    let carry = 0;\n    let result = '';\n    for (let i = num1.length - 1, j = num2.length - 1;\n         i >= 0 || j >= 0 || carry > 0; i--, j--) {\n        let n1 = i >= 0 ? Number(num1[i]) : 0;\n        let n2 = j >= 0 ? Number(num2[j]) : 0;\n        let sum = n1 + n2 + carry;\n        carry = Math.floor(sum / 10);\n        result = (sum % 10).toString() + result;\n    }\n    return result;\n}\n```\n    \n    1. Iterate through all possible positions to split the string into two non-empty numbers num1 and num2.\n2. Check if num1 and num2 are valid, i.e., not having leading zeros for multiple digits numbers.\n3. Calculate the sum of num1 and num2.\n4. Check if the remaining part of the string starts with the sum. If not, return false.\n5. If the remaining string is exactly the sum, return true; otherwise, repeat the process with num2, sum, and the remaining string.\n6. If it's not possible to find a valid combination, return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": "  \"112358 \"",
                    "output": " True",
                    "explanation": " \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8"
                },
                {
                    "input": "  \"199100199 \"",
                    "output": " True",
                    "explanation": " \nThe additive sequence is: 1, 99, 100, 199. \n1 + 99 = 100, 99 + 100 = 199"
                }
            ],
            "function_input": [
                {
                    "input": "",
                    "output": "True"
                },
                {
                    "input": "",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-107",
        "prompt": "An **additive number** is a string whose digits can form an **additive sequence**.\n\nA valid **additive sequence** should contain **at least** three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n\nGiven a string containing only digits, return `true` if it is an **additive number** or `false` otherwise.\n\n**Note:** Numbers in the additive sequence **cannot** have leading zeros, so sequence `1, 2, 03` or `1, 02, 3` is invalid."
    },
    "leetcode-benchmark-108": {
        "id": "leetcode-benchmark-108",
        "title": "Best Time to Buy and Sell Stock with Cooldown",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
            "examples": [
                "**Example 1:**\n\n**Input:** prices = \\[1,2,3,0,2\\]\n**Output:** 3\n**Explanation:** transactions = \\[buy, sell, cooldown, buy, sell\\]\n\n",
                "**Example 2:**\n\n**Input:** prices = \\[1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= prices.length <= 5000`\n*   `0 <= prices[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxProfit(int[] prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "c++": "\n    ```cpp\nint maxProfit(vector<int>& prices) {\n    int profit = 0;\n    for (int i = 1; i < prices.size(); ++i) {\n        profit += max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "python": "\n    ```python\ndef maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        profit += max(prices[i] - prices[i - 1], 0)\n    return profit\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProfit(prices) {\n    let profit = 0;\n    for (let i = 1; i < prices.length; i++) {\n        profit += Math.max(prices[i] - prices[i - 1], 0);\n    }\n    return profit;\n}\n```\n    \n    The algorithm iterates through the given `prices` array. For each day, starting from day 1 (index 1), it calculates the difference between the current day's price and the previous day's price. If the difference is positive, it means there is profit to be made by selling on this day after buying on the previous day. The profitable difference is then added to the total profit. This is done for all consecutive days in the array. By the end of the iteration, the total accumulated profit will be the maximum possible, considering the constraints given in the problem statement. No additional transactions are needed because selling and buying again at the same price does not change the profit.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " prices = [1,2,3,0,2]",
                    "output": " 3",
                    "explanation": " transactions = \\[buy, sell, cooldown, buy, sell\\]"
                },
                {
                    "input": " prices = [1]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,0,2]",
                    "output": "3"
                },
                {
                    "input": "[1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-108",
        "prompt": "You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\n*   After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\n**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again)."
    },
    "leetcode-benchmark-109": {
        "id": "leetcode-benchmark-109",
        "title": "Sparse Matrix Multiplication",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible.",
            "examples": [
                "**Example 1:**\n\n**Input:** mat1 = \\[\\[1,0,0\\],\\[-1,0,3\\]\\], mat2 = \\[\\[7,0,0\\],\\[0,0,0\\],\\[0,0,1\\]\\]\n**Output:** \\[\\[7,0,0\\],\\[-7,0,3\\]\\]\n\n",
                "**Example 2:**\n\n**Input:** mat1 = \\[\\[0\\]\\], mat2 = \\[\\[0\\]\\]\n**Output:** \\[\\[0\\]\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `m == mat1.length`\n*   `k == mat1[i].length == mat2.length`\n*   `n == mat2[i].length`\n*   `1 <= m, n, k <= 100`\n*   `-100 <= mat1[i][j], mat2[i][j] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[][] multiply(int[][] mat1, int[][] mat2) {\n    int m = mat1.length;\n    int k = mat1[0].length;\n    int n = mat2[0].length;\n    int[][] result = new int[m][n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<vector<int>> multiply(vector<vector<int>>& mat1, vector<vector<int>>& mat2) {\n    int m = mat1.size();\n    int k = mat1[0].size();\n    int n = mat2[0].size();\n    vector<vector<int>> result(m, vector<int>(n, 0));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < k; j++) {\n            if (mat1[i][j] != 0) {\n                for (int l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "python": "\n    ```python\ndef multiply(mat1, mat2):\n    m, k, n = len(mat1), len(mat1[0]), len(mat2[0])\n    result = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(k):\n            if mat1[i][j] != 0:\n                for l in range(n):\n                    result[i][l] += mat1[i][j] * mat2[j][l]\n    return result\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "javascript": "\n    ```javascript\nfunction multiply(mat1, mat2) {\n    const m = mat1.length;\n    const k = mat1[0].length;\n    const n = mat2[0].length;\n    const result = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < k; j++) {\n            if (mat1[i][j] !== 0) {\n                for (let l = 0; l < n; l++) {\n                    result[i][l] += mat1[i][j] * mat2[j][l];\n                }\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    Iterate through each element of mat1, and if the element is not zero, perform the corresponding row-column multiplication and update the result in mat3. This avoids unnecessary multiplications by zero during the process.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " mat1 = [[1,0,0],[-1,0,3]], mat2 = [[7,0,0],[0,0,0],[0,0,1]]",
                    "output": " [[7,0,0],[-7,0,3]]",
                    "explanation": null
                },
                {
                    "input": " mat1 = [[0]], mat2 = [[0]]",
                    "output": " [[0]]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[1,0,0],[-1,0,3]],[[7,0,0],[0,0,0],[0,0,1]]",
                    "output": "[[7,0,0],[-7,0,3]]"
                },
                {
                    "input": "[[0]],[[0]]",
                    "output": "[[0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-109",
        "prompt": "Given two [sparse matrices](https://en.wikipedia.org/wiki/Sparse_matrix) `mat1` of size `m x k` and `mat2` of size `k x n`, return the result of `mat1 x mat2`. You may assume that multiplication is always possible."
    },
    "leetcode-benchmark-110": {
        "id": "leetcode-benchmark-110",
        "title": "Super Ugly Number",
        "difficulty": "Medium",
        "content": {
            "problem": "A **super ugly number** is a positive integer whose prime factors are in the array `primes`.\n\nGiven an integer `n` and an array of integers `primes`, return _the_ `nth` _**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit** signed integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 12, primes = \\[2,7,13,19\\]\n**Output:** 32\n**Explanation:** \\[1,2,4,7,8,13,14,16,19,26,28,32\\] is the sequence of the first 12 super ugly numbers given primes = \\[2,7,13,19\\].\n\n",
                "**Example 2:**\n\n**Input:** n = 1, primes = \\[2,3,5\\]\n**Output:** 1\n**Explanation:** 1 has no prime factors, therefore all of its prime factors are in the array primes = \\[2,3,5\\]."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= primes.length <= 100`\n*   `2 <= primes[i] <= 1000`\n*   `primes[i]` is **guaranteed** to be a prime number.\n*   All the values of `primes` are **unique** and sorted in **ascending order**.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int nthSuperUglyNumber(int n, int[] primes) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int[] indices = new int[primes.length];\n\n    for (int i = 1; i < n; i++) {\n        int minVal = Integer.MAX_VALUE;\n\n        for (int j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (int j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ",
        "c++": "\n    ```cpp\nint nthSuperUglyNumber(int n, vector<int>& primes) {\n    vector<int> ugly(n);\n    ugly[0] = 1;\n    vector<int> indices(primes.size(), 0);\n    \n    for (int i = 1; i < n; i++) {\n        int min_val = INT_MAX;\n        \n        for (int j = 0; j < primes.size(); j++)\n            min_val = min(min_val, ugly[indices[j]] * primes[j]);\n        \n        ugly[i] = min_val;\n        \n        for (int j = 0; j < primes.size(); j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n    \n    return ugly.back();\n}\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ",
        "python": "\n    ```python\ndef nthSuperUglyNumber(n, primes):\n    ugly = [0] * n\n    ugly[0] = 1\n    indices = [0] * len(primes)\n\n    for i in range(1, n):\n        min_val = float(\"inf\")\n\n        for j in range(len(primes)):\n            min_val = min(min_val, ugly[indices[j]] * primes[j])\n\n        ugly[i] = min_val\n\n        for j in range(len(primes)):\n            if ugly[i] == ugly[indices[j]] * primes[j]:\n                indices[j] += 1\n\n    return ugly[-1]\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ",
        "javascript": "\n    ```javascript\nfunction nthSuperUglyNumber(n, primes) {\n    let ugly = new Array(n);\n    ugly[0] = 1;\n    let indices = new Array(primes.length).fill(0);\n\n    for (let i = 1; i < n; i++) {\n        let minVal = Number.MAX_SAFE_INTEGER;\n\n        for (let j = 0; j < primes.length; j++)\n            minVal = Math.min(minVal, ugly[indices[j]] * primes[j]);\n\n        ugly[i] = minVal;\n\n        for (let j = 0; j < primes.length; j++)\n            if (ugly[i] == ugly[indices[j]] * primes[j])\n                indices[j]++;\n    }\n\n    return ugly[n - 1];\n}\n```\n    \n    The algorithm uses dynamic programming to find the nth super ugly number. We first create an `ugly` array of size `n`, where `ugly[i]` will store the (i+1)th super ugly number. We initialize `ugly[0]` as 1, since 1 is always a super ugly number.\n\nMaintain an `indices` array of size `primes.length`, initialized with zeros. Each element `indices[j]` represents the index of the next super ugly number to multiply by `primes[j]`.\n\nFor each `i` from 1 to n, we calculate `ugly[i]` as the minimum of `ugly[indices[j]] * primes[j]` for all `j`. Then we increment the index `indices[j]` for which the condition `ugly[i] == ugly[indices[j]] * primes[j]` holds.\n\nFinally, we return the last element of the `ugly` array, which is the nth super ugly number.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 12, primes = [2,7,13,19]",
                    "output": " 32",
                    "explanation": " \\[1,2,4,7,8,13,14,16,19,26,28,32\\] is the sequence of the first 12 super ugly numbers given primes = \\[2,7,13,19\\]."
                },
                {
                    "input": " n = 1, primes = [2,3,5]",
                    "output": " 1",
                    "explanation": " 1 has no prime factors, therefore all of its prime factors are in the array primes = \\[2,3,5\\]."
                }
            ],
            "function_input": [
                {
                    "input": "12,[2,7,13,19]",
                    "output": "32"
                },
                {
                    "input": "1,[2,3,5]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-110",
        "prompt": "A **super ugly number** is a positive integer whose prime factors are in the array `primes`.\n\nGiven an integer `n` and an array of integers `primes`, return _the_ `nth` _**super ugly number**_.\n\nThe `nth` **super ugly number** is **guaranteed** to fit in a **32-bit** signed integer."
    },
    "leetcode-benchmark-111": {
        "id": "leetcode-benchmark-111",
        "title": "Remove Duplicate Letters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"bcabc \"\n**Output:**  \"abc \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"cbacdcbc \"\n**Output:**  \"acdb \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of lowercase English letters.\n\n**Note:** This question is the same as 1081: [https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic class Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[256];\n        boolean[] visited = new boolean[256];\n        Stack<Character> st = new Stack<>();\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]++;\n        }\n        \n        for (char ch : s.toCharArray()) {\n            count[ch]--;\n            if (visited[ch]) continue;\n            while (!st.isEmpty() && ch < st.peek() && count[st.peek()] > 0) {\n                visited[st.pop()] = false;\n            }\n            st.push(ch);\n            visited[ch] = true;\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!st.empty()) {\n            result.append(st.pop());\n        }\n        return result.reverse().toString();\n    }\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nstring removeDuplicateLetters(string s) {\n    vector<int> count(256, 0);\n    vector<bool> visited(256, false);\n    stack<char> st;\n    \n    for (char ch : s) {\n        count[ch]++;\n    }\n    \n    for (char ch : s) {\n        count[ch]--;\n        if (visited[ch]) continue;\n        while (!st.empty() && ch < st.top() && count[st.top()] > 0) {\n            visited[st.top()] = false;\n            st.pop();\n        }\n        st.push(ch);\n        visited[ch] = true;\n    }\n    \n    string result = \"\";\n    while (!st.empty()) {\n        result = st.top() + result;\n        st.pop();\n    }\n    return result;\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "python": "\n    ```python\ndef removeDuplicateLetters(s):\n    count = [0] * 256\n    visited = [False] * 256\n    st = []\n\n    for ch in s:\n        count[ord(ch)] += 1\n\n    for ch in s:\n        count[ord(ch)] -= 1\n        if visited[ord(ch)]:\n            continue\n        while st and ch < st[-1] and count[ord(st[-1])] > 0:\n            visited[ord(st.pop())] = False\n        st.append(ch)\n        visited[ord(ch)] = True\n\n    return \"\".join(st)   \n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "javascript": "\n    ```javascript\nfunction removeDuplicateLetters(s) {\n    let count = new Array(256).fill(0);\n    let visited = new Array(256).fill(false);\n    let st = [];\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]++;\n    }\n    \n    for (let ch of s) {\n        count[ch.charCodeAt(0)]--;\n        if (visited[ch.charCodeAt(0)]) continue;\n        while (st.length > 0 && ch < st[st.length - 1] && count[st[st.length - 1].charCodeAt(0)] > 0) {\n            visited[st.pop().charCodeAt(0)] = false;\n        }\n        st.push(ch);\n        visited[ch.charCodeAt(0)] = true;\n    }\n\n    return st.join(\"\");\n}\n```\n    \n    1. Initialize count and visited arrays. We will use count to track the occurrences of each character in the string and visited to mark if a character has been pushed into the result.\n2. Iterate through the string, count the occurrences of each character.\n3. Iterate through the string again, decrease the count of the current character.\n4. If the current character is visited, continue.\n5. While the stack is not empty, the current character is smaller than the top character on stack, and the count of the top character is greater than 0, set the visited of the top character to false and pop the character from the stack.\n6. Push the current character onto the stack, and set visited to true.\n7. Build the result string from the stack.\n8. Return the result string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"bcabc \"",
                    "output": "  \"abc \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"cbacdcbc \"",
                    "output": "  \"acdb \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"bcabc\"",
                    "output": "\"abc\""
                },
                {
                    "input": "\"cbacdcbc\"",
                    "output": "\"acdb\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-111",
        "prompt": "Given a string `s`, remove duplicate letters so that every letter appears once and only once. You must make sure your result is **the smallest in lexicographical order** among all possible results."
    },
    "leetcode-benchmark-112": {
        "id": "leetcode-benchmark-112",
        "title": "Maximum Product of Word Lengths",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string array `words`, return _the maximum value of_ `length(word[i]) * length(word[j])` _where the two words do not share common letters_. If no such two words exist, return `0`.",
            "examples": [
                "**Example 1:**\n\n**Input:** words = \\[ \"abcw \", \"baz \", \"foo \", \"bar \", \"xtfn \", \"abcdef \"\\]\n**Output:** 16\n**Explanation:** The two words can be  \"abcw \",  \"xtfn \".\n\n",
                "**Example 2:**\n\n**Input:** words = \\[ \"a \", \"ab \", \"abc \", \"d \", \"cd \", \"bcd \", \"abcd \"\\]\n**Output:** 4\n**Explanation:** The two words can be  \"ab \",  \"cd \".\n\n",
                "**Example 3:**\n\n**Input:** words = \\[ \"a \", \"aa \", \"aaa \", \"aaaa \"\\]\n**Output:** 0\n**Explanation:** No such pair of words."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= words.length <= 1000`\n*   `1 <= words[i].length <= 1000`\n*   `words[i]` consists only of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public int maxProduct(String[] words) {\n        int n = words.length;\n        int[] mask = new int[n];\n        for (int i = 0; i < n; i++) {\n            for (char c : words[i].toCharArray()) {\n                mask[i] |= (1 << (c - 'a'));\n            }\n        }\n\n        int maxProduct = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((mask[i] & mask[j]) == 0) {\n                    maxProduct = Math.max(maxProduct, words[i].length() * words[j].length());\n                }\n            }\n        }\n\n        return maxProduct;\n    }\n}\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nint maxProduct(std::vector<std::string>& words) {\n    int n = words.size();\n    std::vector<int> mask(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (char c : words[i]) {\n            mask[i] |= (1 << (c - 'a'));\n        }\n    }\n\n    int max_product = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if ((mask[i] & mask[j]) == 0) {\n                max_product = std::max(max_product, int(words[i].length() * words[j].length()));\n            }\n        }\n    }\n\n    return max_product;\n}\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "python": "\n    ```python\ndef maxProduct(words):\n    n = len(words)\n    mask = [0] * n\n    for i, word in enumerate(words):\n        for c in word:\n            mask[i] |= (1 << (ord(c) - ord('a')))\n    \n    max_product = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (mask[i] & mask[j]) == 0:\n                max_product = max(max_product, len(words[i]) * len(words[j]))\n    \n    return max_product\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "javascript": "\n    ```javascript\nfunction maxProduct(words) {\n    const n = words.length;\n    const mask = new Array(n).fill(0);\n    for (let i = 0; i < n; i++) {\n        for (const c of words[i]) {\n            mask[i] |= (1 << (c.charCodeAt(0) - 'a'.charCodeAt(0)));\n        }\n    }\n\n    let maxProduct = 0;\n    for (let i = 0; i < n; i++) {\n        for (let j = i + 1; j < n; j++) {\n            if ((mask[i] & mask[j]) === 0) {\n                maxProduct = Math.max(maxProduct, words[i].length * words[j].length);\n            }\n        }\n    }\n\n    return maxProduct;\n}\n```\n\n    \n    The algorithm first calculates a binary representation of each word, where each character is represented by a bit '1' in the corresponding position. For example, for the words \"abc\" and \"xyz\", the representation would be: \"abc\" = 0000..0111 and \"xyz\" = 111..0000.\n\nThen, for each pair of words, the algorithm checks if there are common characters by applying the 'and' bitwise operation. If there are no common characters, the 'and' operation will result in 0, meaning that the condition is met. In this case, the product of the lengths of the words is calculated, and the maximum product is updated if needed.\n\nThe algorithm runs in O(n^2) where 'n' is the number of words, since it checks each pair of words.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " words = [ \"abcw \", \"baz \", \"foo \", \"bar \", \"xtfn \", \"abcdef \"]",
                    "output": " 16",
                    "explanation": " The two words can be  \"abcw \",  \"xtfn \"."
                },
                {
                    "input": " words = [ \"a \", \"ab \", \"abc \", \"d \", \"cd \", \"bcd \", \"abcd \"]",
                    "output": " 4",
                    "explanation": " The two words can be  \"ab \",  \"cd \"."
                },
                {
                    "input": " words = [ \"a \", \"aa \", \"aaa \", \"aaaa \"]",
                    "output": " 0",
                    "explanation": " No such pair of words."
                }
            ],
            "function_input": [
                {
                    "input": "[\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]",
                    "output": "16"
                },
                {
                    "input": "[\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]",
                    "output": "4"
                },
                {
                    "input": "[\"a\",\"aa\",\"aaa\",\"aaaa\"]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-112",
        "prompt": "Given a string array `words`, return _the maximum value of_ `length(word[i]) * length(word[j])` _where the two words do not share common letters_. If no such two words exist, return `0`."
    },
    "leetcode-benchmark-113": {
        "id": "leetcode-benchmark-113",
        "title": "Bulb Switcher",
        "difficulty": "Medium",
        "content": {
            "problem": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 1\n**Explanation:** At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on.\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n",
                "**Example 3:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int bulbSwitch(int n) {\n    return (int)Math.sqrt(n);\n}\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "c++": "\n    ```cpp\nint bulbSwitch(int n) {\n    return sqrt(n);\n}\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "python": "\n    ```python\ndef bulbSwitch(n):\n    return int(n**0.5)\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "javascript": "\n    ```javascript\nfunction bulbSwitch(n) {\n    return Math.floor(Math.sqrt(n));\n}\n```\n    \n    Initially, all the bulbs are off. When a bulb is toggled odd number of times, it remains on; otherwise, it remains off. So, we need to figure out how many bulbs have an odd number of toggles after N rounds.\n\nA bulb has a toggle every time one of its divisors is encountered during the rounds. For example, bulb 6 will have toggles during round 1, round 2, round 3, and round 6. Its divisors are 1, 2, 3, and 6. In general, numbers have an even number of divisors. However, square numbers have an odd number of divisors, because their square root divisor gets counted only once. For example, for number 9, there are divisors 1, 3, and 9, and the square root divisor 3 is counted only once.\n\nSince only square numbers have an odd number of divisors (and therefore odd number of toggles), we only need to count the number of square numbers less than or equal to n. In order to do this, we can simply take the square root of n and round it down to the nearest integer, as the function does in each language.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " 1",
                    "explanation": " At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on."
                },
                {
                    "input": " n = 0",
                    "output": " 0",
                    "explanation": null
                },
                {
                    "input": " n = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "1"
                },
                {
                    "input": "0",
                    "output": "0"
                },
                {
                    "input": "1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-113",
        "prompt": "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_."
    },
    "leetcode-benchmark-114": {
        "id": "leetcode-benchmark-114",
        "title": "Generalized Abbreviation",
        "difficulty": "Medium",
        "content": {
            "problem": "A word's **generalized abbreviation** can be constructed by taking any number of **non-overlapping** and **non-adjacent** substrings and replacing them with their respective lengths.\n\n*   For example, `\"abcde \"` can be abbreviated into:\n    *   `\"a3e \"` ( `\"bcd \"` turned into `\"3 \"`)\n    *   `\"1bcd1 \"` ( `\"a \"` and `\"e \"` both turned into `\"1 \"`)\n    *   `\"5 \"` ( `\"abcde \"` turned into `\"5 \"`)\n    *   `\"abcde \"` (no substrings replaced)\n*   However, these abbreviations are **invalid**:\n    *   `\"23 \"` ( `\"ab \"` turned into `\"2 \"` and `\"cde \"` turned into `\"3 \"`) is invalid as the substrings chosen are adjacent.\n    *   `\"22de \"` ( `\"ab \"` turned into `\"2 \"` and `\"bc \"` turned into `\"2 \"`) is invalid as the substring chosen overlap.\n\nGiven a string `word`, return _a list of all the possible **generalized abbreviations** of_ `word`. Return the answer in **any order**.",
            "examples": [
                "**Example 1:**\n\n**Input:** word = \"word\"\n**Output:** \\[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"\\]\n\n",
                "**Example 2:**\n\n**Input:** word = \"a\"\n**Output:** \\[\"1\",\"a\"\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= word.length <= 15`\n*   `word` consists of only lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<String> generateAbbreviations(String word) {\n    List<String> res = new ArrayList<>();\n    res.add(word.isEmpty() ? \"\" : Integer.toString(word.length()));\n    for (int i = 0; i < word.length(); ++i) {\n        String pre = word.substring(0, i);\n        for (String abbr : generateAbbreviations(word.substring(i + 1))) {\n            int num = abbr.chars().findFirst_NEG_INT().getAsInt();\n            if (abbr.isEmpty() || num > 0) {\n                res.add(pre + '1' + abbr);\n            }\n            if (i == 0 || abbr.isEmpty() || abbr.charAt(0) > '9') {\n                res.add(word.substring(0, i + 1) + abbr);\n            }\n        }\n    }\n    return res;\n}\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> generateAbbreviations(std::string word) {\n    std::vector<std::string> res;\n    res.push_back(word.empty() ? \"\" : std::to_string(word.size()));\n    for (size_t i = 0; i < word.size(); ++i)\n        for (const std::string &abbr : generateAbbreviations(word.substr(i + 1))) {\n            size_t num;\n            if (abbr.empty() || (num = abbr.find_first_not_of('123456789')) > 0)\n                res.push_back(word.substr(0, i) + '1' + abbr);\n            if (i == 0 || abbr.empty() || abbr[0] > '9')\n                res.push_back(word.substr(0, i + 1) + abbr);\n        }\n    return res;\n}\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "python": "\n    ```python\ndef generateAbbreviations(word):\n    if not word:\n        return [\"\"]\n    res = []\n    for i in range(len(word) + 1):\n        for item in generateAbbreviations(word[i+1:]):\n            if i == 0 or not item or not item[0].isdigit():\n                res.append(word[:i+1] + item)\n            if item and item[0].isdigit():\n                res.append(word[:i] + '1' + item)\n    return res\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "javascript": "\n    ```javascript\nfunction generateAbbreviations(word) {\n    if (word === '') {\n        return ['']\n    }\n    const res = []\n    for (let i = 0; i < word.length + 1; i++) {\n        for (const item of generateAbbreviations(word.slice(i + 1))) {\n            if (i === 0 || !item || isNaN(item[0])) {\n                res.push(word.slice(0, i + 1) + item)\n            }\n            if (item && !isNaN(item[0])) {\n                res.push(word.slice(0, i) + '1' + item)\n            }\n        }\n    }\n    return res\n}\n```\n    \n    The algorithm to generate generalized abbreviations works as follows:\n1. If the input word is empty, return an empty abbreviation.\n2. Initialize an empty result list.\n3. Iterate over the length of the word, performing the following steps:\n   a. Recursively generate abbreviations for subsequences.\n   b. Check if it's the first iteration or if the item is not a number.\n      If true, append the word slice and item to the result list.\n   c. Check if the item is a number.\n      If true, append the word slice and item with '1' between them to the result list.\n4. Return the result list containing all possible generalized abbreviations.\n\nThis method ensures non-overlapping and non-adjacent substrings because, at each recursive call, we add only one digit or a character. Hence, there will always be either a digit or a character between two digit substrings. Since we do not combine multiple adjacent characters into a single multi-digit substring, we comply with the constraints mentioned in the problem statement.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " word = \"word\"",
                    "output": " [\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"]",
                    "explanation": null
                },
                {
                    "input": " word = \"a\"",
                    "output": " [\"1\",\"a\"]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"word\"",
                    "output": "[\"4\",\"3d\",\"2r1\",\"2rd\",\"1o2\",\"1o1d\",\"1or1\",\"1ord\",\"w3\",\"w2d\",\"w1r1\",\"w1rd\",\"wo2\",\"wo1d\",\"wor1\",\"word\"]"
                },
                {
                    "input": "\"a\"",
                    "output": "[\"1\",\"a\"]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-114",
        "prompt": "A word's **generalized abbreviation** can be constructed by taking any number of **non-overlapping** and **non-adjacent** substrings and replacing them with their respective lengths.\n\n*   For example, `\"abcde \"` can be abbreviated into:\n    *   `\"a3e \"` ( `\"bcd \"` turned into `\"3 \"`)\n    *   `\"1bcd1 \"` ( `\"a \"` and `\"e \"` both turned into `\"1 \"`)\n    *   `\"5 \"` ( `\"abcde \"` turned into `\"5 \"`)\n    *   `\"abcde \"` (no substrings replaced)\n*   However, these abbreviations are **invalid**:\n    *   `\"23 \"` ( `\"ab \"` turned into `\"2 \"` and `\"cde \"` turned into `\"3 \"`) is invalid as the substrings chosen are adjacent.\n    *   `\"22de \"` ( `\"ab \"` turned into `\"2 \"` and `\"bc \"` turned into `\"2 \"`) is invalid as the substring chosen overlap.\n\nGiven a string `word`, return _a list of all the possible **generalized abbreviations** of_ `word`. Return the answer in **any order**."
    },
    "leetcode-benchmark-115": {
        "id": "leetcode-benchmark-115",
        "title": "Coin Change",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
            "examples": [
                "**Example 1:**\n\n**Input:** coins = \\[1,2,5\\], amount = 11\n**Output:** 3\n**Explanation:** 11 = 5 + 5 + 1\n\n",
                "**Example 2:**\n\n**Input:** coins = \\[2\\], amount = 3\n**Output:** -1\n\n",
                "**Example 3:**\n\n**Input:** coins = \\[1\\], amount = 0\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= coins.length <= 12`\n*   `1 <= coins[i] <= 231 - 1`\n*   `0 <= amount <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int coinChange(int[] coins, int amount) {\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, amount + 1);\n    dp[0] = 0;\n    \n    for (int coin : coins) {\n        for (int i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nint coinChange(std::vector<int>& coins, int amount) {\n    std::vector<int> dp(amount + 1, amount + 1);\n    dp[0] = 0;\n    \n    for (int i = 0; i < coins.size(); i++) {\n        for (int j = coins[i]; j <= amount; j++) {\n            dp[j] = std::min(dp[j], dp[j - coins[i]] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "python": "\n    ```python\ndef coinChange(coins, amount):\n    dp = [amount + 1] * (amount + 1)\n    dp[0] = 0\n\n    for coin in coins:\n        for i in range(coin, amount + 1):\n            dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return dp[amount] if dp[amount] <= amount else -1\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "javascript": "\n    ```javascript\nfunction coinChange(coins, amount) {\n    const dp = new Array(amount + 1).fill(amount + 1);\n    dp[0] = 0;\n\n    for (const coin of coins) {\n        for (let i = coin; i <= amount; i++) {\n            dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n        }\n    }\n\n    return dp[amount] <= amount ? dp[amount] : -1;\n}\n```\n    \n    The algorithm here is based on dynamic programming. We create a `dp` array with indices from 0 to the total `amount` we need to target. We initialize the `dp` array with a value greater than the amount (amount + 1). This is because this value can never be achieved using the coins, and the initialization ensures that we always get a valid minimum number of coins.\n\nWe start by initializing `dp[0]` to 0 as there will be 0 coins needed to make a sum of 0.\n\nThen, we iterate through the given coins array and for each coin, we start another iteration from the value of the coin to the total amount. For each index `i` in this inner loop, we update `dp[i]` as the minimum of its current value `dp[i]` and `dp[i - coins[j]] + 1`. This ensures that we get the minimum number of coins required to create the total amount.\n\nAfter this iteration, if the value at `dp[amount]` is less than or equal to the target amount, we return the value as the minimum number of coins required. Otherwise, if it's greater than the amount, it means we couldn't find a combination of coins to make up the total amount, so we return -1.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " coins = [1,2,5], amount = 11",
                    "output": " 3",
                    "explanation": " 11 = 5 + 5 + 1"
                },
                {
                    "input": " coins = [2], amount = 3",
                    "output": " -1",
                    "explanation": null
                },
                {
                    "input": " coins = [1], amount = 0",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,5],11",
                    "output": "3"
                },
                {
                    "input": "[2],3",
                    "output": "-1"
                },
                {
                    "input": "[1],0",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-115",
        "prompt": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn _the fewest number of coins that you need to make up that amount_. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin."
    },
    "leetcode-benchmark-116": {
        "id": "leetcode-benchmark-116",
        "title": "Number of Connected Components in an Undirected Graph",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[3,4\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 2000`\n*   `1 <= edges.length <= 5000`\n*   `edges[i].length == 2`\n*   `0 <= ai <= bi < n`\n*   `ai != bi`\n*   There are no repeated edges.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic int countComponents(int n, int[][] edges) {\n    List<List<Integer>> adjList = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n        adjList.add(new ArrayList<>());\n    }\n    for (int[] edge : edges) {\n        adjList.get(edge[0]).add(edge[1]);\n        adjList.get(edge[1]).add(edge[0]);\n    }\n\n    boolean[] visited = new boolean[n];\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i, visited, adjList);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n\nvoid dfs(int node, boolean[] visited, List<List<Integer>> adjList) {\n    visited[node] = true;\n    for (int neighbor : adjList.get(node)) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited, adjList);\n        }\n    }\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nint countComponents(int n, std::vector<std::vector<int>>& edges) {\n    std::vector<std::vector<int>> adjList(n);\n    for (const auto& edge : edges) {\n        adjList[edge[0]].push_back(edge[1]);\n        adjList[edge[1]].push_back(edge[0]);\n    }\n    \n    std::vector<bool> visited(n, false);\n    int connectedComponents = 0;\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            std::function<void(int)> dfs = [&](int node) {\n                visited[node] = true;\n                for (int neighbor : adjList[node]) {\n                    if (!visited[neighbor]) {\n                        dfs(neighbor);\n                    }\n                }\n            };\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "python": "\n    ```python\ndef countComponents(n, edges):\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0]].append(edge[1])\n        adj_list[edge[1]].append(edge[0])\n\n    visited = [False] * n\n    connected_components = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n\n    return connected_components\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "javascript": "\n    ```javascript\nfunction countComponents(n, edges) {\n    const adjList = new Array(n).fill(0).map(() => []);\n    for (const edge of edges) {\n        adjList[edge[0]].push(edge[1]);\n        adjList[edge[1]].push(edge[0]);\n    }\n\n    const visited = new Array(n).fill(false);\n    let connectedComponents = 0;\n\n    function dfs(node) {\n        visited[node] = true;\n        for (const neighbor of adjList[node]) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n    }\n\n    for (let i = 0; i < n; i++) {\n        if (!visited[i]) {\n            dfs(i);\n            connectedComponents++;\n        }\n    }\n    return connectedComponents;\n}\n```\n\n    \n    The algorithm used to solve this problem is the standard Depth First Search (DFS) on an undirected graph. The number of connected components is incremented each time a new unvisited node is found. The algorithm performs the following steps:\n\n1. Create an adjacency list representation of the graph.\n2. Initialize a visited array to mark visited nodes.\n3. Initialize a count variable for connected components.\n4. Iterate over all the nodes in the graph:\n   a. If a node is not visited, perform DFS on the node and increment the count of connected components.\n   b. In DFS, mark the node as visited and recursively perform DFS on its adjacent nodes if they have not been visited.\n5. Return the count of connected components.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 5, edges = [[0,1],[1,2],[3,4]]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5,[[0,1],[1,2],[3,4]]",
                    "output": "2"
                },
                {
                    "input": "5,[[0,1],[1,2],[2,3],[3,4]]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-116",
        "prompt": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn _the number of connected components in the graph_."
    },
    "leetcode-benchmark-117": {
        "id": "leetcode-benchmark-117",
        "title": "Wiggle Sort II",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...`.\n\nYou may assume the input array always has a valid answer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,5,1,1,6,4\\]\n**Output:** \\[1,6,1,5,1,4\\]\n**Explanation:** \\[1,4,1,5,1,6\\] is also accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,3,2,2,3,1\\]\n**Output:** \\[2,3,1,3,1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 104`\n*   `0 <= nums[i] <= 5000`\n*   It is guaranteed that there will be an answer for the given input `nums`.\n\n**",
            "follow_up": "Follow Up:** Can you do it in `O(n)` time and/or **in-place** with `O(1)` extra space?"
        },
        "java": "\n    ```java\nimport java.util.Arrays;\npublic void wiggleSort(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 1; i < nums.length - 1; i += 2) {\n        int temp = nums[i];\n        nums[i] = nums[i + 1];\n        nums[i + 1] = temp;\n    }\n}\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ",
        "c++": "\n    ```cpp\n#include <algorithm>\nvoid wiggleSort(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    for (int i = 1; i < nums.size() - 1; i += 2) {\n        swap(nums[i], nums[i + 1]);\n    }\n}\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ",
        "python": "\n    ```python\ndef wiggleSort(nums):\n    nums.sort()\n    for i in range(1, len(nums) - 1, 2):\n        nums[i], nums[i + 1] = nums[i + 1], nums[i]\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ",
        "javascript": "\n    ```javascript\nfunction wiggleSort(nums) {\n    nums.sort((a, b) => a - b);\n    for (let i = 1; i < nums.length - 1; i += 2) {\n        [nums[i], nums[i + 1]] = [nums[i + 1], nums[i]];\n    }\n}\n```\n\n    \n    1. First, sort the array in ascending order. This step ensures that the smaller element is always before the larger element in the sorted array.\n2. Iterate through the sorted array, starting from the second element (index 1) and incrementing by 2 so that the iteration only impacts every other element.\n3. Swap the current element with the next element in the array during the iteration. This will make the current element greater than its neighbors, fulfilling the requirements of the wiggle sort.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,5,1,1,6,4]",
                    "output": " [1,6,1,5,1,4]",
                    "explanation": " \\[1,4,1,5,1,6\\] is also accepted."
                },
                {
                    "input": " nums = [1,3,2,2,3,1]",
                    "output": " [2,3,1,3,1,2]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,5,1,1,6,4]",
                    "output": "[1,6,1,5,1,4]"
                },
                {
                    "input": "[1,3,2,2,3,1]",
                    "output": "[2,3,1,3,1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-117",
        "prompt": "Given an integer array `nums`, reorder it such that `nums[0] < nums[1] > nums[2] < nums[3]...`.\n\nYou may assume the input array always has a valid answer."
    },
    "leetcode-benchmark-118": {
        "id": "leetcode-benchmark-118",
        "title": "Maximum Size Subarray Sum Equals k",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` and an integer `k`, return _the maximum length of a_ _subarray_ _that sums to_ `k`. If there is not one, return `0` instead.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,-1,5,-2,3\\], k = 3\n**Output:** 4\n**Explanation:** The subarray \\[1, -1, 5, -2\\] sums to 3 and is the longest.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-2,-1,2,1\\], k = 1\n**Output:** 2\n**Explanation:** The subarray \\[-1, 2\\] sums to 1 and is the longest."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 105`\n*   `-104 <= nums[i] <= 104`\n*   `-109 <= k <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxSubArrayLen(int[] nums, int k) {\n    Map<Integer, Integer> sumIndex = new HashMap<>();\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum == k) maxLength = i + 1;\n        if (sumIndex.containsKey(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.containsKey(sum)) sumIndex.put(sum, i);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "c++": "\n    ```cpp\nint maxSubArrayLen(vector<int>& nums, int k) {\n    unordered_map<int, int> sumIndex;\n    int maxLength = 0, sum = 0;\n    for(int i = 0; i < nums.size(); i++) {\n        sum += nums[i];\n        if(sum == k) maxLength = i + 1;\n        if(sumIndex.count(sum - k)) maxLength = max(maxLength, i - sumIndex[sum - k]);\n        if(!sumIndex.count(sum)) sumIndex[sum] = i;\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "python": "\n    ```python\ndef maxSubArrayLen(nums: List[int], k: int) -> int:\n    sum_index = {}\n    maxLength = sum = 0\n    for i, num in enumerate(nums):\n        sum += num\n        if sum == k:\n            maxLength = i + 1\n        if sum - k in sum_index:\n            maxLength = max(maxLength, i - sum_index[sum - k])\n        if sum not in sum_index:\n            sum_index[sum] = i\n    return maxLength\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "javascript": "\n    ```javascript\nfunction maxSubArrayLen(nums, k) {\n    let sumIndex = new Map();\n    let maxLength = 0, sum = 0;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        if (sum === k) maxLength = i + 1;\n        if (sumIndex.has(sum - k)) maxLength = Math.max(maxLength, i - sumIndex.get(sum - k));\n        if (!sumIndex.has(sum)) sumIndex.set(sum, i);\n    }\n    return maxLength;\n}\n```\n\n    \n    The algorithm uses a HashMap (or dictionary for Python) to store a cumulative sum and its index. The HashMap (called `sumIndex` here) keeps track of the first time a certain sum (up to that index) is encountered in the array. Then, we iterate through the array and maintain a running sum. If the running sum is equal to the given sum `k`, the current maximum length of the subarray is updated as `i + 1`. If the running sum minus `k` exists in `sumIndex`, it means that we've found a subarray that sums to `k`, so we can update the maximum length by comparing with the current subarray length `i - sumIndex[sum - k]`. If the running sum is not present in the `sumIndex`, we can store its index.\n\nThe algorithm works in O(n) time complexity, where n is the length of the array because we traverse the entire array once and perform constant time operations for each element.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,-1,5,-2,3], k = 3",
                    "output": " 4",
                    "explanation": " The subarray \\[1, -1, 5, -2\\] sums to 3 and is the longest."
                },
                {
                    "input": " nums = [-2,-1,2,1], k = 1",
                    "output": " 2",
                    "explanation": " The subarray \\[-1, 2\\] sums to 1 and is the longest."
                }
            ],
            "function_input": [
                {
                    "input": "[1,-1,5,-2,3],3",
                    "output": "4"
                },
                {
                    "input": "[-2,-1,2,1],1",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-118",
        "prompt": "Given an integer array `nums` and an integer `k`, return _the maximum length of a_ _subarray_ _that sums to_ `k`. If there is not one, return `0` instead."
    },
    "leetcode-benchmark-119": {
        "id": "leetcode-benchmark-119",
        "title": "Verify Preorder Serialization of a Binary Tree",
        "difficulty": "Medium",
        "content": {
            "problem": "One way to serialize a binary tree is to use **preorder traversal**. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as `'#'`.\n\nFor example, the above binary tree can be serialized to the string `\"9,3,4,#,#,1,#,#,2,#,6,#,# \"`, where `'#'` represents a null node.\n\nGiven a string of comma-separated values `preorder`, return `true` if it is a correct preorder traversal serialization of a binary tree.\n\nIt is **guaranteed** that each comma-separated value in the string must be either an integer or a character `'#'` representing null pointer.\n\nYou may assume that the input format is always valid.\n\n*   For example, it could never contain two consecutive commas, such as `\"1,,3 \"`.\n\n**Note:** You are not allowed to reconstruct the tree.",
            "examples": [
                "**Example 1:**\n\n**Input:** preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n**Output:** true\n\n",
                "**Example 2:**\n\n**Input:** preorder = \"1,#\"\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** preorder = \"9,#,#,1\"\n**Output:** false"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= preorder.length <= 104`\n*   `preorder` consist of integers in the range `[0, 100]` and `'#'` separated by commas `','`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isValidSerialization(String preorder) {\n    String[] nodes = preorder.split(\",\");\n    int node_count = 1;\n\n    for (String node : nodes) {\n        node_count--;\n\n        if (node_count < 0) return false;\n        if (!node.equals(\"#\")) node_count += 2;\n    }\n\n    return node_count == 0;\n}\n```\n    \n    The algorithm iterates through each node in the given preorder traversal string, decrementing a node count for each iteration. If the node count falls below 0, it returns false, as it means the input is not a valid preorder traversal serialization of a binary tree. If the current node is not a null node (represented by '#'), we increment the node count by 2, as each non-null node would have two children. Once the iteration is complete, we check if the node count is 0, indicating a valid serialization, and return the result accordingly.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n\nbool isValidSerialization(const std::string &preorder) {\n    std::istringstream iss(preorder);\n    std::string token;\n    int node_count = 1;\n\n    while (std::getline(iss, token, ',')) {\n        --node_count;\n        if (node_count < 0) return false;\n        if (token != \"#\") node_count += 2;\n    }\n\n    return node_count == 0;\n}\n```\n    \n    The algorithm iterates through each node in the given preorder traversal string, decrementing a node count for each iteration. If the node count falls below 0, it returns false, as it means the input is not a valid preorder traversal serialization of a binary tree. If the current node is not a null node (represented by '#'), we increment the node count by 2, as each non-null node would have two children. Once the iteration is complete, we check if the node count is 0, indicating a valid serialization, and return the result accordingly.\n    ",
        "python": "\n    ```python\ndef is_valid_serialization(preorder: str) -> bool:\n    nodes = preorder.split(',')\n    node_count = 1\n\n    for node in nodes:\n        node_count -= 1\n        if node_count < 0:\n            return False\n        if node != '#':\n            node_count += 2\n\n    return node_count == 0\n```\n    \n    The algorithm iterates through each node in the given preorder traversal string, decrementing a node count for each iteration. If the node count falls below 0, it returns false, as it means the input is not a valid preorder traversal serialization of a binary tree. If the current node is not a null node (represented by '#'), we increment the node count by 2, as each non-null node would have two children. Once the iteration is complete, we check if the node count is 0, indicating a valid serialization, and return the result accordingly.\n    ",
        "javascript": "\n    ```javascript\nfunction isValidSerialization(preorder) {\n    const nodes = preorder.split(',');\n    let node_count = 1;\n\n    for (let node of nodes) {\n        node_count--;\n\n        if (node_count < 0) return false;\n        if (node !== '#') node_count += 2;\n    }\n\n    return node_count === 0;\n}\n```\n    \n    The algorithm iterates through each node in the given preorder traversal string, decrementing a node count for each iteration. If the node count falls below 0, it returns false, as it means the input is not a valid preorder traversal serialization of a binary tree. If the current node is not a null node (represented by '#'), we increment the node count by 2, as each non-null node would have two children. Once the iteration is complete, we check if the node count is 0, indicating a valid serialization, and return the result accordingly.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"",
                    "output": " True",
                    "explanation": null
                },
                {
                    "input": " preorder = \"1,#\"",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " preorder = \"9,#,#,1\"",
                    "output": " False",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"9,",
                    "output": "True"
                },
                {
                    "input": "\"1,",
                    "output": "False"
                },
                {
                    "input": "\"9,",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-119",
        "prompt": "One way to serialize a binary tree is to use **preorder traversal**. When we encounter a non-null node, we record the node's value. If it is a null node, we record using a sentinel value such as `'#'`.\n\nFor example, the above binary tree can be serialized to the string `\"9,3,4,#,#,1,#,#,2,#,6,#,# \"`, where `'#'` represents a null node.\n\nGiven a string of comma-separated values `preorder`, return `true` if it is a correct preorder traversal serialization of a binary tree.\n\nIt is **guaranteed** that each comma-separated value in the string must be either an integer or a character `'#'` representing null pointer.\n\nYou may assume that the input format is always valid.\n\n*   For example, it could never contain two consecutive commas, such as `\"1,,3 \"`.\n\n**Note:** You are not allowed to reconstruct the tree."
    },
    "leetcode-benchmark-120": {
        "id": "leetcode-benchmark-120",
        "title": "Increasing Triplet Subsequence",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4,5\\]\n**Output:** true\n**Explanation:** Any triplet where i < j < k is valid.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[5,4,3,2,1\\]\n**Output:** false\n**Explanation:** No triplet exists.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[2,1,5,0,4,6\\]\n**Output:** true\n**Explanation:** The triplet (3, 4, 5) is valid because nums\\[3\\] == 0 < nums\\[4\\] == 4 < nums\\[5\\] == 6."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5 * 105`\n*   `-231 <= nums[i] <= 231 - 1`\n\n**",
            "follow_up": "Follow up:** Could you implement a solution that runs in `O(n)` time complexity and `O(1)` space complexity?"
        },
        "java": "\n    ```java\npublic boolean findTriplets(int[] nums) {\n    int first = Integer.MAX_VALUE;\n    int second = Integer.MAX_VALUE;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ",
        "c++": "\n    ```cpp\nbool findTriplets(vector<int>& nums) {\n    int first = INT_MAX, second = INT_MAX;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ",
        "python": "\n    ```python\ndef findTriplets(nums: List[int]) -> bool:\n    first = float('inf')\n    second = float('inf')\n\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n    return False\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ",
        "javascript": "\n    ```javascript\nfunction findTriplets(nums) {\n    let first = Number.MAX_VALUE;\n    let second = Number.MAX_VALUE;\n\n    for (let num of nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n    \n    We use a greedy algorithm here. We keep track of two variables: `first` and `second`. `first` is initialized to the maximum integer value supported by the language. Similarly, `second` is initialized to the max integer value.\n\nWe iterate through the given array `nums`. If the current value is less than or equal to `first`, then we update `first` to be the current value. This helps us find the smallest value in the array. If the current value is not less than `first` but is less than or equal to `second`, we update `second` to be the current value. This helps us find the second smallest value, whose position is strictly greater than the position of `first`.\n\nNow, during iteration, if we find any value that is greater than `second`, then we return `true`, as we have found three indices such that they satisfy the given condition.\n\nIf we iterate through the entire array and don't find a value that is greater than `second`, we return `false`. This means that we couldn't find a triplet satisfying the given condition.\n\nThis greedy algorithm runs in O(n) time complexity, as we iterate through the array once.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,4,5]",
                    "output": " True",
                    "explanation": " Any triplet where i < j < k is valid."
                },
                {
                    "input": " nums = [5,4,3,2,1]",
                    "output": " False",
                    "explanation": " No triplet exists."
                },
                {
                    "input": " nums = [2,1,5,0,4,6]",
                    "output": " True",
                    "explanation": " The triplet (3, 4, 5) is valid because nums\\[3\\] == 0 < nums\\[4\\] == 4 < nums\\[5\\] == 6."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4,5]",
                    "output": "True"
                },
                {
                    "input": "[5,4,3,2,1]",
                    "output": "False"
                },
                {
                    "input": "[2,1,5,0,4,6]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-120",
        "prompt": "Given an integer array `nums`, return `true` _if there exists a triple of indices_ `(i, j, k)` _such that_ `i < j < k` _and_ `nums[i] < nums[j] < nums[k]`. If no such indices exists, return `false`."
    },
    "leetcode-benchmark-121": {
        "id": "leetcode-benchmark-121",
        "title": "House Robber III",
        "difficulty": "Medium",
        "content": {
            "problem": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return _the maximum amount of money the thief can rob **without alerting the police**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[3,2,3,null,3,null,1\\]\n**Output:** 7\n**Explanation:** Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[3,4,5,1,3,null,1\\]\n**Output:** 9\n**Explanation:** Maximum amount of money the thief can rob = 4 + 5 = 9."
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[1, 104]`.\n*   `0 <= Node.val <= 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int rob(TreeNode root) {\n    int[] result = robHelper(root);\n    return Math.max(result[0], result[1]);\n}\n\nprivate int[] robHelper(TreeNode node) {\n    if (node == null) return new int[2];\n\n    int[] left = robHelper(node.left);\n    int[] right = robHelper(node.right);\n    int[] result = new int[2];\n\n    result[0] = node.val + left[1] + right[1];\n    result[1] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n    return result;\n}\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ",
        "c++": "\n    ```cpp\nint robHelper(TreeNode* node, int& includeNode, int& excludeNode) {\n    if (!node) return 0;\n\n    int left_include, left_exclude, right_include, right_exclude;\n\n    robHelper(node->left, left_include, left_exclude);\n    robHelper(node->right, right_include, right_exclude);\n\n    includeNode = node->val + left_exclude + right_exclude;\n    excludeNode = max(left_include, left_exclude) + max(right_include, right_exclude);\n    return max(includeNode, excludeNode);\n}\n\nint rob(TreeNode* root) {\n    int includeNode = 0, excludeNode = 0;\n    return robHelper(root, includeNode, excludeNode);\n}\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ",
        "python": "\n    ```python\ndef rob(self, root: TreeNode) -> int:\n    def rob_helper(node):\n        if not node:\n            return 0, 0\n\n        left_with_node, left_without_node = rob_helper(node.left)\n        right_with_node, right_without_node = rob_helper(node.right)\n\n        with_node = node.val + left_without_node + right_without_node\n        without_node = max(left_with_node, left_without_node) + max(right_with_node, right_without_node)\n        return with_node, without_node\n\n    return max(rob_helper(root))\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ",
        "javascript": "\n    ```javascript\nvar rob = function(root) {\n    const [withNode, withoutNode] = robHelper(root);\n    return Math.max(withNode, withoutNode);\n};\n\nfunction robHelper(node) {\n    if (!node) return [0, 0];\n\n    const [leftWithNode, leftWithoutNode] = robHelper(node.left);\n    const [rightWithNode, rightWithoutNode] = robHelper(node.right);\n\n    const withNode = node.val + leftWithoutNode + rightWithoutNode;\n    const withoutNode = Math.max(leftWithNode, leftWithoutNode) + Math.max(rightWithNode, rightWithoutNode);\n    return [withNode, withoutNode];\n}\n```\n    \n    The algorithm uses a dynamic programming approach to find the optimal sum for each subtree. The helper function has two main cases for each node:\n\n1. Include the current node value in the sum (includeNode): If the current node is included in the sum, its children nodes cannot be included. Therefore, we add the current node value to the sum of the node's grandchildren.\n\n2. Exclude the current node value in the sum (excludeNode): If the current node is not included in the sum, its children can be included. We add the maximum of the children nodes' sum including or excluding the children in the sum.\n\nThe helper function is called recursively for each child node until the leaves are reached. For each node, the helper function returns two values indicating the maximum sum including and excluding the current node. At the end of the recursion, we return the maximum of these two values for the root node as the result.\n\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the tree.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [3,2,3,null,3,null,1]",
                    "output": " 7",
                    "explanation": " Maximum amount of money the thief can rob = 3 + 3 + 1 = 7."
                },
                {
                    "input": " root = [3,4,5,1,3,null,1]",
                    "output": " 9",
                    "explanation": " Maximum amount of money the thief can rob = 4 + 5 = 9."
                }
            ],
            "function_input": [
                {
                    "input": "[3,2,3,null,3,null,1]",
                    "output": "7"
                },
                {
                    "input": "[3,4,5,1,3,null,1]",
                    "output": "9"
                }
            ]
        },
        "task_id": "leetcode-benchmark-121",
        "prompt": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called `root`.\n\nBesides the `root`, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if **two directly-linked houses were broken into on the same night**.\n\nGiven the `root` of the binary tree, return _the maximum amount of money the thief can rob **without alerting the police**_."
    },
    "leetcode-benchmark-122": {
        "id": "leetcode-benchmark-122",
        "title": "Longest Substring with At Most K Distinct Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"eceba \", k = 2\n**Output:** 3\n**Explanation:** The substring is  \"ece \" with length 3.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"aa \", k = 1\n**Output:** 2\n**Explanation:** The substring is  \"aa \" with length 2."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 5 * 104`\n*   `0 <= k <= 50`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int lengthOfLongestSubstringKDistinct(String s, int k) {\n    HashMap<Character, Integer> charCount = new HashMap<>();\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.length(); ++right) {\n        charCount.put(s.charAt(right), charCount.getOrDefault(s.charAt(right), 0) + 1);\n\n        while (charCount.size() > k) {\n            charCount.put(s.charAt(left), charCount.get(s.charAt(left)) - 1);\n            if (charCount.get(s.charAt(left)) == 0) {\n                charCount.remove(s.charAt(left));\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n#include <algorithm>\n\nint lengthOfLongestSubstringKDistinct(std::string s, int k) {\n    std::unordered_map<char, int> charCount;\n    int left = 0, maxLength = 0;\n\n    for (int right = 0; right < s.size(); ++right) {\n        charCount[s[right]]++;\n\n        while (charCount.size() > k) {\n            charCount[s[left]]--;\n            if (charCount[s[left]] == 0) {\n                charCount.erase(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = std::max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "python": "\n    ```python\ndef length_of_longest_substring_k_distinct(s: str, k: int) -> int:\n    char_count = {}\n    left = 0\n    max_length = 0\n\n    for right, char in enumerate(s):\n        char_count[char] = char_count.get(char, 0) + 1\n\n        while len(char_count) > k:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "javascript": "\n    ```javascript\nfunction lengthOfLongestSubstringKDistinct(s, k) {\n    const charCount = new Map();\n    let left = 0;\n    let maxLength = 0;\n\n    for (let right = 0; right < s.length; ++right) {\n        charCount.set(s[right], (charCount.get(s[right]) || 0) + 1);\n\n        while (charCount.size > k) {\n            charCount.set(s[left], charCount.get(s[left]) - 1);\n            if (charCount.get(s[left]) === 0) {\n                charCount.delete(s[left]);\n            }\n            left++;\n        }\n\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}\n```\n    \n    1. Create a hashmap to store character counts within the sliding window.\n2. Initialize `left` and `maxLength` to zero.\n3. Iterate through the string with a for loop:\n    a. Increment the count of the current character in the hashmap.\n    b. If there are more than `k` distinct characters in the hashmap, move `left` to the right to shrink the window and update the count in the hashmap (remove the entry if the count is zero).\n    c. Update `maxLength` with the length of the current window right - left + 1.\n4. Return `maxLength`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"eceba \", k = 2",
                    "output": " 3",
                    "explanation": " The substring is  \"ece \" with length 3."
                },
                {
                    "input": " s =  \"aa \", k = 1",
                    "output": " 2",
                    "explanation": " The substring is  \"aa \" with length 2."
                }
            ],
            "function_input": [
                {
                    "input": "\"eceba\",2",
                    "output": "3"
                },
                {
                    "input": "\"aa\",1",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-122",
        "prompt": "Given a string `s` and an integer `k`, return _the length of the longest_ _substring_ _of_ `s` _that contains at most_ `k` _**distinct** characters_."
    },
    "leetcode-benchmark-123": {
        "id": "leetcode-benchmark-123",
        "title": "Integer Break",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** 2 = 1 + 1, 1 \\* 1 = 1.\n\n",
                "**Example 2:**\n\n**Input:** n = 10\n**Output:** 36\n**Explanation:** 10 = 3 + 3 + 4, 3 \\* 3 \\* 4 = 36."
            ],
            "constraints": "**Constraints:**\n\n*   `2 <= n <= 58`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ",
        "c++": "\n    ```cpp\nint integerBreak(int n) {\n    if (n <= 3) return n - 1;\n    int product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ",
        "python": "\n    ```python\ndef integer_break(n):\n    if n <= 3:\n        return n - 1\n    product = 1\n    while n > 4:\n        product *= 3\n        n -= 3\n    return product * n\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ",
        "javascript": "\n    ```javascript\nfunction integerBreak(n) {\n    if (n <= 3) return n - 1;\n    let product = 1;\n    while (n > 4) {\n        product *= 3;\n        n -= 3;\n    }\n    return product * n;\n}\n```\n    \n    The algorithm is based on the fact that the optimal factorization for the integer n consists of as many 3s as possible, and maybe a 2 or a 4. If we have a factor composed of five 1s, we can always break it into two 2s and a 3, which has a larger product (2 * 2 * 3 > 1 * 1 * 1 * 1 * 1). This means that the factors included in the final product will never be smaller than 2.\n\nThe solution is to repeatedly subtract 3 from the given number `n` and multiply the product by 3. If we end up with `n` being 2, 3, or 4 after this process, we multiply the product by `n` and return it.\n\nThis solution runs in O(n) time complexity.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " 1",
                    "explanation": " 2 = 1 + 1, 1 \\* 1 = 1."
                },
                {
                    "input": " n = 10",
                    "output": " 36",
                    "explanation": " 10 = 3 + 3 + 4, 3 \\* 3 \\* 4 = 36."
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "1"
                },
                {
                    "input": "10",
                    "output": "36"
                }
            ]
        },
        "task_id": "leetcode-benchmark-123",
        "prompt": "Given an integer `n`, break it into the sum of `k` **positive integers**, where `k >= 2`, and maximize the product of those integers.\n\nReturn _the maximum product you can get_."
    },
    "leetcode-benchmark-124": {
        "id": "leetcode-benchmark-124",
        "title": "Android Unlock Patterns",
        "difficulty": "Medium",
        "content": {
            "problem": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an \"unlock pattern \" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a **valid** unlock pattern if both of the following are true:\n\n*   All the dots in the sequence are **distinct**.\n*   If the line segment connecting two consecutive dots in the sequence passes through the **center** of any other dot, the other dot **must have previously appeared** in the sequence. No jumps through the center non-selected dots are allowed.\n    *   For example, connecting dots `2` and `9` without dots `5` or `6` appearing beforehand is valid because the line from dot `2` to dot `9` does not pass through the center of either dot `5` or `6`.\n    *   However, connecting dots `1` and `3` without dot `2` appearing beforehand is invalid because the line from dot `1` to dot `3` passes through the center of dot `2`.\n\nHere are some example valid and invalid unlock patterns:\n\n*   The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n*   The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n*   The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n*   The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return _the **number of unique and valid unlock patterns** of the Android grid lock screen that consist of **at least**_ `m` _keys and **at most**_ `n` _keys._\n\nTwo unlock patterns are considered **unique** if there is a dot in one sequence that is not in the other, or the order of the dots is different.",
            "examples": [
                "**Example 1:**\n\n**Input:** m = 1, n = 1\n**Output:** 9\n\n",
                "**Example 2:**\n\n**Input:** m = 1, n = 2\n**Output:** 65"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= m, n <= 9`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numberOfPatterns(int m, int n) {\n    int[][] jumps = new int[10][10];\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    boolean[] visited = new boolean[10];\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nprivate int dfs(int[][] jumps, boolean[] visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "c++": "\n    ```cpp\nint numberOfPatterns(int m, int n) {\n    const vector<vector<int>> jumps(10, vector<int>(10, 0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    vector<bool> visited(10, false);\n\n    int cnt = 0;\n    for (int i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n}\n\nint dfs(const vector<vector<int>>& jumps, vector<bool>& visited, int curr, int remaining) {\n    if (remaining < 0) return 0;\n    if (remaining == 0) return 1;\n\n    visited[curr] = true;\n    int cnt = 0;\n    for (int next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] == 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "python": "\n    ```python\ndef numberOfPatterns(m: int, n: int) -> int:\n    def dfs(curr, remaining):\n        if remaining < 0:\n            return 0\n        if remaining == 0:\n            return 1\n\n        visited[curr] = True\n        cnt = 0\n        for next in range(1, 10):\n            if not visited[next] and (jumps[curr][next] == 0 or visited[jumps[curr][next]]):\n                cnt += dfs(next, remaining - 1)\n        visited[curr] = False\n\n        return cnt\n\n    jumps = [[0] * 10 for _ in range(10)]\n    jumps[1][3] = jumps[3][1] = 2\n    jumps[1][7] = jumps[7][1] = 4\n    jumps[3][9] = jumps[9][3] = 6\n    jumps[7][9] = jumps[9][7] = 8\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5\n\n    visited = [False] * 10\n\n    cnt = 0\n    for i in range(m, n + 1):\n        cnt += dfs(1, i - 1) * 4  # 1, 3, 7, 9\n        cnt += dfs(2, i - 1) * 4  # 2, 4, 6, 8\n        cnt += dfs(5, i - 1)      # 5\n\n    return cnt\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "javascript": "\n    ```javascript\nvar numberOfPatterns = function(m, n) {\n    const jumps = Array.from({length: 10}, () => Array(10).fill(0));\n    jumps[1][3] = jumps[3][1] = 2;\n    jumps[1][7] = jumps[7][1] = 4;\n    jumps[3][9] = jumps[9][3] = 6;\n    jumps[7][9] = jumps[9][7] = 8;\n    jumps[1][9] = jumps[9][1] = jumps[2][8] = jumps[8][2] = jumps[3][7] = jumps[7][3] = jumps[4][6] = jumps[6][4] = 5;\n\n    const visited = Array(10).fill(false);\n\n    let cnt = 0;\n    for (let i = m; i <= n; ++i) {\n        cnt += dfs(jumps, visited, 1, i - 1) * 4; // 1, 3, 7, 9\n        cnt += dfs(jumps, visited, 2, i - 1) * 4; // 2, 4, 6, 8\n        cnt += dfs(jumps, visited, 5, i - 1);     // 5\n    }\n\n    return cnt;\n};\n\nfunction dfs(jumps, visited, curr, remaining) {\n    if (remaining < 0) return 0;\n    if (remaining === 0) return 1;\n\n    visited[curr] = true;\n    let cnt = 0;\n    for (let next = 1; next <= 9; ++next) {\n        if (!visited[next] && (jumps[curr][next] === 0 || visited[jumps[curr][next]])) {\n            cnt += dfs(jumps, visited, next, remaining - 1);\n        }\n    }\n    visited[curr] = false;\n\n    return cnt;\n}\n```\n\n    \n    The algorithm starts with a depth-first search (DFS) approach to explore all the possible combinations of the unlock patterns. We create a `jumps` matrix to store the condition that if a line segment between any two points passes through another point, the number in the `jumps` matrix represents the middle point.\n\nThe DFS function starts at a certain point and recursively explores all the possible points that can be reached according to the rules. It keeps track of visited points using the `visited` array. The DFS function returns the count of valid patterns for the range of `m` to `n`.\n\nFor each iteration from `m` to `n`, we calculate the number of valid unlock patterns, and we multiply the results by 4 since the grid is symmetric (e.g., patterns starting with 1, 3, 7, 9 are equivalent, and patterns starting with 2, 4, 6, 8 are equivalent). We do this for each corner and side midpoints separately. Finally, we add the count for the center point (5), and return the total count.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " m = 1, n = 1",
                    "output": " 9",
                    "explanation": null
                },
                {
                    "input": " m = 1, n = 2",
                    "output": " 65",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,1",
                    "output": "9"
                },
                {
                    "input": "1,2",
                    "output": "65"
                }
            ]
        },
        "task_id": "leetcode-benchmark-124",
        "prompt": "Android devices have a special lock screen with a `3 x 3` grid of dots. Users can set an \"unlock pattern \" by connecting the dots in a specific sequence, forming a series of joined line segments where each segment's endpoints are two consecutive dots in the sequence. A sequence of `k` dots is a **valid** unlock pattern if both of the following are true:\n\n*   All the dots in the sequence are **distinct**.\n*   If the line segment connecting two consecutive dots in the sequence passes through the **center** of any other dot, the other dot **must have previously appeared** in the sequence. No jumps through the center non-selected dots are allowed.\n    *   For example, connecting dots `2` and `9` without dots `5` or `6` appearing beforehand is valid because the line from dot `2` to dot `9` does not pass through the center of either dot `5` or `6`.\n    *   However, connecting dots `1` and `3` without dot `2` appearing beforehand is invalid because the line from dot `1` to dot `3` passes through the center of dot `2`.\n\nHere are some example valid and invalid unlock patterns:\n\n*   The 1st pattern `[4,1,3,6]` is invalid because the line connecting dots `1` and `3` pass through dot `2`, but dot `2` did not previously appear in the sequence.\n*   The 2nd pattern `[4,1,9,2]` is invalid because the line connecting dots `1` and `9` pass through dot `5`, but dot `5` did not previously appear in the sequence.\n*   The 3rd pattern `[2,4,1,3,6]` is valid because it follows the conditions. The line connecting dots `1` and `3` meets the condition because dot `2` previously appeared in the sequence.\n*   The 4th pattern `[6,5,4,1,9,2]` is valid because it follows the conditions. The line connecting dots `1` and `9` meets the condition because dot `5` previously appeared in the sequence.\n\nGiven two integers `m` and `n`, return _the **number of unique and valid unlock patterns** of the Android grid lock screen that consist of **at least**_ `m` _keys and **at most**_ `n` _keys._\n\nTwo unlock patterns are considered **unique** if there is a dot in one sequence that is not in the other, or the order of the dots is different."
    },
    "leetcode-benchmark-125": {
        "id": "leetcode-benchmark-125",
        "title": "Line Reflection",
        "difficulty": "Medium",
        "content": {
            "problem": "Given `n` points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.\n\nIn other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.\n\n**Note** that there can be repeated points.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[-1,1\\]\\]\n**Output:** true\n**Explanation:** We can choose the line x = 0.\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[-1,-1\\]\\]\n**Output:** false\n**Explanation:** We can't choose a line."
            ],
            "constraints": "**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 104`\n*   `-108 <= points[i][j] <= 108`\n\n**",
            "follow_up": "Follow up:** Could you do better than `O(n2)`?"
        },
        "java": "\n    ```java\npublic boolean isReflected(int[][] points) {\n    int minX = Integer.MAX_VALUE;\n    int maxX = Integer.MIN_VALUE;\n    Set<String> pointSet = new HashSet<>();\n\n    for (int[] point : points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    int sum = minX + maxX;\n    for (int[] point : points) {\n        if (!pointSet.contains((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "c++": "\n    ```cpp\nbool isReflected(vector<vector<int>>& points) {\n    int minX = INT_MAX;\n    int maxX = INT_MIN;\n\n    unordered_set<string> pointSet;\n    for(const auto& point : points) {\n        minX = min(minX, point[0]);\n        maxX = max(maxX, point[0]);\n        pointSet.insert(to_string(point[0]) + \",\" + to_string(point[1]));\n    }\n\n    int sum = minX + maxX;\n    for(const auto& point : points) {\n        if(!pointSet.count(to_string(sum - point[0]) + \",\" + to_string(point[1]))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "python": "\n    ```python\ndef isReflected(points):\n    min_x = min(point[0] for point in points)\n    max_x = max(point[0] for point in points)\n    point_set = {(point[0], point[1]) for point in points}\n    \n    sum_x = min_x + max_x\n    for point in points:\n        if (sum_x - point[0], point[1]) not in point_set:\n            return False\n\n    return True\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "javascript": "\n    ```javascript\nfunction isReflected(points) {\n    let minX = Infinity;\n    let maxX = -Infinity;\n    const pointSet = new Set();\n\n    for (const point of points) {\n        minX = Math.min(minX, point[0]);\n        maxX = Math.max(maxX, point[0]);\n        pointSet.add(point[0] + \",\" + point[1]);\n    }\n\n    const sum = minX + maxX;\n    for (const point of points) {\n        if (!pointSet.has((sum - point[0]) + \",\" + point[1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```\n    \n    1. Iterate through the points and find the minimum and maximum x coordinates. Also, save all points as string (x,y) in a set.\n2. Calculate the sum of min_x and max_x (this will give the x-coordinate of the line of reflection).\n3. Iterate through the points again and check if the reflection point is in the set of points (using the calculated sum from step 2).\n4. If all reflection points exist in the set, return true. Otherwise, return false.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " points = [[1,1],[-1,1]]",
                    "output": " True",
                    "explanation": " We can choose the line x = 0."
                },
                {
                    "input": " points = [[1,1],[-1,-1]]",
                    "output": " False",
                    "explanation": " We can't choose a line."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,1],[-1,1]]",
                    "output": "True"
                },
                {
                    "input": "[[1,1],[-1,-1]]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-125",
        "prompt": "Given `n` points on a 2D plane, find if there is such a line parallel to the y-axis that reflects the given points symmetrically.\n\nIn other words, answer whether or not if there exists a line that after reflecting all points over the given line, the original points' set is the same as the reflected ones.\n\n**Note** that there can be repeated points."
    },
    "leetcode-benchmark-126": {
        "id": "leetcode-benchmark-126",
        "title": "Count Numbers with Unique Digits",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 2\n**Output:** 91\n**Explanation:** The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99\n\n",
                "**Example 2:**\n\n**Input:** n = 0\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `0 <= n <= 8`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n\n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "c++": "\n    ```cpp\nint countNumbersWithUniqueDigits(int n) {\n    if (n == 0) return 1;\n    \n    int total = 10;\n    int uniqueDigits = 9;\n    int currentAvailableDigits = 9;\n    \n    while(n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n    \n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "python": "\n    ```python\ndef countNumbersWithUniqueDigits(n):\n    if n == 0:\n        return 1\n    \n    total = 10\n    unique_digits = 9\n    current_available_digits = 9\n    \n    while n > 1 and current_available_digits > 0:\n        unique_digits *= current_available_digits\n        total += unique_digits\n        current_available_digits -= 1\n        n -= 1\n        \n    return total\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction countNumbersWithUniqueDigits(n) {\n    if (n === 0) return 1;\n\n    let total = 10;\n    let uniqueDigits = 9;\n    let currentAvailableDigits = 9;\n\n    while (n-- > 1 && currentAvailableDigits > 0) {\n        uniqueDigits *= currentAvailableDigits;\n        total += uniqueDigits;\n        currentAvailableDigits--;\n    }\n\n    return total;\n}\n```\n\n    \n    The algorithm starts with a base case when n=0, the result is 1, as there's only one number, 0, that has unique digits.\n\nFor other cases, it initializes total count to 10 (0 to 9), the unique digit count to 9, and the available digits count to 9. Then, it iterates until n becomes 1 or the available digits count becomes 0. In each iteration, the unique digit count is multiplied by the available digit count, which is then added to the total count. The available digit count is decremented in each iteration, as there will be one less digit to choose from to keep the numbers unique.\n\nAt the end, the total count is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 2",
                    "output": " 91",
                    "explanation": " The answer should be the total numbers in the range of 0 <= x < 100, excluding 11,22,33,44,55,66,77,88,99"
                },
                {
                    "input": " n = 0",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2",
                    "output": "91"
                },
                {
                    "input": "0",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-126",
        "prompt": "Given an integer `n`, return the count of all numbers with unique digits, `x`, where `0 <= x < 10n`."
    },
    "leetcode-benchmark-127": {
        "id": "leetcode-benchmark-127",
        "title": "Sort Transformed Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a **sorted** integer array `nums` and three integers `a`, `b` and `c`, apply a quadratic function of the form `f(x) = ax2 + bx + c` to each element `nums[i]` in the array, and return _the array in a sorted order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[-4,-2,2,4\\], a = 1, b = 3, c = 5\n**Output:** \\[3,9,15,33\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[-4,-2,2,4\\], a = -1, b = 3, c = 5\n**Output:** \\[-23,-5,1,7\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `-100 <= nums[i], a, b, c <= 100`\n*   `nums` is sorted in **ascending** order.\n\n**",
            "follow_up": "Follow up:** Could you solve it in `O(n)` time?"
        },
        "java": "\n    ```java\npublic int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n    int[] result = new int[nums.length];\n    int i = 0, j = nums.length - 1, index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "c++": "\n    ```cpp\nvector<int> sortTransformedArray(vector<int>& nums, int a, int b, int c) {\n    vector<int> result(nums.size());\n    int i = 0, j = nums.size() - 1, index = (a >= 0) ? nums.size() - 1 : 0;\n    \n    while (i <= j) {\n        int left = nums[i] * nums[i] * a + nums[i] * b + c;\n        int right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "python": "\n    ```python\ndef sort_transformed_array(nums, a, b, c):\n    result = [0] * len(nums)\n    i, j = 0, len(nums) - 1\n    index = len(nums) - 1 if a >= 0 else 0\n    \n    while i <= j:\n        left = nums[i] * nums[i] * a + nums[i] * b + c\n        right = nums[j] * nums[j] * a + nums[j] * b + c\n        \n        if a >= 0:\n            if left >= right:\n                result[index] = left\n                index -= 1\n                i += 1\n            else:\n                result[index] = right\n                index -= 1\n                j -= 1\n        else:\n            if left <= right:\n                result[index] = left\n                index += 1\n                i += 1\n            else:\n                result[index] = right\n                index += 1\n                j -= 1\n    return result\n```\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "javascript": "\n    ```javascript\nfunction sortTransformedArray(nums, a, b, c) {\n    let result = new Array(nums.length);\n    let i = 0, j = nums.length - 1;\n    let index = (a >= 0) ? nums.length - 1 : 0;\n    \n    while (i <= j) {\n        let left = nums[i] * nums[i] * a + nums[i] * b + c;\n        let right = nums[j] * nums[j] * a + nums[j] * b + c;\n        \n        if (a >= 0) {\n            if (left >= right) {\n                result[index--] = left;\n                i++;\n            } else {\n                result[index--] = right;\n                j--;\n            }\n        } else {\n            if (left <= right) {\n                result[index++] = left;\n                i++;\n            } else {\n                result[index++] = right;\n                j--;\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    The given sorted array needs to be transformed by applying the given quadratic function: f(x) = ax^2 + bx + c. We need to return the new array in sorted order. To solve this problem in O(n) time, we utilize a two-pointer technique. Initialize pointers, i and j, at the beginning and end of the array. Depending on whether the given coefficient 'a' is positive or negative, we'll determine how the values are sorted after transformation when calculated from left or right of the array.\n\nIf 'a' is positive or zero, the parabola of the quadratic function opens upward, meaning larger x values will yield a higher f(x). So, we traverse the array, compare the quadratic function at the indices i and j, and fill the result array from the end to the beginning. If the value at i is greater, store it at current index index, decrement index, and increment i. If value at j is greater or equal, store it and decrement j and index.\n\nOn the other hand, if 'a' is negative, the parabola opens downward, meaning smaller x values will yield a higher f(x). In this case, compare the quadratic function at the indices i and j, fill the result array from the beginning to the end. If the value at i is smaller or equal, store it at current index index, increment index and i. If value at j is smaller, store it and decrement j, then increment index. Once i > j, the result array is fully filled with the sorted transformed values.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [-4,-2,2,4], a = 1, b = 3, c = 5",
                    "output": " [3,9,15,33]",
                    "explanation": null
                },
                {
                    "input": " nums = [-4,-2,2,4], a = -1, b = 3, c = 5",
                    "output": " [-23,-5,1,7]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[-4,-2,2,4],1,3,5",
                    "output": "[3,9,15,33]"
                },
                {
                    "input": "[-4,-2,2,4],-1,3,5",
                    "output": "[-23,-5,1,7]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-127",
        "prompt": "Given a **sorted** integer array `nums` and three integers `a`, `b` and `c`, apply a quadratic function of the form `f(x) = ax2 + bx + c` to each element `nums[i]` in the array, and return _the array in a sorted order_."
    },
    "leetcode-benchmark-128": {
        "id": "leetcode-benchmark-128",
        "title": "Bomb Enemy",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed.",
            "examples": [
                "**Example 1:**\n\n**Input:** grid = \\[\\[ \"0 \", \"E \", \"0 \", \"0 \"\\],\\[ \"E \", \"0 \", \"W \", \"E \"\\],\\[ \"0 \", \"E \", \"0 \", \"0 \"\\]\\]\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** grid = \\[\\[ \"W \", \"W \", \"W \"\\],\\[ \"0 \", \"0 \", \"0 \"\\],\\[ \"E \", \"E \", \"E \"\\]\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 500`\n*   `grid[i][j]` is either `'W'`, `'E'`, or `'0'`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxKilledEnemies(char[][] grid) {\n    if (grid.length == 0) return 0;\n    int m = grid.length, n = grid[0].length, result = 0, rowhits;\n    int[] colhits = new int[n];\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j-1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E' ? 1 : 0;\n            }\n            if (i == 0 || grid[i-1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E' ? 1 : 0;\n            }\n            if (grid[i][j] == '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "c++": "\n    ```cpp\nint maxKilledEnemies(vector<vector<char>>& grid) {\n    if (grid.empty()) return 0;\n    int m = grid.size(), n = grid[0].size(), result = 0, rowhits = 0;\n    vector<int> colhits(n, 0);\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0 || grid[i][j - 1] == 'W') {\n                rowhits = 0;\n                for (int k = j; k < n && grid[i][k] != 'W'; k++)\n                    rowhits += grid[i][k] == 'E';\n            }\n            if (i == 0 || grid[i - 1][j] == 'W') {\n                colhits[j] = 0;\n                for (int k = i; k < m && grid[k][j] != 'W'; k++)\n                    colhits[j] += grid[k][j] == 'E';\n            }\n            if (grid[i][j] == '0') result = max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "python": "\n    ```python\ndef maxKilledEnemies(grid):\n    if not grid: return 0\n    m, n, result, rowhits = len(grid), len(grid[0]), 0, 0\n    colhits = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if j == 0 or grid[i][j - 1] == 'W':\n                rowhits = 0\n                k = j\n                while k < n and grid[i][k] != 'W':\n                    rowhits += grid[i][k] == 'E'\n                    k += 1\n            if i == 0 or grid[i - 1][j] == 'W':\n                colhits[j] = 0\n                k = i\n                while k < m and grid[k][j] != 'W':\n                    colhits[j] += grid[k][j] == 'E'\n                    k += 1\n            if grid[i][j] == '0':\n                result = max(result, rowhits + colhits[j])\n    return result\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "javascript": "\n    ```javascript\nfunction maxKilledEnemies(grid) {\n    if (!grid.length) return 0;\n    let m = grid.length, n = grid[0].length, result = 0, rowhits;\n    let colhits = new Array(n).fill(0);\n    for (let i = 0; i < m; i++) {\n        for (let j = 0; j < n; j++) {\n            if (j === 0 || grid[i][j - 1] === 'W') {\n                rowhits = 0;\n                for (let k = j; k < n && grid[i][k] !== 'W'; k++)\n                    rowhits += grid[i][k] === 'E' ? 1 : 0;\n            }\n            if (i === 0 || grid[i - 1][j] === 'W') {\n                colhits[j] = 0;\n                for (let k = i; k < m && grid[k][j] !== 'W'; k++)\n                    colhits[j] += grid[k][j] === 'E' ? 1 : 0;\n            }\n            if (grid[i][j] === '0') result = Math.max(result, rowhits + colhits[j]);\n        }\n    }\n    return result;\n}\n```\n    \n    Initialize `result` to keep track of the maximum number of enemies that can be killed. Then, initialize `rowhits` and `colhits` to store the number of enemies in the current row and column.\n\nLoop through the `grid`. When you start a new row or encounter a wall in the previous cell, reset `rowhits` and count the number of enemies in the row. If you are in the first row, or encounter a wall in the cell above, reset the `colhits` for that column and count the number of enemies in the column.\n \nIf you encounter an empty cell, update the `result` with the maximum of its current value and the sum of `rowhits` and `colhits` for that position.\n\nReturn `result`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " grid = [[ \"0 \", \"E \", \"0 \", \"0 \"],[ \"E \", \"0 \", \"W \", \"E \"],[ \"0 \", \"E \", \"0 \", \"0 \"]]",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " grid = [[ \"W \", \"W \", \"W \"],[ \"0 \", \"0 \", \"0 \"],[ \"E \", \"E \", \"E \"]]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"0\",\"E\",\"0\",\"0\"],[\"E\",\"0\",\"W\",\"E\"],[\"0\",\"E\",\"0\",\"0\"]]",
                    "output": "3"
                },
                {
                    "input": "[[\"W\",\"W\",\"W\"],[\"0\",\"0\",\"0\"],[\"E\",\"E\",\"E\"]]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-128",
        "prompt": "Given an `m x n` matrix `grid` where each cell is either a wall `'W'`, an enemy `'E'` or empty `'0'`, return _the maximum enemies you can kill using one bomb_. You can only place the bomb in an empty cell.\n\nThe bomb kills all the enemies in the same row and column from the planted point until it hits the wall since it is too strong to be destroyed."
    },
    "leetcode-benchmark-129": {
        "id": "leetcode-benchmark-129",
        "title": "Water and Jug Problem",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given two jugs with capacities `jug1Capacity` and `jug2Capacity` liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly `targetCapacity` liters using these two jugs.\n\nIf `targetCapacity` liters of water are measurable, you must have `targetCapacity` liters of water contained **within one or both buckets** by the end.\n\nOperations allowed:\n\n*   Fill any of the jugs with water.\n*   Empty any of the jugs.\n*   Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty.",
            "examples": [
                "**Example 1:**\n\n**Input:** jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\n**Output:** true\n**Explanation:** The famous [Die Hard](https://www.youtube.com/watch?v=BVtQNK_ZUJg&ab_channel=notnek01) example \n\n",
                "**Example 2:**\n\n**Input:** jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\n**Output:** false\n\n",
                "**Example 3:**\n\n**Input:** jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3\n**Output:** true"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= jug1Capacity, jug2Capacity, targetCapacity <= 106`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nprivate int gcd(int a, int b) {\n    while (b != 0) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n```\n\n    \n    To measure exactly targetCapacity liters using the two jugs, we need to use their GCD (Greatest Common Divisor). The problem can be solved using the mathematical property that the target capacity should be divisible by the GCD of jug1Capacity and jug2Capacity.\n\nFirst, we calculate GCD of the two jug capacities.\nThen, we check if the target capacity is smaller than or equal to the sum of the two jug capacities. If not, it's impossible to get targetCapacity liters.\nReturn true if targetCapacity is equal to either of the jug capacities or their sum, as it's achievable without performing any GCD checks.\nThen, we simply check if targetCapacity is divisible by the GCD of the two jug capacities, returning true if so.\n\nThe algorithm uses a single GCD calculation and a few checks to determine whether it's possible to measure the target capacity or not, making it fast and efficient.\n    ",
        "c++": "\n    ```cpp\nbool canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n}\n\nint gcd(int a, int b) {\n    while (b) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n```\n\n    \n    To measure exactly targetCapacity liters using the two jugs, we need to use their GCD (Greatest Common Divisor). The problem can be solved using the mathematical property that the target capacity should be divisible by the GCD of jug1Capacity and jug2Capacity.\n\nFirst, we calculate GCD of the two jug capacities.\nThen, we check if the target capacity is smaller than or equal to the sum of the two jug capacities. If not, it's impossible to get targetCapacity liters.\nReturn true if targetCapacity is equal to either of the jug capacities or their sum, as it's achievable without performing any GCD checks.\nThen, we simply check if targetCapacity is divisible by the GCD of the two jug capacities, returning true if so.\n\nThe algorithm uses a single GCD calculation and a few checks to determine whether it's possible to measure the target capacity or not, making it fast and efficient.\n    ",
        "python": "\n    ```python\ndef canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity):\n    if targetCapacity > jug1Capacity + jug2Capacity:\n        return False\n    if jug1Capacity == targetCapacity or jug2Capacity == targetCapacity or jug1Capacity + jug2Capacity == targetCapacity:\n        return True\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n```\n\n    \n    To measure exactly targetCapacity liters using the two jugs, we need to use their GCD (Greatest Common Divisor). The problem can be solved using the mathematical property that the target capacity should be divisible by the GCD of jug1Capacity and jug2Capacity.\n\nFirst, we calculate GCD of the two jug capacities.\nThen, we check if the target capacity is smaller than or equal to the sum of the two jug capacities. If not, it's impossible to get targetCapacity liters.\nReturn true if targetCapacity is equal to either of the jug capacities or their sum, as it's achievable without performing any GCD checks.\nThen, we simply check if targetCapacity is divisible by the GCD of the two jug capacities, returning true if so.\n\nThe algorithm uses a single GCD calculation and a few checks to determine whether it's possible to measure the target capacity or not, making it fast and efficient.\n    ",
        "javascript": "\n    ```javascript\nfunction canMeasureWater(jug1Capacity, jug2Capacity, targetCapacity) {\n    if (targetCapacity > jug1Capacity + jug2Capacity) return false;\n    if (jug1Capacity == targetCapacity || jug2Capacity == targetCapacity \n        || jug1Capacity + jug2Capacity == targetCapacity) return true;\n    return targetCapacity % gcd(jug1Capacity, jug2Capacity) === 0;\n}\n\nfunction gcd(a, b) {\n    while (b) {\n        let tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n```\n    \n    To measure exactly targetCapacity liters using the two jugs, we need to use their GCD (Greatest Common Divisor). The problem can be solved using the mathematical property that the target capacity should be divisible by the GCD of jug1Capacity and jug2Capacity.\n\nFirst, we calculate GCD of the two jug capacities.\nThen, we check if the target capacity is smaller than or equal to the sum of the two jug capacities. If not, it's impossible to get targetCapacity liters.\nReturn true if targetCapacity is equal to either of the jug capacities or their sum, as it's achievable without performing any GCD checks.\nThen, we simply check if targetCapacity is divisible by the GCD of the two jug capacities, returning true if so.\n\nThe algorithm uses a single GCD calculation and a few checks to determine whether it's possible to measure the target capacity or not, making it fast and efficient.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4",
                    "output": " True",
                    "explanation": " The famous [Die Hard](https://www.youtube.com/watch?v=BVtQNK_ZUJg&ab_channel=notnek01) example"
                },
                {
                    "input": " jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5",
                    "output": " False",
                    "explanation": null
                },
                {
                    "input": " jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3",
                    "output": " True",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "3,5,4",
                    "output": "True"
                },
                {
                    "input": "2,6,5",
                    "output": "False"
                },
                {
                    "input": "1,2,3",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-129",
        "prompt": "You are given two jugs with capacities `jug1Capacity` and `jug2Capacity` liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly `targetCapacity` liters using these two jugs.\n\nIf `targetCapacity` liters of water are measurable, you must have `targetCapacity` liters of water contained **within one or both buckets** by the end.\n\nOperations allowed:\n\n*   Fill any of the jugs with water.\n*   Empty any of the jugs.\n*   Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty."
    },
    "leetcode-benchmark-130": {
        "id": "leetcode-benchmark-130",
        "title": "Largest Divisible Subset",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a set of **distinct** positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:\n\n*   `answer[i] % answer[j] == 0`, or\n*   `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions, return any of them.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\]\n**Output:** \\[1,2\\]\n**Explanation:** \\[1,3\\] is also accepted.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,4,8\\]\n**Output:** \\[1,2,4,8\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `1 <= nums[i] <= 2 * 109`\n*   All the integers in `nums` are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic List<Integer> largestDivisibleSubset(int[] nums) {\n    Arrays.sort(nums);\n    int n = nums.length;\n    int[] count = new int[n];\n    int[] prev = new int[n];\n    int max_idx = 0;\n    Arrays.fill(prev, -1);\n    Arrays.fill(count, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    List<Integer> res = new ArrayList<>();\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.add(nums[i]);\n    }\n\n    return res;\n}\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> largestDivisibleSubset(vector<int>& nums) {\n    sort(nums.begin(), nums.end());\n    int n = nums.size();\n    vector<int> count(n, 1), prev(n, -1), res;\n    int max_idx = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] % nums[j] == 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) max_idx = i;\n    }\n\n    for (int i = max_idx; i >= 0; i = prev[i]) {\n        res.push_back(nums[i]);\n    }\n\n    return res;\n}\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ",
        "python": "\n    ```python\ndef largestDivisibleSubset(nums):\n    nums.sort()\n    n = len(nums)\n    count = [1] * n\n    prev = [-1] * n\n\n    max_idx = 0\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and count[i] < count[j] + 1:\n                count[i] = count[j] + 1\n                prev[i] = j\n        if count[max_idx] < count[i]:\n            max_idx = i\n\n    res = []\n    i = max_idx\n    while i >= 0:\n        res.append(nums[i])\n        i = prev[i]\n\n    return res\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ",
        "javascript": "\n    ```javascript\nfunction largestDivisibleSubset(nums) {\n    nums.sort((a, b) => a - b);\n    const n = nums.length;\n    const count = new Array(n).fill(1);\n    const prev = new Array(n).fill(-1);\n    let max_idx = 0;\n\n    for (let i = 1; i < n; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] % nums[j] === 0 && count[i] < count[j] + 1) {\n                count[i] = count[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (count[max_idx] < count[i]) {\n            max_idx = i;\n        }\n    }\n\n    const res = [];\n    for (let i = max_idx; i >= 0; i = prev[i]) {\n        res.push(nums[i]);\n    }\n\n    return res;\n}\n```\n    \n    1. Sort the input array.\n2. Initialize two arrays: count and prev, both with the same length as the input array.\n   - count will store the length of the largest subsets ending at index i.\n   - prev stores the index of the previous element in the largest subset.\n3. Initialize max_idx to store the index of the maximum count.\n4. Loop through the sorted array, and for each element, compare it with its previous elements.\n   - If it is divisible by the previous element, update the count and prev arrays accordingly.\n5. After looping and updating the arrays, use max_idx to trace back the elements forming the largest subset.\n6. Return the largest subset.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3]",
                    "output": " [1,2]",
                    "explanation": " \\[1,3\\] is also accepted."
                },
                {
                    "input": " nums = [1,2,4,8]",
                    "output": " [1,2,4,8]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3]",
                    "output": "[1,2]"
                },
                {
                    "input": "[1,2,4,8]",
                    "output": "[1,2,4,8]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-130",
        "prompt": "Given a set of **distinct** positive integers `nums`, return the largest subset `answer` such that every pair `(answer[i], answer[j])` of elements in this subset satisfies:\n\n*   `answer[i] % answer[j] == 0`, or\n*   `answer[j] % answer[i] == 0`\n\nIf there are multiple solutions, return any of them."
    },
    "leetcode-benchmark-131": {
        "id": "leetcode-benchmark-131",
        "title": "Range Addition",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.\n\nYou have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.\n\nReturn `arr` _after applying all the_ `updates`.",
            "examples": [
                "**Example 1:**\n\n**Input:** length = 5, updates = \\[\\[1,3,2\\],\\[2,4,3\\],\\[0,2,-2\\]\\]\n**Output:** \\[-2,0,3,5,3\\]\n\n",
                "**Example 2:**\n\n**Input:** length = 10, updates = \\[\\[2,4,6\\],\\[5,6,8\\],\\[1,9,-4\\]\\]\n**Output:** \\[0,-4,2,2,2,4,4,-4,-4,-4\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= length <= 105`\n*   `0 <= updates.length <= 104`\n*   `0 <= startIdxi <= endIdxi < length`\n*   `-1000 <= inci <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int[] getUpdatedArray(int length, int[][] updates) {\n    int[] arr = new int[length];\n\n    for (int[] update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nvector<int> getUpdatedArray(int length, vector<vector<int>>& updates) {\n    vector<int> arr(length, 0);\n\n    for (const auto& update : updates) {\n        arr[update[0]] += update[2];\n        if (update[1] + 1 < length) {\n            arr[update[1] + 1] -= update[2];\n        }\n    }\n    \n    for (int i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n    \n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "python": "\n    ```python\ndef get_updated_array(length, updates):\n    arr = [0] * length\n\n    for start, end, inc in updates:\n        arr[start] += inc\n        if end + 1 < length:\n            arr[end + 1] -= inc\n\n    for i in range(1, length):\n        arr[i] += arr[i - 1]\n\n    return arr\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "javascript": "\n    ```javascript\nfunction getUpdatedArray(length, updates) {\n    const arr = new Array(length).fill(0);\n\n    for (const [start, end, inc] of updates) {\n        arr[start] += inc;\n        if (end + 1 < length) {\n            arr[end + 1] -= inc;\n        }\n    }\n\n    for (let i = 1; i < length; i++) {\n        arr[i] += arr[i - 1];\n    }\n\n    return arr;\n}\n```\n    \n    The algorithm starts by initializing an array `arr` of length `length` with all zeros. Then, it iterates over each update and simulates its effect on the array. For every update `[startIdx, endIdx, inc]`, the algorithm increases the value at index `startIdx` by `inc` and decreases the value at index `endIdx + 1` by `inc`, assuming `endIdx + 1` is within the bounds of the array. The reason behind this is that it will later make the algorithm simpler.\n\nAfter processing all the updates, the actual values of the elements in the array are calculated using cumulative sums. The idea is that, for each element in the array after the first one, the final value is the previous value plus the current value. This will properly include the increments and decrements for each range from the updates.\n\nFinally, the algorithm returns the updated array.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]",
                    "output": " [-2,0,3,5,3]",
                    "explanation": null
                },
                {
                    "input": " length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]",
                    "output": " [0,-4,2,2,2,4,4,-4,-4,-4]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "5,[[1,3,2],[2,4,3],[0,2,-2]]",
                    "output": "[-2,0,3,5,3]"
                },
                {
                    "input": "10,[[2,4,6],[5,6,8],[1,9,-4]]",
                    "output": "[0,-4,2,2,2,4,4,-4,-4,-4]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-131",
        "prompt": "You are given an integer `length` and an array `updates` where `updates[i] = [startIdxi, endIdxi, inci]`.\n\nYou have an array `arr` of length `length` with all zeros, and you have some operation to apply on `arr`. In the `ith` operation, you should increment all the elements `arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi]` by `inci`.\n\nReturn `arr` _after applying all the_ `updates`."
    },
    "leetcode-benchmark-132": {
        "id": "leetcode-benchmark-132",
        "title": "Sum of Two Integers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two integers `a` and `b`, return _the sum of the two integers without using the operators_ `+` _and_ `-`.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = 1, b = 2\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** a = 2, b = 3\n**Output:** 5"
            ],
            "constraints": "**Constraints:**\n\n*   `-1000 <= a, b <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "c++": "\n    ```cpp\nint add(int a, int b) {\n    while (b != 0) {\n        int carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "python": "\n    ```python\ndef add(a, b):\n    MAX = 0x7FFFFFFF\n    MASK = 0xFFFFFFFF\n    while b:\n        a, b = (a ^ b) & MASK, ((a & b) << 1) & MASK\n    return a if a <= MAX else ~(a ^ MASK)\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "javascript": "\n    ```javascript\nfunction add(a, b) {\n    while (b) {\n        let carry = a & b;\n        a = a ^ b;\n        b = carry << 1;\n    }\n    return a;\n}\n```\n    \n    The algorithm uses bitwise operations to add the two integers without using + or - operators. The addition process can be divided into two parts: addition without considering a carry and handling the carry generated. \n\n1. XOR (^) can be used for adding without carrying, as it sets the bit at a position if the bits in the two numbers being added are different at that position.\n2. AND (&) operation, followed by left shift (<<), is used to find the carry. With this operation, we find the bits which are set in both numbers, and they represent the carry. Then, we shift these bits to the left by one position, which is the correct position of the carry bit.\n\nFinally, we keep looping until there is no carry, at which point we have the sum of the two integers. In the Python implementation, extra steps are required due to the lack of fixed-size integers.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " a = 1, b = 2",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " a = 2, b = 3",
                    "output": " 5",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "1,2",
                    "output": "3"
                },
                {
                    "input": "2,3",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-132",
        "prompt": "Given two integers `a` and `b`, return _the sum of the two integers without using the operators_ `+` _and_ `-`."
    },
    "leetcode-benchmark-133": {
        "id": "leetcode-benchmark-133",
        "title": "Super Pow",
        "difficulty": "Medium",
        "content": {
            "problem": "Your task is to calculate `ab` mod `1337` where `a` is a positive integer and `b` is an extremely large positive integer given in the form of an array.",
            "examples": [
                "**Example 1:**\n\n**Input:** a = 2, b = \\[3\\]\n**Output:** 8\n\n",
                "**Example 2:**\n\n**Input:** a = 2, b = \\[1,0\\]\n**Output:** 1024\n\n",
                "**Example 3:**\n\n**Input:** a = 1, b = \\[4,3,3,8,5,2\\]\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= a <= 231 - 1`\n*   `1 <= b.length <= 2000`\n*   `0 <= b[i] <= 9`\n*   `b` does not contain leading zeros.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int powmod(int a, int b) {\n    if (b == 0) return 1;\n    int res = powmod(a, b / 2);\n    if (b % 2 == 0) return res * res % 1337;\n    return res * res % 1337 * a % 1337;\n}\n\npublic int superPow(int a, int[] b) {\n    int n = 0;\n    for (int bi : b) n = (n * 10 + bi) % 1140;\n    return powmod(a % 1337, n + 1140);\n}\n```\n    \n    - First, we create a utility `powmod` function to compute `a^b % 1337`. We can do this using the fast exponentiation technique, where for an even power, we recursively compute the square, and for an odd power, we additionally multiply by `a`.\n- For the main `superPow` function, we first convert the given array into a single integer `n`. Since, the power could be very large, we can instead calculate `(n % 1140) + 1140`, due to Fermat's Little Theorem and Euler's Theorem: `(a^((n))  1 (mod n))` so `a^(1140) % 1337 = 1` where  is Carmichael function.\n- Finally, we call our `powmod` function with `a % 1337` and `(n % 1140) + 1140` as the power.\n    ",
        "c++": "\n    ```cpp\nint powmod(int a, int b) {\n    if (b == 0) return 1;\n    int res = powmod(a, b / 2);\n    if (b % 2 == 0) return res * res % 1337;\n    return res * res % 1337 * a % 1337;\n}\n\nint superPow(int a, vector<int>& b) {\n    int n = 0;\n    for (int bi : b) n = (n * 10 + bi) % 1140;\n    return powmod(a % 1337, n + 1140);\n}\n```\n    \n    - First, we create a utility `powmod` function to compute `a^b % 1337`. We can do this using the fast exponentiation technique, where for an even power, we recursively compute the square, and for an odd power, we additionally multiply by `a`.\n- For the main `superPow` function, we first convert the given array into a single integer `n`. Since, the power could be very large, we can instead calculate `(n % 1140) + 1140`, due to Fermat's Little Theorem and Euler's Theorem: `(a^((n))  1 (mod n))` so `a^(1140) % 1337 = 1` where  is Carmichael function.\n- Finally, we call our `powmod` function with `a % 1337` and `(n % 1140) + 1140` as the power.\n    ",
        "python": "\n    ```python\ndef powmod(a, b):\n    if b == 0:\n        return 1\n    res = powmod(a, b // 2)\n    return res * res % 1337 * a % 1337 if b % 2 else res * res % 1337\n\ndef superPow(a, b):\n    n = 0\n    for bi in b:\n        n = (n * 10 + bi) % 1140\n    return powmod(a % 1337, n + 1140)\n```\n    \n    - First, we create a utility `powmod` function to compute `a^b % 1337`. We can do this using the fast exponentiation technique, where for an even power, we recursively compute the square, and for an odd power, we additionally multiply by `a`.\n- For the main `superPow` function, we first convert the given array into a single integer `n`. Since, the power could be very large, we can instead calculate `(n % 1140) + 1140`, due to Fermat's Little Theorem and Euler's Theorem: `(a^((n))  1 (mod n))` so `a^(1140) % 1337 = 1` where  is Carmichael function.\n- Finally, we call our `powmod` function with `a % 1337` and `(n % 1140) + 1140` as the power.\n    ",
        "javascript": "\n    ```javascript\nfunction powmod(a, b) {\n    if (b === 0) return 1;\n    const res = powmod(a, Math.floor(b / 2));\n    return b % 2 ? res * res % 1337 * a % 1337 : res * res % 1337;\n}\n\nfunction superPow(a, b) {\n    let n = 0;\n    for (const bi of b) n = (n * 10 + bi) % 1140;\n    return powmod(a % 1337, n + 1140);\n}\n```\n    \n    - First, we create a utility `powmod` function to compute `a^b % 1337`. We can do this using the fast exponentiation technique, where for an even power, we recursively compute the square, and for an odd power, we additionally multiply by `a`.\n- For the main `superPow` function, we first convert the given array into a single integer `n`. Since, the power could be very large, we can instead calculate `(n % 1140) + 1140`, due to Fermat's Little Theorem and Euler's Theorem: `(a^((n))  1 (mod n))` so `a^(1140) % 1337 = 1` where  is Carmichael function.\n- Finally, we call our `powmod` function with `a % 1337` and `(n % 1140) + 1140` as the power.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " a = 2, b = [3]",
                    "output": " 8",
                    "explanation": null
                },
                {
                    "input": " a = 2, b = [1,0]",
                    "output": " 1024",
                    "explanation": null
                },
                {
                    "input": " a = 1, b = [4,3,3,8,5,2]",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "2,[3]",
                    "output": "8"
                },
                {
                    "input": "2,[1,0]",
                    "output": "1024"
                },
                {
                    "input": "1,[4,3,3,8,5,2]",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-133",
        "prompt": "Your task is to calculate `ab` mod `1337` where `a` is a positive integer and `b` is an extremely large positive integer given in the form of an array."
    },
    "leetcode-benchmark-134": {
        "id": "leetcode-benchmark-134",
        "title": "Guess Number Higher or Lower II",
        "difficulty": "Medium",
        "content": {
            "problem": "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n",
                "**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 200`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int getMoneyAmount(int n) {\n    int[][] dp = new int[n + 1][n + 1];\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = Integer.MAX_VALUE;\n            for (int k = i; k < j; k++) {\n                int cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ",
        "c++": "\n    ```cpp\nint getMoneyAmount(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n    for (int i = n - 1; i >= 1; i--) {\n        for (int j = i + 1; j <= n; j++) {\n            int min_cost = INT_MAX;\n            for (int k = i; k < j; k++) {\n                int cost = k + max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ",
        "python": "\n    ```python\ndef getMoneyAmount(n: int) -> int:\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(n - 1, 0, -1):\n        for j in range(i + 1, n + 1):\n            min_cost = float(\"inf\")\n            for k in range(i, j):\n                cost = k + max(dp[i][k - 1], dp[k + 1][j])\n                min_cost = min(min_cost, cost)\n            dp[i][j] = min_cost\n    return dp[1][n]\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ",
        "javascript": "\n    ```javascript\nfunction getMoneyAmount(n) {\n    const dp = Array.from(Array(n + 1), () => Array(n + 1).fill(0));\n    for (let i = n - 1; i >= 1; i--) {\n        for (let j = i + 1; j <= n; j++) {\n            let min_cost = Infinity;\n            for (let k = i; k < j; k++) {\n                const cost = k + Math.max(dp[i][k - 1], dp[k + 1][j]);\n                min_cost = Math.min(min_cost, cost);\n            }\n            dp[i][j] = min_cost;\n        }\n    }\n    return dp[1][n];\n}\n```\n    \n    The algorithm uses dynamic programming to find the minimum cost required to guarantee a win. We create a 2D array `dp` where `dp[i][j]` represents the minimum cost required to guess the correct number from numbers between i and j inclusive.\n\nWe fill in this array from the bottom right corner, and move towards the top left corner. For each value of `i` and `j`, we calculate the cost by guessing a number `k` between `i` and `j`. The cost is equal to `k + max(dp[i][k-1], dp[k+1][j])`, which means that we pay `k` and take the worst-case scenario, and we try to minimize this cost.\n\nAfter filling the `dp` array, the minimum cost required to win the game when guessing numbers from 1 to `n` is stored in `dp[1][n]`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 10",
                    "output": " 16",
                    "explanation": " The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win."
                },
                {
                    "input": " n = 1",
                    "output": " 0",
                    "explanation": " There is only one possible number, so you can guess 1 and not have to pay anything."
                },
                {
                    "input": " n = 2",
                    "output": " 1",
                    "explanation": " There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1."
                }
            ],
            "function_input": [
                {
                    "input": "10",
                    "output": "16"
                },
                {
                    "input": "1",
                    "output": "0"
                },
                {
                    "input": "2",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-134",
        "prompt": "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_."
    },
    "leetcode-benchmark-135": {
        "id": "leetcode-benchmark-135",
        "title": "Wiggle Subsequence",
        "difficulty": "Medium",
        "content": {
            "problem": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,7,4,9,2,5\\]\n**Output:** 6\n**Explanation:** The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,17,5,10,13,15,10,5,16,8\\]\n**Output:** 7\n**Explanation:** There are several subsequences that achieve this length.\nOne is \\[1, 17, 10, 13, 10, 16, 8\\] with differences (16, -7, 3, -3, 6, -8).\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3,4,5,6,7,8,9\\]\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 1000`\n*   `0 <= nums[i] <= 1000`\n\n**",
            "follow_up": "Follow up:** Could you solve this in `O(n)` time?"
        },
        "java": "\n    ```java\npublic int wiggleMaxLength(int[] nums) {\n    int len = nums.length;\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ",
        "c++": "\n    ```cpp\nint wiggleMaxLength(vector<int>& nums) {\n    int len = nums.size();\n    if (len < 2) return len;\n\n    int up = 1, down = 1;\n    for (int i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ",
        "python": "\n    ```python\ndef wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up, down = 1, 1\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up = down + 1\n        elif nums[i] < nums[i - 1]:\n            down = up + 1\n    return max(up, down)\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ",
        "javascript": "\n    ```javascript\nfunction wiggleMaxLength(nums) {\n    let len = nums.length;\n    if (len < 2) return len;\n\n    let up = 1, down = 1;\n    for (let i = 1; i < len; ++i) {\n        if (nums[i] > nums[i - 1])\n            up = down + 1;\n        else if (nums[i] < nums[i - 1])\n            down = up + 1;\n    }\n    return Math.max(up, down);\n}\n```\n    \n    The algorithm uses dynamic programming to find the longest wiggle subsequence in a given array or list of integers. The dynamic programming consists of two parts: the longest increasing subsequence (up) and the longest decreasing subsequence (down).\n\nInitialize up and down to 1. Loop through the input array starting from index 1. For each element, if the current element is greater than the previous element, update `up` to be `down + 1`. If the current element is less than the previous element, update `down` to be `up + 1`.\n\nAfter iterating through the entire array, return the greater value between `up` and `down`, which represents the length of the longest wiggle sequence.\n\nThe algorithm's time complexity is O(n) since it iterates through the input array once, and its space complexity is O(1) as it only uses a constant amount of additional memory.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,7,4,9,2,5]",
                    "output": " 6",
                    "explanation": " The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3)."
                },
                {
                    "input": " nums = [1,17,5,10,13,15,10,5,16,8]",
                    "output": " 7",
                    "explanation": " There are several subsequences that achieve this length.\nOne is \\[1, 17, 10, 13, 10, 16, 8\\] with differences (16, -7, 3, -3, 6, -8)."
                },
                {
                    "input": " nums = [1,2,3,4,5,6,7,8,9]",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,7,4,9,2,5]",
                    "output": "6"
                },
                {
                    "input": "[1,17,5,10,13,15,10,5,16,8]",
                    "output": "7"
                },
                {
                    "input": "[1,2,3,4,5,6,7,8,9]",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-135",
        "prompt": "A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\n*   For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` alternate between positive and negative.\n*   In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\n\nA **subsequence** is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array `nums`, return _the length of the longest **wiggle subsequence** of_ `nums`."
    },
    "leetcode-benchmark-136": {
        "id": "leetcode-benchmark-136",
        "title": "Combination Sum IV",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], target = 4\n**Output:** 7\n**Explanation:**\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[9\\], target = 3\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 1000`\n*   All the elements of `nums` are **unique**.\n*   `1 <= target <= 1000`\n\n**",
            "follow_up": "Follow up:** What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?"
        },
        "java": "\n    ```java\npublic int combinationSum(int[] nums, int target) {\n    int[] dp = new int[target + 1];\n    dp[0] = 1;\n\n    for(int num : nums) {\n        for(int i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n\n    return dp[target];\n}\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nint combinationSum(vector<int>& nums, int target) {\n    vector<int> dp(target + 1, 0);\n    dp[0] = 1;\n    \n    for(int num : nums) {\n        for(int i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n    \n    return dp[target];\n}\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ",
        "python": "\n    ```python\ndef combination_sum(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n\n    for num in nums:\n        for i in range(num, target + 1):\n            dp[i] += dp[i - num]\n\n    return dp[target]\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ",
        "javascript": "\n    ```javascript\nfunction combinationSum(nums, target) {\n    let dp = new Array(target + 1).fill(0);\n    dp[0] = 1;\n\n    for(let num of nums) {\n        for(let i = num; i <= target; i++) {\n            dp[i] += dp[i - num];\n        }\n    }\n\n    return dp[target];\n}\n```\n\n    \n    The basic idea is to use dynamic programming to solve this question. We create an array called \"dp\" with a length of target + 1, initializing all values to 0 except for dp[0], which is set to 1. This is because there is always one way to make a sum of 0.\n\nWe then start iterating through the given `nums` array. For each number in the `nums` array, we iterate from the `num` itself to the `target`. At each step, we add the number of ways we can make the previous sub-target (i.e., `dp[i - num]`) and store this updated count in the `dp[i]`.\n\nFinally, after iterating through all numbers and sub-targets, the value at `dp[target]` will give the number of possible combinations that add up to `target`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3], target = 4",
                    "output": " 7",
                    "explanation": "\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations."
                },
                {
                    "input": " nums = [9], target = 3",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3],4",
                    "output": "7"
                },
                {
                    "input": "[9],3",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-136",
        "prompt": "Given an array of **distinct** integers `nums` and a target integer `target`, return _the number of possible combinations that add up to_ `target`.\n\nThe test cases are generated so that the answer can fit in a **32-bit** integer."
    },
    "leetcode-benchmark-137": {
        "id": "leetcode-benchmark-137",
        "title": "Lexicographical Numbers",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return all the numbers in the range `[1, n]` sorted in lexicographical order.\n\nYou must write an algorithm that runs in `O(n)` time and uses `O(1)` extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 13\n**Output:** \\[1,10,11,12,13,2,3,4,5,6,7,8,9\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 2\n**Output:** \\[1,2\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 5 * 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic static void lexicographicalOrderHelper(int current, int n, List<Integer> result) {\n    if (current > n) return;\n\n    result.add(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\npublic static List<Integer> lexicalOrder(int n) {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n```\n    \n    The algorithm relies on a helper function (`lexicographicalOrderHelper`) that takes the current number, n, and the result array as input. This helper function uses recursion to traverse the range of numbers from 1 to n in lexicographical order.\n\nFirst, the function checks if the current number is greater than n. If so, it returns. Otherwise, it adds the current number to the result array. Then, it loops through the digits 0 to 9, appending each digit to the current number and then recursively calling the function again with the updated value.\n\nThe main function (`lexicalOrder`) initializes the result array and iterates through the starting digits (1 to 9), calling the helper function for each starting digit.\n\nThe algorithm has a time complexity of O(n), as it goes through each number in the range once. Moreover, the function has an extra space complexity of O(1) because all input parameters are scalars (except for the result array, which is created only once and returned, and recursive calls only manipulate references or scalars).\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nvoid lexicographicalOrderHelper(int current, int n, std::vector<int>& result) {\n    if (current > n) return;\n\n    result.push_back(current);\n    for (int i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nstd::vector<int> lexicalOrder(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n```\n    \n    The algorithm relies on a helper function (`lexicographicalOrderHelper`) that takes the current number, n, and the result array as input. This helper function uses recursion to traverse the range of numbers from 1 to n in lexicographical order.\n\nFirst, the function checks if the current number is greater than n. If so, it returns. Otherwise, it adds the current number to the result array. Then, it loops through the digits 0 to 9, appending each digit to the current number and then recursively calling the function again with the updated value.\n\nThe main function (`lexicalOrder`) initializes the result array and iterates through the starting digits (1 to 9), calling the helper function for each starting digit.\n\nThe algorithm has a time complexity of O(n), as it goes through each number in the range once. Moreover, the function has an extra space complexity of O(1) because all input parameters are scalars (except for the result array, which is created only once and returned, and recursive calls only manipulate references or scalars).\n    ",
        "python": "\n    ```python\ndef lexicographical_order_helper(current, n, result):\n    if current > n:\n        return\n\n    result.append(current)\n    for i in range(10):\n        lexicographical_order_helper(current * 10 + i, n, result)\n\ndef lexical_order(n):\n    result = []\n    for i in range(1, 10):\n        lexicographical_order_helper(i, n, result)\n    return result\n```\n    \n    The algorithm relies on a helper function (`lexicographicalOrderHelper`) that takes the current number, n, and the result array as input. This helper function uses recursion to traverse the range of numbers from 1 to n in lexicographical order.\n\nFirst, the function checks if the current number is greater than n. If so, it returns. Otherwise, it adds the current number to the result array. Then, it loops through the digits 0 to 9, appending each digit to the current number and then recursively calling the function again with the updated value.\n\nThe main function (`lexicalOrder`) initializes the result array and iterates through the starting digits (1 to 9), calling the helper function for each starting digit.\n\nThe algorithm has a time complexity of O(n), as it goes through each number in the range once. Moreover, the function has an extra space complexity of O(1) because all input parameters are scalars (except for the result array, which is created only once and returned, and recursive calls only manipulate references or scalars).\n    ",
        "javascript": "\n    ```javascript\nfunction lexicographicalOrderHelper(current, n, result) {\n    if (current > n) return;\n\n    result.push(current);\n    for (let i = 0; i <= 9; ++i) {\n        lexicographicalOrderHelper(current * 10 + i, n, result);\n    }\n}\n\nfunction lexicalOrder(n) {\n    let result = [];\n    for (let i = 1; i <= 9; ++i) {\n        lexicographicalOrderHelper(i, n, result);\n    }\n    return result;\n}\n```\n    \n    The algorithm relies on a helper function (`lexicographicalOrderHelper`) that takes the current number, n, and the result array as input. This helper function uses recursion to traverse the range of numbers from 1 to n in lexicographical order.\n\nFirst, the function checks if the current number is greater than n. If so, it returns. Otherwise, it adds the current number to the result array. Then, it loops through the digits 0 to 9, appending each digit to the current number and then recursively calling the function again with the updated value.\n\nThe main function (`lexicalOrder`) initializes the result array and iterates through the starting digits (1 to 9), calling the helper function for each starting digit.\n\nThe algorithm has a time complexity of O(n), as it goes through each number in the range once. Moreover, the function has an extra space complexity of O(1) because all input parameters are scalars (except for the result array, which is created only once and returned, and recursive calls only manipulate references or scalars).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 13",
                    "output": " [1,10,11,12,13,2,3,4,5,6,7,8,9]",
                    "explanation": null
                },
                {
                    "input": " n = 2",
                    "output": " [1,2]",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "13",
                    "output": "[1,10,11,12,13,2,3,4,5,6,7,8,9]"
                },
                {
                    "input": "2",
                    "output": "[1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-137",
        "prompt": "Given an integer `n`, return all the numbers in the range `[1, n]` sorted in lexicographical order.\n\nYou must write an algorithm that runs in `O(n)` time and uses `O(1)` extra space."
    },
    "leetcode-benchmark-138": {
        "id": "leetcode-benchmark-138",
        "title": "Longest Absolute File Path",
        "difficulty": "Medium",
        "content": {
            "problem": "Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n\nHere, we have `dir` as the only directory in the root. `dir` contains two subdirectories, `subdir1` and `subdir2`. `subdir1` contains a file `file1.ext` and subdirectory `subsubdir1`. `subdir2` contains a subdirectory `subsubdir2`, which contains a file `file2.ext`.\n\nIn text form, it looks like this (with  representing the tab character):\n\ndir\n subdir1\n  file1.ext\n  subsubdir1\n subdir2\n  subsubdir2\n   file2.ext\n\nIf we were to write this representation in code, it will look like this: `\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext \"`. Note that the `'\\n'` and `'\\t'` are the new-line and tab characters.\n\nEvery file and directory has a unique **absolute path** in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by `'/'s`. Using the above example, the **absolute path** to `file2.ext` is `\"dir/subdir2/subsubdir2/file2.ext \"`. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form `name.extension`, where `name` and `extension` consist of letters, digits, and/or spaces.\n\nGiven a string `input` representing the file system in the explained format, return _the length of the **longest absolute path** to a **file** in the abstracted file system_. If there is no file in the system, return `0`.\n\n**Note** that the testcases are generated such that the file system is valid and no file or directory name has length 0.",
            "examples": [
                "**Example 1:**\n\n**Input:** input =  \"dir\\\\n\\\\tsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tfile.ext \"\n**Output:** 20\n**Explanation:** We have only one file, and the absolute path is  \"dir/subdir2/file.ext \" of length 20.\n\n",
                "**Example 2:**\n\n**Input:** input =  \"dir\\\\n\\\\tsubdir1\\\\n\\\\t\\\\tfile1.ext\\\\n\\\\t\\\\tsubsubdir1\\\\n\\\\tsubdir2\\\\n\\\\t\\\\tsubsubdir2\\\\n\\\\t\\\\t\\\\tfile2.ext \"\n**Output:** 32\n**Explanation:** We have two files:\n \"dir/subdir1/file1.ext \" of length 21\n \"dir/subdir2/subsubdir2/file2.ext \" of length 32.\nWe return 32 since it is the longest absolute path to a file.\n\n",
                "**Example 3:**\n\n**Input:** input =  \"a \"\n**Output:** 0\n**Explanation:** We do not have any files, just a single directory named  \"a \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= input.length <= 104`\n*   `input` may contain lowercase or uppercase English letters, a new line character `'\\n'`, a tab character `'\\t'`, a dot `'.'`, a space `' '`, and digits.\n*   All file and directory names have **positive** length.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic int lengthLongestPath(String input) {\n    Stack<Integer> dirLengthStack = new Stack<>();\n    String[] lines = input.split(\"\\n\");\n    int maxFileLength = 0;\n\n    for (String line : lines) {\n        int level = line.lastIndexOf('\\t') + 1;\n        line = line.substring(level);\n\n        while (dirLengthStack.size() > level) {\n            dirLengthStack.pop();\n        }\n\n        int length = (dirLengthStack.isEmpty()) ? line.length() : dirLengthStack.peek() + line.length() + 1;\n        dirLengthStack.push(length);\n\n        if (line.contains(\".\")) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}\n```\n\n    \n    The algorithm maintains a stack named `dir_length_stack` to remember the lengths of the directory paths seen so far.\n\n1. We split the input by new-line `\\n` to get the lines.\n2. For each line, we calculate its level by counting the number of tab `\\t` characters.\n3. We discard old levels from the `dir_length_stack` by popping elements until reaching the current level.\n4. If `dir_length_stack` is not empty, we calculate the length of the current file/directory by adding the length of the parent directory, and the name of the current file/directory. If `dir_length_stack` is empty, we simply use the length of the current line.\n5. We push the length into the `dir_length_stack`.\n6. If the line contains a '.' (file), we update the maximum path length.\n7. After the iteration, the result stored in `max_file_length` is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <sstream>\n#include <vector>\n#include <algorithm>\n\nint lengthLongestPath(std::string input) {\n    std::istringstream ss(input);\n    std::vector<int> dir_length_stack;\n    std::string line;\n    int max_file_length = 0;\n\n    while (std::getline(ss, line, '\\n')) {\n        int level = 0;\n        while (line.find('\\t') != std::string::npos) {\n            line.erase(0, 1);\n            level++;\n        }\n\n        while (dir_length_stack.size() > level)\n            dir_length_stack.pop_back();\n\n        int length;\n        if (dir_length_stack.empty()) {\n            length = line.length();\n        } else {\n            length = dir_length_stack.back() + line.length() + 1;\n        }\n        dir_length_stack.push_back(length);\n\n        if (line.find('.') != std::string::npos) {\n            max_file_length = std::max(max_file_length, length);\n        }\n    }\n\n    return max_file_length;\n}\n```\n\n    \n    The algorithm maintains a stack named `dir_length_stack` to remember the lengths of the directory paths seen so far.\n\n1. We split the input by new-line `\\n` to get the lines.\n2. For each line, we calculate its level by counting the number of tab `\\t` characters.\n3. We discard old levels from the `dir_length_stack` by popping elements until reaching the current level.\n4. If `dir_length_stack` is not empty, we calculate the length of the current file/directory by adding the length of the parent directory, and the name of the current file/directory. If `dir_length_stack` is empty, we simply use the length of the current line.\n5. We push the length into the `dir_length_stack`.\n6. If the line contains a '.' (file), we update the maximum path length.\n7. After the iteration, the result stored in `max_file_length` is returned.\n    ",
        "python": "\n    ```python\ndef length_longest_path(input: str) -> int:\n    dir_length_stack = []\n    max_file_length = 0\n    lines = input.split('\\n')\n\n    for line in lines:\n        level = line.count('\\t')\n        line = line.lstrip('\\t')\n\n        while len(dir_length_stack) > level:\n            dir_length_stack.pop()\n\n        if dir_length_stack:\n            length = dir_length_stack[-1] + len(line) + 1\n        else:\n            length = len(line)\n        dir_length_stack.append(length)\n\n        if '.' in line:\n            max_file_length = max(max_file_length, length)\n            \n    return max_file_length\n```\n\n    \n    The algorithm maintains a stack named `dir_length_stack` to remember the lengths of the directory paths seen so far.\n\n1. We split the input by new-line `\\n` to get the lines.\n2. For each line, we calculate its level by counting the number of tab `\\t` characters.\n3. We discard old levels from the `dir_length_stack` by popping elements until reaching the current level.\n4. If `dir_length_stack` is not empty, we calculate the length of the current file/directory by adding the length of the parent directory, and the name of the current file/directory. If `dir_length_stack` is empty, we simply use the length of the current line.\n5. We push the length into the `dir_length_stack`.\n6. If the line contains a '.' (file), we update the maximum path length.\n7. After the iteration, the result stored in `max_file_length` is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction lengthLongestPath(input) {\n    const dirLengthStack = [];\n    const lines = input.split('\\n');\n    let maxFileLength = 0;\n\n    for (const line of lines) {\n        const level = (line.match(/\\t/g) || []).length;\n        const lineText = line.replace(/\\t/g, '');\n\n        while (dirLengthStack.length > level)\n            dirLengthStack.pop();\n\n        const length = (dirLengthStack.length === 0) ? lineText.length : (dirLengthStack[dirLengthStack.length - 1] + lineText.length + 1);\n        dirLengthStack.push(length);\n\n        if (lineText.includes('.')) {\n            maxFileLength = Math.max(maxFileLength, length);\n        }\n    }\n\n    return maxFileLength;\n}\n```\n\n    \n    The algorithm maintains a stack named `dir_length_stack` to remember the lengths of the directory paths seen so far.\n\n1. We split the input by new-line `\\n` to get the lines.\n2. For each line, we calculate its level by counting the number of tab `\\t` characters.\n3. We discard old levels from the `dir_length_stack` by popping elements until reaching the current level.\n4. If `dir_length_stack` is not empty, we calculate the length of the current file/directory by adding the length of the parent directory, and the name of the current file/directory. If `dir_length_stack` is empty, we simply use the length of the current line.\n5. We push the length into the `dir_length_stack`.\n6. If the line contains a '.' (file), we update the maximum path length.\n7. After the iteration, the result stored in `max_file_length` is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " input =  \"dirntsubdir1ntsubdir2nttfile.ext \"",
                    "output": " 20",
                    "explanation": " We have only one file, and the absolute path is  \"dir/subdir2/file.ext \" of length 20."
                },
                {
                    "input": " input =  \"dirntsubdir1nttfile1.extnttsubsubdir1ntsubdir2nttsubsubdir2ntttfile2.ext \"",
                    "output": " 32",
                    "explanation": " We have two files:\n \"dir/subdir1/file1.ext \" of length 21\n \"dir/subdir2/subsubdir2/file2.ext \" of length 32.\nWe return 32 since it is the longest absolute path to a file."
                },
                {
                    "input": " input =  \"a \"",
                    "output": " 0",
                    "explanation": " We do not have any files, just a single directory named  \"a \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"dirntsubdir1ntsubdir2nttfile.ext\"",
                    "output": "20"
                },
                {
                    "input": "\"dirntsubdir1nttfile1.extnttsubsubdir1ntsubdir2nttsubsubdir2ntttfile2.ext\"",
                    "output": "32"
                },
                {
                    "input": "\"a\"",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-138",
        "prompt": "Suppose we have a file system that stores both files and directories. An example of one system is represented in the following picture:\n\nHere, we have `dir` as the only directory in the root. `dir` contains two subdirectories, `subdir1` and `subdir2`. `subdir1` contains a file `file1.ext` and subdirectory `subsubdir1`. `subdir2` contains a subdirectory `subsubdir2`, which contains a file `file2.ext`.\n\nIn text form, it looks like this (with  representing the tab character):\n\ndir\n subdir1\n  file1.ext\n  subsubdir1\n subdir2\n  subsubdir2\n   file2.ext\n\nIf we were to write this representation in code, it will look like this: `\"dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext \"`. Note that the `'\\n'` and `'\\t'` are the new-line and tab characters.\n\nEvery file and directory has a unique **absolute path** in the file system, which is the order of directories that must be opened to reach the file/directory itself, all concatenated by `'/'s`. Using the above example, the **absolute path** to `file2.ext` is `\"dir/subdir2/subsubdir2/file2.ext \"`. Each directory name consists of letters, digits, and/or spaces. Each file name is of the form `name.extension`, where `name` and `extension` consist of letters, digits, and/or spaces.\n\nGiven a string `input` representing the file system in the explained format, return _the length of the **longest absolute path** to a **file** in the abstracted file system_. If there is no file in the system, return `0`.\n\n**Note** that the testcases are generated such that the file system is valid and no file or directory name has length 0."
    },
    "leetcode-benchmark-139": {
        "id": "leetcode-benchmark-139",
        "title": "Elimination Game",
        "difficulty": "Medium",
        "content": {
            "problem": "You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`:\n\n*   Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n*   Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n*   Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nGiven the integer `n`, return _the last number that remains in_ `arr`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 9\n**Output:** 6\n**Explanation:**\narr = \\[1, 2, 3, 4, 5, 6, 7, 8, 9\\]\narr = \\[2, 4, 6, 8\\]\narr = \\[2, 6\\]\narr = \\[6\\]\n\n",
                "**Example 2:**\n\n**Input:** n = 1\n**Output:** 1"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 109`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int lastRemaining(int n) {\n    boolean direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "c++": "\n    ```cpp\nint lastRemaining(int n) {\n    bool direction = true;\n    int head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 == 1) {\n            head += step;\n        }\n        remaining /= 2;\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "python": "\n    ```python\ndef last_remaining(n: int) -> int:\n    direction = True\n    head = 1\n    remaining = n\n    step = 1\n\n    while remaining > 1:\n        if direction or remaining % 2 == 1:\n            head += step\n        remaining //= 2\n        step *= 2\n        direction = not direction\n\n    return head\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "javascript": "\n    ```javascript\nfunction lastRemaining(n) {\n    let direction = true;\n    let head = 1, remaining = n, step = 1;\n\n    while (remaining > 1) {\n        if (direction || remaining % 2 === 1) {\n            head += step;\n        }\n        remaining = Math.floor(remaining / 2);\n        step *= 2;\n        direction = !direction;\n    }\n\n    return head;\n}\n```\n    \n    The algorithm starts with `head` pointing to the first element, and it will move `head` according to the direction flag and the current value of `remaining`. The `direction` flag alternates between `true` and `false` in each iteration, indicating whether we need to move forwards or backwards. The `remaining` variable represents the number of elements left in the list.\n\nIn each iteration, if the direction is forward (`true`) or the remaining elements are odd, we will increment `head` by the current `step`. Then, we update the remaining elements by dividing it by 2, as half elements are removed in each iteration, and the `step` doubles as the number of removed elements in the next round will also double. Finally, we toggle the `direction` flag, which means reversing the direction in which we move `head`.\n\nAt the end of the algorithm, when there is only one element remaining, the position of `head` will be the number that remains.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 9",
                    "output": " 6",
                    "explanation": "\narr = \\[1, 2, 3, 4, 5, 6, 7, 8, 9\\]\narr = \\[2, 4, 6, 8\\]\narr = \\[2, 6\\]\narr = \\[6\\]"
                },
                {
                    "input": " n = 1",
                    "output": " 1",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "9",
                    "output": "6"
                },
                {
                    "input": "1",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-139",
        "prompt": "You have a list `arr` of all integers in the range `[1, n]` sorted in a strictly increasing order. Apply the following algorithm on `arr`:\n\n*   Starting from left to right, remove the first number and every other number afterward until you reach the end of the list.\n*   Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.\n*   Keep repeating the steps again, alternating left to right and right to left, until a single number remains.\n\nGiven the integer `n`, return _the last number that remains in_ `arr`."
    },
    "leetcode-benchmark-140": {
        "id": "leetcode-benchmark-140",
        "title": "UTF-8 Validation",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `data` representing the data, return whether it is a valid **UTF-8** encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in **UTF8** can be from **1 to 4 bytes** long, subjected to the following rules:\n\n1.  For a **1-byte** character, the first bit is a `0`, followed by its Unicode code.\n2.  For an **n-bytes** character, the first `n` bits are all one's, the `n + 1` bit is `0`, followed by `n - 1` bytes with the most significant `2` bits being `10`.\n\nThis is how the UTF-8 encoding would work:\n\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n`x` denotes a bit in the binary form of a byte that may be either `0` or `1`.\n\n**Note:** The input is an array of integers. Only the **least significant 8 bits** of each integer is used to store the data. This means each integer represents only 1 byte of data.",
            "examples": [
                "**Example 1:**\n\n**Input:** data = \\[197,130,1\\]\n**Output:** true\n**Explanation:** data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\n",
                "**Example 2:**\n\n**Input:** data = \\[235,140,4\\]\n**Output:** false\n**Explanation:** data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= data.length <= 2 * 104`\n*   `0 <= data[i] <= 255`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean validUtf8(int[] data) {\n    int count = 0;\n    for (int byteValue : data) {\n        if (count == 0) {\n            if ((byteValue >> 5) == 0b110) count = 1;\n            else if ((byteValue >> 4) == 0b1110) count = 2;\n            else if ((byteValue >> 3) == 0b11110) count = 3;\n            else if ((byteValue >> 7) == 1) return false;\n        } else {\n            if ((byteValue >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\n```\n    \n    We iterate through each byte in the given data array. If we are not currently processing a multi-byte character (count = 0), we check if it's a 1-byte, 2-byte, 3-byte, or 4-byte character encodings, and update the `count` accordingly. For 1-byte characters, we just check if the first bit is 0.\n\nIn case the current byte is a part of multi-byte character (count > 0), we check whether it is a valid continuation byte by checking if its two most significant bits are `10`. If it's not a valid continuation byte, return `false`.\n\nFinally, return `true` if the `count` is 0 at the end of the iteration, i.e., there are no unfinished multi-byte sequences.\n    ",
        "c++": "\n    ```cpp\nbool validUtf8(vector<int>& data) {\n    int count = 0;\n    for (int byte : data) {\n        if (count == 0) { \n            if ((byte >> 5) == 0b110) count = 1;\n            else if ((byte >> 4) == 0b1110) count = 2;\n            else if ((byte >> 3) == 0b11110) count = 3;\n            else if ((byte >> 7)) return false; \n        } else { \n            if ((byte >> 6) != 0b10) return false;\n            count--;\n        }\n    }\n    return count == 0;\n}\n```\n    \n    We iterate through each byte in the given data array. If we are not currently processing a multi-byte character (count = 0), we check if it's a 1-byte, 2-byte, 3-byte, or 4-byte character encodings, and update the `count` accordingly. For 1-byte characters, we just check if the first bit is 0.\n\nIn case the current byte is a part of multi-byte character (count > 0), we check whether it is a valid continuation byte by checking if its two most significant bits are `10`. If it's not a valid continuation byte, return `false`.\n\nFinally, return `true` if the `count` is 0 at the end of the iteration, i.e., there are no unfinished multi-byte sequences.\n    ",
        "python": "\n    ```python\ndef validUtf8(data):\n    count = 0\n    for byte in data:\n        if count == 0:\n            if byte >> 5 == 0b110:\n                count = 1\n            elif byte >> 4 == 0b1110:\n                count = 2\n            elif byte >> 3 == 0b11110:\n                count = 3\n            elif byte >> 7:\n                return False\n        else:\n            if byte >> 6 != 0b10:\n                return False\n            count -= 1\n    return count == 0\n```\n    \n    We iterate through each byte in the given data array. If we are not currently processing a multi-byte character (count = 0), we check if it's a 1-byte, 2-byte, 3-byte, or 4-byte character encodings, and update the `count` accordingly. For 1-byte characters, we just check if the first bit is 0.\n\nIn case the current byte is a part of multi-byte character (count > 0), we check whether it is a valid continuation byte by checking if its two most significant bits are `10`. If it's not a valid continuation byte, return `false`.\n\nFinally, return `true` if the `count` is 0 at the end of the iteration, i.e., there are no unfinished multi-byte sequences.\n    ",
        "javascript": "\n    ```javascript\nfunction validUtf8(data) {\n    let count = 0;\n    for (let byte of data) {\n        if (count === 0) {\n            if (byte >> 5 === 0b110) count = 1;\n            else if (byte >> 4 === 0b1110) count = 2;\n            else if (byte >> 3 === 0b11110) count = 3;\n            else if (byte >> 7) return false;\n        } else {\n            if (byte >> 6 !== 0b10) return false;\n            count--;\n        }\n    }\n    return count === 0;\n}\n```\n    \n    We iterate through each byte in the given data array. If we are not currently processing a multi-byte character (count = 0), we check if it's a 1-byte, 2-byte, 3-byte, or 4-byte character encodings, and update the `count` accordingly. For 1-byte characters, we just check if the first bit is 0.\n\nIn case the current byte is a part of multi-byte character (count > 0), we check whether it is a valid continuation byte by checking if its two most significant bits are `10`. If it's not a valid continuation byte, return `false`.\n\nFinally, return `true` if the `count` is 0 at the end of the iteration, i.e., there are no unfinished multi-byte sequences.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " data = [197,130,1]",
                    "output": " True",
                    "explanation": " data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character."
                },
                {
                    "input": " data = [235,140,4]",
                    "output": " False",
                    "explanation": " data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid."
                }
            ],
            "function_input": [
                {
                    "input": "[197,130,1]",
                    "output": "True"
                },
                {
                    "input": "[235,140,4]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-140",
        "prompt": "Given an integer array `data` representing the data, return whether it is a valid **UTF-8** encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in **UTF8** can be from **1 to 4 bytes** long, subjected to the following rules:\n\n1.  For a **1-byte** character, the first bit is a `0`, followed by its Unicode code.\n2.  For an **n-bytes** character, the first `n` bits are all one's, the `n + 1` bit is `0`, followed by `n - 1` bytes with the most significant `2` bits being `10`.\n\nThis is how the UTF-8 encoding would work:\n\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n`x` denotes a bit in the binary form of a byte that may be either `0` or `1`.\n\n**Note:** The input is an array of integers. Only the **least significant 8 bits** of each integer is used to store the data. This means each integer represents only 1 byte of data."
    },
    "leetcode-benchmark-141": {
        "id": "leetcode-benchmark-141",
        "title": "Decode String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\n\nThe test cases are generated so that the length of the output will never exceed `105`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"3\\[a\\]2\\[bc\\] \"\n**Output:**  \"aaabcbc \"\n\n",
                "**Example 2:**\n\n**Input:** s =  \"3\\[a2\\[c\\]\\] \"\n**Output:**  \"accaccacc \"\n\n",
                "**Example 3:**\n\n**Input:** s =  \"2\\[abc\\]3\\[cd\\]ef \"\n**Output:**  \"abcabccdcdcdef \""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 30`\n*   `s` consists of lowercase English letters, digits, and square brackets `'[]'`.\n*   `s` is guaranteed to be **a valid** input.\n*   All the integers in `s` are in the range `[1, 300]`.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> counts = new Stack<>();\n        Stack<String> results = new Stack<>();\n        String current = \"\";\n        int ptr = 0;\n\n        while (ptr < s.length()) {\n            if (Character.isDigit(s.charAt(ptr))) {\n                int count = 0;\n                while (Character.isDigit(s.charAt(ptr))) {\n                    count = count * 10 + (s.charAt(ptr) - '0');\n                    ptr++;\n                }\n                counts.push(count);\n            } else if (s.charAt(ptr) == '[') {\n                results.push(current);\n                current = \"\";\n                ptr++;\n            } else if (s.charAt(ptr) == ']') {\n                String prev = results.pop();\n                int count = counts.pop();\n                for (int i = 0; i < count; i++) {\n                    prev += current;\n                }\n                current = prev;\n                ptr++;\n            } else {\n                current += s.charAt(ptr);\n                ptr++;\n            }\n        }\n\n        return current;\n    }\n}\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string decodeString(const std::string &s) {\n    std::stack<int> counts;\n    std::stack<std::string> results;\n    std::string current;\n    int ptr = 0;\n\n    while (ptr < s.size()) {\n        if (isdigit(s[ptr])) {\n            int count = 0;\n            while (isdigit(s[ptr])) {\n                count = count * 10 + (s[ptr] - '0');\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] == '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] == ']') {\n            std::string prev = results.top();\n            results.pop();\n            int count = counts.top();\n            counts.pop();\n            for (int i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "python": "\n    ```python\ndef decodeString(s):\n    counts = []\n    results = []\n    current = \"\"\n    ptr = 0\n\n    while ptr < len(s):\n        if s[ptr].isdigit():\n            count = 0\n            while s[ptr].isdigit():\n                count = count * 10 + int(s[ptr])\n                ptr += 1\n            counts.append(count)\n        elif s[ptr] == '[':\n            results.append(current)\n            current = \"\"\n            ptr += 1\n        elif s[ptr] == ']':\n            prev = results.pop()\n            count = counts.pop()\n            current = prev + current * count\n            ptr += 1\n        else:\n            current += s[ptr]\n            ptr += 1\n\n    return current\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "javascript": "\n    ```javascript\nfunction decodeString(s) {\n    const counts = [];\n    const results = [];\n    let current = \"\";\n    let ptr = 0;\n\n    while (ptr < s.length) {\n        if (s[ptr].match(/\\d/)) {\n            let count = 0;\n            while (s[ptr].match(/\\d/)) {\n                count = count * 10 + parseInt(s[ptr]);\n                ptr++;\n            }\n            counts.push(count);\n        } else if (s[ptr] === '[') {\n            results.push(current);\n            current = \"\";\n            ptr++;\n        } else if (s[ptr] === ']') {\n            const prev = results.pop();\n            const count = counts.pop();\n            for (let i = 0; i < count; i++) {\n                prev += current;\n            }\n            current = prev;\n            ptr++;\n        } else {\n            current += s[ptr];\n            ptr++;\n        }\n    }\n\n    return current;\n}\n```\n    \n    1. Initialize two stacks `counts` and `results`, a pointer `ptr`, and a `current` string.\n2. Loop through the input string `s`.\n3. If the current character is a digit, calculate the number and push it onto the `counts` stack.\n4. If the current character is an opening bracket `[`, push the `current` string into the `results` stack and reset the `current` string.\n5. If the current character is a closing bracket `]`, pop the top strings from the `results` stack and multiply the `current` string with the top count from the `counts` stack. Update the `current` string.\n6. If the current character is a letter, add it to the `current` string.\n7. After looping through `s`, return the `current` string, which is now the decoded version of the input string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"3[a]2[bc] \"",
                    "output": "  \"aaabcbc \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"3[a2[c]] \"",
                    "output": "  \"accaccacc \"",
                    "explanation": null
                },
                {
                    "input": " s =  \"2[abc]3[cd]ef \"",
                    "output": "  \"abcabccdcdcdef \"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"3[a]2[bc]\"",
                    "output": "\"aaabcbc\""
                },
                {
                    "input": "\"3[a2[c]]\"",
                    "output": "\"accaccacc\""
                },
                {
                    "input": "\"2[abc]3[cd]ef\"",
                    "output": "\"abcabccdcdcdef\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-141",
        "prompt": "Given an encoded string, return its decoded string.\n\nThe encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times. Note that `k` is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, `k`. For example, there will not be input like `3a` or `2[4]`.\n\nThe test cases are generated so that the length of the output will never exceed `105`."
    },
    "leetcode-benchmark-142": {
        "id": "leetcode-benchmark-142",
        "title": "Longest Substring with At Least K Repeating Characters",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` and an integer `k`, return _the length of the longest substring of_ `s` _such that the frequency of each character in this substring is greater than or equal to_ `k`.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"aaabb \", k = 3\n**Output:** 3\n**Explanation:** The longest substring is  \"aaa \", as 'a' is repeated 3 times.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"ababbc \", k = 2\n**Output:** 5\n**Explanation:** The longest substring is  \"ababb \", as 'a' is repeated 2 times and 'b' is repeated 3 times."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 104`\n*   `s` consists of only lowercase English letters.\n*   `1 <= k <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.*;\n\npublic int longestSubstring(String s, int k) {\n    if (s == null || s.length() == 0 || k <= 0) return 0;\n\n    Map<Character, Integer> charCount = new HashMap<>();\n    for (char ch : s.toCharArray())\n        charCount.put(ch, charCount.getOrDefault(ch, 0) + 1);\n\n    for (Map.Entry<Character, Integer> entry : charCount.entrySet()) {\n        if (entry.getValue() < k) {\n            int res = 0;\n            for (String str : s.split(Character.toString(entry.getKey())))\n                res = Math.max(res, longestSubstring(str, k));\n            return res;\n        }\n    }\n    return s.length();\n}\n```\n    \n    The algorithm starts by counting the frequency of each character in the input string `s`. If the count of any character is less than `k`, then that character cannot be part of any substring with characters having a frequency greater than or equal to `k`. Therefore, we split the input string around such characters and recursively apply the same logic on each substring. The longest substring's length across different recursive calls is returned.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nint longestSubstring(const std::string& s, int k) {\n    if (s.empty() || k <= 0) return 0;\n\n    std::unordered_map<char, int> char_count;\n    for (char ch : s)\n        char_count[ch]++;\n\n    for (const auto& item : char_count) {\n        if (item.second < k) {\n            int res = 0;\n            for (const std::string& str : split(s, item.first))\n                res = std::max(res, longestSubstring(str, k));\n            return res;\n        }\n    }\n    return s.length();\n}\n\nstd::vector<std::string> split(const std::string& s, char delimiter) {\n    std::vector<std::string> subs;\n    size_t start = 0;\n    size_t end = s.find(delimiter);\n    while (end != std::string::npos) {\n        subs.push_back(s.substr(start, end - start));\n        start = end + 1;\n        end = s.find(delimiter, start);\n    }\n    subs.push_back(s.substr(start));\n    return subs;\n}\n```\n    \n    The algorithm starts by counting the frequency of each character in the input string `s`. If the count of any character is less than `k`, then that character cannot be part of any substring with characters having a frequency greater than or equal to `k`. Therefore, we split the input string around such characters and recursively apply the same logic on each substring. The longest substring's length across different recursive calls is returned.\n    ",
        "python": "\n    ```python\ndef longestSubstring(s: str, k: int) -> int:\n    if not s or k <= 0:\n        return 0\n\n    char_count = {}\n    for ch in s:\n        char_count[ch] = char_count.get(ch, 0) + 1\n\n    for char, count in char_count.items():\n        if count < k:\n            return max(longestSubstring(sub_s, k) for sub_s in s.split(char))\n    return len(s)\n```\n    \n    The algorithm starts by counting the frequency of each character in the input string `s`. If the count of any character is less than `k`, then that character cannot be part of any substring with characters having a frequency greater than or equal to `k`. Therefore, we split the input string around such characters and recursively apply the same logic on each substring. The longest substring's length across different recursive calls is returned.\n    ",
        "javascript": "\n    ```javascript\nfunction longestSubstring(s, k) {\n    if (!s || k <= 0) return 0;\n\n    const charCount = {};\n    for (const ch of s)\n        charCount[ch] = (charCount[ch] || 0) + 1;\n\n    for (const key in charCount) {\n        if (charCount[key] < k) {\n            let res = 0;\n            for (const subStr of s.split(key))\n                res = Math.max(res, longestSubstring(subStr, k));\n            return res;\n        }\n    }\n    return s.length;\n}\n```\n    \n    The algorithm starts by counting the frequency of each character in the input string `s`. If the count of any character is less than `k`, then that character cannot be part of any substring with characters having a frequency greater than or equal to `k`. Therefore, we split the input string around such characters and recursively apply the same logic on each substring. The longest substring's length across different recursive calls is returned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"aaabb \", k = 3",
                    "output": " 3",
                    "explanation": " The longest substring is  \"aaa \", as 'a' is repeated 3 times."
                },
                {
                    "input": " s =  \"ababbc \", k = 2",
                    "output": " 5",
                    "explanation": " The longest substring is  \"ababb \", as 'a' is repeated 2 times and 'b' is repeated 3 times."
                }
            ],
            "function_input": [
                {
                    "input": "\"aaabb\",3",
                    "output": "3"
                },
                {
                    "input": "\"ababbc\",2",
                    "output": "5"
                }
            ]
        },
        "task_id": "leetcode-benchmark-142",
        "prompt": "Given a string `s` and an integer `k`, return _the length of the longest substring of_ `s` _such that the frequency of each character in this substring is greater than or equal to_ `k`."
    },
    "leetcode-benchmark-143": {
        "id": "leetcode-benchmark-143",
        "title": "Rotate Function",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions clock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n*   `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0), F(1), ..., F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,6\\]\n**Output:** 26\n**Explanation:**\nF(0) = (0 \\* 4) + (1 \\* 3) + (2 \\* 2) + (3 \\* 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 \\* 6) + (1 \\* 4) + (2 \\* 3) + (3 \\* 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 \\* 2) + (1 \\* 6) + (2 \\* 4) + (3 \\* 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 \\* 3) + (1 \\* 2) + (2 \\* 6) + (3 \\* 4) = 0 + 2 + 12 + 12 = 26\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[100\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `-100 <= nums[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int maxRotateFunction(int[] nums) {\n    int n = nums.length;\n    int total_sum = 0;\n    int f = 0;\n\n    for (int i = 0; i < n; i++) {\n        total_sum += nums[i];\n        f += i * nums[i];\n    }\n\n    int max_f = f;\n    for (int i = 1; i < n; i++) {\n        f += total_sum - (n * nums[n - i]);\n        max_f = Math.max(max_f, f);\n    }\n\n    return max_f;\n}\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ",
        "c++": "\n    ```cpp\nint maxRotateFunction(vector<int>& nums) {\n    int n = nums.size();\n    int total_sum = 0;\n    int f = 0;\n\n    for (int i = 0; i < n; i++) {\n        total_sum += nums[i];\n        f += i * nums[i];\n    }\n\n    int max_f = f;\n    for (int i = 1; i < n; i++) {\n        f += total_sum - n * nums[n - i];\n        max_f = max(max_f, f);\n    }\n\n    return max_f;\n}\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ",
        "python": "\n    ```python\ndef maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    f = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f\n    for i in range(1, n):\n        f += total_sum - n * nums[-i]\n        max_f = max(max_f, f)\n\n    return max_f\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ",
        "javascript": "\n    ```javascript\nfunction maxRotateFunction(nums) {\n    let n = nums.length;\n    let total_sum = nums.reduce((a, b) => a + b, 0);\n    let f = nums.reduce((acc, val, i) => acc + i * val, 0);\n\n    let max_f = f;\n    for (let i = 1; i < n; i++) {\n        f += total_sum - n * nums[n - i];\n        max_f = Math.max(max_f, f);\n    }\n\n    return max_f;\n}\n```\n\n    \n    1. Calculate the total_sum of elements in the given array.\n2. Calculate the initial value of the rotation function F(0) and assign it to f.\n3. Initialize max_f with the value of f.\n4. Iterate through the array with index i from 1 to n-1.\n5. For each iteration, calculate the value of the rotation function F(i) by adding total_sum to the previous value of the rotation function and subtracting the product of n and nums[n - i]. Update f with the new value.\n6. Compare the new value of f with max_f and update max_f with the maximum value.\n7. Return max_f after finishing the loop.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [4,3,2,6]",
                    "output": " 26",
                    "explanation": "\nF(0) = (0 \\* 4) + (1 \\* 3) + (2 \\* 2) + (3 \\* 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 \\* 6) + (1 \\* 4) + (2 \\* 3) + (3 \\* 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 \\* 2) + (1 \\* 6) + (2 \\* 4) + (3 \\* 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 \\* 3) + (1 \\* 2) + (2 \\* 6) + (3 \\* 4) = 0 + 2 + 12 + 12 = 26\nSo the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26."
                },
                {
                    "input": " nums = [100]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[4,3,2,6]",
                    "output": "26"
                },
                {
                    "input": "[100]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-143",
        "prompt": "You are given an integer array `nums` of length `n`.\n\nAssume `arrk` to be an array obtained by rotating `nums` by `k` positions clock-wise. We define the **rotation function** `F` on `nums` as follow:\n\n*   `F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].`\n\nReturn _the maximum value of_ `F(0), F(1), ..., F(n-1)`.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer."
    },
    "leetcode-benchmark-144": {
        "id": "leetcode-benchmark-144",
        "title": "Integer Replacement",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 8\n**Output:** 3\n**Explanation:** 8 -> 4 -> 2 -> 1\n\n",
                "**Example 2:**\n\n**Input:** n = 7\n**Output:** 4\n**Explanation:** 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1\n\n",
                "**Example 3:**\n\n**Input:** n = 4\n**Output:** 2"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "c++": "\n    ```cpp\nint minOperations(int n) {\n    int steps = 0;\n    while(n > 1) {\n        n = (n % 2 == 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "python": "\n    ```python\ndef min_operations(n):\n    steps = 0\n    while n > 1:\n        n = n // 2 if n % 2 == 0 else n - 1\n        steps += 1\n    return steps\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "javascript": "\n    ```javascript\nfunction minOperations(n) {\n    let steps = 0;\n    while(n > 1) {\n        n = (n % 2 === 0) ? n / 2 : n - 1;\n        steps++;\n    }\n    return steps;\n}\n```\n    \n    The algorithm to calculate the minimum number of operations needed for n to become 1 is straightforward. We initialize a variable `steps` to 0 to keep track of the number of operations performed. In a loop, we iterate until n becomes 1.\n\nIn each iteration of the loop, we check if n is an even number (n % 2 == 0). If it is, we divide n by 2; otherwise, we subtract 1 from n. We increase the count of `steps` by 1 in each iteration.\n\nFinally, we return the total number of `steps` when the loop terminates (when n becomes 1).\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 8",
                    "output": " 3",
                    "explanation": " 8 -> 4 -> 2 -> 1"
                },
                {
                    "input": " n = 7",
                    "output": " 4",
                    "explanation": " 7 -> 8 -> 4 -> 2 -> 1\nor 7 -> 6 -> 3 -> 2 -> 1"
                },
                {
                    "input": " n = 4",
                    "output": " 2",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "8",
                    "output": "3"
                },
                {
                    "input": "7",
                    "output": "4"
                },
                {
                    "input": "4",
                    "output": "2"
                }
            ]
        },
        "task_id": "leetcode-benchmark-144",
        "prompt": "Given a positive integer `n`, you can apply one of the following operations:\n\n1.  If `n` is even, replace `n` with `n / 2`.\n2.  If `n` is odd, replace `n` with either `n + 1` or `n - 1`.\n\nReturn _the minimum number of operations needed for_ `n` _to become_ `1`."
    },
    "leetcode-benchmark-145": {
        "id": "leetcode-benchmark-145",
        "title": "Nth Digit",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer `n`, return the `nth` digit of the infinite integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`.",
            "examples": [
                "**Example 1:**\n\n**Input:** n = 3\n**Output:** 3\n\n",
                "**Example 2:**\n\n**Input:** n = 11\n**Output:** 0\n**Explanation:** The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= n <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    String s = Integer.toString(start);\n    return Character.getNumericValue(s.charAt((n - 1) % size));\n}\n```\n    \n    The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer.\n    ",
        "c++": "\n    ```cpp\nint findNthDigit(int n) {\n    int size = 1;\n    long length = 9;\n    int start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += (n - 1) / size;\n    string s = to_string(start);\n    return s[(n - 1) % size] - '0';\n}\n```\n    \n    The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer.\n    ",
        "python": "\n    ```python\ndef findNthDigit(n):\n    size = 1\n    length = 9\n    start = 1\n\n    while n > length * size:\n        n -= length * size\n        size += 1\n        length *= 10\n        start *= 10\n\n    start += (n - 1) // size\n    s = str(start)\n    return int(s[(n - 1) % size])\n```\n    \n    The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer.\n    ",
        "javascript": "\n    ```javascript\nfunction findNthDigit(n) {\n    let size = 1;\n    let length = 9;\n    let start = 1;\n\n    while (n > length * size) {\n        n -= length * size;\n        size++;\n        length *= 10;\n        start *= 10;\n    }\n\n    start += Math.floor((n - 1) / size);\n    const s = start.toString();\n    return parseInt(s.charAt((n - 1) % size));\n}\n```\n    \n    The solution works as follows:\n1. Initialize the `size` of each number at `1` (single-digit numbers), the `length` of numbers of that size at 9 (there are 9 single-digit numbers), and the `start` number of size `1` as `1`.\n2. Keep subtracting the total length of numbers of the current size from `n` as long as `n` is greater than the total length of numbers of that size.\n3. Increment `size` and multiply `length` and `start` by `10` when moving to the next size.\n4. Add `(n - 1) / size` to `start` (adjusted for index 0) to find the number in the sequence that contains the nth digit.\n5. Convert the found number to a string, and return the digit at position `(n - 1) % size`. In C++ and JavaScript, subtract '0' or use `parseInt` to convert the character back to an integer.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " n = 3",
                    "output": " 3",
                    "explanation": null
                },
                {
                    "input": " n = 11",
                    "output": " 0",
                    "explanation": " The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10."
                }
            ],
            "function_input": [
                {
                    "input": "3",
                    "output": "3"
                },
                {
                    "input": "11",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-145",
        "prompt": "Given an integer `n`, return the `nth` digit of the infinite integer sequence `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...]`."
    },
    "leetcode-benchmark-146": {
        "id": "leetcode-benchmark-146",
        "title": "Remove K Digits",
        "difficulty": "Medium",
        "content": {
            "problem": "Given string num representing a non-negative integer `num`, and an integer `k`, return _the smallest possible integer after removing_ `k` _digits from_ `num`.",
            "examples": [
                "**Example 1:**\n\n**Input:** num =  \"1432219 \", k = 3\n**Output:**  \"1219 \"\n**Explanation:** Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.\n\n",
                "**Example 2:**\n\n**Input:** num =  \"10200 \", k = 1\n**Output:**  \"200 \"\n**Explanation:** Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.\n\n",
                "**Example 3:**\n\n**Input:** num =  \"10 \", k = 2\n**Output:**  \"0 \"\n**Explanation:** Remove all the digits from the number and it is left with nothing which is 0."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= k <= num.length <= 105`\n*   `num` consists of only digits.\n*   `num` does not have any leading zeros except for the zero itself.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String removeKDigits(String num, int k) {\n    StringBuilder result = new StringBuilder();\n    for (char c : num.toCharArray()) {\n        while (k > 0 && result.length() > 0 && result.charAt(result.length() - 1) > c) {\n            result.setLength(result.length() - 1);\n            k--;\n        }\n        result.append(c);\n    }\n    result.setLength(result.length() - k);\n    while (result.length() > 0 && result.charAt(0) == '0') {\n        result.deleteCharAt(0);\n    }\n    return result.length() == 0 ? \"0\" : result.toString();\n}\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ",
        "c++": "\n    ```cpp\n#include <string>\nusing namespace std;\n\nstring removeKDigits(string num, int k) {\n    string result = \"\";\n    for (char c : num) {\n        while (k > 0 && !result.empty() && result.back() > c) {\n            result.pop_back();\n            k--;\n        }\n        result.push_back(c);\n    }\n    result.resize(result.length() - k);\n    while (!result.empty() && result[0] == '0') {\n        result.erase(result.begin());\n    }\n    return result.empty() ? \"0\" : result;\n}\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ",
        "python": "\n    ```python\ndef remove_k_digits(num, k):\n    stack = []\n    for c in num:\n        while k > 0 and stack and stack[-1] > c:\n            stack.pop()\n            k -= 1\n        stack.append(c)\n    while k > 0:\n        stack.pop()\n        k -= 1\n    return ''.join(stack).lstrip('0') or '0'\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ",
        "javascript": "\n    ```javascript\nfunction removeKDigits(num, k) {\n    let stack = [];\n    for (let i = 0; i < num.length; i++) {\n        let c = num[i];\n        while (k > 0 && stack.length > 0 && stack[stack.length - 1] > c) {\n            stack.pop();\n            k--;\n        }\n        stack.push(c);\n    }\n    while (k > 0) {\n        stack.pop();\n        k--;\n    }\n    let result = stack.join('').replace(/^0+/, '');\n    return result || '0';\n}\n```\n    \n    The algorithm maintains a stack, initially empty. It iterates through the input string char by char, and for each char, it tries to remove the largest possible digit from the stack, as long as k is greater than 0. If the stack is empty or its topmost element is smaller than the current char, the current char is pushed into the stack. \n\nAfter the iteration, if k is still greater than 0, then we remove the remaining top k elements from the stack. Finally, the resultant smallest integer is formed from the stack, removing any leading zeros if present, and returned as a string.\n\nThe time complexity of this algorithm is O(n), where n is the length of the input string, as it iterates through the input string once and processes each character.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " num =  \"1432219 \", k = 3",
                    "output": "  \"1219 \"",
                    "explanation": " Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest."
                },
                {
                    "input": " num =  \"10200 \", k = 1",
                    "output": "  \"200 \"",
                    "explanation": " Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes."
                },
                {
                    "input": " num =  \"10 \", k = 2",
                    "output": "  \"0 \"",
                    "explanation": " Remove all the digits from the number and it is left with nothing which is 0."
                }
            ],
            "function_input": [
                {
                    "input": "\"1432219\",3",
                    "output": "\"1219\""
                },
                {
                    "input": "\"10200\",1",
                    "output": "\"200\""
                },
                {
                    "input": "\"10\",2",
                    "output": "\"0\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-146",
        "prompt": "Given string num representing a non-negative integer `num`, and an integer `k`, return _the smallest possible integer after removing_ `k` _digits from_ `num`."
    },
    "leetcode-benchmark-147": {
        "id": "leetcode-benchmark-147",
        "title": "Arithmetic Slices",
        "difficulty": "Medium",
        "content": {
            "problem": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\nGiven an integer array `nums`, return _the number of arithmetic **subarrays** of_ `nums`.\n\nA **subarray** is a contiguous subsequence of the array.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3,4\\]\n**Output:** 3\n**Explanation:** We have 3 arithmetic slices in nums: \\[1, 2, 3\\], \\[2, 3, 4\\] and \\[1,2,3,4\\] itself.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 5000`\n*   `-1000 <= nums[i] <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int numberOfArithmeticSlices(int[] nums) {\n    int n = nums.length, count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ",
        "c++": "\n    ```cpp\nint numberOfArithmeticSlices(vector<int>& nums) {\n    int n = nums.size(), count = 0, cur = 0;\n    for (int i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ",
        "python": "\n    ```python\ndef numberOfArithmeticSlices(nums):\n    n = len(nums)\n    count, cur = 0, 0\n    for i in range(2, n):\n        if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n            cur += 1\n            count += cur\n        else:\n            cur = 0\n    return count\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ",
        "javascript": "\n    ```javascript\nfunction numberOfArithmeticSlices(nums) {\n    let n = nums.length, count = 0, cur = 0;\n    for (let i = 2; i < n; ++i) {\n        if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) {\n            cur++;\n            count += cur;\n        } else {\n            cur = 0;\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates through the given integer array `nums`. Starting from the third element (index 2), for each element, it checks if the difference between the current and the previous element is the same as the difference between the previous and the element before the previous one. If the differences are the same, that means we have an arithmetic subarray, so we increment the `cur` value to keep track of the consecutive arithmetic subarrays, and then add `cur` to the `count` which tracks the total number of arithmetic subarrays. If the differences are not the same, we reset `cur` to 0. Finally, the `count` is returned as the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3,4]",
                    "output": " 3",
                    "explanation": " We have 3 arithmetic slices in nums: \\[1, 2, 3\\], \\[2, 3, 4\\] and \\[1,2,3,4\\] itself."
                },
                {
                    "input": " nums = [1]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3,4]",
                    "output": "3"
                },
                {
                    "input": "[1]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-147",
        "prompt": "An integer array is called arithmetic if it consists of **at least three elements** and if the difference between any two consecutive elements is the same.\n\n*   For example, `[1,3,5,7,9]`, `[7,7,7,7]`, and `[3,-1,-5,-9]` are arithmetic sequences.\n\nGiven an integer array `nums`, return _the number of arithmetic **subarrays** of_ `nums`.\n\nA **subarray** is a contiguous subsequence of the array."
    },
    "leetcode-benchmark-148": {
        "id": "leetcode-benchmark-148",
        "title": "Partition Equal Subset Sum",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,5,11,5\\]\n**Output:** true\n**Explanation:** The array can be partitioned as \\[1, 5, 5\\] and \\[11\\].\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3,5\\]\n**Output:** false\n**Explanation:** The array cannot be partitioned into equal sum subsets."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 200`\n*   `1 <= nums[i] <= 100`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean canPartition(int[] nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    boolean[] dp = new boolean[target + 1];\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n```\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\nusing namespace std;\n\nbool canPartition(vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) sum += num;\n    \n    if (sum % 2 != 0) return false;\n    \n    int target = sum / 2;\n    vector<bool> dp(target + 1, false);\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n```\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ",
        "python": "\n    ```python\ndef canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    \n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for i in range(target, num - 1, -1):\n            dp[i] = dp[i] or dp[i - num]\n    \n    return dp[target]\n```\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ",
        "javascript": "\n    ```javascript\nfunction canPartition(nums) {\n    const sum = nums.reduce((a, b) => a + b);\n    if (sum % 2 !== 0) return false;\n\n    const target = sum / 2;\n    const dp = new Array(target + 1).fill(false);\n    dp[0] = true;\n\n    for (const num of nums) {\n        for (let i = target; i >= num; i--) {\n            dp[i] = dp[i] || dp[i - num];\n        }\n    }\n    return dp[target];\n}\n```\n\n    \n    The algorithm is using Dynamic Programming to solve the partition problem. To determine if the array can be divided into two subsets with equal sum, first find the total sum of the array. If the total sum is odd, it's not possible to divide it into two equal subsets, so return false. If the total sum is even, find the target sum by dividing the total sum by 2.\n\nThe key idea is to find if there is a subset whose sum is equal to the target sum. Create a boolean dp array, where dp[i] represents if there is a subset with sum i. Initialize dp[0] to true, since the sum of 0 can be achieved with an empty subset.\n\nIterate through each number in the array, and for each number, iterate through the dp array backwards starting from the target sum. Update dp[i] to be true if dp[i - num] is true, meaning a subset with sum i - num is possible, and adding the current number num results in a subset with sum i.\n\nFinally, if dp[target] is true, it means there is a subset in the array with sum equal to target, so the array can be partitioned into two equal subsets. Otherwise, it cannot be partitioned.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,5,11,5]",
                    "output": " True",
                    "explanation": " The array can be partitioned as \\[1, 5, 5\\] and \\[11\\]."
                },
                {
                    "input": " nums = [1,2,3,5]",
                    "output": " False",
                    "explanation": " The array cannot be partitioned into equal sum subsets."
                }
            ],
            "function_input": [
                {
                    "input": "[1,5,11,5]",
                    "output": "True"
                },
                {
                    "input": "[1,2,3,5]",
                    "output": "False"
                }
            ]
        },
        "task_id": "leetcode-benchmark-148",
        "prompt": "Given an integer array `nums`, return `true` _if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or_ `false` _otherwise_."
    },
    "leetcode-benchmark-149": {
        "id": "leetcode-benchmark-149",
        "title": "Pacific Atlantic Water Flow",
        "difficulty": "Medium",
        "content": {
            "problem": "There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn _a **2D list** of grid coordinates_ `result` _where_ `result[i] = [ri, ci]` _denotes that rain water can flow from cell_ `(ri, ci)` _to **both** the Pacific and Atlantic oceans_.",
            "examples": [
                "**Example 1:**\n\n**Input:** heights = \\[\\[1,2,2,3,5\\],\\[3,2,3,4,4\\],\\[2,4,5,3,1\\],\\[6,7,1,4,5\\],\\[5,1,1,2,4\\]\\]\n**Output:** \\[\\[0,4\\],\\[1,3\\],\\[1,4\\],\\[2,2\\],\\[3,0\\],\\[3,1\\],\\[4,0\\]\\]\n**Explanation:** The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n\\[0,4\\]: \\[0,4\\] -> Pacific Ocean \n       \\[0,4\\] -> Atlantic Ocean\n\\[1,3\\]: \\[1,3\\] -> \\[0,3\\] -> Pacific Ocean \n       \\[1,3\\] -> \\[1,4\\] -> Atlantic Ocean\n\\[1,4\\]: \\[1,4\\] -> \\[1,3\\] -> \\[0,3\\] -> Pacific Ocean \n       \\[1,4\\] -> Atlantic Ocean\n\\[2,2\\]: \\[2,2\\] -> \\[1,2\\] -> \\[0,2\\] -> Pacific Ocean \n       \\[2,2\\] -> \\[2,3\\] -> \\[2,4\\] -> Atlantic Ocean\n\\[3,0\\]: \\[3,0\\] -> Pacific Ocean \n       \\[3,0\\] -> \\[4,0\\] -> Atlantic Ocean\n\\[3,1\\]: \\[3,1\\] -> \\[3,0\\] -> Pacific Ocean \n       \\[3,1\\] -> \\[4,1\\] -> Atlantic Ocean\n\\[4,0\\]: \\[4,0\\] -> Pacific Ocean \n       \\[4,0\\] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.\n\n",
                "**Example 2:**\n\n**Input:** heights = \\[\\[1\\]\\]\n**Output:** \\[\\[0,0\\]\\]\n**Explanation:** The water can flow from the only cell to the Pacific and Atlantic oceans."
            ],
            "constraints": "**Constraints:**\n\n*   `m == heights.length`\n*   `n == heights[r].length`\n*   `1 <= m, n <= 200`\n*   `0 <= heights[r][c] <= 105`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic List<int[]> pacificAtlantic(int[][] heights) {\n    int m = heights.length;\n    int n = heights[0].length;\n    boolean[][] pacific = new boolean[m][n];\n    boolean[][] atlantic = new boolean[m][n];\n\n    for (int r = 0; r < m; ++r) {\n        dfs(heights, r, 0, -1, pacific);\n        dfs(heights, r, n - 1, -1, atlantic);\n    }\n    for (int c = 0; c < n; ++c) {\n        dfs(heights, 0, c, -1, pacific);\n        dfs(heights, m - 1, c, -1, atlantic);\n    }\n    List<int[]> result = new ArrayList<>();\n    for (int r = 0; r < m; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.add(new int[]{r, c});\n            }\n        }\n    }\n    return result;\n}\n\nprivate void dfs(int[][] heights, int r, int c, int prevHeight, boolean[][] visited) {\n    if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;\n    if (heights[r][c] >= prevHeight && !visited[r][c]) {\n        visited[r][c] = true;\n        dfs(heights, r - 1, c, heights[r][c], visited);\n        dfs(heights, r + 1, c, heights[r][c], visited);\n        dfs(heights, r, c - 1, heights[r][c], visited);\n        dfs(heights, r, c + 1, heights[r][c], visited);\n    }\n}\n```\n\n    \n    We use DFS to traverse the island, starting from the ocean borders. We create two separate matrices (`pacific` and `atlantic`) keeping track of which cells can flow water to the corresponding ocean. For each cell, we perform DFS in all 4 directions if the neighboring cell's height is less than or equal to the current cell's height.\n\nAfter finishing the DFS search for both oceans, we iterate through the matrices to find the intersections (cells that can flow water to both oceans). If a cell can flow water to both oceans, we add its coordinates to the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n\nusing namespace std;\n\nvoid dfs(const vector<vector<int>>& heights, int r, int c, int prevHeight, vector<vector<bool>>& visited) {\n    if (r < 0 || r >= heights.size() || c < 0 || c >= heights[0].size())\n        return;\n    if (heights[r][c] >= prevHeight && !visited[r][c]) {\n        visited[r][c] = true;\n        dfs(heights, r - 1, c, heights[r][c], visited);\n        dfs(heights, r + 1, c, heights[r][c], visited);\n        dfs(heights, r, c - 1, heights[r][c], visited);\n        dfs(heights, r, c + 1, heights[r][c], visited);\n    }\n}\n\nvector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n    int m = heights.size();\n    int n = heights[0].size();\n    vector<vector<bool>> pacific(m, vector<bool>(n, false));\n    vector<vector<bool>> atlantic(m, vector<bool>(n, false));\n\n    for (int r = 0; r < m; ++r) {\n        dfs(heights, r, 0, -1, pacific);\n        dfs(heights, r, n - 1, -1, atlantic);\n    }\n    for (int c = 0; c < n; ++c) {\n        dfs(heights, 0, c, -1, pacific);\n        dfs(heights, m - 1, c, -1, atlantic);\n    }\n    vector<vector<int>> result;\n    for (int r = 0; r < m; ++r) {\n        for (int c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push_back({r, c});\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    We use DFS to traverse the island, starting from the ocean borders. We create two separate matrices (`pacific` and `atlantic`) keeping track of which cells can flow water to the corresponding ocean. For each cell, we perform DFS in all 4 directions if the neighboring cell's height is less than or equal to the current cell's height.\n\nAfter finishing the DFS search for both oceans, we iterate through the matrices to find the intersections (cells that can flow water to both oceans). If a cell can flow water to both oceans, we add its coordinates to the result list.\n    ",
        "python": "\n    ```python\ndef pacificAtlantic(heights):\n    def dfs(r, c, prev_height, visited):\n        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):\n            return\n        if heights[r][c] >= prev_height and not visited[r][c]:\n            visited[r][c] = True\n            dfs(r - 1, c, heights[r][c], visited)\n            dfs(r + 1, c, heights[r][c], visited)\n            dfs(r, c - 1, heights[r][c], visited)\n            dfs(r, c + 1, heights[r][c], visited)\n\n    m, n = len(heights), len(heights[0])\n    pacific = [[False] * n for _ in range(m)]\n    atlantic = [[False] * n for _ in range(m)]\n\n    for r in range(m):\n        dfs(r, 0, -1, pacific)\n        dfs(r, n - 1, -1, atlantic)\n    for c in range(n):\n        dfs(0, c, -1, pacific)\n        dfs(m - 1, c, -1, atlantic)\n\n    result = []\n    for r in range(m):\n        for c in range(n):\n            if pacific[r][c] and atlantic[r][c]:\n                result.append([r, c])\n    return result\n```\n\n    \n    We use DFS to traverse the island, starting from the ocean borders. We create two separate matrices (`pacific` and `atlantic`) keeping track of which cells can flow water to the corresponding ocean. For each cell, we perform DFS in all 4 directions if the neighboring cell's height is less than or equal to the current cell's height.\n\nAfter finishing the DFS search for both oceans, we iterate through the matrices to find the intersections (cells that can flow water to both oceans). If a cell can flow water to both oceans, we add its coordinates to the result list.\n    ",
        "javascript": "\n    ```javascript\nfunction pacificAtlantic(heights) {\n    function dfs(r, c, prevHeight, visited) {\n        if (r < 0 || r >= heights.length || c < 0 || c >= heights[0].length) return;\n        if (heights[r][c] >= prevHeight && !visited[r][c]) {\n            visited[r][c] = true;\n            dfs(r - 1, c, heights[r][c], visited);\n            dfs(r + 1, c, heights[r][c], visited);\n            dfs(r, c - 1, heights[r][c], visited);\n            dfs(r, c + 1, heights[r][c], visited);\n        }\n    }\n\n    const m = heights.length;\n    const n = heights[0].length;\n    const pacific = Array.from(Array(m), () => new Array(n).fill(false));\n    const atlantic = Array.from(Array(m), () => new Array(n).fill(false));\n\n    for (let r = 0; r < m; ++r) {\n        dfs(r, 0, -1, pacific);\n        dfs(r, n - 1, -1, atlantic);\n    }\n    for (let c = 0; c < n; ++c) {\n        dfs(0, c, -1, pacific);\n        dfs(m - 1, c, -1, atlantic);\n    }\n    const result = [];\n    for (let r = 0; r < m; ++r) {\n        for (let c = 0; c < n; ++c) {\n            if (pacific[r][c] && atlantic[r][c]) {\n                result.push([r, c]);\n            }\n        }\n    }\n    return result;\n}\n```\n\n    \n    We use DFS to traverse the island, starting from the ocean borders. We create two separate matrices (`pacific` and `atlantic`) keeping track of which cells can flow water to the corresponding ocean. For each cell, we perform DFS in all 4 directions if the neighboring cell's height is less than or equal to the current cell's height.\n\nAfter finishing the DFS search for both oceans, we iterate through the matrices to find the intersections (cells that can flow water to both oceans). If a cell can flow water to both oceans, we add its coordinates to the result list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
                    "output": " [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]",
                    "explanation": " The following cells can flow to the Pacific and Atlantic oceans, as shown below:\n\\[0,4\\]: \\[0,4\\] -> Pacific Ocean \n       \\[0,4\\] -> Atlantic Ocean\n\\[1,3\\]: \\[1,3\\] -> \\[0,3\\] -> Pacific Ocean \n       \\[1,3\\] -> \\[1,4\\] -> Atlantic Ocean\n\\[1,4\\]: \\[1,4\\] -> \\[1,3\\] -> \\[0,3\\] -> Pacific Ocean \n       \\[1,4\\] -> Atlantic Ocean\n\\[2,2\\]: \\[2,2\\] -> \\[1,2\\] -> \\[0,2\\] -> Pacific Ocean \n       \\[2,2\\] -> \\[2,3\\] -> \\[2,4\\] -> Atlantic Ocean\n\\[3,0\\]: \\[3,0\\] -> Pacific Ocean \n       \\[3,0\\] -> \\[4,0\\] -> Atlantic Ocean\n\\[3,1\\]: \\[3,1\\] -> \\[3,0\\] -> Pacific Ocean \n       \\[3,1\\] -> \\[4,1\\] -> Atlantic Ocean\n\\[4,0\\]: \\[4,0\\] -> Pacific Ocean \n       \\[4,0\\] -> Atlantic Ocean\nNote that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans."
                },
                {
                    "input": " heights = [[1]]",
                    "output": " [[0,0]]",
                    "explanation": " The water can flow from the only cell to the Pacific and Atlantic oceans."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
                    "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
                },
                {
                    "input": "[[1]]",
                    "output": "[[0,0]]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-149",
        "prompt": "There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn _a **2D list** of grid coordinates_ `result` _where_ `result[i] = [ri, ci]` _denotes that rain water can flow from cell_ `(ri, ci)` _to **both** the Pacific and Atlantic oceans_."
    },
    "leetcode-benchmark-150": {
        "id": "leetcode-benchmark-150",
        "title": "Sentence Screen Fitting",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.\n\nThe order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line.",
            "examples": [
                "**Example 1:**\n\n**Input:** sentence = \\[ \"hello \", \"world \"\\], rows = 2, cols = 8\n**Output:** 1\n**Explanation:**\nhello---\nworld---\nThe character '-' signifies an empty space on the screen.\n\n",
                "**Example 2:**\n\n**Input:** sentence = \\[ \"a \",  \"bcd \",  \"e \"\\], rows = 3, cols = 6\n**Output:** 2\n**Explanation:**\na-bcd- \ne-a---\nbcd-e-\nThe character '-' signifies an empty space on the screen.\n\n",
                "**Example 3:**\n\n**Input:** sentence = \\[ \"i \", \"had \", \"apple \", \"pie \"\\], rows = 4, cols = 5\n**Output:** 1\n**Explanation:**\ni-had\napple\npie-i\nhad--\nThe character '-' signifies an empty space on the screen."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= sentence.length <= 100`\n*   `1 <= sentence[i].length <= 10`\n*   `sentence[i]` consists of lowercase English letters.\n*   `1 <= rows, cols <= 2 * 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int wordsTyping(String[] sentence, int rows, int cols) {\n    int totalChars = 0;\n    for (String word : sentence) {\n        totalChars += word.length() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remainingCols = cols;\n        while (true) {\n            int wordLen = sentence[index].length();\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "c++": "\n    ```cpp\nint wordsTyping(vector<string>& sentence, int rows, int cols) {\n    int total_chars = 0;\n    for (const auto& word : sentence) {\n        total_chars += word.size() + 1;\n    }\n\n    int result = 0;\n    int index = 0;\n    for (int r = 0; r < rows; ++r) {\n        int remaining_cols = cols;\n        while (true) {\n            int word_len = sentence[index].size();\n            if (remaining_cols >= word_len) {\n                remaining_cols -= word_len + 1;\n                index = (index + 1) % sentence.size();\n                if (index == 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "python": "\n    ```python\ndef words_typing(sentence, rows, cols):\n    total_chars = sum(len(word) + 1 for word in sentence)\n\n    result = 0\n    index = 0\n    for _ in range(rows):\n        remaining_cols = cols\n        while True:\n            word_len = len(sentence[index])\n            if remaining_cols >= word_len:\n                remaining_cols -= word_len + 1\n                index = (index + 1) % len(sentence)\n                if index == 0:\n                    result += 1\n            else:\n                break\n\n    return result\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "javascript": "\n    ```javascript\nfunction wordsTyping(sentence, rows, cols) {\n    let totalChars = sentence.reduce((acc, word) => acc + word.length + 1, 0);\n\n    let result = 0;\n    let index = 0;\n    for (let r = 0; r < rows; ++r) {\n        let remainingCols = cols;\n        while (true) {\n            let wordLen = sentence[index].length;\n            if (remainingCols >= wordLen) {\n                remainingCols -= wordLen + 1;\n                index = (index + 1) % sentence.length;\n                if (index === 0) result++;\n            } else {\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```\n    \n    The algorithm works as follows:\n1. Calculate the total number of characters in the sentence (including space after each word).\n2. Initialize the result (count of repetitions) and the index of the current word in the sentence.\n3. For each row:\n   1. Keep track of remaining columns (initially equal to `cols`).\n   2. Iterate through words in the sentence, and for each word:\n      1. Check if the word can fit in the remaining columns.\n      2. If it fits, update the remaining columns and index for the next word. If the index equals zero, increment the result.\n      3. If it doesn't fit, break the current row iteration.\n4. Return the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " sentence = [ \"hello \", \"world \"], rows = 2, cols = 8",
                    "output": " 1",
                    "explanation": "\nhello---\nworld---\nThe character '-' signifies an empty space on the screen."
                },
                {
                    "input": " sentence = [ \"a \",  \"bcd \",  \"e \"], rows = 3, cols = 6",
                    "output": " 2",
                    "explanation": "\na-bcd- \ne-a---\nbcd-e-\nThe character '-' signifies an empty space on the screen."
                },
                {
                    "input": " sentence = [ \"i \", \"had \", \"apple \", \"pie \"], rows = 4, cols = 5",
                    "output": " 1",
                    "explanation": "\ni-had\napple\npie-i\nhad--\nThe character '-' signifies an empty space on the screen."
                }
            ],
            "function_input": [
                {
                    "input": "[\"hello\",\"world\"],2,8",
                    "output": "1"
                },
                {
                    "input": "[\"a\",\"bcd\",\"e\"],3,6",
                    "output": "2"
                },
                {
                    "input": "[\"i\",\"had\",\"apple\",\"pie\"],4,5",
                    "output": "1"
                }
            ]
        },
        "task_id": "leetcode-benchmark-150",
        "prompt": "Given a `rows x cols` screen and a `sentence` represented as a list of strings, return _the number of times the given sentence can be fitted on the screen_.\n\nThe order of words in the sentence must remain unchanged, and a word cannot be split into two lines. A single space must separate two consecutive words in a line."
    },
    "leetcode-benchmark-151": {
        "id": "leetcode-benchmark-151",
        "title": "Battleships in a Board",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",
            "examples": [
                "**Example 1:**\n\n**Input:** board = \\[\\[ \"X \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\],\\[ \". \", \". \", \". \", \"X \"\\]\\]\n**Output:** 2\n\n",
                "**Example 2:**\n\n**Input:** board = \\[\\[ \". \"\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 200`\n*   `board[i][j]` is either `'.'` or `'X'`.\n\n**",
            "follow_up": "Follow up:** Could you do it in one-pass, using only `O(1)` extra memory and without modifying the values `board`?"
        },
        "java": "\n    ```java\npublic int countBattleships(char[][] board) {\n    int count = 0;\n    for (int i = 0; i < board.length; i++) {\n        for (int j = 0; j < board[i].length; j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "c++": "\n    ```cpp\nint countBattleships(vector<vector<char>>& board) {\n    int count = 0;\n    for (int i = 0; i < board.size(); i++) {\n        for (int j = 0; j < board[i].size(); j++) {\n            if (board[i][j] == 'X' &&\n                (i == 0 || board[i - 1][j] == '.') &&\n                (j == 0 || board[i][j - 1] == '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "python": "\n    ```python\ndef countBattleships(board):\n    count = 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if (board[i][j] == 'X' and\n                (i == 0 or board[i - 1][j] == '.') and\n                (j == 0 or board[i][j - 1] == '.')):\n                count += 1\n    return count\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "javascript": "\n    ```javascript\nfunction countBattleships(board) {\n    let count = 0;\n    for (let i = 0; i < board.length; i++) {\n        for (let j = 0; j < board[i].length; j++) {\n            if (board[i][j] === 'X' &&\n                (i === 0 || board[i - 1][j] === '.') &&\n                (j === 0 || board[i][j - 1] === '.')) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```\n    \n    The algorithm iterates over each cell in the given `board`. If the current cell is 'X' (a battleship) and both the cell above it (if exists) and the cell to its left (if exists) are not 'X', it means we have found a new battleship. We increment the count of battleships in this case. In the end, we return the total count of battleships found.\n\nThe reason we check only the top and left cells is that we only want to count the start of a battleship, and not count the same battleship multiple times. Since the battleships can be in the horizontal or vertical direction, checking the left and top cells ensures that we count each battleship only once. \n    ",
        "passk": {
            "input_example": [
                {
                    "input": " board = [[ \"X \", \". \", \". \", \"X \"],[ \". \", \". \", \". \", \"X \"],[ \". \", \". \", \". \", \"X \"]]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " board = [[ \". \"]]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]",
                    "output": "2"
                },
                {
                    "input": "[[\".\"]]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-151",
        "prompt": "Given an `m x n` matrix `board` where each cell is a battleship `'X'` or empty `'.'`, return _the number of the **battleships** on_ `board`.\n\n**Battleships** can only be placed horizontally or vertically on `board`. In other words, they can only be made of the shape `1 x k` (`1` row, `k` columns) or `k x 1` (`k` rows, `1` column), where `k` can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships)."
    },
    "leetcode-benchmark-152": {
        "id": "leetcode-benchmark-152",
        "title": "Maximum XOR of Two Numbers in an Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums`, return _the maximum result of_ `nums[i] XOR nums[j]`, where `0 <= i <= j < n`.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[3,10,5,25,2,8\\]\n**Output:** 28\n**Explanation:** The maximum result is 5 XOR 25 = 28.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[14,70,53,83,49,91,36,80,92,51,66,70\\]\n**Output:** 127"
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= nums.length <= 2 * 105`\n*   `0 <= nums[i] <= 231 - 1`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int findMaximumXOR(int[] nums) {\n    int max_xor = 0, mask = 0;\n    \n    for (int i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        HashSet<Integer> prefixes = new HashSet<>();\n        \n        for (int num : nums) {\n            prefixes.add(num & mask);\n        }\n        \n        int possible_max = max_xor | (1 << i);\n        \n        for (int prefix : prefixes) {\n            if (prefixes.contains(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n    \n    return max_xor;\n}\n```\n    \n    1. Initialize max_xor and mask to 0.\n2. Loop through the 32-bit integer type from the most significant bit to the least significant bit.\n3. In each iteration, find the longest prefix of the XOR value, which is built from more significant bits to less significant bit. Update mask by left-shifting 1 and bitwise OR with the mask.\n4. Add each element bitwise AND the mask into a set called prefixes.\n5. Calculate the possible max XOR value up to the current bit by bitwise OR with (1 << i) and the current max_xor.\n6. Loop through the prefixes and check if the XOR of prefix and possible_max is in the set of prefixes.\n7. If it's in the set, update max_xor to the possible_max and break the loop, otherwise, continue with the next bit.\n8. After processing all bits, return max_xor as the final result.\n    ",
        "c++": "\n    ```cpp\nint findMaximumXOR(vector<int>& nums) {\n    int max_xor = 0;\n    int mask = 0;\n\n    for (int i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        unordered_set<int> prefixes;\n\n        for (int num : nums) {\n            prefixes.insert(num & mask);\n        }\n\n        int possible_max = max_xor | (1 << i);\n\n        for (int prefix : prefixes) {\n            if (prefixes.count(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n\n    return max_xor;\n}\n```\n    \n    1. Initialize max_xor and mask to 0.\n2. Loop through the 32-bit integer type from the most significant bit to the least significant bit.\n3. In each iteration, find the longest prefix of the XOR value, which is built from more significant bits to less significant bit. Update mask by left-shifting 1 and bitwise OR with the mask.\n4. Add each element bitwise AND the mask into a set called prefixes.\n5. Calculate the possible max XOR value up to the current bit by bitwise OR with (1 << i) and the current max_xor.\n6. Loop through the prefixes and check if the XOR of prefix and possible_max is in the set of prefixes.\n7. If it's in the set, update max_xor to the possible_max and break the loop, otherwise, continue with the next bit.\n8. After processing all bits, return max_xor as the final result.\n    ",
        "python": "\n    ```python\ndef findMaximumXOR(nums):\n    max_xor = 0\n    mask = 0\n\n    for i in range(31, -1, -1):\n        mask |= (1 << i)\n        prefixes = {num & mask for num in nums}\n\n        possible_max = max_xor | (1 << i)\n\n        for prefix in prefixes:\n            if prefix ^ possible_max in prefixes:\n                max_xor = possible_max\n                break\n\n    return max_xor\n```\n    \n    1. Initialize max_xor and mask to 0.\n2. Loop through the 32-bit integer type from the most significant bit to the least significant bit.\n3. In each iteration, find the longest prefix of the XOR value, which is built from more significant bits to less significant bit. Update mask by left-shifting 1 and bitwise OR with the mask.\n4. Add each element bitwise AND the mask into a set called prefixes.\n5. Calculate the possible max XOR value up to the current bit by bitwise OR with (1 << i) and the current max_xor.\n6. Loop through the prefixes and check if the XOR of prefix and possible_max is in the set of prefixes.\n7. If it's in the set, update max_xor to the possible_max and break the loop, otherwise, continue with the next bit.\n8. After processing all bits, return max_xor as the final result.\n    ",
        "javascript": "\n    ```javascript\nfunction findMaximumXOR(nums) {\n    let max_xor = 0, mask = 0;\n    \n    for (let i = 31; i >= 0; i--) {\n        mask |= (1 << i);\n        let prefixes = new Set();\n        \n        for (let num of nums) {\n            prefixes.add(num & mask);\n        }\n        \n        let possible_max = max_xor | (1 << i);\n\n        for (let prefix of prefixes) {\n            if (prefixes.has(prefix ^ possible_max)) {\n                max_xor = possible_max;\n                break;\n            }\n        }\n    }\n    \n    return max_xor;\n}\n```\n    \n    1. Initialize max_xor and mask to 0.\n2. Loop through the 32-bit integer type from the most significant bit to the least significant bit.\n3. In each iteration, find the longest prefix of the XOR value, which is built from more significant bits to less significant bit. Update mask by left-shifting 1 and bitwise OR with the mask.\n4. Add each element bitwise AND the mask into a set called prefixes.\n5. Calculate the possible max XOR value up to the current bit by bitwise OR with (1 << i) and the current max_xor.\n6. Loop through the prefixes and check if the XOR of prefix and possible_max is in the set of prefixes.\n7. If it's in the set, update max_xor to the possible_max and break the loop, otherwise, continue with the next bit.\n8. After processing all bits, return max_xor as the final result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [3,10,5,25,2,8]",
                    "output": " 28",
                    "explanation": " The maximum result is 5 XOR 25 = 28."
                },
                {
                    "input": " nums = [14,70,53,83,49,91,36,80,92,51,66,70]",
                    "output": " 127",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[3,10,5,25,2,8]",
                    "output": "28"
                },
                {
                    "input": "[14,70,53,83,49,91,36,80,92,51,66,70]",
                    "output": "127"
                }
            ]
        },
        "task_id": "leetcode-benchmark-152",
        "prompt": "Given an integer array `nums`, return _the maximum result of_ `nums[i] XOR nums[j]`, where `0 <= i <= j < n`."
    },
    "leetcode-benchmark-153": {
        "id": "leetcode-benchmark-153",
        "title": "Reconstruct Original Digits from English",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `s` containing an out-of-order English representation of digits `0-9`, return _the digits in **ascending** order_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s = \"owoztneoer\"\n**Output:** \"012\"\n\n",
                "**Example 2:**\n\n**Input:** s = \"fviefuro\"\n**Output:** \"45\""
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s[i]` is one of the characters `[ \"e \", \"g \", \"f \", \"i \", \"h \", \"o \", \"n \", \"s \", \"r \", \"u \", \"t \", \"w \", \"v \", \"x \", \"z \"]`.\n*   `s` is **guaranteed** to be valid.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic String findDigitsInAscendingOrder(String s) {\n    int[] count = new int[10];\n    for (char c : s.toCharArray()) {\n        if (c == 'z') count[0]++;\n        if (c == 'w') count[2]++;\n        if (c == 'u') count[4]++;\n        if (c == 'x') count[6]++;\n        if (c == 'g') count[8]++;\n        if (c == 'o') count[1]++;\n        if (c == 'h') count[3]++;\n        if (c == 'f') count[5]++;\n        if (c == 's') count[7]++;\n        if (c == 'i') count[9]++;\n    }\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n    \n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            sb.append(i);\n        }\n    }\n    return sb.toString();\n}\n```\n\n    \n    The algorithm consists of the following steps:\n1. Initialize an array `count` of size 10 to store the count of digits from 0 to 9.\n2. Iterate through the given string (`s`). Update the `count` array according to the appearance of characters as follows:\n    - Count `0` for every `'z'`\n    - Count `2` for every `'w'`\n    - Count `4` for every `'u'`\n    - Count `6` for every `'x'`\n    - Count `8` for every `'g'`\n    - Count `1` for every `'o'` (one + two + four)\n    - Count `3` for every `'h'` (three + eight)\n    - Count `5` for every `'f'` (five + seven)\n    - Count `7` for every `'s'` (six + seven)\n    - Count `9` for every `'i'` (five + six + eight + nine)\n3. Update the counts of digits `1`, `3`, `5`, `7`, and `9` by subtracting the overlapping counts of other digits.\n4. Iterate through the `count` array and append the digit (i) `count[i]` times to the result string. This ensures we have the digits in ascending order.\n5. Return the result.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nstring find_digits_in_ascending_order(string s) {\n    vector<int> count(10, 0);\n    for (char c : s) {\n        if (c == 'z') count[0]++;\n        if (c == 'w') count[2]++;\n        if (c == 'u') count[4]++;\n        if (c == 'x') count[6]++;\n        if (c == 'g') count[8]++;\n        if (c == 'o') count[1]++;  // o = one + two + four\n        if (c == 'h') count[3]++;  // h = three + eight\n        if (c == 'f') count[5]++;  // f = five + seven\n        if (c == 's') count[7]++;  // s = six + seven\n        if (c == 'i') count[9]++;  // i = five + six + eight + nine\n    }\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n    \n    string res;\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < count[i]; j++) {\n            res += to_string(i);\n        }\n    }\n    return res;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n1. Initialize an array `count` of size 10 to store the count of digits from 0 to 9.\n2. Iterate through the given string (`s`). Update the `count` array according to the appearance of characters as follows:\n    - Count `0` for every `'z'`\n    - Count `2` for every `'w'`\n    - Count `4` for every `'u'`\n    - Count `6` for every `'x'`\n    - Count `8` for every `'g'`\n    - Count `1` for every `'o'` (one + two + four)\n    - Count `3` for every `'h'` (three + eight)\n    - Count `5` for every `'f'` (five + seven)\n    - Count `7` for every `'s'` (six + seven)\n    - Count `9` for every `'i'` (five + six + eight + nine)\n3. Update the counts of digits `1`, `3`, `5`, `7`, and `9` by subtracting the overlapping counts of other digits.\n4. Iterate through the `count` array and append the digit (i) `count[i]` times to the result string. This ensures we have the digits in ascending order.\n5. Return the result.\n    ",
        "python": "\n    ```python\ndef find_digits_in_ascending_order(s):\n    count = [0] * 10\n    for c in s:\n        if c == 'z': count[0] += 1\n        if c == 'w': count[2] += 1\n        if c == 'u': count[4] += 1\n        if c == 'x': count[6] += 1\n        if c == 'g': count[8] += 1\n        if c == 'o': count[1] += 1\n        if c == 'h': count[3] += 1\n        if c == 'f': count[5] += 1\n        if c == 's': count[7] += 1\n        if c == 'i': count[9] += 1\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    \n    res = []\n    for i in range(10):\n        res.extend([str(i)] * count[i])\n    return ''.join(res)\n```\n\n    \n    The algorithm consists of the following steps:\n1. Initialize an array `count` of size 10 to store the count of digits from 0 to 9.\n2. Iterate through the given string (`s`). Update the `count` array according to the appearance of characters as follows:\n    - Count `0` for every `'z'`\n    - Count `2` for every `'w'`\n    - Count `4` for every `'u'`\n    - Count `6` for every `'x'`\n    - Count `8` for every `'g'`\n    - Count `1` for every `'o'` (one + two + four)\n    - Count `3` for every `'h'` (three + eight)\n    - Count `5` for every `'f'` (five + seven)\n    - Count `7` for every `'s'` (six + seven)\n    - Count `9` for every `'i'` (five + six + eight + nine)\n3. Update the counts of digits `1`, `3`, `5`, `7`, and `9` by subtracting the overlapping counts of other digits.\n4. Iterate through the `count` array and append the digit (i) `count[i]` times to the result string. This ensures we have the digits in ascending order.\n5. Return the result.\n    ",
        "javascript": "\n    ```javascript\nfunction findDigitsInAscendingOrder(s) {\n    const count = new Array(10).fill(0);\n    for (const c of s) {\n        if (c === 'z') count[0]++;\n        if (c === 'w') count[2]++;\n        if (c === 'u') count[4]++;\n        if (c === 'x') count[6]++;\n        if (c === 'g') count[8]++;\n        if (c === 'o') count[1]++;\n        if (c === 'h') count[3]++;\n        if (c === 'f') count[5]++;\n        if (c === 's') count[7]++;\n        if (c === 'i') count[9]++;\n    }\n    count[1] -= (count[0] + count[2] + count[4]);\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= (count[5] + count[6] + count[8]);\n    \n    let res = \"\";\n    for (let i = 0; i < 10; i++) {\n        res += String(i).repeat(count[i]);\n    }\n    return res;\n}\n```\n\n    \n    The algorithm consists of the following steps:\n1. Initialize an array `count` of size 10 to store the count of digits from 0 to 9.\n2. Iterate through the given string (`s`). Update the `count` array according to the appearance of characters as follows:\n    - Count `0` for every `'z'`\n    - Count `2` for every `'w'`\n    - Count `4` for every `'u'`\n    - Count `6` for every `'x'`\n    - Count `8` for every `'g'`\n    - Count `1` for every `'o'` (one + two + four)\n    - Count `3` for every `'h'` (three + eight)\n    - Count `5` for every `'f'` (five + seven)\n    - Count `7` for every `'s'` (six + seven)\n    - Count `9` for every `'i'` (five + six + eight + nine)\n3. Update the counts of digits `1`, `3`, `5`, `7`, and `9` by subtracting the overlapping counts of other digits.\n4. Iterate through the `count` array and append the digit (i) `count[i]` times to the result string. This ensures we have the digits in ascending order.\n5. Return the result.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s = \"owoztneoer\"",
                    "output": " \"012\"",
                    "explanation": null
                },
                {
                    "input": " s = \"fviefuro\"",
                    "output": " \"45\"",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "\"owoztneoer\"",
                    "output": "\"012\""
                },
                {
                    "input": "\"fviefuro\"",
                    "output": "\"45\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-153",
        "prompt": "Given a string `s` containing an out-of-order English representation of digits `0-9`, return _the digits in **ascending** order_."
    },
    "leetcode-benchmark-154": {
        "id": "leetcode-benchmark-154",
        "title": "Longest Repeating Character Replacement",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn _the length of the longest substring containing the same letter you can get after performing the above operations_.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"ABAB \", k = 2\n**Output:** 4\n**Explanation:** Replace the two 'A's with two 'B's or vice versa.\n\n",
                "**Example 2:**\n\n**Input:** s =  \"AABABBA \", k = 1\n**Output:** 4\n**Explanation:** Replace the one 'A' in the middle with 'B' and form  \"AABBBBA \".\nThe substring  \"BBBB \" has the longest repeating letters, which is 4."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length <= 105`\n*   `s` consists of only uppercase English letters.\n*   `0 <= k <= s.length`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int characterReplacement(String s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int[] freq = new int[26];\n    \n    for (right = 0; right < n; right++) {\n        freq[s.charAt(right) - 'A']++;\n        maxFreq = Math.max(maxFreq, freq[s.charAt(right) - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charAt(left) - 'A']--;\n            left++;\n        }\n        \n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint characterReplacement(string s, int k) {\n    int n = s.length();\n    int left = 0, right = 0, maxFreq = 0, result = 0;\n    int freq[26] = {0};\n    \n    for (right = 0; right < n; right++) {\n        freq[s[right] - 'A']++;\n        maxFreq = max(maxFreq, freq[s[right] - 'A']);\n        \n        if (right - left + 1 - maxFreq > k) {\n            freq[s[left] - 'A']--;\n            left++;\n        }\n        \n        result = max(result, right - left + 1);\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "python": "\n    ```python\ndef characterReplacement(s:str, k:int) -> int:\n    n = len(s)\n    left = 0\n    right = 0\n    maxFreq = 0\n    result = 0\n    freq = [0] * 26\n\n    for right in range(n):\n        freq[ord(s[right]) - ord('A')] += 1\n        maxFreq = max(maxFreq, freq[ord(s[right]) - ord('A')])\n\n        if right - left + 1 - maxFreq > k:\n            freq[ord(s[left]) - ord('A')] -= 1\n            left += 1\n\n        result = max(result, right - left + 1)\n\n    return result\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "javascript": "\n    ```javascript\nfunction characterReplacement(s, k) {\n    let n = s.length;\n    let left = 0, right = 0, maxFreq = 0, result = 0;\n    let freq = new Array(26).fill(0);\n\n    for (right = 0; right < n; right++) {\n        freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]++;\n        maxFreq = Math.max(maxFreq, freq[s.charCodeAt(right) - 'A'.charCodeAt(0)]);\n\n        if (right - left + 1 - maxFreq > k) {\n            freq[s.charCodeAt(left) - 'A'.charCodeAt(0)]--;\n            left++;\n        }\n\n        result = Math.max(result, right - left + 1);\n    }\n    \n    return result;\n}\n```\n\n    \n    1. Keep two pointers, left and right, to define the current substring we are evaluating.\n2. For each character, increment its count in the frequency array and update the current maximum frequency.\n3. If the length of the current substring minus the maximum frequency (i.e., the number of changes needed to make all characters the same) is greater than k, move the left pointer and update the frequency array.\n4. Keep track of the longest substring updating result and return it after iterating through the string.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"ABAB \", k = 2",
                    "output": " 4",
                    "explanation": " Replace the two 'A's with two 'B's or vice versa."
                },
                {
                    "input": " s =  \"AABABBA \", k = 1",
                    "output": " 4",
                    "explanation": " Replace the one 'A' in the middle with 'B' and form  \"AABBBBA \".\nThe substring  \"BBBB \" has the longest repeating letters, which is 4."
                }
            ],
            "function_input": [
                {
                    "input": "\"ABAB\",2",
                    "output": "4"
                },
                {
                    "input": "\"AABABBA\",1",
                    "output": "4"
                }
            ]
        },
        "task_id": "leetcode-benchmark-154",
        "prompt": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most `k` times.\n\nReturn _the length of the longest substring containing the same letter you can get after performing the above operations_."
    },
    "leetcode-benchmark-155": {
        "id": "leetcode-benchmark-155",
        "title": "Non-overlapping Intervals",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,3\\]\\]\n**Output:** 1\n**Explanation:** \\[1,3\\] can be removed and the rest of the intervals are non-overlapping.\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[1,2\\],\\[1,2\\]\\]\n**Output:** 2\n**Explanation:** You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping.\n\n",
                "**Example 3:**\n\n**Input:** intervals = \\[\\[1,2\\],\\[2,3\\]\\]\n**Output:** 0\n**Explanation:** You don't need to remove any of the intervals since they're already non-overlapping."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `-5 * 104 <= starti < endi <= 5 * 104`",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Arrays;\n\npublic int eraseOverlapIntervals(int[][] intervals) {\n    if (intervals.length == 0) return 0;\n\n    Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n    int count = 0;\n    int prev_end = intervals[0][1];\n\n    for (int i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <algorithm>\n\nbool compare(const std::vector<int>& a, const std::vector<int>& b) {\n    return a[1] < b[1];\n}\n\nint eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n    \n    std::sort(intervals.begin(), intervals.end(), compare);\n    \n    int count = 0;\n    int prev_end = intervals[0][1];\n    \n    for (size_t i = 1; i < intervals.size(); i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n    \n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "python": "\n    ```python\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n    \n    intervals.sort(key=lambda x: x[1])\n    \n    count = 0\n    prev_end = intervals[0][1]\n    \n    for i in range(1, len(intervals)):\n        if intervals[i][0] < prev_end:\n            count += 1\n        else:\n            prev_end = intervals[i][1]\n    \n    return count\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "javascript": "\n    ```javascript\nfunction eraseOverlapIntervals(intervals) {\n    if (intervals.length === 0) return 0;\n\n    intervals.sort((a, b) => a[1] - b[1]);\n\n    let count = 0;\n    let prev_end = intervals[0][1];\n\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] < prev_end) {\n            count++;\n        } else {\n            prev_end = intervals[i][1];\n        }\n    }\n\n    return count;\n}\n```\n    \n    The algorithm starts by sorting the input intervals by their ending times. This is because we want to select a minimum number of intervals with the smallest end time to make the rest of the intervals non-overlapping. Then, the algorithm initializes the count of overlapping intervals to 0 and the previous ending value with the first interval's end time.\n\nWe loop through the intervals starting from the second interval. In each iteration, if the current interval's start time is less than the previous end time, it means the current interval overlaps with the previous one. We increment the count in this case. If there's no overlap, we update the previous end time with the current interval's end time. After looping through all the intervals, the count is returned as the minimum number of intervals to remove for non-overlapping intervals.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " intervals = [[1,2],[2,3],[3,4],[1,3]]",
                    "output": " 1",
                    "explanation": " \\[1,3\\] can be removed and the rest of the intervals are non-overlapping."
                },
                {
                    "input": " intervals = [[1,2],[1,2],[1,2]]",
                    "output": " 2",
                    "explanation": " You need to remove two \\[1,2\\] to make the rest of the intervals non-overlapping."
                },
                {
                    "input": " intervals = [[1,2],[2,3]]",
                    "output": " 0",
                    "explanation": " You don't need to remove any of the intervals since they're already non-overlapping."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2],[2,3],[3,4],[1,3]]",
                    "output": "1"
                },
                {
                    "input": "[[1,2],[1,2],[1,2]]",
                    "output": "2"
                },
                {
                    "input": "[[1,2],[2,3]]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-155",
        "prompt": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_."
    },
    "leetcode-benchmark-156": {
        "id": "leetcode-benchmark-156",
        "title": "Find Right Interval",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an array of `intervals`, where `intervals[i] = [starti, endi]` and each `starti` is **unique**.\n\nThe **right interval** for an interval `i` is an interval `j` such that `startj >= endi` and `startj` is **minimized**. Note that `i` may equal `j`.\n\nReturn _an array of **right interval** indices for each interval `i`_. If no **right interval** exists for interval `i`, then put `-1` at index `i`.",
            "examples": [
                "**Example 1:**\n\n**Input:** intervals = \\[\\[1,2\\]\\]\n**Output:** \\[-1\\]\n**Explanation:** There is only one interval in the collection, so it outputs -1.\n\n",
                "**Example 2:**\n\n**Input:** intervals = \\[\\[3,4\\],\\[2,3\\],\\[1,2\\]\\]\n**Output:** \\[-1,0,1\\]\n**Explanation:** There is no right interval for \\[3,4\\].\nThe right interval for \\[2,3\\] is \\[3,4\\] since start0 = 3 is the smallest start that is >= end1 = 3.\nThe right interval for \\[1,2\\] is \\[2,3\\] since start1 = 2 is the smallest start that is >= end2 = 2.\n\n",
                "**Example 3:**\n\n**Input:** intervals = \\[\\[1,4\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** \\[-1,2,-1\\]\n**Explanation:** There is no right interval for \\[1,4\\] and \\[3,4\\].\nThe right interval for \\[2,3\\] is \\[3,4\\] since start2 = 3 is the smallest start that is >= end1 = 3."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= intervals.length <= 2 * 104`\n*   `intervals[i].length == 2`\n*   `-106 <= starti <= endi <= 106`\n*   The start point of each interval is **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.TreeMap;\nimport java.util.Map;\n\npublic int[] findRightInterval(int[][] intervals) {\n    int[] res = new int[intervals.length];\n    TreeMap<Integer, Integer> starts = new TreeMap<>();\n\n    for(int i = 0; i < intervals.length; i++) {\n        starts.put(intervals[i][0], i);\n    }\n\n    for(int i = 0; i < intervals.length; i++) {\n        Map.Entry<Integer, Integer> right = starts.ceilingEntry(intervals[i][1]);\n        res[i] = right == null ? -1 : right.getValue();\n    }\n\n    return res;\n}\n```\n    \n    The algorithm first creates a map, `starts`, to store the start times of each interval with their corresponding index in the original array. Then, we iterate through each interval, finding the minimum interval start time greater than or equal to the interval's end time using either lower_bound (C++) or ceilingEntry (Java) or filter (Python, JavaScript). If we find a valid start time, we get the corresponding index from the `starts` map and store it in the result array, otherwise we store -1.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <map>\n\nstd::vector<int> findRightInterval(std::vector<std::vector<int>>& intervals) {\n    std::vector<int> res(intervals.size(), -1);\n    std::map<int, int> starts;\n    for(int i = 0; i < intervals.size(); ++i) {\n        starts[intervals[i][0]] = i;\n    }\n\n    for(int i = 0; i < intervals.size(); ++i) {\n        auto it = starts.lower_bound(intervals[i][1]);\n        if(it != starts.end()) {\n            res[i] = it->second;\n        }\n    }\n\n    return res;\n}\n```\n    \n    The algorithm first creates a map, `starts`, to store the start times of each interval with their corresponding index in the original array. Then, we iterate through each interval, finding the minimum interval start time greater than or equal to the interval's end time using either lower_bound (C++) or ceilingEntry (Java) or filter (Python, JavaScript). If we find a valid start time, we get the corresponding index from the `starts` map and store it in the result array, otherwise we store -1.\n    ",
        "python": "\n    ```python\ndef findRightInterval(intervals):\n    starts = {interval[0]: index for index, interval in enumerate(intervals)}\n    res = []\n\n    for interval in intervals:\n        right = min(filter(lambda x: x >= interval[1], starts.keys()), default=-1)\n        res.append(starts[right] if right != -1 else -1)\n\n    return res\n```\n    \n    The algorithm first creates a map, `starts`, to store the start times of each interval with their corresponding index in the original array. Then, we iterate through each interval, finding the minimum interval start time greater than or equal to the interval's end time using either lower_bound (C++) or ceilingEntry (Java) or filter (Python, JavaScript). If we find a valid start time, we get the corresponding index from the `starts` map and store it in the result array, otherwise we store -1.\n    ",
        "javascript": "\n    ```javascript\nfunction findRightInterval(intervals) {\n    const starts = new Map();\n    const res = [];\n\n    intervals.forEach((interval, index) => {\n        starts.set(interval[0], index);\n    });\n\n    for (const interval of intervals) {\n        const rightKeys = [...starts.keys()].filter(x => x >= interval[1]);\n        const right = Math.min(...rightKeys);\n        res.push(right === Infinity ? -1 : starts.get(right));\n    }\n\n    return res;\n}\n```\n    \n    The algorithm first creates a map, `starts`, to store the start times of each interval with their corresponding index in the original array. Then, we iterate through each interval, finding the minimum interval start time greater than or equal to the interval's end time using either lower_bound (C++) or ceilingEntry (Java) or filter (Python, JavaScript). If we find a valid start time, we get the corresponding index from the `starts` map and store it in the result array, otherwise we store -1.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " intervals = [[1,2]]",
                    "output": " [-1]",
                    "explanation": " There is only one interval in the collection, so it outputs -1."
                },
                {
                    "input": " intervals = [[3,4],[2,3],[1,2]]",
                    "output": " [-1,0,1]",
                    "explanation": " There is no right interval for \\[3,4\\].\nThe right interval for \\[2,3\\] is \\[3,4\\] since start0 = 3 is the smallest start that is >= end1 = 3.\nThe right interval for \\[1,2\\] is \\[2,3\\] since start1 = 2 is the smallest start that is >= end2 = 2."
                },
                {
                    "input": " intervals = [[1,4],[2,3],[3,4]]",
                    "output": " [-1,2,-1]",
                    "explanation": " There is no right interval for \\[1,4\\] and \\[3,4\\].\nThe right interval for \\[2,3\\] is \\[3,4\\] since start2 = 3 is the smallest start that is >= end1 = 3."
                }
            ],
            "function_input": [
                {
                    "input": "[[1,2]]",
                    "output": "[-1]"
                },
                {
                    "input": "[[3,4],[2,3],[1,2]]",
                    "output": "[-1,0,1]"
                },
                {
                    "input": "[[1,4],[2,3],[3,4]]",
                    "output": "[-1,2,-1]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-156",
        "prompt": "You are given an array of `intervals`, where `intervals[i] = [starti, endi]` and each `starti` is **unique**.\n\nThe **right interval** for an interval `i` is an interval `j` such that `startj >= endi` and `startj` is **minimized**. Note that `i` may equal `j`.\n\nReturn _an array of **right interval** indices for each interval `i`_. If no **right interval** exists for interval `i`, then put `-1` at index `i`."
    },
    "leetcode-benchmark-157": {
        "id": "leetcode-benchmark-157",
        "title": "Path Sum III",
        "difficulty": "Medium",
        "content": {
            "problem": "Given the `root` of a binary tree and an integer `targetSum`, return _the number of paths where the sum of the values along the path equals_ `targetSum`.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).",
            "examples": [
                "**Example 1:**\n\n**Input:** root = \\[10,5,-3,3,2,null,11,3,-2,null,1\\], targetSum = 8\n**Output:** 3\n**Explanation:** The paths that sum to 8 are shown.\n\n",
                "**Example 2:**\n\n**Input:** root = \\[5,4,8,11,null,13,4,7,2,null,null,5,1\\], targetSum = 22\n**Output:** 3"
            ],
            "constraints": "**Constraints:**\n\n*   The number of nodes in the tree is in the range `[0, 1000]`.\n*   `-109 <= Node.val <= 109`\n*   `-1000 <= targetSum <= 1000`",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int pathSumHelper(TreeNode node, int targetSum, int currentSum) {\n    if (node == null) {\n        return 0;\n    }\n    \n    currentSum += node.val;\n    int totalPaths = currentSum == targetSum ? 1 : 0;\n    totalPaths += pathSumHelper(node.left, targetSum, currentSum);\n    totalPaths += pathSumHelper(node.right, targetSum, currentSum);\n    return totalPaths;\n}\n\npublic int pathSum(TreeNode root, int targetSum) {\n    if (root == null) {\n        return 0;\n    }\n\n    return pathSumHelper(root, targetSum, 0) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\n}\n```\n\n    \n    1. Create a recursive helper function `pathSumHelper` which takes the current node, `targetSum`, and the `currentSum` on the path.\n2. If the current node is null, return 0 as the base case.\n3. Add the value of the current node to `currentSum`.\n4. Check if the `currentSum` is equal to `targetSum`. If yes, update the number of total paths by 1.\n5. Recursively call the `pathSumHelper` function for the left and right child of the current node, and update the total paths accordingly.\n6. Return the total paths.\n7. The main function `pathSum` just calls the helper function for the root node, the left subtree and the right subtree and sums up the results.\n    ",
        "c++": "\n    ```cpp\nint pathSumHelper(TreeNode* node, int targetSum, int currentSum) {\n    if (node == nullptr) {\n        return 0;\n    }\n    \n    currentSum += node->val;\n    int totalPaths = currentSum == targetSum;\n    totalPaths += pathSumHelper(node->left, targetSum, currentSum);\n    totalPaths += pathSumHelper(node->right, targetSum, currentSum);\n    return totalPaths;\n}\n\nint pathSum(TreeNode* root, int targetSum) {\n    if (root == nullptr) {\n        return 0;\n    }\n\n    return pathSumHelper(root, targetSum, 0) + pathSum(root->left, targetSum) + pathSum(root->right, targetSum);\n}\n```\n\n    \n    1. Create a recursive helper function `pathSumHelper` which takes the current node, `targetSum`, and the `currentSum` on the path.\n2. If the current node is null, return 0 as the base case.\n3. Add the value of the current node to `currentSum`.\n4. Check if the `currentSum` is equal to `targetSum`. If yes, update the number of total paths by 1.\n5. Recursively call the `pathSumHelper` function for the left and right child of the current node, and update the total paths accordingly.\n6. Return the total paths.\n7. The main function `pathSum` just calls the helper function for the root node, the left subtree and the right subtree and sums up the results.\n    ",
        "python": "\n    ```python\ndef path_sum_helper(node, target_sum, current_sum):\n    if node is None:\n        return 0\n\n    current_sum += node.val\n    total_paths = 1 if current_sum == target_sum else 0\n    total_paths += path_sum_helper(node.left, target_sum, current_sum)\n    total_paths += path_sum_helper(node.right, target_sum, current_sum)\n    return total_paths\n\ndef path_sum(root, target_sum):\n    if root is None:\n        return 0\n\n    return path_sum_helper(root, target_sum, 0) + path_sum(root.left, target_sum) + path_sum(root.right, target_sum)\n```\n\n    \n    1. Create a recursive helper function `pathSumHelper` which takes the current node, `targetSum`, and the `currentSum` on the path.\n2. If the current node is null, return 0 as the base case.\n3. Add the value of the current node to `currentSum`.\n4. Check if the `currentSum` is equal to `targetSum`. If yes, update the number of total paths by 1.\n5. Recursively call the `pathSumHelper` function for the left and right child of the current node, and update the total paths accordingly.\n6. Return the total paths.\n7. The main function `pathSum` just calls the helper function for the root node, the left subtree and the right subtree and sums up the results.\n    ",
        "javascript": "\n    ```javascript\nfunction pathSumHelper(node, targetSum, currentSum) {\n    if (node === null) {\n        return 0;\n    }\n\n    currentSum += node.val;\n    let totalPaths = (currentSum === targetSum) ? 1 : 0;\n    totalPaths += pathSumHelper(node.left, targetSum, currentSum);\n    totalPaths += pathSumHelper(node.right, targetSum, currentSum);\n    return totalPaths;\n}\n\nfunction pathSum(root, targetSum) {\n    if (root === null) {\n        return 0;\n    }\n\n    return pathSumHelper(root, targetSum, 0) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum);\n}\n```\n\n    \n    1. Create a recursive helper function `pathSumHelper` which takes the current node, `targetSum`, and the `currentSum` on the path.\n2. If the current node is null, return 0 as the base case.\n3. Add the value of the current node to `currentSum`.\n4. Check if the `currentSum` is equal to `targetSum`. If yes, update the number of total paths by 1.\n5. Recursively call the `pathSumHelper` function for the left and right child of the current node, and update the total paths accordingly.\n6. Return the total paths.\n7. The main function `pathSum` just calls the helper function for the root node, the left subtree and the right subtree and sums up the results.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8",
                    "output": " 3",
                    "explanation": " The paths that sum to 8 are shown."
                },
                {
                    "input": " root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22",
                    "output": " 3",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[10,5,-3,3,2,null,11,3,-2,null,1],8",
                    "output": "3"
                },
                {
                    "input": "[5,4,8,11,null,13,4,7,2,null,null,5,1],22",
                    "output": "3"
                }
            ]
        },
        "task_id": "leetcode-benchmark-157",
        "prompt": "Given the `root` of a binary tree and an integer `targetSum`, return _the number of paths where the sum of the values along the path equals_ `targetSum`.\n\nThe path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes)."
    },
    "leetcode-benchmark-158": {
        "id": "leetcode-benchmark-158",
        "title": "Find All Anagrams in a String",
        "difficulty": "Medium",
        "content": {
            "problem": "Given two strings `s` and `p`, return _an array of all the start indices of_ `p`_'s anagrams in_ `s`. You may return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
            "examples": [
                "**Example 1:**\n\n**Input:** s =  \"cbaebabacd \", p =  \"abc \"\n**Output:** \\[0,6\\]\n**Explanation:**\nThe substring with start index = 0 is  \"cba \", which is an anagram of  \"abc \".\nThe substring with start index = 6 is  \"bac \", which is an anagram of  \"abc \".\n\n",
                "**Example 2:**\n\n**Input:** s =  \"abab \", p =  \"ab \"\n**Output:** \\[0,1,2\\]\n**Explanation:**\nThe substring with start index = 0 is  \"ab \", which is an anagram of  \"ab \".\nThe substring with start index = 1 is  \"ba \", which is an anagram of  \"ab \".\nThe substring with start index = 2 is  \"ab \", which is an anagram of  \"ab \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= s.length, p.length <= 3 * 104`\n*   `s` and `p` consist of lowercase English letters.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic List<Integer> findAnagrams(String s, String p) {\n    List<Integer> result = new ArrayList<>();\n    if (s.length() < p.length()) return result;\n\n    int[] s_count = new int[26];\n    int[] p_count = new int[26];\n    for (char c : p.toCharArray()) p_count[c - 'a']++;\n\n    for (int i = 0; i < s.length(); i++) {\n        s_count[s.charAt(i) - 'a']++;\n        if (i >= p.length()) s_count[s.charAt(i - p.length()) - 'a']--;\n        if (java.util.Arrays.equals(s_count, p_count)) result.add(i - p.length() + 1);\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <string>\n\nstd::vector<int> findAnagrams(std::string s, std::string p) {\n    std::vector<int> result;\n    if (s.size() < p.size()) return result;\n\n    std::vector<int> s_count(26, 0), p_count(26, 0);\n    for (char c : p) p_count[c - 'a']++;\n\n    for (int i = 0; i < s.size(); i++) {\n        s_count[s[i] - 'a']++;\n        if (i >= p.size()) s_count[s[i - p.size()] - 'a']--;\n        if (s_count == p_count) result.push_back(i - p.size() + 1);\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "python": "\n    ```python\ndef find_anagrams(s, p):\n    if len(s) < len(p):\n        return []\n\n    s_count = [0] * 26\n    p_count = [0] * 26\n    for c in p:\n        p_count[ord(c) - ord('a')] += 1\n\n    result = []\n    for i in range(len(s)):\n        s_count[ord(s[i]) - ord('a')] += 1\n        if i >= len(p):\n            s_count[ord(s[i - len(p)]) - ord('a')] -= 1\n        if s_count == p_count:\n            result.append(i - len(p) + 1)\n\n    return result\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "javascript": "\n    ```javascript\nfunction findAnagrams(s, p) {\n    if (s.length < p.length) return [];\n\n    const s_count = new Array(26).fill(0);\n    const p_count = new Array(26).fill(0);\n    for (const c of p) p_count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n\n    const result = [];\n    for (let i = 0; i < s.length; i++) {\n        s_count[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        if (i >= p.length) s_count[s.charCodeAt(i - p.length) - 'a'.charCodeAt(0)]--;\n        if (s_count.join(',') === p_count.join(',')) result.push(i - p.length + 1);\n    }\n\n    return result;\n}\n```\n    \n    1. Create an empty result list.\n2. If the given string `s` is shorter than the pattern string `p`, return the empty result list as there cannot be any anagram of `p` in `s`.\n3. Create 2 arrays, `s_count` and `p_count`, with a fixed size of 26, to keep count of characters in the sliding window of `s` and characters in `p`.\n4. Fill `p_count` using the characters count in `p`.\n5. Iterate over the string `s`, updating the count of the characters in `s_count`.\n6. If the iteration index `i` is greater than or equal to the length of `p`, reduce the count of the character that is now out of the sliding window.\n7. If the `s_count` and `p_count` have the same counts, it means that a valid anagram has been found. Add the starting index of the anagram in the result list.\n8. Return the result list.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " s =  \"cbaebabacd \", p =  \"abc \"",
                    "output": " [0,6]",
                    "explanation": "\nThe substring with start index = 0 is  \"cba \", which is an anagram of  \"abc \".\nThe substring with start index = 6 is  \"bac \", which is an anagram of  \"abc \"."
                },
                {
                    "input": " s =  \"abab \", p =  \"ab \"",
                    "output": " [0,1,2]",
                    "explanation": "\nThe substring with start index = 0 is  \"ab \", which is an anagram of  \"ab \".\nThe substring with start index = 1 is  \"ba \", which is an anagram of  \"ab \".\nThe substring with start index = 2 is  \"ab \", which is an anagram of  \"ab \"."
                }
            ],
            "function_input": [
                {
                    "input": "\"cbaebabacd\",\"abc\"",
                    "output": "[0,6]"
                },
                {
                    "input": "\"abab\",\"ab\"",
                    "output": "[0,1,2]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-158",
        "prompt": "Given two strings `s` and `p`, return _an array of all the start indices of_ `p`_'s anagrams in_ `s`. You may return the answer in **any order**.\n\nAn **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once."
    },
    "leetcode-benchmark-159": {
        "id": "leetcode-benchmark-159",
        "title": "Ternary Expression Parser",
        "difficulty": "Medium",
        "content": {
            "problem": "Given a string `expression` representing arbitrarily nested ternary expressions, evaluate the expression, and return _the result of it_.\n\nYou can always assume that the given expression is valid and only contains digits, `'?'`, `':'`, `'T'`, and `'F'` where `'T'` is true and `'F'` is false. All the numbers in the expression are **one-digit** numbers (i.e., in the range `[0, 9]`).\n\nThe conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, `'T'` or `'F'`.",
            "examples": [
                "**Example 1:**\n\n**Input:** expression =  \"T?2:3 \"\n**Output:**  \"2 \"\n**Explanation:** If true, then result is 2; otherwise result is 3.\n\n",
                "**Example 2:**\n\n**Input:** expression =  \"F?1:T?4:5 \"\n**Output:**  \"4 \"\n**Explanation:** The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n \"(F ? 1 : (T ? 4 : 5)) \" -->  \"(F ? 1 : 4) \" -->  \"4 \"\nor  \"(F ? 1 : (T ? 4 : 5)) \" -->  \"(T ? 4 : 5) \" -->  \"4 \"\n\n",
                "**Example 3:**\n\n**Input:** expression =  \"T?T?F:5:3 \"\n**Output:**  \"F \"\n**Explanation:** The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n \"(T ? (T ? F : 5) : 3) \" -->  \"(T ? F : 3) \" -->  \"F \"\n \"(T ? (T ? F : 5) : 3) \" -->  \"(T ? F : 5) \" -->  \"F \""
            ],
            "constraints": "**Constraints:**\n\n*   `5 <= expression.length <= 104`\n*   `expression` consists of digits, `'T'`, `'F'`, `'?'`, and `':'`.\n*   It is **guaranteed** that `expression` is a valid ternary expression and that each number is a **one-digit number**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.Stack;\n\npublic String parseTernary(String expression) {\n    Stack<Character> stk = new Stack<>();\n    for (int i = expression.length() - 1; i >= 0; --i) {\n        char c = expression.charAt(i);\n        if (!stk.isEmpty() && stk.peek() == '?') {\n            stk.pop(); // Pop '?'\n            char first = stk.pop();\n            stk.pop(); // Pop ':'\n            char second = stk.pop();\n            stk.push(c == 'T' ? first : second);\n        } else {\n            stk.push(c);\n        }\n    }\n    return String.valueOf(stk.peek());\n}\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "c++": "\n    ```cpp\n#include <string>\n#include <stack>\n\nstd::string parseTernary(std::string expression) {\n    std::stack<char> stk;\n    for (int i = expression.size() - 1; i >= 0; --i) {\n        char c = expression[i];\n        if (!stk.empty() && stk.top() == '?') {\n            stk.pop(); // Pop '?'\n            char first = stk.top();\n            stk.pop();\n            stk.pop(); // Pop ':'\n            char second = stk.top();\n            stk.pop();\n            stk.push(c == 'T' ? first : second);\n        } else {\n            stk.push(c);\n        }\n    }\n    return std::string(1, stk.top());\n}\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "python": "\n    ```python\ndef parseTernary(expression: str) -> str:\n    stack = []\n    for c in reversed(expression):\n        if stack and stack[-1] == '?':\n            stack.pop()  # Pop '?'\n            first = stack.pop()\n            stack.pop()  # Pop ':'\n            second = stack.pop()\n            stack.append(first if c == 'T' else second)\n        else:\n            stack.append(c)\n    return stack[-1]\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "javascript": "\n    ```javascript\nfunction parseTernary(expression) {\n    const stack = [];\n    for (let i = expression.length - 1; i >= 0; i--) {\n        const c = expression[i];\n        if (stack.length && stack[stack.length - 1] === '?') {\n            stack.pop(); // Pop '?'\n            const first = stack.pop();\n            stack.pop(); // Pop ':'\n            const second = stack.pop();\n            stack.push(c === 'T' ? first : second);\n        } else {\n            stack.push(c);\n        }\n    }\n    return stack[stack.length - 1];\n}\n```\n\n    \n    The algorithm uses a stack to process the ternary expression. Iterate through the expression from the right to left, and push each character on the stack. If the stack is not empty and the top of the stack is a '?', then pop the '?' from the stack and store the next two elements (first and second). Pop the ':' from the stack and push either 'first' or 'second' on the stack based on whether the current character is 'T' or 'F'. The top element of the stack after iteration has the result of evaluating the ternary expression.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " expression =  \"T?2:3 \"",
                    "output": "  \"2 \"",
                    "explanation": " If true, then result is 2; otherwise result is 3."
                },
                {
                    "input": " expression =  \"F?1:T?4:5 \"",
                    "output": "  \"4 \"",
                    "explanation": " The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n \"(F ? 1 : (T ? 4 : 5)) \" -->  \"(F ? 1 : 4) \" -->  \"4 \"\nor  \"(F ? 1 : (T ? 4 : 5)) \" -->  \"(T ? 4 : 5) \" -->  \"4 \""
                },
                {
                    "input": " expression =  \"T?T?F:5:3 \"",
                    "output": "  \"F \"",
                    "explanation": " The conditional expressions group right-to-left. Using parenthesis, it is read/evaluated as:\n \"(T ? (T ? F : 5) : 3) \" -->  \"(T ? F : 3) \" -->  \"F \"\n \"(T ? (T ? F : 5) : 3) \" -->  \"(T ? F : 5) \" -->  \"F \""
                }
            ],
            "function_input": [
                {
                    "input": "\"T?2:3\"",
                    "output": "\"2\""
                },
                {
                    "input": "\"F?1:T?4:5\"",
                    "output": "\"4\""
                },
                {
                    "input": "\"T?T?F:5:3\"",
                    "output": "\"F\""
                }
            ]
        },
        "task_id": "leetcode-benchmark-159",
        "prompt": "Given a string `expression` representing arbitrarily nested ternary expressions, evaluate the expression, and return _the result of it_.\n\nYou can always assume that the given expression is valid and only contains digits, `'?'`, `':'`, `'T'`, and `'F'` where `'T'` is true and `'F'` is false. All the numbers in the expression are **one-digit** numbers (i.e., in the range `[0, 9]`).\n\nThe conditional expressions group right-to-left (as usual in most languages), and the result of the expression will always evaluate to either a digit, `'T'` or `'F'`."
    },
    "leetcode-benchmark-160": {
        "id": "leetcode-benchmark-160",
        "title": "Find All Duplicates in an Array",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, return _an array of all the integers that appears **twice**_.\n\nYou must write an algorithm that runs in `O(n)` time and uses only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[4,3,2,7,8,2,3,1\\]\n**Output:** \\[2,3\\]\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,1,2\\]\n**Output:** \\[1\\]\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1\\]\n**Output:** \\[\\]"
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 105`\n*   `1 <= nums[i] <= n`\n*   Each element in `nums` appears **once** or **twice**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic List<Integer> findDuplicates(int[] nums) {\n    List<Integer> duplicates = new ArrayList<>();\n    for (int i = 0; i < nums.length; i++) {\n        int index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.add(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "c++": "\n    ```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> findDuplicates(std::vector<int>& nums) {\n    std::vector<int> duplicates;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push_back(abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "python": "\n    ```python\ndef find_duplicates(nums):\n    duplicates = []\n    for i in range(len(nums)):\n        index = abs(nums[i]) - 1\n        if nums[index] < 0:\n            duplicates.append(abs(nums[i]))\n        else:\n            nums[index] *= -1\n    return duplicates\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "javascript": "\n    ```javascript\nfunction findDuplicates(nums) {\n    let duplicates = [];\n    for (let i = 0; i < nums.length; i++) {\n        let index = Math.abs(nums[i]) - 1;\n        if (nums[index] < 0) {\n            duplicates.push(Math.abs(nums[i]));\n        } else {\n            nums[index] *= -1;\n        }\n    }\n    return duplicates;\n}\n```\n    \n    The algorithm iterates through the input array, using the array values as indices. For each index, we make the corresponding value in the array negative. If we encounter a negative value during the process, that means this index was seen before (i.e., the value was duplicated), so we add the absolute value of the duplicated number to the result.\n\nThe algorithm runs in O(n) time complexity, as there is only one iteration through the input array. It also uses constant extra space, because the input array is utilized for marking, and only the result array is created separately.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [4,3,2,7,8,2,3,1]",
                    "output": " [2,3]",
                    "explanation": null
                },
                {
                    "input": " nums = [1,1,2]",
                    "output": " [1]",
                    "explanation": null
                },
                {
                    "input": " nums = [1]",
                    "output": " []",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[4,3,2,7,8,2,3,1]",
                    "output": "[2,3]"
                },
                {
                    "input": "[1,1,2]",
                    "output": "[1]"
                },
                {
                    "input": "[1]",
                    "output": "[]"
                }
            ]
        },
        "task_id": "leetcode-benchmark-160",
        "prompt": "Given an integer array `nums` of length `n` where all the integers of `nums` are in the range `[1, n]` and each integer appears **once** or **twice**, return _an array of all the integers that appears **twice**_.\n\nYou must write an algorithm that runs in `O(n)` time and uses only constant extra space."
    },
    "leetcode-benchmark-161": {
        "id": "leetcode-benchmark-161",
        "title": "String Compression",
        "difficulty": "Medium",
        "content": {
            "problem": "Given an array of characters `chars`, compress it using the following algorithm:\n\nBegin with an empty string `s`. For each group of **consecutive repeating characters** in `chars`:\n\n*   If the group's length is `1`, append the character to `s`.\n*   Otherwise, append the character followed by the group's length.\n\nThe compressed string `s` **should not be returned separately**, but instead, be stored **in the input character array `chars`**. Note that group lengths that are `10` or longer will be split into multiple characters in `chars`.\n\nAfter you are done **modifying the input array,** return _the new length of the array_.\n\nYou must write an algorithm that uses only constant extra space.",
            "examples": [
                "**Example 1:**\n\n**Input:** chars = \\[ \"a \", \"a \", \"b \", \"b \", \"c \", \"c \", \"c \"\\]\n**Output:** Return 6, and the first 6 characters of the input array should be: \\[ \"a \", \"2 \", \"b \", \"2 \", \"c \", \"3 \"\\]\n**Explanation:** The groups are  \"aa \",  \"bb \", and  \"ccc \". This compresses to  \"a2b2c3 \".\n\n",
                "**Example 2:**\n\n**Input:** chars = \\[ \"a \"\\]\n**Output:** Return 1, and the first character of the input array should be: \\[ \"a \"\\]\n**Explanation:** The only group is  \"a \", which remains uncompressed since it's a single character.\n\n",
                "**Example 3:**\n\n**Input:** chars = \\[ \"a \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \"\\]\n**Output:** Return 4, and the first 4 characters of the input array should be: \\[ \"a \", \"b \", \"1 \", \"2 \"\\].\n**Explanation:** The groups are  \"a \" and  \"bbbbbbbbbbbb \". This compresses to  \"ab12 \"."
            ],
            "constraints": "**Constraints:**\n\n*   `1 <= chars.length <= 2000`\n*   `chars[i]` is a lowercase English letter, uppercase English letter, digit, or symbol.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic int compress(char[] chars) {\n    int index = 0, count;\n    for(int i = 0; i < chars.length; i += count) {\n        count = 1;\n        while(i + count < chars.length && chars[i] == chars[i + count]) {\n            count++;\n        }\n        chars[index++] = chars[i];\n        if(count > 1) {\n            for(char c : Integer.toString(count).toCharArray()) {\n                chars[index++] = c;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    This algorithm iterates through the input array `chars`, for each character, it counts the number of consecutive occurrences (using `count` variable) of that character. Then, the algorithm replaces the current character(s) with the compressed form (the character itself, followed by the count if it is greater than 1). `index` keeps track of the position in the modified input array `chars`.\n\nAt the end of each iteration, the value of `i` is incremented by `count` to move to the next unique character in the array. Finally, the algorithm returns `index`, which is the new length of the array.\n\nThis implementation uses only constant extra space by modifying the input array itself and using a couple of simple variables.\n    ",
        "c++": "\n    ```cpp\nint compress(vector<char>& chars) {\n    int index = 0, count;\n    for(int i = 0; i < chars.size(); i += count) {\n        count = 1;\n        while(i + count < chars.size() && chars[i] == chars[i + count]) {\n            count++;\n        }\n        chars[index++] = chars[i];\n        if(count > 1) {\n            for(char c : to_string(count)) {\n                chars[index++] = c;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    This algorithm iterates through the input array `chars`, for each character, it counts the number of consecutive occurrences (using `count` variable) of that character. Then, the algorithm replaces the current character(s) with the compressed form (the character itself, followed by the count if it is greater than 1). `index` keeps track of the position in the modified input array `chars`.\n\nAt the end of each iteration, the value of `i` is incremented by `count` to move to the next unique character in the array. Finally, the algorithm returns `index`, which is the new length of the array.\n\nThis implementation uses only constant extra space by modifying the input array itself and using a couple of simple variables.\n    ",
        "python": "\n    ```python\ndef compress(chars):\n    index, i = 0, 0\n    \n    while i < len(chars):\n        count = 1\n        while i + count < len(chars) and chars[i] == chars[i + count]:\n            count += 1\n            \n        chars[index] = chars[i]\n        index += 1\n        \n        if count > 1:\n            count_str = str(count)\n            for c in count_str:\n                chars[index] = c\n                index += 1\n                \n        i += count\n        \n    return index\n```\n    \n    This algorithm iterates through the input array `chars`, for each character, it counts the number of consecutive occurrences (using `count` variable) of that character. Then, the algorithm replaces the current character(s) with the compressed form (the character itself, followed by the count if it is greater than 1). `index` keeps track of the position in the modified input array `chars`.\n\nAt the end of each iteration, the value of `i` is incremented by `count` to move to the next unique character in the array. Finally, the algorithm returns `index`, which is the new length of the array.\n\nThis implementation uses only constant extra space by modifying the input array itself and using a couple of simple variables.\n    ",
        "javascript": "\n    ```javascript\nfunction compress(chars) {\n    let index = 0, count;\n    for(let i = 0; i < chars.length; i += count) {\n        count = 1;\n        while(i + count < chars.length && chars[i] === chars[i + count]) {\n            count++;\n        }\n        chars[index++] = chars[i];\n        if(count > 1) {\n            for(let c of count.toString()) {\n                chars[index++] = c;\n            }\n        }\n    }\n    return index;\n}\n```\n    \n    This algorithm iterates through the input array `chars`, for each character, it counts the number of consecutive occurrences (using `count` variable) of that character. Then, the algorithm replaces the current character(s) with the compressed form (the character itself, followed by the count if it is greater than 1). `index` keeps track of the position in the modified input array `chars`.\n\nAt the end of each iteration, the value of `i` is incremented by `count` to move to the next unique character in the array. Finally, the algorithm returns `index`, which is the new length of the array.\n\nThis implementation uses only constant extra space by modifying the input array itself and using a couple of simple variables.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " chars = [ \"a \", \"a \", \"b \", \"b \", \"c \", \"c \", \"c \"]",
                    "output": " Return 6, and the first 6 characters of the input array should be: [ \"a \", \"2 \", \"b \", \"2 \", \"c \", \"3 \"]",
                    "explanation": " The groups are  \"aa \",  \"bb \", and  \"ccc \". This compresses to  \"a2b2c3 \"."
                },
                {
                    "input": " chars = [ \"a \"]",
                    "output": " Return 1, and the first character of the input array should be: [ \"a \"]",
                    "explanation": " The only group is  \"a \", which remains uncompressed since it's a single character."
                },
                {
                    "input": " chars = [ \"a \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \", \"b \"]",
                    "output": " Return 4, and the first 4 characters of the input array should be: [ \"a \", \"b \", \"1 \", \"2 \"].",
                    "explanation": " The groups are  \"a \" and  \"bbbbbbbbbbbb \". This compresses to  \"ab12 \"."
                }
            ],
            "function_input": [
                {
                    "input": "[\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]",
                    "output": "Return6,andthefirst6charactersoftheinputarrayshouldbe:[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]"
                },
                {
                    "input": "[\"a\"]",
                    "output": "Return1,andthefirstcharacteroftheinputarrayshouldbe:[\"a\"]"
                },
                {
                    "input": "[\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]",
                    "output": "Return4,andthefirst4charactersoftheinputarrayshouldbe:[\"a\",\"b\",\"1\",\"2\"]."
                }
            ]
        },
        "task_id": "leetcode-benchmark-161",
        "prompt": "Given an array of characters `chars`, compress it using the following algorithm:\n\nBegin with an empty string `s`. For each group of **consecutive repeating characters** in `chars`:\n\n*   If the group's length is `1`, append the character to `s`.\n*   Otherwise, append the character followed by the group's length.\n\nThe compressed string `s` **should not be returned separately**, but instead, be stored **in the input character array `chars`**. Note that group lengths that are `10` or longer will be split into multiple characters in `chars`.\n\nAfter you are done **modifying the input array,** return _the new length of the array_.\n\nYou must write an algorithm that uses only constant extra space."
    },
    "leetcode-benchmark-162": {
        "id": "leetcode-benchmark-162",
        "title": "Sequence Reconstruction",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given an integer array `nums` of length `n` where `nums` is a permutation of the integers in the range `[1, n]`. You are also given a 2D integer array `sequences` where `sequences[i]` is a subsequence of `nums`.\n\nCheck if `nums` is the shortest possible and the only **supersequence**. The shortest **supersequence** is a sequence **with the shortest length** and has all `sequences[i]` as subsequences. There could be multiple valid **supersequences** for the given array `sequences`.\n\n*   For example, for `sequences = [[1,2],[1,3]]`, there are two shortest **supersequences**, `[1,2,3]` and `[1,3,2]`.\n*   While for `sequences = [[1,2],[1,3],[1,2,3]]`, the only shortest **supersequence** possible is `[1,2,3]`. `[1,2,3,4]` is a possible supersequence but not the shortest.\n\nReturn `true` _if_ `nums` _is the only shortest **supersequence** for_ `sequences`_, or_ `false` _otherwise_.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.",
            "examples": [
                "**Example 1:**\n\n**Input:** nums = \\[1,2,3\\], sequences = \\[\\[1,2\\],\\[1,3\\]\\]\n**Output:** false\n**Explanation:** There are two possible supersequences: \\[1,2,3\\] and \\[1,3,2\\].\nThe sequence \\[1,2\\] is a subsequence of both: \\[**1**,**2**,3\\] and \\[**1**,3,**2**\\].\nThe sequence \\[1,3\\] is a subsequence of both: \\[**1**,2,**3**\\] and \\[**1**,**3**,2\\].\nSince nums is not the only shortest supersequence, we return false.\n\n",
                "**Example 2:**\n\n**Input:** nums = \\[1,2,3\\], sequences = \\[\\[1,2\\]\\]\n**Output:** false\n**Explanation:** The shortest possible supersequence is \\[1,2\\].\nThe sequence \\[1,2\\] is a subsequence of it: \\[**1**,**2**\\].\nSince nums is not the shortest supersequence, we return false.\n\n",
                "**Example 3:**\n\n**Input:** nums = \\[1,2,3\\], sequences = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** true\n**Explanation:** The shortest possible supersequence is \\[1,2,3\\].\nThe sequence \\[1,2\\] is a subsequence of it: \\[**1**,**2**,3\\].\nThe sequence \\[1,3\\] is a subsequence of it: \\[**1**,2,**3**\\].\nThe sequence \\[2,3\\] is a subsequence of it: \\[1,**2**,**3**\\].\nSince nums is the only shortest supersequence, we return true."
            ],
            "constraints": "**Constraints:**\n\n*   `n == nums.length`\n*   `1 <= n <= 104`\n*   `nums` is a permutation of all the integers in the range `[1, n]`.\n*   `1 <= sequences.length <= 104`\n*   `1 <= sequences[i].length <= 104`\n*   `1 <= sum(sequences[i].length) <= 105`\n*   `1 <= sequences[i][j] <= n`\n*   All the arrays of `sequences` are **unique**.\n*   `sequences[i]` is a subsequence of `nums`.",
            "follow_up": ""
        },
        "java": "\n    ```java\npublic boolean isShortestAndUniqueSupersequence(int[] nums, int[][] sequences) {\n    Map<Integer, Integer> pos = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n        pos.put(nums[i], i);\n    }\n\n    for (int[] seq : sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "c++": "\n    ```cpp\nbool isShortestAndUniqueSupersequence(vector<int>& nums, vector<vector<int>>& sequences) {\n    unordered_map<int, int> pos;\n    for (int i = 0; i < nums.size(); ++i) {\n        pos[nums[i]] = i;\n    }\n\n    for (const auto& seq : sequences) {\n        if (pos[seq[0]] > pos[seq.back()]) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "python": "\n    ```python\ndef is_shortest_and_unique_supersequence(nums, sequences):\n    pos = {val: idx for idx, val in enumerate(nums)}\n\n    for seq in sequences:\n        if pos[seq[0]] > pos[seq[-1]]:\n            return False\n    return True\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "javascript": "\n    ```javascript\nfunction isShortestAndUniqueSupersequence(nums, sequences) {\n    const pos = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        pos.set(nums[i], i);\n    }\n\n    for (const seq of sequences) {\n        if (pos.get(seq[0]) > pos.get(seq[seq.length - 1])) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n    \n    We start by creating a hashmap (or dictionary in Python and Map in JavaScript) to store the position of each element in the given `nums` array for efficient lookup. The map is filled with each value of the `nums` array as the key and its index as the value.\n\nWe then iterate through each sequence in `sequences` and check if the position of the first element in the sequence is greater than the position of the last element in the same sequence. If so, it means the given sequence is not a valid subsequence of the given `nums`, and we return `false`.\n\nIf we passed all sequences in the iteration without returning `false`, it means that the given `nums` array is the shortest possible and the only supersequence of the input sequences. Thus, we return `true`.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " nums = [1,2,3], sequences = [[1,2],[1,3]]",
                    "output": " False",
                    "explanation": " There are two possible supersequences: \\[1,2,3\\] and \\[1,3,2\\].\nThe sequence \\[1,2\\] is a subsequence of both: \\[**1**,**2**,3\\] and \\[**1**,3,**2**\\].\nThe sequence \\[1,3\\] is a subsequence of both: \\[**1**,2,**3**\\] and \\[**1**,**3**,2\\].\nSince nums is not the only shortest supersequence, we return false."
                },
                {
                    "input": " nums = [1,2,3], sequences = [[1,2]]",
                    "output": " False",
                    "explanation": " The shortest possible supersequence is \\[1,2\\].\nThe sequence \\[1,2\\] is a subsequence of it: \\[**1**,**2**\\].\nSince nums is not the shortest supersequence, we return false."
                },
                {
                    "input": " nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]",
                    "output": " True",
                    "explanation": " The shortest possible supersequence is \\[1,2,3\\].\nThe sequence \\[1,2\\] is a subsequence of it: \\[**1**,**2**,3\\].\nThe sequence \\[1,3\\] is a subsequence of it: \\[**1**,2,**3**\\].\nThe sequence \\[2,3\\] is a subsequence of it: \\[1,**2**,**3**\\].\nSince nums is the only shortest supersequence, we return true."
                }
            ],
            "function_input": [
                {
                    "input": "[1,2,3],[[1,2],[1,3]]",
                    "output": "False"
                },
                {
                    "input": "[1,2,3],[[1,2]]",
                    "output": "False"
                },
                {
                    "input": "[1,2,3],[[1,2],[1,3],[2,3]]",
                    "output": "True"
                }
            ]
        },
        "task_id": "leetcode-benchmark-162",
        "prompt": "You are given an integer array `nums` of length `n` where `nums` is a permutation of the integers in the range `[1, n]`. You are also given a 2D integer array `sequences` where `sequences[i]` is a subsequence of `nums`.\n\nCheck if `nums` is the shortest possible and the only **supersequence**. The shortest **supersequence** is a sequence **with the shortest length** and has all `sequences[i]` as subsequences. There could be multiple valid **supersequences** for the given array `sequences`.\n\n*   For example, for `sequences = [[1,2],[1,3]]`, there are two shortest **supersequences**, `[1,2,3]` and `[1,3,2]`.\n*   While for `sequences = [[1,2],[1,3],[1,2,3]]`, the only shortest **supersequence** possible is `[1,2,3]`. `[1,2,3,4]` is a possible supersequence but not the shortest.\n\nReturn `true` _if_ `nums` _is the only shortest **supersequence** for_ `sequences`_, or_ `false` _otherwise_.\n\nA **subsequence** is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements."
    },
    "leetcode-benchmark-163": {
        "id": "leetcode-benchmark-163",
        "title": "Number of Boomerangs",
        "difficulty": "Medium",
        "content": {
            "problem": "You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.\n\nReturn _the number of boomerangs_.",
            "examples": [
                "**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:** 2\n**Explanation:** The two boomerangs are \\[\\[1,0\\],\\[0,0\\],\\[2,0\\]\\] and \\[\\[1,0\\],\\[2,0\\],\\[0,0\\]\\].\n\n",
                "**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 2\n\n",
                "**Example 3:**\n\n**Input:** points = \\[\\[1,1\\]\\]\n**Output:** 0"
            ],
            "constraints": "**Constraints:**\n\n*   `n == points.length`\n*   `1 <= n <= 500`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the points are **unique**.",
            "follow_up": ""
        },
        "java": "\n    ```java\nimport java.util.HashMap;\n\npublic int numberOfBoomerangs(int[][] points) {\n    int count = 0;\n\n    for (int[] i : points) {\n        HashMap<Integer, Integer> group_count = new HashMap<>();\n        for (int[] j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n\n            group_count.put(dist, group_count.getOrDefault(dist, 0) + 1);\n        }\n\n        for (int g : group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "c++": "\n    ```cpp\n#include <unordered_map>\n\nint numberOfBoomerangs(vector<vector<int>>& points) {\n    int count = 0;\n\n    for (auto& i : points) {\n        unordered_map<int, int> group_count;\n        for (auto& j : points) {\n            int dx = i[0] - j[0], dy = i[1] - j[1];\n            int dist = dx * dx + dy * dy;\n            group_count[dist]++;\n        }\n\n        for (auto& g : group_count) {\n            count += g.second * (g.second - 1);\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "python": "\n    ```python\ndef numberOfBoomerangs(points):\n    count = 0\n\n    for i in points:\n        group_count = {}\n        for j in points:\n            dx, dy = i[0] - j[0], i[1] - j[1]\n            dist = dx * dx + dy * dy\n            group_count[dist] = group_count.get(dist, 0) + 1\n\n        for g in group_count.values():\n            count += g * (g - 1)\n\n    return count\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "javascript": "\n    ```javascript\nfunction numberOfBoomerangs(points) {\n    let count = 0;\n\n    for (let i of points) {\n        let group_count = new Map();\n        for (let j of points) {\n            let dx = i[0] - j[0], dy = i[1] - j[1];\n            let dist = dx * dx + dy * dy;\n            group_count.set(dist, (group_count.get(dist) || 0) + 1);\n        }\n\n        for (let g of group_count.values()) {\n            count += g * (g - 1);\n        }\n    }\n\n    return count;\n}\n```\n    \n    1. For every point `i` in the input, we create a hash map called `group_count` to store the count of points with the same distance from point `i`.\n2. For every point `j`, we calculate the squared distance from `i` to `j`. We use the squared distance to avoid using a square root function, as it's not necessary for this problem.\n3. Increment the count of the squared distance in `group_count`.\n4. To calculate the number of boomerangs, iterate through the values of `group_count`. For every count `g`, we have `g * (g - 1)` boomerangs because there are `g` choices for the second point and `g - 1` choices for the third point.\n5. Return the total number of boomerangs.\n    ",
        "passk": {
            "input_example": [
                {
                    "input": " points = [[0,0],[1,0],[2,0]]",
                    "output": " 2",
                    "explanation": " The two boomerangs are \\[\\[1,0\\],\\[0,0\\],\\[2,0\\]\\] and \\[\\[1,0\\],\\[2,0\\],\\[0,0\\]\\]."
                },
                {
                    "input": " points = [[1,1],[2,2],[3,3]]",
                    "output": " 2",
                    "explanation": null
                },
                {
                    "input": " points = [[1,1]]",
                    "output": " 0",
                    "explanation": null
                }
            ],
            "function_input": [
                {
                    "input": "[[0,0],[1,0],[2,0]]",
                    "output": "2"
                },
                {
                    "input": "[[1,1],[2,2],[3,3]]",
                    "output": "2"
                },
                {
                    "input": "[[1,1]]",
                    "output": "0"
                }
            ]
        },
        "task_id": "leetcode-benchmark-163",
        "prompt": "You are given `n` `points` in the plane that are all **distinct**, where `points[i] = [xi, yi]`. A **boomerang** is a tuple of points `(i, j, k)` such that the distance between `i` and `j` equals the distance between `i` and `k` **(the order of the tuple matters)**.\n\nReturn _the number of boomerangs_."
    }
}